{
  "problem_idx": 2518,
  "task_name": "Number of Great Partitions",
  "markdown_description": "\nYou are given an array `nums` consisting of **positive** integers and an integer `k`.\n\n\n**Partition** the array into two ordered **groups** such that each element is in exactly **one** group. A partition is called great if the **sum** of elements of each group is greater than or equal to `k`.\n\n\nReturn *the number of **distinct** great partitions*. Since the answer may be too large, return it **modulo** `109 + 7`.\n\n\nTwo partitions are considered distinct if some element `nums[i]` is in different groups in the two partitions.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** nums = [1,2,3,4], k = 4\n**Output:** 6\n**Explanation:** The great partitions are: ([1,2,3], [4]), ([1,3], [2,4]), ([1,4], [2,3]), ([2,3], [1,4]), ([2,4], [1,3]) and ([4], [1,2,3]).\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** nums = [3,3,3], k = 4\n**Output:** 0\n**Explanation:** There are no great partitions for this array.\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** nums = [6,6], k = 2\n**Output:** 2\n**Explanation:** We can either put nums[0] in the first partition or in the second partition.\nThe great partitions will be ([6], [6]) and ([6], [6]).\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= nums.length, k <= 1000`\n* `1 <= nums[i] <= 109`\n\n\n",
  "canonical_solution": "class Solution:\n    def countPartitions(self, nums: List[int], k: int) -> int:\n        if sum(nums) < k * 2:\n            return 0\n        mod = 10**9 + 7\n        n = len(nums)\n        f = [[0] * k for _ in range(n + 1)]\n        f[0][0] = 1\n        ans = 1\n        for i in range(1, n + 1):\n            ans = ans * 2 % mod\n            for j in range(k):\n                f[i][j] = f[i - 1][j]\n                if j >= nums[i - 1]:\n                    f[i][j] = (f[i][j] + f[i - 1][j - nums[i - 1]]) % mod\n        return (ans - sum(f[-1]) * 2 + mod) % mod\n",
  "test_case_generator": "\nimport random\n\nclass Solution:\n    def countPartitions(self, nums: List[int], k: int) -> int:\n        if sum(nums) < k * 2:\n            return 0\n        mod = 10**9 + 7\n        n = len(nums)\n        f = [[0] * k for _ in range(n + 1)]\n        f[0][0] = 1\n        ans = 1\n        for i in range(1, n + 1):\n            ans = ans * 2 % mod\n            for j in range(k):\n                f[i][j] = f[i - 1][j]\n                if j >= nums[i - 1]:\n                    f[i][j] = (f[i][j] + f[i - 1][j - nums[i - 1]]) % mod\n        return (ans - sum(f[-1]) * 2 + mod) % mod\n\n\ndef generate_test_case():\n    solution = Solution()\n    \n    # Generate random numbers list\n    nums = random.sample(range(1, 101), random.randint(2, 10))\n\n    # Generate a random k\n    k = random.randint(1, 1001)\n\n    # Calculate the expected result using the provided Solution class\n    expected_result = solution.countPartitions(nums, k)\n\n    return nums, k, expected_result\n\ndef test_generated_test_cases(num_tests):\n    test_case_generator_results = []\n    for i in range(num_tests):\n        nums, k, expected_result = generate_test_case()\n        solution = Solution()\n        assert solution.countPartitions(nums, k) == expected_result\n        print(f\"assert solution.countPartitions({nums}, {k}) == {expected_result}\")\n        test_case_generator_results.append(f\"assert solution.countPartitions({nums}, {k}) == {expected_result}\") # You can find that we construct the test case in the same format as the example\n    return test_case_generator_results\n\nif __name__ == \"__main__\":\n    num_tests = 100  # You can change this to generate more test cases\n    test_case_generator_results = test_generated_test_cases(num_tests)\n",
  "test_case": "assert solution.countPartitions([35, 8], 231) == 0\nassert solution.countPartitions([25, 41, 68, 66, 43, 4, 96, 8], 62) == 224\nassert solution.countPartitions([68, 75, 23, 32], 633) == 0\nassert solution.countPartitions([95, 50, 13, 100, 76, 30, 39, 79, 86], 16) == 508\nassert solution.countPartitions([57, 30, 78, 89, 31, 74, 92], 334) == 0\nassert solution.countPartitions([3, 76], 195) == 0\nassert solution.countPartitions([55, 10, 14], 21) == 2\nassert solution.countPartitions([32, 10, 38, 5], 708) == 0\nassert solution.countPartitions([18, 46, 81, 100, 30], 368) == 0\nassert solution.countPartitions([38, 29, 41, 46, 94, 99, 39], 885) == 0\nassert solution.countPartitions([99, 33, 88], 975) == 0\nassert solution.countPartitions([90, 63], 387) == 0\nassert solution.countPartitions([100, 22, 61, 82, 47, 66], 13) == 62\nassert solution.countPartitions([9, 23, 30], 54) == 0\nassert solution.countPartitions([15, 18], 56) == 0\nassert solution.countPartitions([76, 35, 72], 81) == 0\nassert solution.countPartitions([51, 84, 27, 4, 3, 67, 24, 70, 81, 15], 733) == 0\nassert solution.countPartitions([76, 14, 10, 58, 42, 75, 66], 319) == 0\nassert solution.countPartitions([60, 80, 12, 97, 74, 19, 18, 84], 273) == 0\nassert solution.countPartitions([49, 27, 11, 16], 417) == 0\nassert solution.countPartitions([38, 87, 80, 15, 81, 64], 110) == 38\nassert solution.countPartitions([11, 54, 10, 67, 41, 34, 97], 102) == 68\nassert solution.countPartitions([17, 50, 97, 64, 88, 100, 72], 717) == 0\nassert solution.countPartitions([71, 57, 87, 8, 74, 24, 35, 48], 478) == 0\nassert solution.countPartitions([9, 50, 86, 17], 833) == 0\nassert solution.countPartitions([47, 94, 73, 76, 36, 38, 56, 87, 95], 230) == 244\nassert solution.countPartitions([84, 37, 74], 472) == 0\nassert solution.countPartitions([20, 54, 83, 47], 951) == 0\nassert solution.countPartitions([14, 42, 55, 10, 62], 270) == 0\nassert solution.countPartitions([99, 46, 16, 14, 59, 82, 5, 56, 32], 655) == 0\nassert solution.countPartitions([61, 29, 46, 18, 62, 2, 92, 52, 54, 22], 419) == 0\nassert solution.countPartitions([16, 85], 772) == 0\nassert solution.countPartitions([11, 52, 25, 83, 20], 356) == 0\nassert solution.countPartitions([75, 90, 61, 23, 59, 3, 64, 88, 69], 114) == 452\nassert solution.countPartitions([68, 95, 10, 77, 33], 256) == 0\nassert solution.countPartitions([77, 74, 30, 6], 961) == 0\nassert solution.countPartitions([42, 37, 60, 47, 70, 18, 22, 9, 96], 381) == 0\nassert solution.countPartitions([88, 42, 22, 91, 98], 816) == 0\nassert solution.countPartitions([62, 74, 61, 7, 75], 36) == 28\nassert solution.countPartitions([84, 97, 29, 82, 53, 13, 61], 28) == 124\nassert solution.countPartitions([94, 45, 49, 48, 56, 53, 100, 16], 651) == 0\nassert solution.countPartitions([25, 36, 26, 18, 20, 95, 87, 56, 5], 960) == 0\nassert solution.countPartitions([74, 67, 3, 28, 66], 672) == 0\nassert solution.countPartitions([24, 38, 52], 296) == 0\nassert solution.countPartitions([36, 70, 7, 23, 59, 2, 31], 141) == 0\nassert solution.countPartitions([90, 49, 95, 65, 93, 73, 67, 21], 681) == 0\nassert solution.countPartitions([95, 34, 8, 16, 12, 28, 92, 44, 38], 9) == 508\nassert solution.countPartitions([61, 40, 68, 2, 32, 23, 46], 834) == 0\nassert solution.countPartitions([53, 3], 865) == 0\nassert solution.countPartitions([41, 20, 88, 26], 659) == 0\nassert solution.countPartitions([87, 52, 82, 50, 40, 48, 28], 131) == 70\nassert solution.countPartitions([45, 99, 96, 73, 69, 37, 97, 6, 5, 94], 109) == 944\nassert solution.countPartitions([33, 73, 7, 12, 71, 36, 91, 34, 42, 84], 188) == 460\nassert solution.countPartitions([90, 47], 583) == 0\nassert solution.countPartitions([12, 34, 59], 643) == 0\nassert solution.countPartitions([16, 56, 34, 46, 24, 82, 85, 45], 511) == 0\nassert solution.countPartitions([6, 70, 16, 84], 477) == 0\nassert solution.countPartitions([36, 69, 82, 24, 23], 77) == 16\nassert solution.countPartitions([62, 94], 342) == 0\nassert solution.countPartitions([54, 58], 777) == 0\nassert solution.countPartitions([72, 76, 34, 3, 15], 643) == 0\nassert solution.countPartitions([70, 82, 60, 5, 32, 73, 38, 64, 55], 350) == 0\nassert solution.countPartitions([44, 96], 498) == 0\nassert solution.countPartitions([14, 66, 56, 46, 58, 35, 9], 186) == 0\nassert solution.countPartitions([74, 63, 8, 26, 25, 46], 81) == 30\nassert solution.countPartitions([63, 78, 25, 37, 7, 39, 31, 75, 93, 91], 792) == 0\nassert solution.countPartitions([21, 52, 47, 11, 60, 89, 2, 19, 81], 472) == 0\nassert solution.countPartitions([42, 78, 50, 88, 3, 65, 27], 101) == 84\nassert solution.countPartitions([61, 13, 33, 1, 73, 80], 451) == 0\nassert solution.countPartitions([49, 99, 72, 46, 32, 24, 95], 534) == 0\nassert solution.countPartitions([37, 47], 394) == 0\nassert solution.countPartitions([93, 49, 4, 99, 18, 14], 232) == 0\nassert solution.countPartitions([84, 67, 30, 29, 12, 79, 21, 4, 55, 85], 215) == 152\nassert solution.countPartitions([86, 15, 29, 93, 34, 30, 71, 61, 16], 993) == 0\nassert solution.countPartitions([29, 10, 50, 45, 8], 272) == 0\nassert solution.countPartitions([53, 48, 30, 57, 65, 76, 61, 92], 618) == 0\nassert solution.countPartitions([63, 65], 153) == 0\nassert solution.countPartitions([18, 92, 25, 19, 9, 84], 365) == 0\nassert solution.countPartitions([29, 71, 82, 26, 9], 351) == 0\nassert solution.countPartitions([98, 6, 61, 71, 42, 69, 95], 234) == 0\nassert solution.countPartitions([83, 81, 15, 36, 97], 925) == 0\nassert solution.countPartitions([88, 25, 57, 66, 99, 54, 30, 36, 27], 301) == 0\nassert solution.countPartitions([40, 100, 69, 38], 847) == 0\nassert solution.countPartitions([60, 27, 62, 35, 92], 403) == 0\nassert solution.countPartitions([79, 73], 519) == 0\nassert solution.countPartitions([44, 9, 73, 68, 29], 567) == 0\nassert solution.countPartitions([8, 35, 25, 92, 15, 100, 59, 52], 866) == 0\nassert solution.countPartitions([92, 93, 80, 2, 53], 635) == 0\nassert solution.countPartitions([26, 55, 25, 93, 14, 97, 7, 69, 4], 592) == 0\nassert solution.countPartitions([3, 71, 26, 42, 7, 12, 49, 5, 46], 170) == 0\nassert solution.countPartitions([6, 74, 89, 80, 75, 60, 39, 52], 166) == 142\nassert solution.countPartitions([89, 64, 94, 66, 75, 62, 45, 73], 914) == 0\nassert solution.countPartitions([47, 79, 54, 1, 16, 86, 94, 80, 65, 90], 1000) == 0\nassert solution.countPartitions([39, 26, 80, 15, 76, 87, 38, 45], 773) == 0\nassert solution.countPartitions([36, 35, 9, 20, 61, 67, 5, 77, 48, 86], 636) == 0\nassert solution.countPartitions([65, 23, 51, 5, 6], 665) == 0\nassert solution.countPartitions([15, 41], 987) == 0\nassert solution.countPartitions([95, 3, 23, 89, 92], 930) == 0\nassert solution.countPartitions([1, 37, 55, 34], 656) == 0\nassert solution.countPartitions([16, 73, 50, 67], 168) == 0",
  "inefficient_solution": "class Solution:\n    def countPartitions(self, nums: List[int], k: int) -> int:\n        if sum(nums) < k * 2:\n            return 0\n        mod = 10**9 + 7\n        n = len(nums)\n        f = [[[0] * k for _ in range(n + 1)] for _ in range(n + 1)]\n        f[0][0][0] = 1\n        ans = 1\n        for i in range(1, n + 1):\n            f[i][i][0] = 1\n            for j in range(i):\n                for l in range(k):\n                    f[i][j+1][l] = f[i][j][l]\n                    if l >= nums[i-1]:\n                        f[i][j+1][l] = (f[i][j+1][l] + f[i-1][j][l - nums[i-1]]) % mod\n            for j in range(i + 1):\n                for l in range(k):\n                    if l >= nums[i-1]:\n                        f[i][j][l] = (f[i][j][l] + f[i-1][j-1][l - nums[i-1]]) % mod\n            ans = ans * 2 % mod\n        return (ans - sum([sum([sum(row) for row in col]) for col in f[-1]]) * 2 + mod) % mod",
  "is_python": true
}