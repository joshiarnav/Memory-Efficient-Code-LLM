{
  "problem_idx": 1203,
  "task_name": "Sort Items by Groups Respecting Dependencies",
  "markdown_description": "\nThere are\u00a0`n`\u00a0items each\u00a0belonging to zero or one of\u00a0`m`\u00a0groups where `group[i]`\u00a0is the group that the `i`-th item belongs to and it's equal to `-1`\u00a0if the `i`-th item belongs to no group. The items and the groups are zero indexed. A group can have no item belonging to it.\n\n\nReturn a sorted list of the items such that:\n\n\n* The items that belong to the same group are next to each other in the sorted list.\n* There are some\u00a0relations\u00a0between these items where\u00a0`beforeItems[i]`\u00a0is a list containing all the items that should come before the\u00a0`i`-th item in the sorted array (to the left of the\u00a0`i`-th item).\n\n\nReturn any solution if there is more than one solution and return an **empty list**\u00a0if there is no solution.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n**![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1200-1299/1203.Sort%20Items%20by%20Groups%20Respecting%20Dependencies/images/1359_ex1.png)**\n\n\n\n```\n\n**Input:** n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3,6],[],[],[]]\n**Output:** [6,3,4,1,5,2,0,7]\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3],[],[4],[]]\n**Output:** []\n**Explanation:**\u00a0This is the same as example 1 except that 4 needs to be before 6 in the sorted list.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= m <= n <= 3 * 104`\n* `group.length == beforeItems.length == n`\n* `-1 <= group[i] <= m - 1`\n* `0 <= beforeItems[i].length <= n - 1`\n* `0 <= beforeItems[i][j] <= n - 1`\n* `i != beforeItems[i][j]`\n* `beforeItems[i]`does not contain\u00a0duplicates elements.\n\n\n",
  "canonical_solution": "class Solution:\n    def sortItems(\n        self, n: int, m: int, group: List[int], beforeItems: List[List[int]]\n    ) -> List[int]:\n        def topo_sort(degree, graph, items):\n            q = deque(i for _, i in enumerate(items) if degree[i] == 0)\n            res = []\n            while q:\n                i = q.popleft()\n                res.append(i)\n                for j in graph[i]:\n                    degree[j] -= 1\n                    if degree[j] == 0:\n                        q.append(j)\n            return res if len(res) == len(items) else []\n\n        idx = m\n        group_items = [[] for _ in range(n + m)]\n        for i, g in enumerate(group):\n            if g == -1:\n                group[i] = idx\n                idx += 1\n            group_items[group[i]].append(i)\n\n        item_degree = [0] * n\n        group_degree = [0] * (n + m)\n        item_graph = [[] for _ in range(n)]\n        group_graph = [[] for _ in range(n + m)]\n        for i, gi in enumerate(group):\n            for j in beforeItems[i]:\n                gj = group[j]\n                if gi == gj:\n                    item_degree[i] += 1\n                    item_graph[j].append(i)\n                else:\n                    group_degree[gi] += 1\n                    group_graph[gj].append(gi)\n\n        group_order = topo_sort(group_degree, group_graph, range(n + m))\n        if not group_order:\n            return []\n        ans = []\n        for gi in group_order:\n            items = group_items[gi]\n            item_order = topo_sort(item_degree, item_graph, items)\n            if len(items) != len(item_order):\n                return []\n            ans.extend(item_order)\n        return ans\n",
  "test_case_generator": "\nimport random\n\nclass Solution:\n    def sortItems(self, n, m, group, beforeItems):\n        def topo_sort(degree, graph, items):\n            q = deque(i for _, i in enumerate(items) if degree[i] == 0)\n            res = []\n            while q:\n                i = q.popleft()\n                res.append(i)\n                for j in graph[i]:\n                    degree[j] -= 1\n                    if degree[j] == 0:\n                        q.append(j)\n            return res if len(res) == len(items) else []\n\n        idx = m\n        group_items = [[] for _ in range(n + m)]\n        for i, g in enumerate(group):\n            if g == -1:\n                group[i] = idx\n                idx += 1\n            group_items[group[i]].append(i)\n\n        item_degree = [0] * n\n        group_degree = [0] * (n + m)\n        item_graph = [[] for _ in range(n)]\n        group_graph = [[] for _ in range(n + m)]\n        for i, gi in enumerate(group):\n            for j in beforeItems[i]:\n                gj = group[j]\n                if gi == gj:\n                    item_degree[i] += 1\n                    item_graph[j].append(i)\n                else:\n                    group_degree[gi] += 1\n                    group_graph[gj].append(gi)\n\n        group_order = topo_sort(group_degree, group_graph, range(n + m))\n        if not group_order:\n            return []\n        ans = []\n        for gi in group_order:\n            items = group_items[gi]\n            item_order = topo_sort(item_degree, item_graph, items)\n            if len(items) != len(item_order):\n                return []\n            ans.extend(item_order)\n        return ans\n\ndef generate_test_case():\n    solution = Solution()\n\n    # Generate random integers for n and m\n    n = random.randint(2, 10)\n    m = random.randint(1, n)\n\n    # Generate random group list\n    group = [random.randint(-1, m-1) for _ in range(n)]\n\n    # Generate random beforeItems list\n    beforeItems = [[] for _ in range(n)]\n    for i in range(n):\n        num_items = random.randint(0, n-1)\n        for _ in range(num_items):\n            beforeItems[i].append(random.randint(0, n-1))\n\n    # Calculate the expected result using the provided Solution class\n    expected_result = solution.sortItems(n, m, group, beforeItems)\n\n    return n, m, group, beforeItems, expected_result\n\ndef test_generated_test_cases(num_tests):\n    test_case_generator_results = []\n    for i in range(num_tests):\n        n, m, group, beforeItems, expected_result = generate_test_case()\n        solution = Solution()\n        assert solution.sortItems(n, m, group, beforeItems) == expected_result\n        if len(expected_result) != 0:\n            print(f\"assert solution.sortItems({n}, {m}, {group}, {beforeItems}) == {expected_result}\")\n            test_case_generator_results.append(f\"assert solution.sortItems({n}, {m}, {group}, {beforeItems}) == {expected_result}\")\n    return test_case_generator_results\n\nif __name__ == \"__main__\":\n    num_tests = 100  # You can change this to generate more test cases\n    test_case_generator_results = test_generated_test_cases(num_tests)\n",
  "test_case": "assert solution.sortItems(3, 3, [0, 2, 3], [[], [], [0]]) == [0, 1, 2]\nassert solution.sortItems(2, 2, [2, 0], [[], []]) == [1, 0]\nassert solution.sortItems(6, 1, [1, 0, 2, 0, 3, 4], [[4, 5, 5, 4, 4], [0], [], [0, 5], [2], []]) == [2, 5, 4, 0, 1, 3]\nassert solution.sortItems(2, 1, [0, 0], [[1], []]) == [1, 0]\nassert solution.sortItems(4, 2, [1, 1, 1, 0], [[], [], [], [1, 0]]) == [0, 1, 2, 3]\nassert solution.sortItems(4, 4, [0, 1, 2, 0], [[], [2, 3], [3, 3, 3], []]) == [0, 3, 2, 1]\nassert solution.sortItems(4, 2, [1, 2, 0, 0], [[3, 2, 2], [3], [], []]) == [2, 3, 0, 1]\nassert solution.sortItems(2, 1, [1, 2], [[], [0]]) == [0, 1]\nassert solution.sortItems(3, 1, [1, 2, 0], [[1], [2], []]) == [2, 1, 0]\nassert solution.sortItems(2, 1, [1, 0], [[1], []]) == [1, 0]\nassert solution.sortItems(6, 3, [0, 3, 1, 4, 0, 5], [[4, 1, 4], [], [0, 1], [1, 2], [], [0]]) == [1, 4, 0, 2, 5, 3]",
  "inefficient_solution": "class Solution:\n    def sortItems(\n        self, n: int, m: int, group: List[int], beforeItems: List[List[int]]\n    ) -> List[int]:\n        idx = m\n        group_items = [[] for _ in range(n + m)]\n        for i, g in enumerate(group):\n            if g == -1:\n                group[i] = idx\n                idx += 1\n            group_items[group[i]].append(i)\n\n        item_degree = [0] * n\n        group_degree = [0] * (n + m)\n        item_graph = [[] for _ in range(n)]\n        group_graph = [[] for _ in range(n + m)]\n        for i, gi in enumerate(group):\n            for j in beforeItems[i]:\n                gj = group[j]\n                if gi == gj:\n                    item_degree[i] += 1\n                    item_graph[j].append(i)\n                else:\n                    group_degree[gi] += 1\n                    group_graph[gj].append(gi)\n\n        group_order = self.topo_sort(group_degree, group_graph, range(n + m), n + m)\n        if not group_order:\n            return []\n        ans = []\n        for gi in group_order:\n            items = group_items[gi]\n            item_order = self.topo_sort(item_degree, item_graph, items, n)\n            if len(items) != len(item_order):\n                return []\n            ans.extend(item_order)\n        return ans\n\n    def topo_sort(self, degree, graph, items, max_item):\n        q = deque(i for _, i in enumerate(items) if degree[i] == 0)\n        res = []\n        while q:\n            i = q.popleft()\n            res.append(i)\n            for j in graph[i]:\n                degree[j] -= 1\n                if degree[j] >= 0:\n                    q.append(j)\n        return res if len(res) == len(items) else []\n\n    def check_topo_sort(self, degree, graph, items):\n        count = 0\n        for i in range(len(degree)):\n            if degree[i] == 0:\n                count += 1\n        if count == 0:\n            return False\n        res = []\n        q = deque(i for i in range(len(degree)) if degree[i] == 0)\n        while q:\n            i = q.popleft()\n            res.append(i)\n            for j in graph[i]:\n                degree[j] -= 1\n                if degree[j] >= 0:\n                    q.append(j)\n        return len(res) == len(items)\n\n    def dfs(self, degree, graph, items, max_item):\n        for i in range(len(degree)):\n            if degree[i] == 0:\n                self.dfs_util(degree, graph, items, max_item, i)\n\n    def dfs_util(self, degree, graph, items, max_item, i):\n        res = []\n        q = deque(i)\n        while q:\n            i = q.popleft()\n            res.append(i)\n            for j in graph[i]:\n                degree[j] -= 1\n                if degree[j] >= 0:\n                    q.append(j)\n        if len(res) != len(items):\n            return False\n        return True",
  "is_python": true
}