{
  "problem_idx": 1477,
  "task_name": "Find Two Non",
  "markdown_description": "\nYou are given an array of integers `arr` and an integer `target`.\n\n\nYou have to find **two non-overlapping sub-arrays** of `arr` each with a sum equal `target`. There can be multiple answers so you have to find an answer where the sum of the lengths of the two sub-arrays is **minimum**.\n\n\nReturn *the minimum sum of the lengths* of the two required sub-arrays, or return `-1` if you cannot find such two sub-arrays.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** arr = [3,2,2,4,3], target = 3\n**Output:** 2\n**Explanation:** Only two sub-arrays have sum = 3 ([3] and [3]). The sum of their lengths is 2.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** arr = [7,3,4,7], target = 7\n**Output:** 2\n**Explanation:** Although we have three non-overlapping sub-arrays of sum = 7 ([7], [3,4] and [7]), but we will choose the first and third sub-arrays as the sum of their lengths is 2.\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** arr = [4,3,2,6,2,3,4], target = 6\n**Output:** -1\n**Explanation:** We have only one sub-array of sum = 6.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= arr.length <= 105`\n* `1 <= arr[i] <= 1000`\n* `1 <= target <= 108`\n\n\n",
  "canonical_solution": "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        d = {0: 0}\n        s, n = 0, len(arr)\n        f = [inf] * (n + 1)\n        ans = inf\n        for i, v in enumerate(arr, 1):\n            s += v\n            f[i] = f[i - 1]\n            if s - target in d:\n                j = d[s - target]\n                f[i] = min(f[i], i - j)\n                ans = min(ans, f[j] + i - j)\n            d[s] = i\n        return -1 if ans > n else ans\n",
  "test_case_generator": "\nimport random\nfrom math import inf\nfrom typing import List\n\nclass Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        d = {0: 0}\n        s, n = 0, len(arr)\n        f = [inf] * (n + 1)\n        ans = inf\n        for i, v in enumerate(arr, 1):\n            s += v\n            f[i] = f[i - 1]\n            if s - target in d:\n                j = d[s - target]\n                f[i] = min(f[i], i - j)\n                ans = min(ans, f[j] + i - j)\n            d[s] = i\n        return -1 if ans > n else ans\n\n\ndef generate_test_case():\n    solution = Solution()\n    \n    # Generate random numbers list\n    arr = random.sample(range(1, 1001), random.randint(1, 101))\n    \n    # Generate a random target sum\n    target = random.randint(1, 10**8)\n\n    # Calculate the expected result using the provided Solution class\n    expected_result = solution.minSumOfLengths(arr, target)\n\n    return arr, target, expected_result\n\ndef test_generated_test_cases(num_tests):\n    test_case_generator_results = []\n    for i in range(num_tests):\n        arr, target, expected_result = generate_test_case()\n        solution = Solution()\n        assert solution.minSumOfLengths(arr, target) == expected_result\n        if expected_result != -1:\n            print(f\"assert solution.minSumOfLengths({arr}, {target}) == {expected_result}\")\n            test_case_generator_results.append(f\"assert solution.minSumOfLengths({arr}, {target}) == {expected_result}\") # You can find that we construct the test case in the same format as the example\n    return test_case_generator_results\n\nif __name__ == \"__main__\":\n    num_tests = 100  # You can change this to generate more test cases\n    test_case_generator_results = test_generated_test_cases(num_tests)\n",
  "test_case": "",
  "inefficient_solution": "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        sums = [0] * len(arr)\n        for i in range(len(arr)):\n            sums[i] = sums[i-1] + arr[i] if i > 0 else arr[i]\n        lengths = [float('inf')] * len(arr)\n        dp = [[float('inf')] * len(arr) for _ in range(len(arr))]\n        ans = float('inf')\n        for i in range(len(arr)):\n            for j in range(i, len(arr)):\n                s = sums[j] - sums[i-1] if i > 0 else sums[j]\n                if s == target:\n                    lengths[i] = min(lengths[i], j - i + 1)\n                    for k in range(i):\n                        dp[i][j] = min(dp[i][j], dp[k][i-1] + j - i + 1)\n                    ans = min(ans, dp[i][j])\n                dp[i][j] = min(dp[i][j], lengths[j])\n        return -1 if ans > len(arr) else ans",
  "is_python": true
}