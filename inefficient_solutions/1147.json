{
  "problem_idx": 1147,
  "task_name": "Longest Chunked Palindrome Decomposition",
  "markdown_description": "\nYou are given a string `text`. You should split it to k substrings `(subtext1, subtext2, ..., subtextk)` such that:\n\n\n* `subtexti` is a **non-empty** string.\n* The concatenation of all the substrings is equal to `text` (i.e., `subtext1 + subtext2 + ... + subtextk == text`).\n* `subtexti == subtextk - i + 1` for all valid values of `i` (i.e., `1 <= i <= k`).\n\n\nReturn the largest possible value of `k`.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** text = \"ghiabcdefhelloadamhelloabcdefghi\"\n**Output:** 7\n**Explanation:** We can split the string on \"(ghi)(abcdef)(hello)(adam)(hello)(abcdef)(ghi)\".\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** text = \"merchant\"\n**Output:** 1\n**Explanation:** We can split the string on \"(merchant)\".\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** text = \"antaprezatepzapreanta\"\n**Output:** 11\n**Explanation:** We can split the string on \"(a)(nt)(a)(pre)(za)(tep)(za)(pre)(a)(nt)(a)\".\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= text.length <= 1000`\n* `text` consists only of lowercase English characters.\n\n\n",
  "canonical_solution": "class Solution:\n    def longestDecomposition(self, text: str) -> int:\n        ans = 0\n        i, j = 0, len(text) - 1\n        while i <= j:\n            k = 1\n            ok = False\n            while i + k - 1 < j - k + 1:\n                if text[i : i + k] == text[j - k + 1 : j + 1]:\n                    ans += 2\n                    i += k\n                    j -= k\n                    ok = True\n                    break\n                k += 1\n            if not ok:\n                ans += 1\n                break\n        return ans\n",
  "test_case_generator": "\nimport random\n\nclass Solution:\n    def longestDecomposition(self, text: str) -> int:\n        ans = 0\n        i, j = 0, len(text) - 1\n        while i <= j:\n            k = 1\n            ok = False\n            while i + k - 1 < j - k + 1:\n                if text[i : i + k] == text[j - k + 1 : j + 1]:\n                    ans += 2\n                    i += k\n                    j -= k\n                    ok = True\n                    break\n                k += 1\n            if not ok:\n                ans += 1\n                break\n        return ans\n\ndef generate_test_case():\n    solution = Solution()\n    \n    # Generate random string \n    text = ''.join(random.choices('abcdefghijklmnopqrstuvwxyz', k=random.randint(1, 10)))\n    \n    # Calculate the expected result using the provided Solution class\n    expected_result = solution.longestDecomposition(text)\n\n    return text, expected_result\n\ndef test_generated_test_cases(num_tests):\n    test_case_generator_results = []\n    for i in range(num_tests):\n        text, expected_result = generate_test_case()\n        solution = Solution()\n        assert solution.longestDecomposition(text) == expected_result\n        if expected_result != 0:\n            print(f\"assert solution.longestDecomposition('{text}') == {expected_result}\")\n            test_case_generator_results.append(f\"assert solution.longestDecomposition('{text}') == {expected_result}\")\n    return test_case_generator_results\n\nif __name__ == \"__main__\":\n    num_tests = 100  # You can change this to generate more test cases\n    test_case_generator_results = test_generated_test_cases(num_tests)\n",
  "test_case": "assert solution.longestDecomposition('vtzvhpipsq') == 1\nassert solution.longestDecomposition('rehtb') == 1\nassert solution.longestDecomposition('wqbktuqss') == 1\nassert solution.longestDecomposition('axbqecj') == 1\nassert solution.longestDecomposition('hgd') == 1\nassert solution.longestDecomposition('qvkfvmj') == 1\nassert solution.longestDecomposition('phyoiep') == 3\nassert solution.longestDecomposition('wcye') == 1\nassert solution.longestDecomposition('suhieqly') == 1\nassert solution.longestDecomposition('sizkid') == 1\nassert solution.longestDecomposition('zwi') == 1\nassert solution.longestDecomposition('gus') == 1\nassert solution.longestDecomposition('brgvki') == 1\nassert solution.longestDecomposition('o') == 1\nassert solution.longestDecomposition('jitfvjnb') == 1\nassert solution.longestDecomposition('ceksb') == 1\nassert solution.longestDecomposition('hyhbuvf') == 1\nassert solution.longestDecomposition('dhn') == 1\nassert solution.longestDecomposition('hdfsrwus') == 1\nassert solution.longestDecomposition('fmm') == 1\nassert solution.longestDecomposition('ht') == 1\nassert solution.longestDecomposition('ttkjagw') == 1\nassert solution.longestDecomposition('fxcoul') == 1\nassert solution.longestDecomposition('wgnltnond') == 1\nassert solution.longestDecomposition('dih') == 1\nassert solution.longestDecomposition('fftyo') == 1\nassert solution.longestDecomposition('iezyxjazc') == 1\nassert solution.longestDecomposition('v') == 1\nassert solution.longestDecomposition('gjhtxdy') == 1\nassert solution.longestDecomposition('h') == 1\nassert solution.longestDecomposition('cfo') == 1\nassert solution.longestDecomposition('mubkvvme') == 1\nassert solution.longestDecomposition('ydqi') == 1\nassert solution.longestDecomposition('yewbo') == 1\nassert solution.longestDecomposition('dop') == 1\nassert solution.longestDecomposition('wjljbus') == 1\nassert solution.longestDecomposition('j') == 1\nassert solution.longestDecomposition('ekpbusjag') == 1\nassert solution.longestDecomposition('qlpwmqv') == 1\nassert solution.longestDecomposition('vgtnlt') == 1\nassert solution.longestDecomposition('blzgflon') == 1\nassert solution.longestDecomposition('mqqm') == 4\nassert solution.longestDecomposition('uqhxlvkee') == 1\nassert solution.longestDecomposition('isqjyglnhy') == 1\nassert solution.longestDecomposition('kgrbgssvs') == 1\nassert solution.longestDecomposition('bzt') == 1\nassert solution.longestDecomposition('mmsvm') == 3\nassert solution.longestDecomposition('hr') == 1\nassert solution.longestDecomposition('mqv') == 1\nassert solution.longestDecomposition('ze') == 1\nassert solution.longestDecomposition('drxrg') == 1\nassert solution.longestDecomposition('o') == 1\nassert solution.longestDecomposition('fnjq') == 1\nassert solution.longestDecomposition('vggmyjjz') == 1\nassert solution.longestDecomposition('nmyg') == 1\nassert solution.longestDecomposition('bj') == 1\nassert solution.longestDecomposition('fl') == 1\nassert solution.longestDecomposition('fhp') == 1\nassert solution.longestDecomposition('zfks') == 1\nassert solution.longestDecomposition('t') == 1\nassert solution.longestDecomposition('kv') == 1\nassert solution.longestDecomposition('jwwri') == 1\nassert solution.longestDecomposition('exxd') == 1\nassert solution.longestDecomposition('kzenz') == 1\nassert solution.longestDecomposition('ohnhrsy') == 1\nassert solution.longestDecomposition('ss') == 2\nassert solution.longestDecomposition('fvn') == 1\nassert solution.longestDecomposition('kuduwx') == 1\nassert solution.longestDecomposition('ypcrleeroq') == 1\nassert solution.longestDecomposition('ppatsmxt') == 1\nassert solution.longestDecomposition('fyvrbngp') == 1\nassert solution.longestDecomposition('unl') == 1\nassert solution.longestDecomposition('ueylwlplwq') == 1\nassert solution.longestDecomposition('jh') == 1\nassert solution.longestDecomposition('sauazq') == 1\nassert solution.longestDecomposition('utjszcer') == 1\nassert solution.longestDecomposition('bephljx') == 1\nassert solution.longestDecomposition('ccmkmxtnsg') == 1\nassert solution.longestDecomposition('wt') == 1\nassert solution.longestDecomposition('giuldd') == 1\nassert solution.longestDecomposition('ki') == 1\nassert solution.longestDecomposition('fbvwxw') == 1\nassert solution.longestDecomposition('dvyfyp') == 1\nassert solution.longestDecomposition('kjppsavsr') == 1\nassert solution.longestDecomposition('zihzecksso') == 1\nassert solution.longestDecomposition('qfhhffb') == 1\nassert solution.longestDecomposition('eqrkqfi') == 1\nassert solution.longestDecomposition('ge') == 1\nassert solution.longestDecomposition('opechc') == 1\nassert solution.longestDecomposition('fwvdplnsnq') == 1\nassert solution.longestDecomposition('nlqabqe') == 1\nassert solution.longestDecomposition('tnpewdfbs') == 1\nassert solution.longestDecomposition('bafycspac') == 1\nassert solution.longestDecomposition('hmyvsbkzea') == 1\nassert solution.longestDecomposition('pjdyad') == 1\nassert solution.longestDecomposition('vpg') == 1\nassert solution.longestDecomposition('cqrxwqev') == 1\nassert solution.longestDecomposition('kbpkb') == 3\nassert solution.longestDecomposition('rbuoyi') == 1\nassert solution.longestDecomposition('j') == 1",
  "inefficient_solution": "class Solution:\n    def longestDecomposition(self, text: str) -> int:\n        ans = 0\n        for i in range(len(text)):\n            for j in range(i, len(text)):\n                temp = text[i:j+1]\n                for k in range(len(text)):\n                    for last in range(k, len(temp)):\n                        if temp == temp[last-k+1:last+1] and text[k:last+1] == temp:\n                            ans += 1\n                            text = text[:i] + text[i+1:j+1] + text[j+1:]\n                            break\n                    if ans > 0:\n                        break\n                if ans > 0:\n                    break\n            if ans > 0:\n                break\n        return ans",
  "is_python": true
}