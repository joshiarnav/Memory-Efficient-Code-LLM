{
  "problem_idx": 399,
  "task_name": "Evaluate Division",
  "markdown_description": "\nYou are given an array of variable pairs `equations` and an array of real numbers `values`, where `equations[i] = [Ai, Bi]` and `values[i]` represent the equation `Ai / Bi = values[i]`. Each `Ai` or `Bi` is a string that represents a single variable.\n\n\nYou are also given some `queries`, where `queries[j] = [Cj, Dj]` represents the `jth` query where you must find the answer for `Cj / Dj = ?`.\n\n\nReturn *the answers to all queries*. If a single answer cannot be determined, return `-1.0`.\n\n\n**Note:** The input is always valid. You may assume that evaluating the queries will not result in division by zero and that there is no contradiction.\n\n\n**Note:**The variables that do not occur in the list of equations are undefined, so the answer cannot be determined for them.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]\n**Output:** [6.00000,0.50000,-1.00000,1.00000,-1.00000]\n**Explanation:** \nGiven: *a / b = 2.0*, *b / c = 3.0*\nqueries are: *a / c = ?*, *b / a = ?*, *a / e = ?*, *a / a = ?*, *x / x = ?* \nreturn: [6.0, 0.5, -1.0, 1.0, -1.0 ]\nnote: x is undefined => -1.0\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]\n**Output:** [3.75000,0.40000,5.00000,0.20000]\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]\n**Output:** [0.50000,2.00000,-1.00000,-1.00000]\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= equations.length <= 20`\n* `equations[i].length == 2`\n* `1 <= Ai.length, Bi.length <= 5`\n* `values.length == equations.length`\n* `0.0 < values[i] <= 20.0`\n* `1 <= queries.length <= 20`\n* `queries[i].length == 2`\n* `1 <= Cj.length, Dj.length <= 5`\n* `Ai, Bi, Cj, Dj` consist of lower case English letters and digits.\n\n\n",
  "canonical_solution": "class Solution:\n    def calcEquation(\n        self, equations: List[List[str]], values: List[float], queries: List[List[str]]\n    ) -> List[float]:\n        def find(x):\n            if p[x] != x:\n                origin = p[x]\n                p[x] = find(p[x])\n                w[x] *= w[origin]\n            return p[x]\n\n        w = defaultdict(lambda: 1)\n        p = defaultdict()\n        for a, b in equations:\n            p[a], p[b] = a, b\n        for i, v in enumerate(values):\n            a, b = equations[i]\n            pa, pb = find(a), find(b)\n            if pa == pb:\n                continue\n            p[pa] = pb\n            w[pa] = w[b] * v / w[a]\n        return [\n            -1 if c not in p or d not in p or find(c) != find(d) else w[c] / w[d]\n            for c, d in queries\n        ]\n",
  "test_case_generator": "\nimport random\n\nfrom typing import List, Tuple\nfrom collections import defaultdict\n\ndef generate_test_case() -> Tuple[List[List[str]], List[float], List[List[str]], List[float]]:\n    solution = Solution()\n\n    equations = []\n    values = []\n    queries = []\n\n    # Generate random equations and values\n    num_equations = random.randint(1, 21)\n    for _ in range(num_equations):\n        equation = [random.choice(string.ascii_lowercase + string.digits) for _ in range(2)]\n        value = random.uniform(0.1, 20.0)\n        equations.append(equation)\n        values.append(value)\n\n    # Generate random queries\n    num_queries = random.randint(1, 21)\n    for _ in range(num_queries):\n        query = [random.choice(string.ascii_lowercase + string.digits) for _ in range(2)]\n        queries.append(query)\n\n    # Calculate the expected result using the provided Solution class\n    expected_result = solution.calcEquation(equations, values, queries)\n\n    return equations, values, queries, expected_result\n\ndef test_generated_test_cases(num_tests: int) -> List[Tuple[List[List[str]], List[float], List[List[str]], List[float]]]:\n    test_case_generator_results = []\n    for i in range(num_tests):\n        equations, values, queries, expected_result = generate_test_case()\n        solution = Solution()\n        assert solution.calcEquation(equations, values, queries) == expected_result\n        print(f\"assert solution.calcEquation({equations}, {values}, {queries}) == {expected_result}\")\n        test_case_generator_results.append((equations, values, queries, expected_result))\n    return test_case_generator_results\n\nif __name__ == \"__main__\":\n    import string\n    num_tests = 100  # You can change this to generate more test cases\n    test_case_generator_results = test_generated_test_cases(num_tests)\n",
  "test_case": "",
  "inefficient_solution": "class Solution:\n    def calcEquation(\n        self, equations: List[List[str]], values: List[float], queries: List[List[str]]\n    ) -> List[float]:\n        def find(x):\n            if p[x] != x:\n                origin = p[x]\n                p[x] = find(p[x])\n                w[x] *= float(w[origin])\n            return p[x]\n\n        global w, p\n        w = {}\n        p = {}\n        for i, eq in enumerate(equations):\n            for a, b in [(eq[0], eq[1]), (eq[1], eq[0])]:\n                w[a] = w.get(a, [0] * len(equations))\n                w[a][i] = values[i]\n                p[a] = a\n                p[b] = b\n        for i, eq in enumerate(equations):\n            for j, eq2 in enumerate(equations):\n                if i != j:\n                    for a, b in [(eq[0], eq2[0]), (eq[0], eq2[1]), (eq[1], eq2[0]), (eq[1], eq2[1])]:\n                        pa, pb = find(a), find(b)\n                        if pa == pb:\n                            continue\n                        p[pa] = pb\n                        w[pa] = w.get(pa, [0] * len(equations))\n                        w[pa][j] = w[b][j] * values[i] / w[a][i]\n        return [\n            -1\n            if c not in p or d not in p or find(c) != find(d)\n            else w[find(c)][len(equations)]\n            for c, d in queries\n        ]",
  "is_python": true
}