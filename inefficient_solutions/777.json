{
  "problem_idx": 777,
  "task_name": "Swap Adjacent in LR String",
  "markdown_description": "\nIn a string composed of `'L'`, `'R'`, and `'X'` characters, like `\"RXXLRXRXL\"`, a move consists of either replacing one occurrence of `\"XL\"` with `\"LX\"`, or replacing one occurrence of `\"RX\"` with `\"XR\"`. Given the starting string `start` and the ending string `end`, return `True` if and only if there exists a sequence of moves to transform one string to the other.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** start = \"RXXLRXRXL\", end = \"XRLXXRRLX\"\n**Output:** true\n**Explanation:** We can transform start to end following these steps:\nRXXLRXRXL ->\nXRXLRXRXL ->\nXRLXRXRXL ->\nXRLXXRRXL ->\nXRLXXRRLX\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** start = \"X\", end = \"L\"\n**Output:** false\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= start.length\u00a0<= 104`\n* `start.length == end.length`\n* Both `start` and `end` will only consist of characters in `'L'`, `'R'`, and\u00a0`'X'`.\n\n\n",
  "canonical_solution": "class Solution:\n    def canTransform(self, start: str, end: str) -> bool:\n        n = len(start)\n        i = j = 0\n        while 1:\n            while i < n and start[i] == 'X':\n                i += 1\n            while j < n and end[j] == 'X':\n                j += 1\n            if i >= n and j >= n:\n                return True\n            if i >= n or j >= n or start[i] != end[j]:\n                return False\n            if start[i] == 'L' and i < j:\n                return False\n            if start[i] == 'R' and i > j:\n                return False\n            i, j = i + 1, j + 1\n",
  "test_case_generator": "\nimport random\n\nclass Solution:\n    def canTransform(self, start: str, end: str) -> bool:\n        n = len(start)\n        i = j = 0\n        while 1:\n            while i < n and start[i] == 'X':\n                i += 1\n            while j < n and end[j] == 'X':\n                j += 1\n            if i >= n and j >= n:\n                return True\n            if i >= n or j >= n or start[i] != end[j]:\n                return False\n            if start[i] == 'L' and i < j:\n                return False\n            if start[i] == 'R' and i > j:\n                return False\n            i, j = i + 1, j + 1\n\ndef generate_test_case():\n    solution = Solution()\n    \n    # Generate random start and end strings\n    start = \"\".join(random.choices(['L', 'R', 'X'], k=random.randint(1, 10)))\n    end = \"\".join(random.choices(['L', 'R', 'X'], k=len(start)))\n\n    # Calculate the expected result using the provided Solution class\n    expected_result = solution.canTransform(start, end)\n\n    return start, end, expected_result\n\ndef test_generated_test_cases(num_tests):\n    test_case_generator_results = []\n    for i in range(num_tests):\n        start, end, expected_result = generate_test_case()\n        solution = Solution()\n        assert solution.canTransform(start, end) == expected_result\n        print(f\"assert solution.canTransform('{start}', '{end}') == {expected_result}\")\n        test_case_generator_results.append(f\"assert solution.canTransform('{start}', '{end}') == {expected_result}\") # You can find that we construct the test case in the same format as the example\n    return test_case_generator_results\n\nif __name__ == \"__main__\":\n    num_tests = 100  # You can change this to generate more test cases\n    test_case_generator_results = test_generated_test_cases(num_tests)\n",
  "test_case": "assert solution.canTransform('R', 'L') == False\nassert solution.canTransform('LLLX', 'RRXR') == False\nassert solution.canTransform('LXRXRXLRL', 'RXXXLXXXR') == False\nassert solution.canTransform('LLRXLLLL', 'RXRLRLXR') == False\nassert solution.canTransform('R', 'X') == False\nassert solution.canTransform('R', 'R') == True\nassert solution.canTransform('XLRL', 'RXXL') == False\nassert solution.canTransform('RR', 'XL') == False\nassert solution.canTransform('LRLRLLLRR', 'RRRXRLXXL') == False\nassert solution.canTransform('XXL', 'RXR') == False\nassert solution.canTransform('RLRXRLXLLX', 'LXRLXLRRXX') == False\nassert solution.canTransform('LXL', 'XRX') == False\nassert solution.canTransform('LLRR', 'LLLX') == False\nassert solution.canTransform('XLXXLRRXRX', 'LXXXXLLLLL') == False\nassert solution.canTransform('RRRL', 'XRLL') == False\nassert solution.canTransform('XRLRL', 'XLRLX') == False\nassert solution.canTransform('XR', 'LX') == False\nassert solution.canTransform('L', 'X') == False\nassert solution.canTransform('XLLRLRRR', 'RLRRLRRL') == False\nassert solution.canTransform('XXRRLLL', 'XXXRXRX') == False\nassert solution.canTransform('RRXL', 'RXRR') == False\nassert solution.canTransform('LRXXXRRX', 'LLRLLXRR') == False\nassert solution.canTransform('LX', 'XL') == False\nassert solution.canTransform('RLXXXRLLX', 'XLRRRRLXR') == False\nassert solution.canTransform('XRRRRR', 'RRRLXR') == False\nassert solution.canTransform('RLL', 'RRL') == False\nassert solution.canTransform('LL', 'LL') == True\nassert solution.canTransform('XLLXLLXRX', 'XLXLXRLXR') == False\nassert solution.canTransform('LLRXRXRXRR', 'RRRXRRRRRR') == False\nassert solution.canTransform('XXXXLRXRLX', 'LRLLXRRLLX') == False\nassert solution.canTransform('RR', 'LX') == False\nassert solution.canTransform('LR', 'XX') == False\nassert solution.canTransform('LLLXLXRXX', 'LLXRLRXXL') == False\nassert solution.canTransform('LR', 'LR') == True\nassert solution.canTransform('RLXLR', 'RRLXL') == False\nassert solution.canTransform('XLRR', 'RXXX') == False\nassert solution.canTransform('LLRRRX', 'RRXRLR') == False\nassert solution.canTransform('R', 'L') == False\nassert solution.canTransform('RRRL', 'RRXR') == False\nassert solution.canTransform('LRLRX', 'XRXLR') == False\nassert solution.canTransform('RXLX', 'LLRX') == False\nassert solution.canTransform('XRLR', 'LLXX') == False\nassert solution.canTransform('LX', 'LL') == False\nassert solution.canTransform('LRXXLXL', 'RRRRLLL') == False\nassert solution.canTransform('LXL', 'RRL') == False\nassert solution.canTransform('RLRL', 'RXRL') == False\nassert solution.canTransform('LXXLLXX', 'XLLLRLX') == False\nassert solution.canTransform('LXLX', 'XLLL') == False\nassert solution.canTransform('LR', 'LX') == False\nassert solution.canTransform('LRR', 'XRR') == False\nassert solution.canTransform('XRLLR', 'RLLXR') == False\nassert solution.canTransform('RXL', 'LLR') == False\nassert solution.canTransform('LX', 'XL') == False\nassert solution.canTransform('XRRLLXX', 'RLXRLXX') == False\nassert solution.canTransform('XRXRLRR', 'LRRXLLR') == False\nassert solution.canTransform('RRLXXLRX', 'RXRLRLRL') == False\nassert solution.canTransform('RRRLXX', 'XRLXRX') == False\nassert solution.canTransform('LLRXR', 'XXRRL') == False\nassert solution.canTransform('RXXXLXXXXL', 'XXXXRLRLRX') == False\nassert solution.canTransform('XRRRRL', 'LXLXRX') == False\nassert solution.canTransform('LRRXLXLX', 'XLLLXRRR') == False\nassert solution.canTransform('RXRXXRRR', 'RXRRLLRR') == False\nassert solution.canTransform('XRRRLXLXR', 'LRRLLXRRX') == False\nassert solution.canTransform('LX', 'XX') == False\nassert solution.canTransform('XRXLXLRLXX', 'XLRXRRXRXR') == False\nassert solution.canTransform('LRLX', 'XLRX') == False\nassert solution.canTransform('RLLRRXXXL', 'LRRXXLLXX') == False\nassert solution.canTransform('XXXRX', 'LRXLL') == False\nassert solution.canTransform('LXX', 'LRL') == False\nassert solution.canTransform('XLXRXL', 'XXRRRX') == False\nassert solution.canTransform('XXXXXLXL', 'LXRRLXXR') == False\nassert solution.canTransform('XRLXLLLR', 'LRXXXXLL') == False\nassert solution.canTransform('RRRR', 'XXXL') == False\nassert solution.canTransform('RRXLLR', 'LRXXRR') == False\nassert solution.canTransform('LXXX', 'XLRX') == False\nassert solution.canTransform('RRLLRRXX', 'LRRRRLXR') == False\nassert solution.canTransform('RLLR', 'LRXR') == False\nassert solution.canTransform('XR', 'RR') == False\nassert solution.canTransform('RLLLLLRXL', 'LLXLXRRLX') == False\nassert solution.canTransform('RXLRLLXXXX', 'LXRRXLLXXR') == False\nassert solution.canTransform('XLLLRXLLLX', 'LRLLRLLXLL') == False\nassert solution.canTransform('XRXRRXXLLX', 'RXRXXXXLLX') == False\nassert solution.canTransform('LLXXLRLXRL', 'XXXXLRXRXX') == False\nassert solution.canTransform('LLLRLX', 'RRXLLX') == False\nassert solution.canTransform('RXRXRLXX', 'RXRXRXLR') == False\nassert solution.canTransform('L', 'X') == False\nassert solution.canTransform('RXRRXLR', 'XLLRLXX') == False\nassert solution.canTransform('L', 'L') == True\nassert solution.canTransform('R', 'R') == True\nassert solution.canTransform('RXRRX', 'LXXRL') == False\nassert solution.canTransform('LL', 'LX') == False\nassert solution.canTransform('RXR', 'XLL') == False\nassert solution.canTransform('LRR', 'XRL') == False\nassert solution.canTransform('LRLXLLXXL', 'LLRLRRXLX') == False\nassert solution.canTransform('LXRRRXLR', 'LLRLXRRX') == False\nassert solution.canTransform('RXXXXX', 'XLLXRR') == False\nassert solution.canTransform('LXLXLXXRLL', 'LXLLLLXLRX') == False\nassert solution.canTransform('RLLR', 'XRXR') == False\nassert solution.canTransform('XRRL', 'RRRL') == False\nassert solution.canTransform('LLXRLRRL', 'XXLLRXRX') == False",
  "inefficient_solution": "class Solution:\n    def canTransform(self, start: str, end: str) -> bool:\n        n = len(start) + 1\n        start = list(start) + ['']\n        end = list(end) + ['']\n        i = j = 0\n        while i < n:\n            while i < n and start[i] == 'X':\n                i += 1\n            while j < n and end[j] == 'X':\n                j += 1\n            if i >= n and j >= n:\n                return True\n            if i >= n or j >= n or start[i] != end[j]:\n                return False\n            if start[i] == 'L' and i < j:\n                i += 1\n                start = start[:i] + [''] + start[i:]\n            if start[i] == 'R' and i > j:\n                j += 1\n                end = end[:j] + [''] + end[j:]\n            if start[i] == 'L' and i > j:\n                return False\n            if start[i] == 'R' and i < j:\n                return False\n            i, j = i + 1, j + 1",
  "is_python": true
}