{
  "problem_idx": 782,
  "task_name": "Transform to Chessboard",
  "markdown_description": "\nYou are given an `n x n` binary grid `board`. In each move, you can swap any two rows with each other, or any two columns with each other.\n\n\nReturn *the minimum number of moves to transform the board into a **chessboard board***. If the task is impossible, return `-1`.\n\n\nA **chessboard board** is a board where no `0`'s and no `1`'s are 4-directionally adjacent.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0700-0799/0782.Transform%20to%20Chessboard/images/chessboard1-grid.jpg)\n\n```\n\n**Input:** board = [[0,1,1,0],[0,1,1,0],[1,0,0,1],[1,0,0,1]]\n**Output:** 2\n**Explanation:** One potential sequence of moves is shown.\nThe first move swaps the first and second column.\nThe second move swaps the second and third row.\n\n```\n\n**Example 2:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0700-0799/0782.Transform%20to%20Chessboard/images/chessboard2-grid.jpg)\n\n```\n\n**Input:** board = [[0,1],[1,0]]\n**Output:** 0\n**Explanation:** Also note that the board with 0 in the top left corner, is also a valid chessboard.\n\n```\n\n**Example 3:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0700-0799/0782.Transform%20to%20Chessboard/images/chessboard3-grid.jpg)\n\n```\n\n**Input:** board = [[1,0],[1,0]]\n**Output:** -1\n**Explanation:** No matter what sequence of moves you make, you cannot end with a valid chessboard.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `n == board.length`\n* `n == board[i].length`\n* `2 <= n <= 30`\n* `board[i][j]` is either\u00a0`0` or `1`.\n\n\n",
  "canonical_solution": "class Solution:\n    def movesToChessboard(self, board: List[List[int]]) -> int:\n        def f(mask, cnt):\n            ones = mask.bit_count()\n            if n & 1:\n                if abs(n - 2 * ones) != 1 or abs(n - 2 * cnt) != 1:\n                    return -1\n                if ones == n // 2:\n                    return n // 2 - (mask & 0xAAAAAAAA).bit_count()\n                return (n + 1) // 2 - (mask & 0x55555555).bit_count()\n            else:\n                if ones != n // 2 or cnt != n // 2:\n                    return -1\n                cnt0 = n // 2 - (mask & 0xAAAAAAAA).bit_count()\n                cnt1 = n // 2 - (mask & 0x55555555).bit_count()\n                return min(cnt0, cnt1)\n\n        n = len(board)\n        mask = (1 << n) - 1\n        rowMask = colMask = 0\n        for i in range(n):\n            rowMask |= board[0][i] << i\n            colMask |= board[i][0] << i\n        revRowMask = mask ^ rowMask\n        revColMask = mask ^ colMask\n        sameRow = sameCol = 0\n        for i in range(n):\n            curRowMask = curColMask = 0\n            for j in range(n):\n                curRowMask |= board[i][j] << j\n                curColMask |= board[j][i] << j\n            if curRowMask not in (rowMask, revRowMask) or curColMask not in (\n                colMask,\n                revColMask,\n            ):\n                return -1\n            sameRow += curRowMask == rowMask\n            sameCol += curColMask == colMask\n        t1 = f(rowMask, sameRow)\n        t2 = f(colMask, sameCol)\n        return -1 if t1 == -1 or t2 == -1 else t1 + t2\n",
  "test_case_generator": "\nimport random\n\nclass Solution:\n    def movesToChessboard(self, board: List[List[int]]) -> int:\n        def f(mask, cnt):\n            ones = mask.bit_count()\n            if n & 1:\n                if abs(n - 2 * ones) != 1 or abs(n - 2 * cnt) != 1:\n                    return -1\n                if ones == n // 2:\n                    return n // 2 - (mask & 0xAAAAAAAA).bit_count()\n                return (n + 1) // 2 - (mask & 0x55555555).bit_count()\n            else:\n                if ones != n // 2 or cnt != n // 2:\n                    return -1\n                cnt0 = n // 2 - (mask & 0xAAAAAAAA).bit_count()\n                cnt1 = n // 2 - (mask & 0x55555555).bit_count()\n                return min(cnt0, cnt1)\n\n        n = len(board)\n        mask = (1 << n) - 1\n        rowMask = colMask = 0\n        for i in range(n):\n            rowMask |= board[0][i] << i\n            colMask |= board[i][0] << i\n        revRowMask = mask ^ rowMask\n        revColMask = mask ^ colMask\n        sameRow = sameCol = 0\n        for i in range(n):\n            curRowMask = curColMask = 0\n            for j in range(n):\n                curRowMask |= board[i][j] << j\n                curColMask |= board[j][i] << j\n            if curRowMask not in (rowMask, revRowMask) or curColMask not in (\n                colMask,\n                revColMask,\n            ):\n                return -1\n            sameRow += curRowMask == rowMask\n            sameCol += curColMask == colMask\n        t1 = f(rowMask, sameRow)\n        t2 = f(colMask, sameCol)\n        return -1 if t1 == -1 or t2 == -1 else t1 + t2\n\ndef generate_test_case():\n    solution = Solution()\n    \n    # Generate random board size\n    n = random.randint(2, 5)\n\n    # Generate random board\n    board = [[random.randint(0, 1) for _ in range(n)] for _ in range(n)]\n\n    # Calculate the expected result using the provided Solution class\n    expected_result = solution.movesToChessboard(board)\n\n    return board, expected_result\n\ndef test_generated_test_cases(num_tests):\n    test_case_generator_results = []\n    for i in range(num_tests):\n        board, expected_result = generate_test_case()\n        solution = Solution()\n        assert solution.movesToChessboard(board) == expected_result\n        print(f\"assert solution.movesToChessboard({board}) == {expected_result}\")\n        test_case_generator_results.append(f\"assert solution.movesToChessboard({board}) == {expected_result}\") # You can find that we construct the test case in the same format as the example\n    return test_case_generator_results\n\nif __name__ == \"__main__\":\n    num_tests = 100  # You can change this to generate more test cases\n    test_case_generator_results = test_generated_test_cases(num_tests)\n",
  "test_case": "assert solution.movesToChessboard([[1, 1, 1], [1, 0, 0], [0, 0, 1]]) == -1\nassert solution.movesToChessboard([[0, 0, 0], [0, 0, 1], [1, 1, 1]]) == -1\nassert solution.movesToChessboard([[0, 0, 0, 1, 0], [0, 0, 0, 0, 0], [1, 0, 1, 1, 1], [1, 0, 0, 0, 1], [1, 0, 0, 1, 1]]) == -1\nassert solution.movesToChessboard([[1, 1, 1, 1, 0], [1, 1, 0, 1, 0], [1, 0, 1, 1, 0], [1, 0, 1, 0, 1], [1, 0, 0, 1, 0]]) == -1\nassert solution.movesToChessboard([[0, 0], [1, 0]]) == -1\nassert solution.movesToChessboard([[0, 1], [0, 1]]) == -1\nassert solution.movesToChessboard([[1, 1, 1, 0], [1, 1, 0, 1], [1, 0, 0, 1], [0, 0, 1, 0]]) == -1\nassert solution.movesToChessboard([[1, 1, 1, 0], [0, 1, 0, 1], [1, 0, 1, 1], [1, 1, 1, 1]]) == -1\nassert solution.movesToChessboard([[1, 1], [1, 0]]) == -1\nassert solution.movesToChessboard([[0, 0], [0, 1]]) == -1\nassert solution.movesToChessboard([[1, 1, 0, 1, 0], [1, 1, 0, 1, 0], [1, 1, 1, 1, 0], [0, 0, 0, 0, 0], [1, 0, 0, 1, 1]]) == -1\nassert solution.movesToChessboard([[1, 0, 1, 0], [1, 0, 1, 0], [0, 1, 0, 0], [0, 0, 1, 0]]) == -1\nassert solution.movesToChessboard([[1, 1, 0, 0, 1], [0, 1, 0, 0, 1], [0, 0, 0, 0, 0], [0, 0, 0, 0, 1], [0, 0, 0, 1, 0]]) == -1\nassert solution.movesToChessboard([[0, 1, 1, 1, 1], [0, 1, 0, 1, 0], [0, 1, 0, 0, 0], [0, 1, 0, 0, 0], [0, 1, 0, 1, 0]]) == -1\nassert solution.movesToChessboard([[1, 0, 0, 1], [0, 0, 0, 1], [1, 1, 0, 1], [1, 1, 1, 0]]) == -1\nassert solution.movesToChessboard([[0, 0], [1, 0]]) == -1\nassert solution.movesToChessboard([[1, 0], [1, 0]]) == -1\nassert solution.movesToChessboard([[0, 1, 1], [1, 0, 1], [0, 0, 1]]) == -1\nassert solution.movesToChessboard([[1, 1, 1, 0, 0], [0, 0, 1, 0, 0], [1, 1, 0, 0, 0], [1, 0, 1, 1, 0], [0, 1, 1, 0, 1]]) == -1\nassert solution.movesToChessboard([[0, 1, 0], [1, 0, 1], [0, 1, 0]]) == 0\nassert solution.movesToChessboard([[1, 1, 0], [0, 1, 0], [1, 0, 0]]) == -1\nassert solution.movesToChessboard([[1, 0, 1, 1, 1], [1, 1, 1, 0, 1], [1, 0, 1, 1, 1], [0, 1, 1, 1, 0], [0, 1, 1, 0, 0]]) == -1\nassert solution.movesToChessboard([[1, 1, 0, 1], [0, 1, 0, 1], [1, 0, 0, 0], [0, 1, 0, 1]]) == -1\nassert solution.movesToChessboard([[0, 0, 0], [1, 0, 0], [1, 0, 1]]) == -1\nassert solution.movesToChessboard([[0, 1, 0, 0, 1], [1, 0, 1, 1, 1], [1, 0, 1, 1, 1], [0, 0, 0, 0, 1], [1, 0, 1, 1, 0]]) == -1\nassert solution.movesToChessboard([[1, 0, 1], [0, 1, 0], [1, 1, 1]]) == -1\nassert solution.movesToChessboard([[1, 1, 1], [0, 0, 1], [1, 1, 1]]) == -1\nassert solution.movesToChessboard([[0, 1, 1, 0, 1], [1, 0, 1, 1, 1], [1, 1, 1, 1, 0], [1, 1, 0, 1, 0], [0, 1, 0, 1, 0]]) == -1\nassert solution.movesToChessboard([[0, 1, 0, 0, 0], [0, 1, 1, 0, 0], [1, 0, 0, 0, 0], [0, 0, 1, 0, 1], [1, 1, 0, 0, 0]]) == -1\nassert solution.movesToChessboard([[1, 0], [1, 0]]) == -1\nassert solution.movesToChessboard([[0, 1, 1, 0], [1, 0, 1, 1], [0, 0, 1, 0], [1, 0, 1, 1]]) == -1\nassert solution.movesToChessboard([[0, 0, 0, 1], [0, 1, 1, 0], [0, 1, 0, 1], [0, 0, 1, 1]]) == -1\nassert solution.movesToChessboard([[1, 1, 0, 1], [1, 1, 1, 1], [0, 0, 1, 0], [1, 1, 0, 1]]) == -1\nassert solution.movesToChessboard([[1, 1], [1, 0]]) == -1\nassert solution.movesToChessboard([[0, 1, 1, 1, 0], [1, 1, 0, 0, 1], [0, 1, 0, 1, 1], [0, 1, 1, 0, 1], [0, 0, 1, 1, 0]]) == -1\nassert solution.movesToChessboard([[1, 1], [0, 0]]) == -1\nassert solution.movesToChessboard([[1, 1, 0], [1, 1, 0], [1, 0, 1]]) == -1\nassert solution.movesToChessboard([[1, 1], [1, 1]]) == -1\nassert solution.movesToChessboard([[1, 1, 1, 1], [1, 1, 0, 0], [0, 0, 1, 0], [0, 1, 1, 0]]) == -1\nassert solution.movesToChessboard([[0, 1, 1], [0, 1, 1], [1, 1, 1]]) == -1\nassert solution.movesToChessboard([[0, 1, 0, 0, 0], [1, 0, 0, 0, 1], [1, 1, 1, 1, 1], [1, 1, 0, 1, 1], [1, 0, 1, 1, 0]]) == -1\nassert solution.movesToChessboard([[0, 1, 1, 0], [1, 1, 1, 0], [1, 1, 1, 1], [1, 1, 0, 0]]) == -1\nassert solution.movesToChessboard([[1, 1, 1], [0, 1, 0], [1, 1, 0]]) == -1\nassert solution.movesToChessboard([[0, 1, 1, 1], [0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1]]) == -1\nassert solution.movesToChessboard([[1, 0, 0, 0, 0], [1, 0, 1, 0, 0], [0, 1, 0, 1, 0], [0, 0, 1, 0, 0], [0, 0, 0, 1, 0]]) == -1\nassert solution.movesToChessboard([[0, 0], [0, 1]]) == -1\nassert solution.movesToChessboard([[0, 0, 0], [0, 1, 1], [0, 0, 0]]) == -1\nassert solution.movesToChessboard([[1, 0, 0, 0, 1], [0, 1, 1, 1, 0], [0, 1, 1, 0, 0], [1, 0, 0, 1, 1], [1, 0, 0, 1, 0]]) == -1\nassert solution.movesToChessboard([[0, 1, 1], [1, 0, 1], [0, 0, 0]]) == -1\nassert solution.movesToChessboard([[1, 1, 0, 0], [0, 1, 0, 1], [1, 1, 0, 0], [1, 1, 0, 0]]) == -1\nassert solution.movesToChessboard([[0, 1, 1], [0, 1, 1], [1, 0, 0]]) == 2\nassert solution.movesToChessboard([[1, 0, 1, 0, 1], [0, 0, 1, 0, 0], [0, 1, 1, 0, 0], [0, 1, 1, 0, 1], [1, 0, 1, 1, 1]]) == -1\nassert solution.movesToChessboard([[0, 0, 0, 1, 1], [1, 0, 0, 1, 1], [0, 0, 0, 1, 1], [0, 0, 1, 1, 0], [0, 0, 1, 1, 0]]) == -1\nassert solution.movesToChessboard([[0, 0, 0, 0], [1, 1, 1, 0], [0, 1, 1, 0], [1, 0, 1, 0]]) == -1\nassert solution.movesToChessboard([[1, 0], [0, 1]]) == 0\nassert solution.movesToChessboard([[0, 0], [1, 1]]) == -1\nassert solution.movesToChessboard([[0, 1, 1, 0, 1], [0, 0, 0, 0, 1], [1, 1, 0, 0, 1], [1, 1, 1, 0, 1], [1, 1, 1, 1, 1]]) == -1\nassert solution.movesToChessboard([[1, 0, 1], [1, 1, 0], [1, 1, 0]]) == -1\nassert solution.movesToChessboard([[0, 0, 1, 1, 0], [1, 0, 1, 0, 0], [1, 0, 0, 0, 1], [0, 0, 0, 0, 1], [0, 0, 0, 0, 1]]) == -1\nassert solution.movesToChessboard([[1, 1, 1], [0, 0, 0], [0, 1, 1]]) == -1\nassert solution.movesToChessboard([[1, 0, 1], [1, 0, 0], [1, 1, 1]]) == -1\nassert solution.movesToChessboard([[0, 0], [1, 1]]) == -1\nassert solution.movesToChessboard([[1, 0, 1, 0, 1], [0, 0, 1, 1, 1], [1, 0, 1, 1, 0], [0, 0, 0, 1, 1], [1, 1, 1, 0, 0]]) == -1\nassert solution.movesToChessboard([[1, 0], [1, 0]]) == -1\nassert solution.movesToChessboard([[1, 0, 1, 0], [0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 0]]) == -1\nassert solution.movesToChessboard([[0, 1], [0, 1]]) == -1\nassert solution.movesToChessboard([[0, 0, 1, 1, 1], [0, 0, 0, 0, 1], [1, 1, 1, 1, 0], [0, 1, 0, 0, 1], [1, 1, 1, 1, 0]]) == -1\nassert solution.movesToChessboard([[0, 0, 1, 0], [0, 0, 1, 0], [0, 1, 0, 1], [0, 0, 0, 1]]) == -1\nassert solution.movesToChessboard([[1, 0, 1, 1, 1], [1, 1, 0, 0, 1], [1, 1, 1, 1, 0], [0, 0, 0, 1, 0], [0, 1, 0, 0, 0]]) == -1\nassert solution.movesToChessboard([[1, 1, 0, 0], [1, 1, 0, 0], [1, 0, 0, 0], [1, 0, 0, 0]]) == -1\nassert solution.movesToChessboard([[0, 1, 0, 1], [1, 0, 0, 1], [0, 1, 0, 1], [0, 1, 1, 0]]) == -1\nassert solution.movesToChessboard([[1, 1, 0, 0, 1], [1, 0, 1, 1, 1], [0, 1, 1, 0, 1], [0, 1, 1, 1, 0], [0, 0, 0, 0, 1]]) == -1\nassert solution.movesToChessboard([[0, 0, 1], [1, 0, 0], [1, 1, 0]]) == -1\nassert solution.movesToChessboard([[1, 1], [0, 1]]) == -1\nassert solution.movesToChessboard([[0, 0, 0, 0, 1], [0, 1, 1, 1, 1], [0, 0, 0, 1, 1], [1, 1, 1, 0, 0], [0, 0, 0, 0, 1]]) == -1\nassert solution.movesToChessboard([[1, 0, 1, 0], [0, 1, 1, 0], [0, 0, 1, 1], [0, 0, 0, 0]]) == -1\nassert solution.movesToChessboard([[1, 1, 1], [0, 0, 0], [0, 1, 0]]) == -1\nassert solution.movesToChessboard([[1, 1], [0, 1]]) == -1\nassert solution.movesToChessboard([[0, 1, 1, 1, 1], [0, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 0, 1, 1], [0, 0, 0, 0, 1]]) == -1\nassert solution.movesToChessboard([[1, 0, 1], [0, 0, 1], [0, 0, 1]]) == -1\nassert solution.movesToChessboard([[0, 1], [0, 0]]) == -1\nassert solution.movesToChessboard([[0, 0, 1], [1, 1, 1], [1, 0, 0]]) == -1\nassert solution.movesToChessboard([[0, 0, 0], [1, 0, 1], [1, 0, 1]]) == -1\nassert solution.movesToChessboard([[0, 1, 1, 0], [0, 1, 0, 0], [1, 0, 1, 1], [1, 0, 1, 0]]) == -1\nassert solution.movesToChessboard([[0, 0, 1, 1], [1, 0, 1, 1], [0, 0, 1, 1], [0, 0, 1, 0]]) == -1\nassert solution.movesToChessboard([[0, 0, 0], [0, 0, 0], [0, 0, 1]]) == -1\nassert solution.movesToChessboard([[1, 0, 0, 1], [0, 0, 0, 1], [1, 0, 1, 1], [1, 1, 1, 0]]) == -1\nassert solution.movesToChessboard([[1, 0, 1, 0, 0], [0, 0, 0, 0, 1], [1, 1, 0, 1, 1], [0, 1, 0, 1, 0], [0, 1, 0, 1, 1]]) == -1\nassert solution.movesToChessboard([[0, 1, 0], [0, 0, 1], [0, 0, 0]]) == -1\nassert solution.movesToChessboard([[1, 1, 1, 1, 0], [0, 1, 1, 0, 0], [1, 1, 1, 1, 0], [1, 0, 1, 0, 1], [1, 1, 1, 1, 1]]) == -1\nassert solution.movesToChessboard([[1, 1], [1, 1]]) == -1\nassert solution.movesToChessboard([[1, 1], [0, 1]]) == -1\nassert solution.movesToChessboard([[1, 1, 1], [0, 0, 1], [1, 0, 1]]) == -1\nassert solution.movesToChessboard([[1, 1, 0, 0], [0, 1, 0, 1], [1, 1, 0, 1], [1, 0, 0, 0]]) == -1\nassert solution.movesToChessboard([[1, 1, 0], [0, 0, 0], [1, 0, 0]]) == -1\nassert solution.movesToChessboard([[1, 0, 0], [0, 1, 1], [0, 0, 0]]) == -1\nassert solution.movesToChessboard([[1, 1], [0, 0]]) == -1\nassert solution.movesToChessboard([[1, 0, 0], [1, 0, 1], [1, 1, 0]]) == -1\nassert solution.movesToChessboard([[1, 1, 0, 0, 0], [0, 0, 0, 1, 0], [0, 1, 1, 0, 1], [0, 1, 0, 1, 1], [0, 0, 0, 1, 1]]) == -1\nassert solution.movesToChessboard([[1, 1, 1], [0, 1, 0], [1, 0, 1]]) == -1",
  "inefficient_solution": "class Solution:\n    def movesToChessboard(self, board):\n        n = len(board)\n        moves = 0\n        rowMoves = [0] * n\n        colMoves = [0] * n\n        targetRow = [0] * n\n        targetCol = [0] * n\n\n        for i in range(n):\n            for j in range(n):\n                if board[i][j] == 1:\n                    rowMoves[i] += 1\n                    colMoves[j] += 1\n                    targetRow[i] = 1\n                    targetCol[j] = 1\n\n        for i in range(n):\n            if rowMoves[i] != (n + 1) // 2:\n                targetRow[i] = 0\n            if colMoves[i] != (n + 1) // 2:\n                targetCol[i] = 0\n\n        moves += self.countMoves(rowMoves, targetRow)\n        moves += self.countMoves(colMoves, targetCol)\n\n        return moves\n\n    def countMoves(self, moves, target):\n        minMoves = float('inf')\n        for i in range(len(moves)):\n            if moves[i] != target[i]:\n                moves[i] = 0\n        for i in range(len(moves)):\n            if moves[i] != 0:\n                for j in range(len(moves)):\n                    if moves[j] == 0:\n                        moves[j], moves[i] = moves[i], moves[j]\n                        minMoves = min(minMoves, self.getMoves(moves, target))\n                        moves[j], moves[i] = moves[i], moves[j]\n        return minMoves\n\n    def getMoves(self, moves, target):\n        count = 0\n        for i in range(len(moves)):\n            if moves[i] != target[i]:\n                count += 1\n                if i + 1 < len(moves):\n                    moves[i], moves[i + 1] = moves[i + 1], moves[i]\n        return count",
  "is_python": true
}