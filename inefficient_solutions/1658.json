{
  "problem_idx": 1658,
  "task_name": "Minimum Operations to Reduce X to Zero",
  "markdown_description": "\nYou are given an integer array `nums` and an integer `x`. In one operation, you can either remove the leftmost or the rightmost element from the array `nums` and subtract its value from `x`. Note that this **modifies** the array for future operations.\n\n\nReturn *the **minimum number** of operations to reduce* `x` *to **exactly*** `0` *if it is possible**, otherwise, return* `-1`.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** nums = [1,1,4,2,3], x = 5\n**Output:** 2\n**Explanation:** The optimal solution is to remove the last two elements to reduce x to zero.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** nums = [5,6,7,8,9], x = 4\n**Output:** -1\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** nums = [3,2,20,1,1,3], x = 10\n**Output:** 5\n**Explanation:** The optimal solution is to remove the last three elements and the first two elements (5 operations in total) to reduce x to zero.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= nums.length <= 105`\n* `1 <= nums[i] <= 104`\n* `1 <= x <= 109`\n\n\n",
  "canonical_solution": "class Solution:\n    def minOperations(self, nums: List[int], x: int) -> int:\n        x = sum(nums) - x\n        ans = inf\n        n = len(nums)\n        s = j = 0\n        for i, v in enumerate(nums):\n            s += v\n            while j <= i and s > x:\n                s -= nums[j]\n                j += 1\n            if s == x:\n                ans = min(ans, n - (i - j + 1))\n        return -1 if ans == inf else ans\n",
  "test_case_generator": "\nimport random\n\nclass Solution:\n    def minOperations(self, nums: List[int], x: int) -> int:\n        x = sum(nums) - x\n        ans = inf\n        n = len(nums)\n        s = j = 0\n        for i, v in enumerate(nums):\n            s += v\n            while j <= i and s > x:\n                s -= nums[j]\n                j += 1\n            if s == x:\n                ans = min(ans, n - (i - j + 1))\n        return -1 if ans == inf else ans\n\ndef generate_test_case():\n    solution = Solution()\n    \n    # Generate random numbers list\n    nums = random.choices(range(1, 10001), k=random.randint(2, 10))\n    \n    # Generate a random x\n    x = random.randint(1, 1000000000)\n\n    # Calculate the expected result using the provided Solution class\n    expected_result = solution.minOperations(nums, x)\n\n    return nums, x, expected_result\n\ndef test_generated_test_cases(num_tests):\n    test_case_generator_results = []\n    for i in range(num_tests):\n        nums, x, expected_result = generate_test_case()\n        solution = Solution()\n        assert solution.minOperations(nums, x) == expected_result\n        if expected_result != -1:\n            print(f\"assert solution.minOperations({nums}, {x}) == {expected_result}\")\n            test_case_generator_results.append(f\"assert solution.minOperations({nums}, {x}) == {expected_result}\") # You can find that we construct the test case in the same format as the example\n    return test_case_generator_results\n\nif __name__ == \"__main__\":\n    num_tests = 100  # You can change this to generate more test cases\n    test_case_generator_results = test_generated_test_cases(num_tests)\n",
  "test_case": "",
  "inefficient_solution": "class Solution:\n    def minOperations(self, nums: List[int], x: int) -> int:\n        x = sum(nums) - x\n        res = []\n        n = len(nums)\n        for i in range(n):\n            temp = nums[i:]\n            temp_sum = sum(temp)\n            if temp_sum == x:\n                res.append(temp)\n        if not res:\n            return -1\n        ans = inf\n        for i, v in enumerate(res):\n            ans = min(ans, n - len(v))\n        return ans",
  "is_python": true
}