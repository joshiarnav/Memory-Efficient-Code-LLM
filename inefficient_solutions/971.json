{
  "problem_idx": 971,
  "task_name": "Flip Binary Tree To Match Preorder Traversal",
  "markdown_description": "\nYou are given the `root` of a binary tree with `n` nodes, where each node is uniquely assigned a value from `1` to `n`. You are also given a sequence of `n` values `voyage`, which is the **desired** [**pre-order traversal**](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order) of the binary tree.\n\n\nAny node in the binary tree can be **flipped** by swapping its left and right subtrees. For example, flipping node 1 will have the following effect:\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0900-0999/0971.Flip%20Binary%20Tree%20To%20Match%20Preorder%20Traversal/images/fliptree.jpg)\nFlip the **smallest** number of nodes so that the **pre-order traversal** of the tree **matches** `voyage`.\n\n\nReturn *a list of the values of all **flipped** nodes. You may return the answer in **any order**. If it is **impossible** to flip the nodes in the tree to make the pre-order traversal match* `voyage`*, return the list* `[-1]`.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0900-0999/0971.Flip%20Binary%20Tree%20To%20Match%20Preorder%20Traversal/images/1219-01.png)\n\n```\n\n**Input:** root = [1,2], voyage = [2,1]\n**Output:** [-1]\n**Explanation:** It is impossible to flip the nodes such that the pre-order traversal matches voyage.\n\n```\n\n**Example 2:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0900-0999/0971.Flip%20Binary%20Tree%20To%20Match%20Preorder%20Traversal/images/1219-02.png)\n\n```\n\n**Input:** root = [1,2,3], voyage = [1,3,2]\n**Output:** [1]\n**Explanation:** Flipping node 1 swaps nodes 2 and 3, so the pre-order traversal matches voyage.\n```\n\n**Example 3:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0900-0999/0971.Flip%20Binary%20Tree%20To%20Match%20Preorder%20Traversal/images/1219-02.png)\n\n```\n\n**Input:** root = [1,2,3], voyage = [1,2,3]\n**Output:** []\n**Explanation:** The tree's pre-order traversal already matches voyage, so no nodes need to be flipped.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* The number of nodes in the tree is `n`.\n* `n == voyage.length`\n* `1 <= n <= 100`\n* `1 <= Node.val, voyage[i] <= n`\n* All the values in the tree are **unique**.\n* All the values in `voyage` are **unique**.\n\n\n",
  "canonical_solution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def flipMatchVoyage(self, root: Optional[TreeNode], voyage: List[int]) -> List[int]:\n        def dfs(root):\n            nonlocal i, ok\n            if root is None or not ok:\n                return\n            if root.val != voyage[i]:\n                ok = False\n                return\n            i += 1\n            if root.left is None or root.left.val == voyage[i]:\n                dfs(root.left)\n                dfs(root.right)\n            else:\n                ans.append(root.val)\n                dfs(root.right)\n                dfs(root.left)\n\n        ans = []\n        i = 0\n        ok = True\n        dfs(root)\n        return ans if ok else [-1]\n",
  "test_case_generator": "\nimport random\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def flipMatchVoyage(self, root, voyage):\n        def dfs(root):\n            nonlocal i, ok\n            if root is None or not ok:\n                return\n            if root.val != voyage[i]:\n                ok = False\n                return\n            i += 1\n            if root.left is None or root.left.val == voyage[i]:\n                dfs(root.left)\n                dfs(root.right)\n            else:\n                ans.append(root.val)\n                dfs(root.right)\n                dfs(root.left)\n\n        ans = []\n        i = 0\n        ok = True\n        dfs(root)\n        return ans if ok else [-1]\n\ndef generate_test_case():\n    solution = Solution()\n    \n    # Generate random tree with n nodes\n    n = random.randint(1, 10)\n    tree_nodes = list(range(1, n + 1))\n    random.shuffle(tree_nodes)\n    root = TreeNode(tree_nodes[0])\n    stack = [root]\n    for i in range(1, n):\n        node = TreeNode(tree_nodes[i])\n        parent = stack[-1]\n        if parent.left is None:\n            parent.left = node\n        else:\n            parent.right = node\n            stack.pop()\n        stack.append(node)\n    \n    # Generate voyage\n    voyage = random.sample(tree_nodes, n)\n\n    # Calculate the expected result using the provided Solution class\n    expected_result = solution.flipMatchVoyage(root, voyage)\n\n    return root, voyage, expected_result\n\ndef test_generated_test_cases(num_tests):\n    test_case_generator_results = []\n    for i in range(num_tests):\n        root, voyage, expected_result = generate_test_case()\n        solution = Solution()\n        assert solution.flipMatchVoyage(root, voyage) == expected_result\n        if expected_result != [-1]:\n            print(f\"assert solution.flipMatchVoyage({root}, {voyage}) == {expected_result}\")\n            test_case_generator_results.append(f\"assert solution.flipMatchVoyage({root}, {voyage}) == {expected_result}\")\n    return test_case_generator_results\n\nif __name__ == \"__main__\":\n    num_tests = 100\n    test_case_generator_results = test_generated_test_cases(num_tests)\n",
  "test_case": "assert solution.flipMatchVoyage(<__main__.TreeNode object at 0x7f1abc1d0b10>, [2, 3, 1]) == []\nassert solution.flipMatchVoyage(<__main__.TreeNode object at 0x7f1abc1d0d90>, [2, 1]) == []\nassert solution.flipMatchVoyage(<__main__.TreeNode object at 0x7f1abc1aa210>, [1]) == []\nassert solution.flipMatchVoyage(<__main__.TreeNode object at 0x7f1abc1d1210>, [1]) == []\nassert solution.flipMatchVoyage(<__main__.TreeNode object at 0x7f1abc1d1210>, [1]) == []\nassert solution.flipMatchVoyage(<__main__.TreeNode object at 0x7f1abc1d1590>, [1]) == []\nassert solution.flipMatchVoyage(<__main__.TreeNode object at 0x7f1abc1d1990>, [1]) == []\nassert solution.flipMatchVoyage(<__main__.TreeNode object at 0x7f1abc1d1950>, [1, 2]) == []\nassert solution.flipMatchVoyage(<__main__.TreeNode object at 0x7f1abc1d2210>, [1]) == []\nassert solution.flipMatchVoyage(<__main__.TreeNode object at 0x7f1abc1d2250>, [1]) == []\nassert solution.flipMatchVoyage(<__main__.TreeNode object at 0x7f1abc1d2d10>, [2, 1]) == []\nassert solution.flipMatchVoyage(<__main__.TreeNode object at 0x7f1abc1d2910>, [1]) == []\nassert solution.flipMatchVoyage(<__main__.TreeNode object at 0x7f1abc1d2bd0>, [1]) == []\nassert solution.flipMatchVoyage(<__main__.TreeNode object at 0x7f1abc1d26d0>, [1]) == []\nassert solution.flipMatchVoyage(<__main__.TreeNode object at 0x7f1abc1d25d0>, [2, 1]) == []\nassert solution.flipMatchVoyage(<__main__.TreeNode object at 0x7f1abc1d3010>, [1]) == []\nassert solution.flipMatchVoyage(<__main__.TreeNode object at 0x7f1abc1d3410>, [1, 2]) == []\nassert solution.flipMatchVoyage(<__main__.TreeNode object at 0x7f1abc1d3490>, [2, 1, 3]) == []",
  "inefficient_solution": "class Solution:\n    def flipMatchVoyage(self, root: Optional[TreeNode], voyage: List[int]) -> List[int]:\n        self.ans = []\n        self.i = 0\n        self.ok = True\n        self.voyage = voyage\n        self.dfs(root)\n        return self.ans if self.ok else [-1]\n\n    def dfs(self, root):\n        if root is None:\n            return\n        self.dfs(root.left)\n        if root.val != self.voyage[self.i]:\n            self.ok = False\n            return\n        self.i += 1\n        if root.right is not None and root.right.val != self.voyage[self.i]:\n            self.ans.append(root.val)\n            self.i += 1\n        self.dfs(root.right)\n        self.dfs(root.left)",
  "is_python": true
}