{
  "problem_idx": 93,
  "task_name": "Restore IP Addresses",
  "markdown_description": "\nA **valid IP address** consists of exactly four integers separated by single dots. Each integer is between `0` and `255` (**inclusive**) and cannot have leading zeros.\n\n\n* For example, `\"0.1.2.201\"` and `\"192.168.1.1\"` are **valid** IP addresses, but `\"0.011.255.245\"`, `\"192.168.1.312\"` and `\"192.168@1.1\"` are **invalid** IP addresses.\n\n\nGiven a string `s` containing only digits, return *all possible valid IP addresses that can be formed by inserting dots into* `s`. You are **not** allowed to reorder or remove any digits in `s`. You may return the valid IP addresses in **any** order.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** s = \"25525511135\"\n**Output:** [\"255.255.11.135\",\"255.255.111.35\"]\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** s = \"0000\"\n**Output:** [\"0.0.0.0\"]\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** s = \"101023\"\n**Output:** [\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"]\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= s.length <= 20`\n* `s` consists of digits only.\n\n\n",
  "canonical_solution": "class Solution:\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        def check(i: int, j: int) -> int:\n            if s[i] == \"0\" and i != j:\n                return False\n            return 0 <= int(s[i : j + 1]) <= 255\n\n        def dfs(i: int):\n            if i >= n and len(t) == 4:\n                ans.append(\".\".join(t))\n                return\n            if i >= n or len(t) >= 4:\n                return\n            for j in range(i, min(i + 3, n)):\n                if check(i, j):\n                    t.append(s[i : j + 1])\n                    dfs(j + 1)\n                    t.pop()\n\n        n = len(s)\n        ans = []\n        t = []\n        dfs(0)\n        return ans\n",
  "test_case_generator": "\nimport random\n\nclass Solution:\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        def check(i: int, j: int) -> int:\n            if s[i] == \"0\" and i != j:\n                return False\n            return 0 <= int(s[i : j + 1]) <= 255\n\n        def dfs(i: int):\n            if i >= n and len(t) == 4:\n                ans.append(\".\".join(t))\n                return\n            if i >= n or len(t) >= 4:\n                return\n            for j in range(i, min(i + 3, n)):\n                if check(i, j):\n                    t.append(s[i : j + 1])\n                    dfs(j + 1)\n                    t.pop()\n\n        n = len(s)\n        ans = []\n        t = []\n        dfs(0)\n        return ans\n        \ndef generate_test_case():\n    solution = Solution()\n    \n    # Generate random string that contains only digits\n    n = random.randint(1, 20)\n    s = \"\".join(random.choice(string.digits) for _ in range(n))\n    \n    # Calculate the expected result using the provided Solution class\n    expected_result = solution.restoreIpAddresses(s)\n\n    return s, expected_result\n\ndef test_generated_test_cases(num_tests):\n    test_case_generator_results = []\n    solution = Solution()\n    for i in range(num_tests):\n        s, expected_result = generate_test_case()\n        assert solution.restoreIpAddresses(s) == expected_result\n        if len(expected_result) != 0:\n            print(f\"assert solution.restoreIpAddresses('{s}') == {expected_result}\")\n            test_case_generator_results.append(f\"assert solution.restoreIpAddresses('{s}') == {expected_result}\") # You can find that we construct the test case in the same format as the example\n    return test_case_generator_results\n\nif __name__ == \"__main__\":\n    num_tests = 100  # You can change this to generate more test cases\n    test_case_generator_results = test_generated_test_cases(num_tests)\n",
  "test_case": "assert solution.restoreIpAddresses('1335') == ['1.3.3.5']\nassert solution.restoreIpAddresses('0287') == ['0.2.8.7']\nassert solution.restoreIpAddresses('96857618') == ['96.85.76.18']\nassert solution.restoreIpAddresses('56603852') == ['56.60.38.52']\nassert solution.restoreIpAddresses('8844') == ['8.8.4.4']\nassert solution.restoreIpAddresses('62905') == ['6.2.90.5', '6.29.0.5', '62.9.0.5']\nassert solution.restoreIpAddresses('1986') == ['1.9.8.6']\nassert solution.restoreIpAddresses('72460111') == ['7.24.60.111', '7.246.0.111', '72.4.60.111', '72.46.0.111']\nassert solution.restoreIpAddresses('78491031') == ['78.49.10.31', '78.49.103.1']\nassert solution.restoreIpAddresses('821042') == ['8.2.10.42', '8.2.104.2', '8.21.0.42', '8.210.4.2', '82.1.0.42', '82.10.4.2']\nassert solution.restoreIpAddresses('16192') == ['1.6.1.92', '1.6.19.2', '1.61.9.2', '16.1.9.2']\nassert solution.restoreIpAddresses('16140') == ['1.6.1.40', '1.6.14.0', '1.61.4.0', '16.1.4.0']\nassert solution.restoreIpAddresses('247196756') == ['247.19.67.56', '247.196.7.56', '247.196.75.6']\nassert solution.restoreIpAddresses('54851') == ['5.4.8.51', '5.4.85.1', '5.48.5.1', '54.8.5.1']\nassert solution.restoreIpAddresses('2727') == ['2.7.2.7']\nassert solution.restoreIpAddresses('286079') == ['2.8.60.79', '2.86.0.79', '28.6.0.79', '28.60.7.9']\nassert solution.restoreIpAddresses('96148') == ['9.6.1.48', '9.6.14.8', '9.61.4.8', '96.1.4.8']\nassert solution.restoreIpAddresses('5163') == ['5.1.6.3']\nassert solution.restoreIpAddresses('41160') == ['4.1.1.60', '4.1.16.0', '4.11.6.0', '41.1.6.0']\nassert solution.restoreIpAddresses('9431402') == ['9.43.140.2', '94.3.140.2', '94.31.40.2']\nassert solution.restoreIpAddresses('56060') == ['5.6.0.60', '5.60.6.0', '56.0.6.0']\nassert solution.restoreIpAddresses('6930') == ['6.9.3.0']\nassert solution.restoreIpAddresses('942038254') == ['94.20.38.254', '94.203.8.254', '94.203.82.54']\nassert solution.restoreIpAddresses('0914') == ['0.9.1.4']",
  "inefficient_solution": "class Solution:\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        def check(i: int, j: int) -> int:\n            if i == j:\n                return 0\n            if s[i] == \"0\":\n                return 0\n            return 1 if int(s[i : j + 1]) <= 255 else 0\n\n        def dfs(i: int):\n            if i >= len(s) and len(t) == 4:\n                ans.append(\".\".join([str(x) for x in t]))\n                return\n            if i >= len(s) or len(t) >= 4:\n                return\n            for j in range(i, min(i + 3, len(s))):\n                if check(i, j):\n                    t.append(int(s[i : j + 1]))\n                    dfs(j + 1)\n                    t.pop()\n\n        ans = []\n        t = []\n        dfs(0)\n        return ans",
  "is_python": true
}