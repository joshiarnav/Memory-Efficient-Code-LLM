{
  "problem_idx": 2867,
  "task_name": "Count Valid Paths in a Tree",
  "markdown_description": "\nThere is an undirected tree with `n` nodes labeled from `1` to `n`. You are given the integer `n` and a 2D integer array `edges` of length `n - 1`, where `edges[i] = [ui, vi]` indicates that there is an edge between nodes `ui` and `vi` in the tree.\n\n\nReturn *the **number of valid paths** in the tree*.\n\n\nA path `(a, b)` is **valid** if there exists **exactly one** prime number among the node labels in the path from `a` to `b`.\n\n\n**Note** that:\n\n\n* The path `(a, b)` is a sequence of **distinct** nodes starting with node `a` and ending with node `b` such that every two adjacent nodes in the sequence share an edge in the tree.\n* Path `(a, b)` and path `(b, a)` are considered the **same** and counted only **once**.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2800-2899/2867.Count%20Valid%20Paths%20in%20a%20Tree/images/example1.png)\n\n```\n\n**Input:** n = 5, edges = [[1,2],[1,3],[2,4],[2,5]]\n**Output:** 4\n**Explanation:** The pairs with exactly one prime number on the path between them are: \n- (1, 2) since the path from 1 to 2 contains prime number 2. \n- (1, 3) since the path from 1 to 3 contains prime number 3.\n- (1, 4) since the path from 1 to 4 contains prime number 2.\n- (2, 4) since the path from 2 to 4 contains prime number 2.\nIt can be shown that there are only 4 valid paths.\n\n```\n\n**Example 2:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2800-2899/2867.Count%20Valid%20Paths%20in%20a%20Tree/images/example2.png)\n\n```\n\n**Input:** n = 6, edges = [[1,2],[1,3],[2,4],[3,5],[3,6]]\n**Output:** 6\n**Explanation:** The pairs with exactly one prime number on the path between them are: \n- (1, 2) since the path from 1 to 2 contains prime number 2.\n- (1, 3) since the path from 1 to 3 contains prime number 3.\n- (1, 4) since the path from 1 to 4 contains prime number 2.\n- (1, 6) since the path from 1 to 6 contains prime number 3.\n- (2, 4) since the path from 2 to 4 contains prime number 2.\n- (3, 6) since the path from 3 to 6 contains prime number 3.\nIt can be shown that there are only 6 valid paths.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= n <= 105`\n* `edges.length == n - 1`\n* `edges[i].length == 2`\n* `1 <= ui, vi <= n`\n* The input is generated such that `edges` represent a valid tree.\n\n\n",
  "canonical_solution": "class Solution:\n    def countPaths(self, n: int, edges: List[List[int]]) -> int:\n        def mul(x, y):\n            return x * y\n\n        def dfs(x, f, con, prime, r):\n            v = [1 - prime[x], prime[x]]\n            for y in con[x]:\n                if y == f:\n                    continue\n                p = dfs(y, x, con, prime, r)\n                r[0] += mul(p[0], v[1]) + mul(p[1], v[0])\n                if prime[x]:\n                    v[1] += p[0]\n                else:\n                    v[0] += p[0]\n                    v[1] += p[1]\n            return v\n\n        prime = [True] * (n + 1)\n        prime[1] = False\n\n        all_primes = []\n        for i in range(2, n + 1):\n            if prime[i]:\n                all_primes.append(i)\n            for x in all_primes:\n                temp = i * x\n                if temp > n:\n                    break\n                prime[temp] = False\n                if i % x == 0:\n                    break\n\n        con = [[] for _ in range(n + 1)]\n        for e in edges:\n            con[e[0]].append(e[1])\n            con[e[1]].append(e[0])\n\n        r = [0]\n        dfs(1, 0, con, prime, r)\n        return r[0]\n",
  "test_case_generator": "\nclass Solution:\n    def countPaths(self, n: int, edges: List[List[int]]) -> int:\n        def mul(x, y):\n            return x * y\n\n        def dfs(x, f, con, prime, r):\n            v = [1 - prime[x], prime[x]]\n            for y in con[x]:\n                if y == f:\n                    continue\n                p = dfs(y, x, con, prime, r)\n                r[0] += mul(p[0], v[1]) + mul(p[1], v[0])\n                if prime[x]:\n                    v[1] += p[0]\n                else:\n                    v[0] += p[0]\n                    v[1] += p[1]\n            return v\n\n        prime = [True] * (n + 1)\n        prime[1] = False\n\n        all_primes = []\n        for i in range(2, n + 1):\n            if prime[i]:\n                all_primes.append(i)\n            for x in all_primes:\n                temp = i * x\n                if temp > n:\n                    break\n                prime[temp] = False\n                if i % x == 0:\n                    break\n\n        con = [[] for _ in range(n + 1)]\n        for e in edges:\n            con[e[0]].append(e[1])\n            con[e[1]].append(e[0])\n\n        r = [0]\n        dfs(1, 0, con, prime, r)\n        return r[0]\n",
  "test_case": "",
  "inefficient_solution": "class Solution:\n    def countPaths(self, n: int, edges: List[List[int]]) -> int:\n        def mul(x, y):\n            res = []\n            for i in range(x):\n                for j in range(y):\n                    res.append(i * y + j)\n            return res\n\n        def dfs(x, f, con, prime, r):\n            v = [1 - prime[x], prime[x]]\n            for y in con[x]:\n                if y == f:\n                    continue\n                p = dfs(y, x, con, prime, r)\n                for i in p:\n                    r[0] += mul(i, v)[1]\n                if prime[x]:\n                    v[1] += p[0]\n                else:\n                    v[0] += p[0]\n                    v[1] += p[1]\n            return v\n\n        prime = [True] * (n + 1)\n        prime[1] = False\n\n        all_primes = []\n        for i in range(2, n + 1):\n            if prime[i]:\n                all_primes.append(i)\n            for x in all_primes:\n                temp = i * x\n                if temp > n:\n                    break\n                prime[temp] = False\n                if i % x == 0:\n                    break\n\n        con = [[] for _ in range(n + 1)]\n        for e in edges:\n            con[e[0]].append(e[1])\n            con[e[1]].append(e[0])\n\n        r = [0]\n        dfs(1, 0, con, prime, r)\n        return r[0]",
  "is_python": true
}