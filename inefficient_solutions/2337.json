{
  "problem_idx": 2337,
  "task_name": "Move Pieces to Obtain a String",
  "markdown_description": "\nYou are given two strings `start` and `target`, both of length `n`. Each string consists **only** of the characters `'L'`, `'R'`, and `'_'` where:\n\n\n* The characters `'L'` and `'R'` represent pieces, where a piece `'L'` can move to the **left** only if there is a **blank** space directly to its left, and a piece `'R'` can move to the **right** only if there is a **blank** space directly to its right.\n* The character `'_'` represents a blank space that can be occupied by **any** of the `'L'` or `'R'` pieces.\n\n\nReturn `true` *if it is possible to obtain the string* `target` *by moving the pieces of the string* `start` ***any** number of times*. Otherwise, return `false`.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** start = \"_L__R__R_\", target = \"L______RR\"\n**Output:** true\n**Explanation:** We can obtain the string target from start by doing the following moves:\n- Move the first piece one step to the left, start becomes equal to \"**L**___R__R_\".\n- Move the last piece one step to the right, start becomes equal to \"L___R___**R**\".\n- Move the second piece three steps to the right, start becomes equal to \"L______**R**R\".\nSince it is possible to get the string target from start, we return true.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** start = \"R_L_\", target = \"__LR\"\n**Output:** false\n**Explanation:** The 'R' piece in the string start can move one step to the right to obtain \"_**R**L_\".\nAfter that, no pieces can move anymore, so it is impossible to obtain the string target from start.\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** start = \"_R\", target = \"R_\"\n**Output:** false\n**Explanation:** The piece in the string start can move only to the right, so it is impossible to obtain the string target from start.\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `n == start.length == target.length`\n* `1 <= n <= 105`\n* `start` and `target` consist of the characters `'L'`, `'R'`, and `'_'`.\n\n\n",
  "canonical_solution": "class Solution:\n    def canChange(self, start: str, target: str) -> bool:\n        a = [(v, i) for i, v in enumerate(start) if v != '_']\n        b = [(v, i) for i, v in enumerate(target) if v != '_']\n        if len(a) != len(b):\n            return False\n        for (c, i), (d, j) in zip(a, b):\n            if c != d:\n                return False\n            if c == 'L' and i < j:\n                return False\n            if c == 'R' and i > j:\n                return False\n        return True\n",
  "test_case_generator": "\nimport random\n\nclass Solution:\n    def canChange(self, start: str, target: str) -> bool:\n        a = [(v, i) for i, v in enumerate(start) if v != '_']\n        b = [(v, i) for i, v in enumerate(target) if v != '_']\n        if len(a) != len(b):\n            return False\n        for (c, i), (d, j) in zip(a, b):\n            if c != d:\n                return False\n            if c == 'L' and i < j:\n                return False\n            if c == 'R' and i > j:\n                return False\n        return True\n\ndef generate_test_case():\n    solution = Solution()\n    \n    # Generate random start string\n    start = ''.join(random.choices(['L', 'R', '_'], k=random.randint(1, 10)))\n    \n    # Generate random target string\n    target = ''.join(random.choices(['L', 'R', '_'], k=random.randint(1, 10)))\n\n    # Calculate the expected result using the provided Solution class\n    expected_result = solution.canChange(start, target)\n    \n    return start, target, expected_result\n\ndef test_generated_test_cases(num_tests):\n    test_case_generator_results = []\n    for i in range(num_tests):\n        start, target, expected_result = generate_test_case()\n        solution = Solution()\n        assert solution.canChange(start, target) == expected_result\n        print(f\"assert solution.canChange('{start}', '{target}') == {expected_result}\")\n        test_case_generator_results.append(f\"assert solution.canChange('{start}', '{target}') == {expected_result}\")\n    return test_case_generator_results\n\nif __name__ == \"__main__\":\n    num_tests = 100  # You can change this to generate more test cases\n    test_case_generator_results = test_generated_test_cases(num_tests)\n",
  "test_case": "assert solution.canChange('R__LR_LRL_', 'L__RRLLLL') == False\nassert solution.canChange('RRR_R_LRR_', '_') == False\nassert solution.canChange('L_L_RL_LRR', 'L_') == False\nassert solution.canChange('LLRLR', '____LL_') == False\nassert solution.canChange('_', '__R_') == False\nassert solution.canChange('LRR__R_', 'LRL___LLL') == False\nassert solution.canChange('RLR_R_R_RL', '__RR_R_') == False\nassert solution.canChange('LL_L_LRL', '_LLL') == False\nassert solution.canChange('RLRLL_', '_L_RLR') == False\nassert solution.canChange('_L', 'R__R__') == False\nassert solution.canChange('LL', 'LRLL') == False\nassert solution.canChange('L', 'L_LR') == False\nassert solution.canChange('__RRRRLR', '_') == False\nassert solution.canChange('_', '_R_L') == False\nassert solution.canChange('R_L_RL_', '_LLLR_') == False\nassert solution.canChange('RR__RLLL_', '_L') == False\nassert solution.canChange('LR', 'LR_RR') == False\nassert solution.canChange('R_R_RR_', 'L') == False\nassert solution.canChange('LRR___L', '_RLL__R') == False\nassert solution.canChange('LR_L_L', 'RR_LL_R') == False\nassert solution.canChange('RR', 'R_RRRL___L') == False\nassert solution.canChange('LLL__', 'L_L_LL_LR_') == False\nassert solution.canChange('RL', 'LR_R_') == False\nassert solution.canChange('L__RR_L', 'L__RR') == False\nassert solution.canChange('_R', 'L__RL') == False\nassert solution.canChange('_L__RLR', '_RL') == False\nassert solution.canChange('_RRR', '_R_LR_') == False\nassert solution.canChange('__LRL__', '_LLRRL') == False\nassert solution.canChange('L', 'LLRR_RLLL_') == False\nassert solution.canChange('R', 'LLRLRRRR') == False\nassert solution.canChange('LL_', 'L') == False\nassert solution.canChange('R___', 'L') == False\nassert solution.canChange('RLRLR__L', 'R_L_R') == False\nassert solution.canChange('LLL__', 'R') == False\nassert solution.canChange('LL', '_L_L_RRL_') == False\nassert solution.canChange('_', 'RR_RL') == False\nassert solution.canChange('_', 'RL_L') == False\nassert solution.canChange('LRRR_L___R', '_LL_R_') == False\nassert solution.canChange('__L', '_') == False\nassert solution.canChange('__RLL_LR_L', '_RL_L_RL_L') == False\nassert solution.canChange('LLRLLLR', '__LLRR_LL_') == False\nassert solution.canChange('RR___RR_LL', 'L_L_LR_LR') == False\nassert solution.canChange('L__R', 'L') == False\nassert solution.canChange('_', 'RLRRR_') == False\nassert solution.canChange('_L__RR_', 'L_R__L_RRR') == False\nassert solution.canChange('RRL___RRLL', 'L_RRR_L_LL') == False\nassert solution.canChange('_RL__R_LR', 'RLRLL') == False\nassert solution.canChange('_LLL', '___LL') == False\nassert solution.canChange('_', 'L') == False\nassert solution.canChange('L', '_L_RL_RRR') == False\nassert solution.canChange('LRLR__RR', 'L_L____') == False\nassert solution.canChange('RL_RL__', 'L_LR__RR') == False\nassert solution.canChange('RLR__L_LLL', 'L__L') == False\nassert solution.canChange('_LL_RLRR_R', 'L_LLLL') == False\nassert solution.canChange('L_', '___R_') == False\nassert solution.canChange('LR_R_RL_R', '_R_L_LL_L') == False\nassert solution.canChange('_LR_L_RLL_', 'RLR') == False\nassert solution.canChange('_L__L_', 'LRRRRR') == False\nassert solution.canChange('R_RR', '__L') == False\nassert solution.canChange('_R', '__RL') == False\nassert solution.canChange('_LR', 'LLRRL__') == False\nassert solution.canChange('RRR_L', '_L___LRL') == False\nassert solution.canChange('RRLL', '__') == False\nassert solution.canChange('LLLL_', 'R___L_L_') == False\nassert solution.canChange('RLRR_RLL', 'RRR_L_') == False\nassert solution.canChange('RRR_R__R', '_R_') == False\nassert solution.canChange('LLR_LL___R', 'L__R_') == False\nassert solution.canChange('RR_LRL', 'L') == False\nassert solution.canChange('LLL__L_', '_L_LRLLR') == False\nassert solution.canChange('R_', 'R_RRL_L___') == False\nassert solution.canChange('R_LLR', 'L_LL_RRLL') == False\nassert solution.canChange('_L', 'L') == True\nassert solution.canChange('R', 'LL') == False\nassert solution.canChange('RRLL__', 'RLRRR') == False\nassert solution.canChange('RLLRLL', 'LLR____') == False\nassert solution.canChange('_R_', 'R') == False\nassert solution.canChange('RL_LRLRLR', 'L') == False\nassert solution.canChange('_R', 'RLL_RLRRR_') == False\nassert solution.canChange('_RR', 'LLL_') == False\nassert solution.canChange('LL', 'R_RRLLRLRR') == False\nassert solution.canChange('L', '_RRLL_L') == False\nassert solution.canChange('L_RRL_', 'RR_LRL_L') == False\nassert solution.canChange('L', 'L') == True\nassert solution.canChange('R_RRRLRR_R', '__L') == False\nassert solution.canChange('RL', 'LLR_RLRR') == False\nassert solution.canChange('_R__RRL_L', 'LRRRL_') == False\nassert solution.canChange('R_RLL_L_L', 'RLR_RRRRR') == False\nassert solution.canChange('L', 'LR__') == False\nassert solution.canChange('L', 'R___L') == False\nassert solution.canChange('LL', 'L') == False\nassert solution.canChange('RR_RRLRRLR', '_L') == False\nassert solution.canChange('_LLRR_RR', '_RLLLLRLLL') == False\nassert solution.canChange('L_LR', '_RR') == False\nassert solution.canChange('__L_R_RRR_', 'R_RL_LR') == False\nassert solution.canChange('RRR_', '__RR_R') == True\nassert solution.canChange('LLR', 'L_L_LR_R_R') == False\nassert solution.canChange('RRL', '__LRR') == False\nassert solution.canChange('L_LRLL_', 'R_RR_LLR_R') == False\nassert solution.canChange('LLR_R_', 'LLLRR_RL__') == False\nassert solution.canChange('_L', '_L_RL_LR') == False",
  "inefficient_solution": "class Solution:\n    def canChange(self, start: str, target: str) -> bool:\n        s = start\n        t = target\n        s = list(s)\n        t = list(t)\n        \n        def move_left(s, i, c):\n            s[i] = '_'\n            for j in range(i-1, -1, -1):\n                if s[j] == '_':\n                    s[j] = c\n                    return True\n            return False\n        \n        def move_right(s, i, c):\n            s[i] = '_'\n            for j in range(i+1, len(s)):\n                if s[j] == '_':\n                    s[j] = c\n                    return True\n            return False\n        \n        for i in range(len(s)):\n            if s[i] != t[i]:\n                if s[i] == '_':\n                    for j in range(i+1, len(s)):\n                        if s[j] != '_':\n                            if t[j] == 'L' and move_left(s, j, 'L'):\n                                break\n                            if t[j] == 'R' and move_right(s, j, 'R'):\n                                break\n                            else:\n                                return False\n                    for j in range(i-1, -1, -1):\n                        if s[j] != '_':\n                            if t[j] == 'L' and move_left(s, j, 'L'):\n                                break\n                            if t[j] == 'R' and move_right(s, j, 'R'):\n                                break\n                            else:\n                                return False\n                else:\n                    if t[i] == 'L' and move_left(s, i, 'L'):\n                        pass\n                    elif t[i] == 'R' and move_right(s, i, 'R'):\n                        pass\n                    else:\n                        return False\n        \n        for i in range(len(s)):\n            if s[i] != '_':\n                if t[i] == 'L' and move_left(s, i, 'L'):\n                    pass\n                elif t[i] == 'R' and move_right(s, i, 'R'):\n                    pass\n                else:\n                    return False\n        \n        return True",
  "is_python": true
}