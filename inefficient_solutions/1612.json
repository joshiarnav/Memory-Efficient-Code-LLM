{
  "problem_idx": 1612,
  "task_name": "Check If Two Expression Trees are Equivalent",
  "markdown_description": "\nA **[binary expression tree](https://en.wikipedia.org/wiki/Binary_expression_tree)** is a kind of binary tree used to represent arithmetic expressions. Each node of a binary expression tree has either zero or two children. Leaf nodes (nodes with 0 children) correspond to operands (variables), and internal nodes (nodes with two children) correspond to the operators. In this problem, we only consider the `'+'` operator (i.e. addition).\n\n\nYou are given the roots of two binary expression trees, `root1` and `root2`. Return `true` *if the two binary expression trees are equivalent*. Otherwise, return `false`.\n\n\nTwo binary expression trees are equivalent if they **evaluate to the same value** regardless of what the variables are set to.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** root1 = [x], root2 = [x]\n**Output:** true\n\n```\n\n**Example 2:**\n\n\n**![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1600-1699/1612.Check%20If%20Two%20Expression%20Trees%20are%20Equivalent/images/tree1.png)**\n\n\n\n```\n\n**Input:** root1 = [+,a,+,null,null,b,c], root2 = [+,+,a,b,c]\n**Output:** true\n**Explanation****:** a + (b + c) == (b + c) + a\n```\n\n**Example 3:**\n\n\n**![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1600-1699/1612.Check%20If%20Two%20Expression%20Trees%20are%20Equivalent/images/tree2.png)**\n\n\n\n```\n\n**Input:** root1 = [+,a,+,null,null,b,c], root2 = [+,+,a,b,d]\n**Output:** false\n**Explanation****:** a + (b + c) != (b + d) + a\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* The number of nodes in both trees are equal, odd and, in the range `[1, 4999]`.\n* `Node.val` is `'+'` or a lower-case English letter.\n* It's **guaranteed** that the tree given is a valid binary expression tree.\n\n\n\u00a0\n\n\n**Follow up:** What will you change in your solution if the tree also supports the `'-'` operator (i.e. subtraction)?\n\n\n",
  "canonical_solution": "# Definition for a binary tree node.\n# class Node(object):\n#     def __init__(self, val=\" \", left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def checkEquivalence(self, root1: 'Node', root2: 'Node') -> bool:\n        def dfs(root):\n            cnt = [0] * 26\n            if root is None:\n                return cnt\n            if root.val in '+-':\n                l, r = dfs(root.left), dfs(root.right)\n                k = 1 if root.val == '+' else -1\n                for i in range(26):\n                    cnt[i] += l[i] + r[i] * k\n            else:\n                cnt[ord(root.val) - ord('a')] += 1\n            return cnt\n\n        return dfs(root1) == dfs(root2)\n",
  "test_case_generator": "\ndef generate_test_case():\n    solution = Solution()\n    \n    root1 = generate_random_binary_expression_tree()\n    root2 = generate_random_binary_expression_tree()\n\n    expected_result = solution.checkEquivalence(root1, root2)\n\n    return root1, root2, expected_result\n\ndef generate_random_binary_expression_tree():\n    # Define the node class\n    class Node(object):\n        def __init__(self, val=\" \", left=None, right=None):\n            self.val = val\n            self.left = left\n            self.right = right\n\n    # Generate a random binary expression tree\n    def generate_tree(probability=0.2):\n        if random.random() < probability:\n            val = random.choice(['+', '-'])\n            left = generate_tree(probability)\n            right = generate_tree(probability)\n            return Node(val, left, right)\n        else:\n            val = random.choice(list('abcdefghijklmnopqrstuvwxyz'))\n            return Node(val)\n\n    return generate_tree()\n\ndef test_generated_test_cases(num_tests):\n    test_case_generator_results = []\n    for i in range(num_tests):\n        root1, root2, expected_result = generate_test_case()\n        solution = Solution()\n        assert solution.checkEquivalence(root1, root2) == expected_result\n        print(f\"root1 = {serialize_tree(root1)}, root2 = {serialize_tree(root2)}\")\n        test_case_generator_results.append(f\"root1 = {serialize_tree(root1)}, root2 = {serialize_tree(root2)}\")\n\n    return test_case_generator_results\n\ndef serialize_tree(root):\n    if root is None:\n        return \"[]\"\n\n    queue = [root]\n    res = []\n    while queue:\n        node = queue.pop(0)\n        if node is None:\n            res.append('null')\n            continue\n        res.append(str(node.val))\n        queue.append(node.left)\n        queue.append(node.right)\n\n    while res and res[-1] == 'null':\n        res.pop()\n\n    return '[' + ','.join(res) + ']'\n\nif __name__ == \"__main__\":\n    num_tests = 100  # You can change this to generate more test cases\n    test_case_generator_results = test_generated_test_cases(num_tests)\n",
  "test_case": "root1 = [u], root2 = [e]\nroot1 = [-,r,c], root2 = [k]\nroot1 = [n], root2 = [n]\nroot1 = [x], root2 = [y]\nroot1 = [-,i,a], root2 = [+,-,+,k,+,h,+,null,null,-,c,null,null,+,w,v,l,null,null,g,x]\nroot1 = [c], root2 = [g]\nroot1 = [w], root2 = [+,u,v]\nroot1 = [j], root2 = [-,+,a,v,b]\nroot1 = [-,x,a], root2 = [c]\nroot1 = [k], root2 = [v]\nroot1 = [e], root2 = [k]\nroot1 = [c], root2 = [f]\nroot1 = [-,c,k], root2 = [q]\nroot1 = [n], root2 = [a]\nroot1 = [a], root2 = [c]\nroot1 = [v], root2 = [q]\nroot1 = [j], root2 = [i]\nroot1 = [s], root2 = [e]\nroot1 = [q], root2 = [m]\nroot1 = [-,y,l], root2 = [s]\nroot1 = [p], root2 = [+,f,c]\nroot1 = [-,q,y], root2 = [i]\nroot1 = [q], root2 = [s]\nroot1 = [+,j,g], root2 = [k]\nroot1 = [c], root2 = [+,v,w]\nroot1 = [b], root2 = [o]\nroot1 = [u], root2 = [-,i,x]\nroot1 = [p], root2 = [j]\nroot1 = [q], root2 = [b]\nroot1 = [z], root2 = [v]\nroot1 = [-,u,-,null,null,e,w], root2 = [s]\nroot1 = [j], root2 = [v]\nroot1 = [-,t,g], root2 = [z]\nroot1 = [i], root2 = [x]\nroot1 = [j], root2 = [h]\nroot1 = [+,f,-,null,null,o,w], root2 = [g]\nroot1 = [u], root2 = [+,n,g]\nroot1 = [x], root2 = [-,c,-,null,null,-,k,g,r]\nroot1 = [-,u,o], root2 = [d]\nroot1 = [y], root2 = [i]\nroot1 = [-,b,-,null,null,-,-,s,m,t,q], root2 = [+,s,z]\nroot1 = [p], root2 = [u]\nroot1 = [c], root2 = [s]\nroot1 = [v], root2 = [n]\nroot1 = [w], root2 = [q]\nroot1 = [e], root2 = [m]\nroot1 = [y], root2 = [v]\nroot1 = [g], root2 = [p]\nroot1 = [w], root2 = [b]\nroot1 = [m], root2 = [o]\nroot1 = [f], root2 = [+,p,j]\nroot1 = [z], root2 = [h]\nroot1 = [+,x,y], root2 = [l]\nroot1 = [n], root2 = [g]\nroot1 = [k], root2 = [+,f,-,null,null,v,o]\nroot1 = [r], root2 = [o]\nroot1 = [z], root2 = [+,a,b]\nroot1 = [o], root2 = [+,t,x]\nroot1 = [o], root2 = [e]\nroot1 = [r], root2 = [s]\nroot1 = [t], root2 = [f]\nroot1 = [a], root2 = [a]\nroot1 = [d], root2 = [i]\nroot1 = [t], root2 = [u]\nroot1 = [c], root2 = [o]\nroot1 = [c], root2 = [q]\nroot1 = [c], root2 = [-,p,-,null,null,v,o]\nroot1 = [h], root2 = [o]\nroot1 = [+,a,+,null,null,a,y], root2 = [h]\nroot1 = [w], root2 = [c]\nroot1 = [v], root2 = [s]\nroot1 = [s], root2 = [+,w,+,null,null,-,+,o,l,n,s]\nroot1 = [j], root2 = [v]\nroot1 = [h], root2 = [+,k,p]\nroot1 = [z], root2 = [y]\nroot1 = [z], root2 = [w]\nroot1 = [-,+,s,g,j], root2 = [n]\nroot1 = [i], root2 = [+,m,+,null,null,n,f]\nroot1 = [r], root2 = [-,m,n]\nroot1 = [t], root2 = [g]\nroot1 = [+,i,e], root2 = [+,+,o,t,s]\nroot1 = [q], root2 = [i]\nroot1 = [r], root2 = [k]\nroot1 = [+,v,z], root2 = [v]\nroot1 = [w], root2 = [e]\nroot1 = [e], root2 = [+,a,i]\nroot1 = [z], root2 = [z]\nroot1 = [a], root2 = [u]\nroot1 = [k], root2 = [k]\nroot1 = [i], root2 = [v]\nroot1 = [z], root2 = [h]\nroot1 = [t], root2 = [r]\nroot1 = [l], root2 = [o]\nroot1 = [u], root2 = [j]\nroot1 = [j], root2 = [i]\nroot1 = [t], root2 = [-,f,r]\nroot1 = [s], root2 = [+,-,c,-,q,null,null,-,-,null,null,-,i,k,c,l,z]\nroot1 = [v], root2 = [d]\nroot1 = [b], root2 = [p]\nroot1 = [m], root2 = [-,-,t,p,-,null,null,null,null,q,u]",
  "inefficient_solution": "",
  "is_python": true
}