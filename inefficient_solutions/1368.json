{
  "problem_idx": 1368,
  "task_name": "Minimum Cost to Make at Least One Valid Path in a Grid",
  "markdown_description": "\nGiven an `m x n` grid. Each cell of the grid has a sign pointing to the next cell you should visit if you are currently in this cell. The sign of `grid[i][j]` can be:\n\n\n* `1` which means go to the cell to the right. (i.e go from `grid[i][j]` to `grid[i][j + 1]`)\n* `2` which means go to the cell to the left. (i.e go from `grid[i][j]` to `grid[i][j - 1]`)\n* `3` which means go to the lower cell. (i.e go from `grid[i][j]` to `grid[i + 1][j]`)\n* `4` which means go to the upper cell. (i.e go from `grid[i][j]` to `grid[i - 1][j]`)\n\n\nNotice that there could be some signs on the cells of the grid that point outside the grid.\n\n\nYou will initially start at the upper left cell `(0, 0)`. A valid path in the grid is a path that starts from the upper left cell `(0, 0)` and ends at the bottom-right cell `(m - 1, n - 1)` following the signs on the grid. The valid path does not have to be the shortest.\n\n\nYou can modify the sign on a cell with `cost = 1`. You can modify the sign on a cell **one time only**.\n\n\nReturn *the minimum cost to make the grid have at least one valid path*.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1300-1399/1368.Minimum%20Cost%20to%20Make%20at%20Least%20One%20Valid%20Path%20in%20a%20Grid/images/grid1.png)\n\n```\n\n**Input:** grid = [[1,1,1,1],[2,2,2,2],[1,1,1,1],[2,2,2,2]]\n**Output:** 3\n**Explanation:** You will start at point (0, 0).\nThe path to (3, 3) is as follows. (0, 0) --> (0, 1) --> (0, 2) --> (0, 3) change the arrow to down with cost = 1 --> (1, 3) --> (1, 2) --> (1, 1) --> (1, 0) change the arrow to down with cost = 1 --> (2, 0) --> (2, 1) --> (2, 2) --> (2, 3) change the arrow to down with cost = 1 --> (3, 3)\nThe total cost = 3.\n\n```\n\n**Example 2:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1300-1399/1368.Minimum%20Cost%20to%20Make%20at%20Least%20One%20Valid%20Path%20in%20a%20Grid/images/grid2.png)\n\n```\n\n**Input:** grid = [[1,1,3],[3,2,2],[1,1,4]]\n**Output:** 0\n**Explanation:** You can follow the path from (0, 0) to (2, 2).\n\n```\n\n**Example 3:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1300-1399/1368.Minimum%20Cost%20to%20Make%20at%20Least%20One%20Valid%20Path%20in%20a%20Grid/images/grid3.png)\n\n```\n\n**Input:** grid = [[1,2],[4,3]]\n**Output:** 1\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `m == grid.length`\n* `n == grid[i].length`\n* `1 <= m, n <= 100`\n* `1 <= grid[i][j] <= 4`\n\n\n",
  "canonical_solution": "class Solution:\n    def minCost(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        dirs = [[0, 0], [0, 1], [0, -1], [1, 0], [-1, 0]]\n        q = deque([(0, 0, 0)])\n        vis = set()\n        while q:\n            i, j, d = q.popleft()\n            if (i, j) in vis:\n                continue\n            vis.add((i, j))\n            if i == m - 1 and j == n - 1:\n                return d\n            for k in range(1, 5):\n                x, y = i + dirs[k][0], j + dirs[k][1]\n                if 0 <= x < m and 0 <= y < n:\n                    if grid[i][j] == k:\n                        q.appendleft((x, y, d))\n                    else:\n                        q.append((x, y, d + 1))\n        return -1\n",
  "test_case_generator": "\n# Test case generator\nimport random\n\nclass Solution:\n    def minCost(self, grid):\n        m, n = len(grid), len(grid[0])\n        dirs = [[0, 0], [0, 1], [0, -1], [1, 0], [-1, 0]]\n        q = deque([(0, 0, 0)])\n        vis = set()\n        while q:\n            i, j, d = q.popleft()\n            if (i, j) in vis:\n                continue\n            vis.add((i, j))\n            if i == m - 1 and j == n - 1:\n                return d\n            for k in range(1, 5):\n                x, y = i + dirs[k][0], j + dirs[k][1]\n                if 0 <= x < m and 0 <= y < n:\n                    if grid[i][j] == k:\n                        q.appendleft((x, y, d))\n                    else:\n                        q.append((x, y, d + 1))\n        return -1\n\ndef generate_test_case():\n    solution = Solution()\n    \n    # Generate random grid\n    m = random.randint(1, 5)\n    n = random.randint(1, 5)\n    grid = [[random.randint(1, 4) for j in range(n)] for i in range(m)]\n\n    # Calculate the expected result using the provided Solution class\n    expected_result = solution.minCost(grid)\n\n    return grid, expected_result\n\ndef test_generated_test_cases(num_tests):\n    test_case_generator_results = []\n    for i in range(num_tests):\n        grid, expected_result = generate_test_case()\n        solution = Solution()\n        assert solution.minCost(grid) == expected_result\n        print(f\"assert solution.minCost({grid}) == {expected_result}\")\n        test_case_generator_results.append(f\"assert solution.minCost({grid}) == {expected_result}\") # You can find that we construct the test case in the same format as the example\n    return test_case_generator_results\n\nif __name__ == \"__main__\":\n    num_tests = 100  # You can change this to generate more test cases\n    test_case_generator_results = test_generated_test_cases(num_tests)\n",
  "test_case": "assert solution.minCost([[4, 4, 2, 3, 4], [3, 2, 1, 3, 3], [1, 1, 1, 1, 4], [4, 3, 3, 1, 1]]) == 2\nassert solution.minCost([[1, 2, 4, 2]]) == 2\nassert solution.minCost([[2, 2, 4, 4, 2], [2, 4, 4, 2, 4], [3, 3, 1, 1, 4], [2, 1, 3, 3, 1]]) == 5\nassert solution.minCost([[2, 1, 3, 1], [2, 1, 1, 1], [1, 3, 1, 4], [2, 1, 3, 3]]) == 3\nassert solution.minCost([[1], [1], [2], [3]]) == 3\nassert solution.minCost([[3, 4, 2], [2, 3, 2]]) == 2\nassert solution.minCost([[2, 1], [3, 3], [3, 1]]) == 2\nassert solution.minCost([[1], [1], [4], [4], [1]]) == 4\nassert solution.minCost([[2, 4, 3, 2], [1, 4, 1, 1]]) == 2\nassert solution.minCost([[2]]) == 0\nassert solution.minCost([[1, 4]]) == 0\nassert solution.minCost([[4, 3, 3], [4, 3, 4], [1, 3, 2], [2, 1, 1]]) == 1\nassert solution.minCost([[2, 1, 4, 3, 2], [3, 3, 4, 1, 4], [3, 2, 4, 2, 3]]) == 3\nassert solution.minCost([[2], [2]]) == 1\nassert solution.minCost([[2], [1], [2], [2], [1]]) == 4\nassert solution.minCost([[3, 4], [1, 1]]) == 0\nassert solution.minCost([[2], [1], [2], [2]]) == 3\nassert solution.minCost([[4, 3], [1, 3], [2, 2], [3, 2], [1, 2]]) == 2\nassert solution.minCost([[3, 4]]) == 1\nassert solution.minCost([[1, 2, 4], [4, 1, 1], [4, 3, 4]]) == 2\nassert solution.minCost([[1, 4, 3, 3, 1], [4, 2, 3, 1, 1], [4, 3, 2, 3, 3]]) == 3\nassert solution.minCost([[2, 3]]) == 1\nassert solution.minCost([[2, 1, 4, 4, 1]]) == 3\nassert solution.minCost([[4, 4, 3], [4, 3, 4], [2, 1, 3], [3, 1, 3], [1, 3, 3]]) == 2\nassert solution.minCost([[1], [3], [3], [4], [1]]) == 2\nassert solution.minCost([[1, 2], [2, 2], [2, 3]]) == 2\nassert solution.minCost([[3, 3, 2, 2, 2], [1, 3, 1, 1, 4], [4, 1, 2, 4, 1], [3, 1, 1, 4, 2]]) == 2\nassert solution.minCost([[2, 3, 1], [3, 4, 1], [1, 4, 4]]) == 2\nassert solution.minCost([[2], [3], [3], [2], [1]]) == 2\nassert solution.minCost([[4, 3, 2, 3], [2, 2, 1, 1], [1, 1, 3, 1], [2, 1, 2, 1], [4, 3, 2, 1]]) == 4\nassert solution.minCost([[3, 3, 3], [2, 1, 4], [4, 3, 1], [1, 4, 1]]) == 3\nassert solution.minCost([[2, 2, 2], [4, 1, 4], [4, 3, 1], [2, 2, 4], [1, 4, 4]]) == 5\nassert solution.minCost([[4, 1, 1, 1, 2], [1, 4, 3, 1, 3], [4, 4, 1, 3, 3], [2, 3, 3, 1, 3], [4, 3, 1, 3, 4]]) == 2\nassert solution.minCost([[3, 1, 3], [3, 1, 4], [1, 3, 4]]) == 1\nassert solution.minCost([[1, 1, 4, 2], [2, 4, 1, 2]]) == 1\nassert solution.minCost([[3, 3, 3, 2, 3]]) == 4\nassert solution.minCost([[4, 2]]) == 1\nassert solution.minCost([[2, 4], [2, 3], [4, 4], [3, 3]]) == 3\nassert solution.minCost([[3], [2], [3], [4], [3]]) == 2\nassert solution.minCost([[2, 4, 2, 2], [3, 1, 2, 2], [1, 4, 3, 4], [3, 2, 2, 3], [3, 2, 2, 1]]) == 3\nassert solution.minCost([[2, 1], [1, 3]]) == 1\nassert solution.minCost([[3, 1, 3], [4, 3, 1], [4, 2, 1], [2, 4, 4]]) == 3\nassert solution.minCost([[4, 1, 1, 3, 4], [3, 2, 4, 3, 2], [1, 4, 3, 2, 1], [4, 3, 3, 4, 3], [2, 1, 2, 4, 1]]) == 3\nassert solution.minCost([[1, 3, 1, 4, 1], [1, 3, 2, 1, 4]]) == 2\nassert solution.minCost([[4, 3, 4], [2, 4, 4], [4, 1, 1]]) == 2\nassert solution.minCost([[3, 4, 4, 1], [3, 3, 2, 4], [4, 3, 2, 1], [4, 4, 4, 1]]) == 3\nassert solution.minCost([[3, 2, 1]]) == 2\nassert solution.minCost([[2, 2, 3, 3, 2], [4, 2, 1, 1, 1], [3, 2, 3, 3, 2]]) == 3\nassert solution.minCost([[3, 1, 3, 2, 1], [1, 1, 3, 4, 3], [1, 3, 3, 1, 3]]) == 1\nassert solution.minCost([[1, 2, 3, 3], [4, 2, 2, 4], [4, 1, 2, 2], [1, 2, 3, 3], [1, 2, 1, 3]]) == 3\nassert solution.minCost([[1, 3], [4, 4], [3, 3], [4, 4]]) == 1\nassert solution.minCost([[1, 4, 1]]) == 1\nassert solution.minCost([[3, 2, 3, 1], [1, 2, 4, 2], [4, 3, 2, 1]]) == 3\nassert solution.minCost([[1, 4, 3, 4], [3, 1, 4, 4], [3, 2, 4, 3]]) == 3\nassert solution.minCost([[1], [3], [4], [1], [4]]) == 3\nassert solution.minCost([[2, 2]]) == 1\nassert solution.minCost([[2, 3, 2, 4], [4, 4, 1, 1], [2, 3, 2, 1], [1, 1, 3, 3]]) == 3\nassert solution.minCost([[3, 1, 4], [4, 1, 1], [1, 1, 4]]) == 1\nassert solution.minCost([[1, 1, 4], [1, 1, 2], [4, 4, 1], [3, 1, 4], [2, 2, 4]]) == 4\nassert solution.minCost([[2], [4], [3]]) == 2\nassert solution.minCost([[2, 4]]) == 1\nassert solution.minCost([[3, 4], [3, 2], [4, 4]]) == 1\nassert solution.minCost([[2, 2, 3, 3, 3], [2, 4, 1, 3, 3], [4, 3, 2, 4, 2], [1, 1, 4, 2, 4]]) == 4\nassert solution.minCost([[1, 3, 2, 3, 3], [4, 4, 4, 4, 4]]) == 3\nassert solution.minCost([[1, 2, 4], [2, 1, 1], [3, 3, 1], [4, 2, 3]]) == 3\nassert solution.minCost([[2, 1, 1, 3], [1, 4, 1, 4]]) == 1\nassert solution.minCost([[4, 1, 3, 1, 1], [4, 4, 4, 1, 2], [4, 1, 2, 1, 1], [2, 1, 4, 1, 2]]) == 4\nassert solution.minCost([[4, 4], [1, 1], [2, 1]]) == 2\nassert solution.minCost([[1], [4]]) == 1\nassert solution.minCost([[4, 2], [2, 4], [3, 2]]) == 3\nassert solution.minCost([[2], [2]]) == 1\nassert solution.minCost([[4, 3], [2, 3]]) == 1\nassert solution.minCost([[4, 2, 1], [3, 1, 3], [2, 1, 4], [1, 4, 4], [1, 1, 2]]) == 3\nassert solution.minCost([[2, 2, 3], [2, 4, 2], [3, 4, 3], [1, 4, 1], [4, 2, 1]]) == 4\nassert solution.minCost([[3], [2], [2], [3], [4]]) == 2\nassert solution.minCost([[3, 1, 4, 1, 4], [2, 3, 3, 2, 3], [3, 4, 2, 3, 1], [4, 4, 3, 2, 3]]) == 4\nassert solution.minCost([[4, 2, 2]]) == 2\nassert solution.minCost([[3, 3, 2], [2, 4, 4]]) == 2\nassert solution.minCost([[4]]) == 0\nassert solution.minCost([[4, 3], [4, 4]]) == 1\nassert solution.minCost([[1, 2, 2], [1, 3, 2], [1, 2, 4], [1, 2, 2], [3, 3, 1]]) == 4\nassert solution.minCost([[4, 1], [4, 3], [1, 4], [2, 3], [1, 4]]) == 3\nassert solution.minCost([[1, 3, 1, 1, 4], [1, 1, 4, 2, 2], [1, 2, 4, 1, 2]]) == 2\nassert solution.minCost([[2, 3, 3, 1, 2], [3, 4, 2, 2, 3], [4, 1, 2, 2, 1]]) == 4\nassert solution.minCost([[4, 4, 3, 3], [3, 4, 4, 3], [4, 3, 1, 2], [4, 2, 3, 1], [3, 2, 3, 3]]) == 4\nassert solution.minCost([[2, 4], [3, 4], [4, 3], [1, 4]]) == 2\nassert solution.minCost([[4, 2, 2, 1], [3, 1, 4, 1]]) == 3\nassert solution.minCost([[2, 2], [3, 1], [3, 4]]) == 2\nassert solution.minCost([[3, 2, 1], [2, 1, 1], [2, 3, 4]]) == 2\nassert solution.minCost([[2], [2]]) == 1\nassert solution.minCost([[2, 1, 2, 2, 2]]) == 3\nassert solution.minCost([[2, 2, 3], [3, 4, 2], [2, 3, 4]]) == 3\nassert solution.minCost([[2, 2, 3, 1], [2, 3, 3, 1], [3, 1, 3, 2], [3, 3, 3, 2], [1, 3, 4, 1]]) == 3\nassert solution.minCost([[1, 4, 3], [2, 3, 4], [4, 3, 2], [3, 4, 1]]) == 2\nassert solution.minCost([[4, 3, 2], [3, 2, 1], [4, 3, 2]]) == 3\nassert solution.minCost([[3, 3], [2, 2], [3, 4], [3, 1]]) == 2\nassert solution.minCost([[4, 4, 4], [2, 3, 3], [3, 4, 2], [4, 1, 2], [2, 1, 3]]) == 4\nassert solution.minCost([[2, 3, 2], [2, 3, 3], [4, 1, 3]]) == 1\nassert solution.minCost([[2, 3, 4, 4], [4, 1, 2, 4], [3, 2, 2, 3]]) == 3\nassert solution.minCost([[3, 1, 2], [3, 2, 2], [4, 3, 1], [3, 3, 1], [3, 2, 1]]) == 2",
  "inefficient_solution": "class Solution:\n    def minCost(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        dirs = [[0, 0], [0, 1], [0, -1], [1, 0], [-1, 0]]\n        visited = [[False]*n for _ in range(m)]\n        q = []\n        for i in range(m):\n            for j in range(n):\n                q.append((i, j, 0))\n                visited[i][j] = True\n        while q:\n            temp_q = []\n            for i, j, d in q:\n                if i == m - 1 and j == n - 1:\n                    return d\n                for k in range(1, 5):\n                    x, y = i + dirs[k][0], j + dirs[k][1]\n                    if 0 <= x < m and 0 <= y < n:\n                        if grid[i][j] == k:\n                            temp_q.insert(0, (x, y, d))\n                        else:\n                            temp_q.append((x, y, d + 1))\n            q = temp_q\n        return -1",
  "is_python": true
}