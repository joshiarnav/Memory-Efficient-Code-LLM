{
  "problem_idx": 115,
  "task_name": "Distinct Subsequences",
  "markdown_description": "\nGiven two strings s and t, return *the number of distinct* ***subsequences*** *of* s *which equals* t.\n\n\nThe test cases are generated so that the answer fits on a 32-bit signed integer.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** s = \"rabbbit\", t = \"rabbit\"\n**Output:** 3\n**Explanation:**\nAs shown below, there are 3 ways you can generate \"rabbit\" from s.\n**rabb**b**it**\n**ra**b**bbit**\n**rab**b**bit**\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** s = \"babgbag\", t = \"bag\"\n**Output:** 5\n**Explanation:**\nAs shown below, there are 5 ways you can generate \"bag\" from s.\n**ba**b**g**bag\n**ba**bgba**g**\n**b**abgb**ag**\nba**b**gb**ag**\nbabg**bag**\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= s.length, t.length <= 1000`\n* `s` and `t` consist of English letters.\n\n\n",
  "canonical_solution": "class Solution:\n    def numDistinct(self, s: str, t: str) -> int:\n        n = len(t)\n        f = [1] + [0] * n\n        for a in s:\n            for j in range(n, 0, -1):\n                if a == t[j - 1]:\n                    f[j] += f[j - 1]\n        return f[n]\n",
  "test_case_generator": "\nimport random\n\nclass Solution:\n    def numDistinct(self, s: str, t: str) -> int:\n        n = len(t)\n        f = [1] + [0] * n\n        for a in s:\n            for j in range(n, 0, -1):\n                if a == t[j - 1]:\n                    f[j] += f[j - 1]\n        return f[n]\n\ndef generate_test_case():\n    solution = Solution()\n    \n    # Generate random strings s and t\n    s = ''.join(random.choices('abcdefghijklmnopqrstuvwxyz', k=random.randint(1, 11)))\n    t = ''.join(random.choices('abcdefghijklmnopqrstuvwxyz', k=random.randint(1, 11)))\n    \n    # Calculate the expected result using the provided Solution class\n    expected_result = solution.numDistinct(s, t)\n\n    return s, t, expected_result\n\ndef test_generated_test_cases(num_tests):\n    test_case_generator_results = []\n    for i in range(num_tests):\n        s, t, expected_result = generate_test_case()\n        solution = Solution()\n        assert solution.numDistinct(s, t) == expected_result\n        print(f\"assert solution.numDistinct('{s}', '{t}') == {expected_result}\")\n        test_case_generator_results.append(f\"assert solution.numDistinct('{s}', '{t}') == {expected_result}\")\n    return test_case_generator_results\n\nif __name__ == \"__main__\":\n    num_tests = 100  # You can change this to generate more test cases\n    test_case_generator_results = test_generated_test_cases(num_tests)\n",
  "test_case": "assert solution.numDistinct('uk', 'rhu') == 0\nassert solution.numDistinct('qgqmkyzz', 'qiejskhs') == 0\nassert solution.numDistinct('hytnx', 'nz') == 0\nassert solution.numDistinct('slmbty', 'rurrpz') == 0\nassert solution.numDistinct('hukwjtmrt', 'ppkfj') == 0\nassert solution.numDistinct('dkwqsiowosa', 'x') == 0\nassert solution.numDistinct('jauglhjqq', 'qmzzu') == 0\nassert solution.numDistinct('efui', 'm') == 0\nassert solution.numDistinct('wrmk', 'szgg') == 0\nassert solution.numDistinct('wu', 'yyfbgvx') == 0\nassert solution.numDistinct('fz', 'ay') == 0\nassert solution.numDistinct('wtuoy', 'gmmvxxeh') == 0\nassert solution.numDistinct('tmrewqax', 'w') == 1\nassert solution.numDistinct('cve', 'svp') == 0\nassert solution.numDistinct('p', 'lnhgrdu') == 0\nassert solution.numDistinct('wga', 'xymk') == 0\nassert solution.numDistinct('wtxiuwh', 'ds') == 0\nassert solution.numDistinct('rbcmas', 'x') == 0\nassert solution.numDistinct('mavwj', 'shdqor') == 0\nassert solution.numDistinct('hghzmqnq', 'wiookuz') == 0\nassert solution.numDistinct('segmir', 'hozs') == 0\nassert solution.numDistinct('dcxh', 'tzjsbor') == 0\nassert solution.numDistinct('iwrmrjb', 'uyck') == 0\nassert solution.numDistinct('hlpyuass', 'rrqm') == 0\nassert solution.numDistinct('ywt', 'y') == 1\nassert solution.numDistinct('ieqwy', 'ennpjh') == 0\nassert solution.numDistinct('krxntbdywg', 'ddridarjm') == 0\nassert solution.numDistinct('nxmvufrnbyl', 'lrgygdry') == 0\nassert solution.numDistinct('ficsbascq', 'qkhgsn') == 0\nassert solution.numDistinct('eaopbquhckj', 'ushk') == 0\nassert solution.numDistinct('brno', 'fizoft') == 0\nassert solution.numDistinct('vzltbq', 'cre') == 0\nassert solution.numDistinct('aiqt', 'znoxiltt') == 0\nassert solution.numDistinct('iar', 'fao') == 0\nassert solution.numDistinct('xueihbvbm', 'mcne') == 0\nassert solution.numDistinct('shciaxxynu', 'gzfx') == 0\nassert solution.numDistinct('cnheq', 'ojthtlpxu') == 0\nassert solution.numDistinct('z', 'wqesm') == 0\nassert solution.numDistinct('qu', 'vyfdugja') == 0\nassert solution.numDistinct('ekalijijo', 'mkzbyn') == 0\nassert solution.numDistinct('mweesfk', 'cxjgbizth') == 0\nassert solution.numDistinct('mxkvsgggt', 'nyhdfk') == 0\nassert solution.numDistinct('rzkimgugyml', 'le') == 0\nassert solution.numDistinct('fckklfde', 'ujlqzzzbq') == 0\nassert solution.numDistinct('tzvyv', 'amwve') == 0\nassert solution.numDistinct('ceh', 'icvhuzegcq') == 0\nassert solution.numDistinct('sketav', 'ssbxhap') == 0\nassert solution.numDistinct('wkvz', 'anqquoy') == 0\nassert solution.numDistinct('iso', 'rpdrvu') == 0\nassert solution.numDistinct('gddpvyeef', 'gvtqtswc') == 0\nassert solution.numDistinct('t', 'sqcxg') == 0\nassert solution.numDistinct('oue', 'wdrdugr') == 0\nassert solution.numDistinct('mcayqhz', 'cmxylqz') == 0\nassert solution.numDistinct('qje', 'oxmoftglqv') == 0\nassert solution.numDistinct('e', 'a') == 0\nassert solution.numDistinct('i', 'dhbzlt') == 0\nassert solution.numDistinct('cpmkgcsnw', 'tepmohcotsl') == 0\nassert solution.numDistinct('otb', 'oulxvypktnt') == 0\nassert solution.numDistinct('wiy', 'lnty') == 0\nassert solution.numDistinct('ibggdlat', 'baz') == 0\nassert solution.numDistinct('ddmpsicss', 'taa') == 0\nassert solution.numDistinct('gulg', 'wtkzhdu') == 0\nassert solution.numDistinct('qketxt', 'mdp') == 0\nassert solution.numDistinct('td', 'que') == 0\nassert solution.numDistinct('kud', 'ubmkhlxgrtc') == 0\nassert solution.numDistinct('qyjr', 'szzihljiy') == 0\nassert solution.numDistinct('ew', 'peycmq') == 0\nassert solution.numDistinct('ggxpcxododc', 'ldbialcpxpj') == 0\nassert solution.numDistinct('fxrdfzz', 'mb') == 0\nassert solution.numDistinct('y', 'qozopipd') == 0\nassert solution.numDistinct('zo', 'o') == 1\nassert solution.numDistinct('imavtf', 'mion') == 0\nassert solution.numDistinct('dhp', 'lkjbnhh') == 0\nassert solution.numDistinct('vwnzlsdxaj', 'ezlpmrft') == 0\nassert solution.numDistinct('trnfwv', 'wilduy') == 0\nassert solution.numDistinct('eaifakvhoxq', 'iujmq') == 0\nassert solution.numDistinct('ll', 'naecle') == 0\nassert solution.numDistinct('xkojcqfalxr', 'nmw') == 0\nassert solution.numDistinct('ezkro', 'c') == 0\nassert solution.numDistinct('j', 'hx') == 0\nassert solution.numDistinct('kwlqjpw', 'ojpdufjx') == 0\nassert solution.numDistinct('kwnd', 'rznf') == 0\nassert solution.numDistinct('gikxw', 'qrclsa') == 0\nassert solution.numDistinct('bdfziqrak', 'cbw') == 0\nassert solution.numDistinct('xc', 'bbupxxfxg') == 0\nassert solution.numDistinct('p', 'uvlogmtnnkn') == 0\nassert solution.numDistinct('nfddsefsl', 'ja') == 0\nassert solution.numDistinct('cvhu', 'udtw') == 0\nassert solution.numDistinct('vedolsqwydq', 'gwjeubvepkx') == 0\nassert solution.numDistinct('tpyi', 'm') == 0\nassert solution.numDistinct('wvyewe', 'nkzuvf') == 0\nassert solution.numDistinct('ybioqvfaj', 'y') == 1\nassert solution.numDistinct('edqezteczf', 'xz') == 0\nassert solution.numDistinct('wglmxzc', 'zzsdjs') == 0\nassert solution.numDistinct('oyhovsx', 'lgcjq') == 0\nassert solution.numDistinct('ztvavjytjuj', 'w') == 0\nassert solution.numDistinct('e', 'rgyponhklt') == 0\nassert solution.numDistinct('rzxbehzhkrl', 'lc') == 0\nassert solution.numDistinct('tss', 'aru') == 0\nassert solution.numDistinct('ymqmynkvc', 'gcas') == 0",
  "inefficient_solution": "class Solution:\n    def numDistinct(self, s: str, t: str) -> int:\n        n = len(t)\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(n + 1):\n            dp[i][0] = 1\n        for i in range(1, n + 1):\n            for j in range(1, n + 1):\n                if t[i - 1] == s[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + dp[i][j - 1]\n                else:\n                    dp[i][j] = dp[i][j - 1]\n        return dp[n][n]",
  "is_python": true
}