{
  "problem_idx": 10,
  "task_name": "Regular Expression Matching",
  "markdown_description": "\nGiven an input string `s`\u00a0and a pattern `p`, implement regular expression matching with support for `'.'` and `'*'` where:\n\n\n* `'.'` Matches any single character.\u200b\u200b\u200b\u200b\n* `'*'` Matches zero or more of the preceding element.\n\n\nThe matching should cover the **entire** input string (not partial).\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** s = \"aa\", p = \"a\"\n**Output:** false\n**Explanation:** \"a\" does not match the entire string \"aa\".\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** s = \"aa\", p = \"a*\"\n**Output:** true\n**Explanation:** '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes \"aa\".\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** s = \"ab\", p = \".*\"\n**Output:** true\n**Explanation:** \".*\" means \"zero or more (*) of any character (.)\".\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= s.length\u00a0<= 20`\n* `1 <= p.length\u00a0<= 20`\n* `s` contains only lowercase English letters.\n* `p` contains only lowercase English letters, `'.'`, and\u00a0`'*'`.\n* It is guaranteed for each appearance of the character `'*'`, there will be a previous valid character to match.\n\n\n",
  "canonical_solution": "class Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        m, n = len(s), len(p)\n        f = [[False] * (n + 1) for _ in range(m + 1)]\n        f[0][0] = True\n        for i in range(m + 1):\n            for j in range(1, n + 1):\n                if p[j - 1] == \"*\":\n                    f[i][j] = f[i][j - 2]\n                    if i > 0 and (p[j - 2] == \".\" or s[i - 1] == p[j - 2]):\n                        f[i][j] |= f[i - 1][j]\n                elif i > 0 and (p[j - 1] == \".\" or s[i - 1] == p[j - 1]):\n                    f[i][j] = f[i - 1][j - 1]\n        return f[m][n]\n",
  "test_case_generator": "\nimport random\n\nclass Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        m, n = len(s), len(p)\n        f = [[False] * (n + 1) for _ in range(m + 1)]\n        f[0][0] = True\n        for i in range(m + 1):\n            for j in range(1, n + 1):\n                if p[j - 1] == \"*\":\n                    f[i][j] = f[i][j - 2]\n                    if i > 0 and (p[j - 2] == \".\" or s[i - 1] == p[j - 2]):\n                        f[i][j] |= f[i - 1][j]\n                elif i > 0 and (p[j - 1] == \".\" or s[i - 1] == p[j - 1]):\n                    f[i][j] = f[i - 1][j - 1]\n        return f[m][n]\n\ndef generate_test_case():\n    solution = Solution()\n\n    # Generate random input strings\n    s = ''.join(random.choice('abcdefghijklmnopqrstuvwxyz') for _ in range(random.randint(1, 20)))\n    p = ''.join(random.choice('abcdefghijklmnopqrstuvwxyz.*') for _ in range(random.randint(1, 20)))\n\n    # Calculate the expected result using the provided Solution class\n    expected_result = solution.isMatch(s, p)\n\n    return s, p, expected_result\n\ndef test_generated_test_cases(num_tests):\n    test_case_generator_results = []\n    for i in range(num_tests):\n        s, p, expected_result = generate_test_case()\n        solution = Solution()\n        assert solution.isMatch(s, p) == expected_result\n        print(f\"assert solution.isMatch('{s}', '{p}') == {expected_result}\")\n        test_case_generator_results.append(f\"assert solution.isMatch('{s}', '{p}') == {expected_result}\") # You can find that we construct the test case in the same format as the example\n    return test_case_generator_results\n\nif __name__ == \"__main__\":\n    num_tests = 100  # You can change this to generate more test cases\n    test_case_generator_results = test_generated_test_cases(num_tests)\n",
  "test_case": "assert solution.isMatch('xneafi', '.asrgzjwjjxxoho') == False\nassert solution.isMatch('ggmxwwkbebouidkhdya', 'rhe') == False\nassert solution.isMatch('dyz', 'biragpervxyvwagor') == False\nassert solution.isMatch('s', 'a*yxshux') == False\nassert solution.isMatch('jeca', 'rxifxnlxzpy') == False\nassert solution.isMatch('zrekwkvncxfhnwgfmck', 'cxtg.sgbsbyp.caiec') == False\nassert solution.isMatch('nlhmapmzabxqxt', 'mwzlpmbijinrwvge') == False\nassert solution.isMatch('incrgvcsc', 'qbd') == False\nassert solution.isMatch('ouhygwjsglv', 'cvcgnfzc') == False\nassert solution.isMatch('pk', 'pcbpfxw*l') == False\nassert solution.isMatch('sd', 'iypxwpgejslu*wqtqyvk') == False\nassert solution.isMatch('gmwqnpwawv', 'khz.gtmysllz.') == False\nassert solution.isMatch('nkhzmyclyjobwkkrc', 'ffqqe.*yyxysqipbzwp') == False\nassert solution.isMatch('sfejkuroonfiipbn', 'cxwghtsu') == False\nassert solution.isMatch('iqeoxedyls', 'hnwzzmarhuuqexgq') == False\nassert solution.isMatch('ckxxuetxtunhxulv', 'ra') == False\nassert solution.isMatch('edasbqof', 'hmeerob') == False\nassert solution.isMatch('ehtyhcqabus', 'fwfijiijuitwjros.') == False\nassert solution.isMatch('hdtmxfomuviukyivux', 'upkjuivcay') == False\nassert solution.isMatch('hjzvlncfjocskq', 'qrqwysoiy') == False\nassert solution.isMatch('swdrfxuyavtfc', 'vxpgtgnc*ksadwbkh') == False\nassert solution.isMatch('nkpnkwohshhxpju', 'cgwwv') == False\nassert solution.isMatch('voalimludxvnqvqq', 'ewp*pgbd') == False\nassert solution.isMatch('izmxpmpkof', 'bjdibxflx*') == False\nassert solution.isMatch('uhgiv', 'mptu*jdah.xiumjk') == False\nassert solution.isMatch('prtjcephkkockfgjn', 'hriyili*ppiyr') == False\nassert solution.isMatch('cgo', 'dq') == False\nassert solution.isMatch('uzb', 'qypk*gpjbudflqpxwaaq') == False\nassert solution.isMatch('ofkbkok', 'bk') == False\nassert solution.isMatch('nfwuvlqtpmfhzsw', 'rezvbdfau') == False\nassert solution.isMatch('afmbsgvhfgwskw', 'kkumpithkwj') == False\nassert solution.isMatch('spcutcvulwyiopmgxplp', 'q') == False\nassert solution.isMatch('sjohbkneshyxxxzdgjfk', 'zpfyyomj.') == False\nassert solution.isMatch('iab', 'jehafyx') == False\nassert solution.isMatch('y', 'xouyzmpvepvmv*') == False\nassert solution.isMatch('abxjmsmtgo', 'jgroc*y') == False\nassert solution.isMatch('kajqjtdhufr', 'adoyqlmg.') == False\nassert solution.isMatch('diqjl', 'i.jalwbofipb') == False\nassert solution.isMatch('kdatvjhdlevbnxb', 'v.uctktedzoscsv') == False\nassert solution.isMatch('aosdwysfk', 'pulpkil') == False\nassert solution.isMatch('gjqjppghj', 'xxvgbhxqspklga.nz') == False\nassert solution.isMatch('sib', 'iwkaz') == False\nassert solution.isMatch('jzstbvfbg', 'fgo') == False\nassert solution.isMatch('sdo', 'aauzzb.copmu') == False\nassert solution.isMatch('nfdvdybrmxxjxzyhlhu', 'swgunrfru') == False\nassert solution.isMatch('llkyofdqbzcrkedwvkia', 'gvlgxvsoqsqn') == False\nassert solution.isMatch('qq', 'ymcagxp') == False\nassert solution.isMatch('gshqvmt', 'yjffwrpkehzdtmmelt') == False\nassert solution.isMatch('wkszekahiveah', 'zs') == False\nassert solution.isMatch('tslkvllemudjwpp', 'owwmhqkaea.na.') == False\nassert solution.isMatch('lvmmaqvw', 'lvsxmtrgtkv') == False\nassert solution.isMatch('egozonhkpjiqtutd', 'rfxfij') == False\nassert solution.isMatch('mwgtgyspazlhwq', 'wdatq') == False\nassert solution.isMatch('qoywvoazu', 'vg') == False\nassert solution.isMatch('cufl', 'taxqil.rg') == False\nassert solution.isMatch('czjmhaszzpocnso', 'ljkbh') == False\nassert solution.isMatch('gnnbjrbpqlnfsbkmao', 'bz.r.x.rwar') == False\nassert solution.isMatch('jtixicezo', 'cpcovznqjytznjuqi') == False\nassert solution.isMatch('fckg', 'yhqsee') == False\nassert solution.isMatch('eutkfdfhovhsxtikhlmy', 'aobcz.yvs.') == False\nassert solution.isMatch('pv', 'fuqyqr*ehsv') == False\nassert solution.isMatch('xldsrjlcqz', 'yruvll*vgoqdrwgenzl') == False\nassert solution.isMatch('wgojyn', 'tprjzcptufmey') == False\nassert solution.isMatch('nhaiizcnyelvmbpbpozn', 'njxknagex') == False\nassert solution.isMatch('ayj', 'nkqv') == False\nassert solution.isMatch('npumewtxslxqom', 'pnren.f') == False\nassert solution.isMatch('oewdtosxobavsx', 'apl.e.kx*znmh') == False\nassert solution.isMatch('hccuxscgagl', 's') == False\nassert solution.isMatch('odrsso', 'dd') == False\nassert solution.isMatch('iqzpderh', 'bzoczx.tbgviwpmyig') == False\nassert solution.isMatch('lex', 'y.t') == False\nassert solution.isMatch('popmdoksl', 'v*rshcs.') == False\nassert solution.isMatch('utnubrtwqihqioujk', 'lj') == False\nassert solution.isMatch('gia', 'xatsysslflixsecmdv') == False\nassert solution.isMatch('wbhqvbvqzbdnaoqt', 'eenfkqjhzthnxdkf') == False\nassert solution.isMatch('vagkljjnjba', 'vgvclpznlcopvr') == False\nassert solution.isMatch('nftmqlkmegkhdukf', 'ghzbi.') == False\nassert solution.isMatch('fzg', '..kfhuzbozqvdh') == False\nassert solution.isMatch('puzdsr', 'sfm.x') == False\nassert solution.isMatch('giulzuy', 'khsctxi.jvnw.') == False\nassert solution.isMatch('jshawbdbpqqduuk', 'qt*xayydeclgethuz') == False\nassert solution.isMatch('wdsqrzgdqoyojgtycwkq', 'x') == False\nassert solution.isMatch('qrziuskopd', 'yv') == False\nassert solution.isMatch('lktmldbfkswqircfdk', 'hrvqfzj') == False\nassert solution.isMatch('vceoftbg', 'jyegakv*ht') == False\nassert solution.isMatch('ooyv', 'lsn') == False\nassert solution.isMatch('rrfltvbjnywj', 'edjsvmy.kwueenm') == False\nassert solution.isMatch('ttm', 'fu.wvtt') == False\nassert solution.isMatch('ssdo', 'jzx.mkhlxuu*hvzabi') == False\nassert solution.isMatch('tz', 'rvgbf*wxsktpistx') == False\nassert solution.isMatch('vpldqwvlgz', 'jlf*imnvxo*q') == False\nassert solution.isMatch('ydoqvov', 'git') == False\nassert solution.isMatch('mnlhrmyixnjghgzei', 'vor*ibkqkdusyjn') == False\nassert solution.isMatch('dfeha', 'vqdi') == False\nassert solution.isMatch('x', 'hurqmec.xpk') == False\nassert solution.isMatch('zrewgwhijhm', 'rzmd.') == False\nassert solution.isMatch('k', '*ptuwocht.zobiuqsuj') == False\nassert solution.isMatch('ehqxldimvywai', 'sugmtebi') == False\nassert solution.isMatch('uomvmrrktpyzossgtcbv', '*kppyes') == False\nassert solution.isMatch('iqcvepvtqcllxgfxgjj', 'tvcy*oxincyhqhtgb') == False",
  "inefficient_solution": "class Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        m, n = len(s), len(p)\n        match = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\n        for i in range(m + 1):\n            match[i] = match[i].copy()\n        for i in range(m + 1):\n            match[i] = match[i].copy()\n        match[0][0] = True\n        for i in range(m + 1):\n            match[i] = match[i].copy()\n        for i in range(m + 1):\n            match[i] = match[i].copy()\n        for i in range(1, n + 1):\n            match[0][i] = match[0][i].copy()\n        for i in range(1, n + 1):\n            match[0][i] = match[0][i].copy()\n        for i in range(1, n + 1):\n            match[0][i] = match[0][i].copy()\n        for i in range(1, n + 1):\n            if p[i - 1] == \"*\":\n                for j in range(m + 1):\n                    match[j][i] = match[j][i].copy()\n                match[j][i] = match[j][i].copy()\n                if j > 0 and (p[i - 2] == \".\" or s[j - 1] == p[i - 2]):\n                    match[j][i] = match[j][i].copy()\n                    for k in range(j):\n                        match[k][i] = match[k][i].copy()\n                    for k in range(j):\n                        match[k][i] = match[k][i].copy()\n            elif i > 0 and (p[i - 1] == \".\" or s[j - 1] == p[i - 1]):\n                match[j][i] = match[j][i].copy()\n                match[j][i] = match[j][i].copy()\n        return match[m][n]",
  "is_python": true
}