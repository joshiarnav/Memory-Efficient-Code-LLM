{
  "problem_idx": 926,
  "task_name": "Flip String to Monotone Increasing",
  "markdown_description": "\nA binary string is monotone increasing if it consists of some number of `0`'s (possibly none), followed by some number of `1`'s (also possibly none).\n\n\nYou are given a binary string `s`. You can flip `s[i]` changing it from `0` to `1` or from `1` to `0`.\n\n\nReturn *the minimum number of flips to make* `s` *monotone increasing*.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** s = \"00110\"\n**Output:** 1\n**Explanation:** We flip the last digit to get 00111.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** s = \"010110\"\n**Output:** 2\n**Explanation:** We flip to get 011111, or alternatively 000111.\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** s = \"00011000\"\n**Output:** 2\n**Explanation:** We flip to get 00000000.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= s.length <= 105`\n* `s[i]` is either `'0'` or `'1'`.\n\n\n",
  "canonical_solution": "class Solution:\n    def minFlipsMonoIncr(self, s: str) -> int:\n        n = len(s)\n        left, right = [0] * (n + 1), [0] * (n + 1)\n        ans = 0x3F3F3F3F\n        for i in range(1, n + 1):\n            left[i] = left[i - 1] + (1 if s[i - 1] == '1' else 0)\n        for i in range(n - 1, -1, -1):\n            right[i] = right[i + 1] + (1 if s[i] == '0' else 0)\n        for i in range(0, n + 1):\n            ans = min(ans, left[i] + right[i])\n        return ans\n",
  "test_case_generator": "\nimport random\n\nclass Solution:\n    def minFlipsMonoIncr(self, s: str) -> int:\n        n = len(s)\n        left, right = [0] * (n + 1), [0] * (n + 1)\n        ans = 0x3F3F3F3F\n        for i in range(1, n + 1):\n            left[i] = left[i - 1] + (1 if s[i - 1] == '1' else 0)\n        for i in range(n - 1, -1, -1):\n            right[i] = right[i + 1] + (1 if s[i] == '0' else 0)\n        for i in range(0, n + 1):\n            ans = min(ans, left[i] + right[i])\n        return ans\n\n\ndef generate_test_case():\n    solution = Solution()\n    \n    # Generate a random binary string\n    s = ''.join(random.choices(['0', '1'], k=random.randint(1, 10)))\n    \n    # Calculate the expected result using the provided Solution class\n    expected_result = solution.minFlipsMonoIncr(s)\n\n    return s, expected_result\n\ndef test_generated_test_cases(num_tests):\n    test_case_generator_results = []\n    for i in range(num_tests):\n        s, expected_result = generate_test_case()\n        solution = Solution()\n        assert solution.minFlipsMonoIncr(s) == expected_result\n        print(f\"assert solution.minFlipsMonoIncr('{s}') == {expected_result}\")\n        test_case_generator_results.append(f\"assert solution.minFlipsMonoIncr('{s}') == {expected_result}\")\n    return test_case_generator_results\n\nif __name__ == \"__main__\":\n    num_tests = 100  # You can change this to generate more test cases\n    test_case_generator_results = test_generated_test_cases(num_tests)\n",
  "test_case": "assert solution.minFlipsMonoIncr('01001011') == 2\nassert solution.minFlipsMonoIncr('010000') == 1\nassert solution.minFlipsMonoIncr('001000') == 1\nassert solution.minFlipsMonoIncr('01101100') == 3\nassert solution.minFlipsMonoIncr('0011010') == 2\nassert solution.minFlipsMonoIncr('0101011') == 2\nassert solution.minFlipsMonoIncr('010001011') == 2\nassert solution.minFlipsMonoIncr('1111') == 0\nassert solution.minFlipsMonoIncr('000') == 0\nassert solution.minFlipsMonoIncr('1100011100') == 4\nassert solution.minFlipsMonoIncr('0000111101') == 1\nassert solution.minFlipsMonoIncr('11101') == 1\nassert solution.minFlipsMonoIncr('100110111') == 2\nassert solution.minFlipsMonoIncr('011110000') == 4\nassert solution.minFlipsMonoIncr('001') == 0\nassert solution.minFlipsMonoIncr('11111100') == 2\nassert solution.minFlipsMonoIncr('1111') == 0\nassert solution.minFlipsMonoIncr('0') == 0\nassert solution.minFlipsMonoIncr('10') == 1\nassert solution.minFlipsMonoIncr('0') == 0\nassert solution.minFlipsMonoIncr('0110100') == 3\nassert solution.minFlipsMonoIncr('1') == 0\nassert solution.minFlipsMonoIncr('10') == 1\nassert solution.minFlipsMonoIncr('001111010') == 2\nassert solution.minFlipsMonoIncr('00111') == 0\nassert solution.minFlipsMonoIncr('001001') == 1\nassert solution.minFlipsMonoIncr('10000100') == 2\nassert solution.minFlipsMonoIncr('1001') == 1\nassert solution.minFlipsMonoIncr('0') == 0\nassert solution.minFlipsMonoIncr('0011') == 0\nassert solution.minFlipsMonoIncr('1110') == 1\nassert solution.minFlipsMonoIncr('110110') == 2\nassert solution.minFlipsMonoIncr('11') == 0\nassert solution.minFlipsMonoIncr('001000001') == 1\nassert solution.minFlipsMonoIncr('000111000') == 3\nassert solution.minFlipsMonoIncr('10') == 1\nassert solution.minFlipsMonoIncr('1') == 0\nassert solution.minFlipsMonoIncr('100101') == 2\nassert solution.minFlipsMonoIncr('00') == 0\nassert solution.minFlipsMonoIncr('01') == 0\nassert solution.minFlipsMonoIncr('1001101') == 2\nassert solution.minFlipsMonoIncr('11000') == 2\nassert solution.minFlipsMonoIncr('11100001') == 3\nassert solution.minFlipsMonoIncr('1110100001') == 4\nassert solution.minFlipsMonoIncr('1100000010') == 3\nassert solution.minFlipsMonoIncr('1100101011') == 4\nassert solution.minFlipsMonoIncr('001110101') == 2\nassert solution.minFlipsMonoIncr('110101') == 2\nassert solution.minFlipsMonoIncr('111') == 0\nassert solution.minFlipsMonoIncr('110011111') == 2\nassert solution.minFlipsMonoIncr('0011001100') == 4\nassert solution.minFlipsMonoIncr('1100001') == 2\nassert solution.minFlipsMonoIncr('1100') == 2\nassert solution.minFlipsMonoIncr('0') == 0\nassert solution.minFlipsMonoIncr('0001') == 0\nassert solution.minFlipsMonoIncr('1001101') == 2\nassert solution.minFlipsMonoIncr('0000') == 0\nassert solution.minFlipsMonoIncr('0110101010') == 4\nassert solution.minFlipsMonoIncr('0100111') == 1\nassert solution.minFlipsMonoIncr('010') == 1\nassert solution.minFlipsMonoIncr('1') == 0\nassert solution.minFlipsMonoIncr('0001010') == 2\nassert solution.minFlipsMonoIncr('1') == 0\nassert solution.minFlipsMonoIncr('0100111000') == 4\nassert solution.minFlipsMonoIncr('01000001') == 1\nassert solution.minFlipsMonoIncr('111') == 0\nassert solution.minFlipsMonoIncr('01') == 0\nassert solution.minFlipsMonoIncr('011') == 0\nassert solution.minFlipsMonoIncr('0000000') == 0\nassert solution.minFlipsMonoIncr('01011111') == 1\nassert solution.minFlipsMonoIncr('0010') == 1\nassert solution.minFlipsMonoIncr('101110') == 2\nassert solution.minFlipsMonoIncr('0010011') == 1\nassert solution.minFlipsMonoIncr('00') == 0\nassert solution.minFlipsMonoIncr('0001111') == 0\nassert solution.minFlipsMonoIncr('0111') == 0\nassert solution.minFlipsMonoIncr('10101000') == 3\nassert solution.minFlipsMonoIncr('1') == 0\nassert solution.minFlipsMonoIncr('1111001000') == 5\nassert solution.minFlipsMonoIncr('1000111') == 1\nassert solution.minFlipsMonoIncr('100101111') == 2\nassert solution.minFlipsMonoIncr('00001') == 0\nassert solution.minFlipsMonoIncr('01010111') == 2\nassert solution.minFlipsMonoIncr('111000') == 3\nassert solution.minFlipsMonoIncr('01100100') == 3\nassert solution.minFlipsMonoIncr('01') == 0\nassert solution.minFlipsMonoIncr('111110') == 1\nassert solution.minFlipsMonoIncr('1010111000') == 5\nassert solution.minFlipsMonoIncr('000001') == 0\nassert solution.minFlipsMonoIncr('011010') == 2\nassert solution.minFlipsMonoIncr('1') == 0\nassert solution.minFlipsMonoIncr('1111') == 0\nassert solution.minFlipsMonoIncr('10101') == 2\nassert solution.minFlipsMonoIncr('010') == 1\nassert solution.minFlipsMonoIncr('01') == 0\nassert solution.minFlipsMonoIncr('001') == 0\nassert solution.minFlipsMonoIncr('00110110') == 2\nassert solution.minFlipsMonoIncr('101110011') == 3\nassert solution.minFlipsMonoIncr('11100100') == 4\nassert solution.minFlipsMonoIncr('1010110011') == 4",
  "inefficient_solution": "class Solution:\n    def minFlipsMonoIncr(self, s: str) -> int:\n        n = len(s)\n        flips = [0] * n\n        for i in range(n):\n            for j in range(i + 1):\n                if s[j] == '1':\n                    flips[i] += 1\n        max_flips = [0] * n\n        for i in range(n - 1, -1, -1):\n            for j in range(i, n):\n                max_flips[i] = max(max_flips[i], max_flips[j] + 1)\n        ans = 0x3F3F3F3F\n        for i in range(n):\n            for j in range(n):\n                ans = min(ans, flips[i] + max_flips[j])\n        return ans",
  "is_python": true
}