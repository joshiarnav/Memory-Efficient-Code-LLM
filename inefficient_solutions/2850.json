{
  "problem_idx": 2850,
  "task_name": "Minimum Moves to Spread Stones Over Grid",
  "markdown_description": "\nYou are given a **0-indexed** 2D integer matrix `grid` of size `3 * 3`, representing the number of stones in each cell. The grid contains exactly `9` stones, and there can be **multiple** stones in a single cell.\n\n\nIn one move, you can move a single stone from its current cell to any other cell if the two cells share a side.\n\n\nReturn *the **minimum number of moves** required to place one stone in each cell*.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2800-2899/2850.Minimum%20Moves%20to%20Spread%20Stones%20Over%20Grid/images/example1-3.svg)\n\n```\n\n**Input:** grid = [[1,1,0],[1,1,1],[1,2,1]]\n**Output:** 3\n**Explanation:** One possible sequence of moves to place one stone in each cell is: \n1- Move one stone from cell (2,1) to cell (2,2).\n2- Move one stone from cell (2,2) to cell (1,2).\n3- Move one stone from cell (1,2) to cell (0,2).\nIn total, it takes 3 moves to place one stone in each cell of the grid.\nIt can be shown that 3 is the minimum number of moves required to place one stone in each cell.\n\n```\n\n**Example 2:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2800-2899/2850.Minimum%20Moves%20to%20Spread%20Stones%20Over%20Grid/images/example2-2.svg)\n\n```\n\n**Input:** grid = [[1,3,0],[1,0,0],[1,0,3]]\n**Output:** 4\n**Explanation:** One possible sequence of moves to place one stone in each cell is:\n1- Move one stone from cell (0,1) to cell (0,2).\n2- Move one stone from cell (0,1) to cell (1,1).\n3- Move one stone from cell (2,2) to cell (1,2).\n4- Move one stone from cell (2,2) to cell (2,1).\nIn total, it takes 4 moves to place one stone in each cell of the grid.\nIt can be shown that 4 is the minimum number of moves required to place one stone in each cell.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `grid.length == grid[i].length == 3`\n* `0 <= grid[i][j] <= 9`\n* Sum of `grid` is equal to `9`.\n\n\n",
  "canonical_solution": "class Solution:\n    def minimumMoves(self, grid: List[List[int]]) -> int:\n        def cal(a: tuple, b: tuple) -> int:\n            return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n        left, right = [], []\n        for i in range(3):\n            for j in range(3):\n                if grid[i][j] == 0:\n                    left.append((i, j))\n                else:\n                    for _ in range(grid[i][j] - 1):\n                        right.append((i, j))\n\n        n = len(left)\n        f = [inf] * (1 << n)\n        f[0] = 0\n        for i in range(1, 1 << n):\n            k = i.bit_count()\n            for j in range(n):\n                if i >> j & 1:\n                    f[i] = min(f[i], f[i ^ (1 << j)] + cal(left[k - 1], right[j]))\n        return f[-1]\n",
  "test_case_generator": "\nimport random\nfrom typing import List\nfrom math import inf\n\nclass Solution:\n    def minimumMoves(self, grid: List[List[int]]) -> int:\n        def cal(a: tuple, b: tuple) -> int:\n            return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n        left, right = [], []\n        for i in range(3):\n            for j in range(3):\n                if grid[i][j] == 0:\n                    left.append((i, j))\n                else:\n                    for _ in range(grid[i][j] - 1):\n                        right.append((i, j))\n\n        n = len(left)\n        f = [inf] * (1 << n)\n        f[0] = 0\n        for i in range(1, 1 << n):\n            k = i.bit_count()\n            for j in range(n):\n                if i >> j & 1:\n                    f[i] = min(f[i], f[i ^ (1 << j)] + cal(left[k - 1], right[j]))\n        return f[-1]\n\ndef generate_test_case():\n    solution = Solution()\n    \n    # Generate random numbers list\n    grid = [[random.randint(0, 9) for _ in range(3)] for _ in range(3)]\n\n    # Calculate the expected result using the provided Solution class\n    expected_result = solution.minimumMoves(grid)\n\n    return grid, expected_result\n\ndef test_generated_test_cases(num_tests):\n    test_case_generator_results = []\n    for _ in range(num_tests):\n        grid, expected_result = generate_test_case()\n        solution = Solution()\n        assert solution.minimumMoves(grid) == expected_result\n        print(f\"assert solution.minimumMoves({grid}) == {expected_result}\")\n        test_case_generator_results.append(f\"assert solution.minimumMoves({grid}) == {expected_result}\")\n    return test_case_generator_results\n\nif __name__ == \"__main__\":\n    num_tests = 100  # You can change this to generate more test cases\n    test_case_generator_results = test_generated_test_cases(num_tests)\n",
  "test_case": "assert solution.minimumMoves([[1, 6, 7], [8, 6, 6], [2, 4, 9]]) == 0\nassert solution.minimumMoves([[1, 6, 2], [2, 3, 1], [7, 1, 2]]) == 0\nassert solution.minimumMoves([[9, 0, 6], [7, 2, 6], [3, 3, 6]]) == 1\nassert solution.minimumMoves([[6, 0, 3], [7, 1, 4], [2, 3, 2]]) == 1\nassert solution.minimumMoves([[5, 6, 8], [1, 6, 9], [5, 6, 2]]) == 0\nassert solution.minimumMoves([[1, 6, 6], [6, 7, 5], [7, 2, 7]]) == 0\nassert solution.minimumMoves([[5, 7, 8], [6, 6, 7], [2, 2, 2]]) == 0\nassert solution.minimumMoves([[5, 6, 7], [5, 7, 9], [5, 0, 9]]) == 3\nassert solution.minimumMoves([[9, 0, 0], [3, 0, 3], [1, 9, 3]]) == 5\nassert solution.minimumMoves([[0, 1, 9], [6, 7, 8], [6, 2, 7]]) == 2\nassert solution.minimumMoves([[4, 4, 1], [4, 2, 2], [4, 4, 5]]) == 0\nassert solution.minimumMoves([[7, 3, 2], [3, 4, 7], [1, 4, 6]]) == 0\nassert solution.minimumMoves([[5, 4, 3], [1, 3, 1], [7, 5, 5]]) == 0\nassert solution.minimumMoves([[8, 0, 2], [3, 8, 2], [0, 2, 7]]) == 3\nassert solution.minimumMoves([[6, 9, 8], [3, 1, 3], [9, 4, 9]]) == 0\nassert solution.minimumMoves([[2, 1, 5], [5, 7, 9], [9, 7, 8]]) == 0\nassert solution.minimumMoves([[8, 5, 8], [6, 4, 8], [6, 4, 6]]) == 0\nassert solution.minimumMoves([[6, 4, 5], [7, 8, 4], [8, 8, 3]]) == 0\nassert solution.minimumMoves([[6, 5, 5], [5, 5, 0], [1, 2, 5]]) == 3\nassert solution.minimumMoves([[2, 8, 0], [5, 5, 9], [0, 6, 0]]) == 6\nassert solution.minimumMoves([[0, 9, 2], [9, 4, 5], [0, 8, 0]]) == 7\nassert solution.minimumMoves([[1, 0, 4], [2, 8, 6], [1, 7, 4]]) == 1\nassert solution.minimumMoves([[5, 0, 7], [4, 6, 5], [0, 1, 8]]) == 3\nassert solution.minimumMoves([[0, 4, 1], [3, 6, 7], [3, 5, 5]]) == 1\nassert solution.minimumMoves([[3, 5, 4], [8, 7, 0], [8, 8, 4]]) == 3\nassert solution.minimumMoves([[0, 0, 8], [8, 8, 4], [8, 4, 4]]) == 3\nassert solution.minimumMoves([[2, 7, 1], [9, 3, 9], [6, 7, 4]]) == 0\nassert solution.minimumMoves([[2, 2, 9], [3, 9, 8], [1, 0, 7]]) == 3\nassert solution.minimumMoves([[9, 4, 1], [5, 3, 3], [1, 7, 0]]) == 4\nassert solution.minimumMoves([[3, 5, 9], [4, 6, 4], [2, 6, 8]]) == 0\nassert solution.minimumMoves([[6, 2, 1], [3, 2, 2], [8, 9, 8]]) == 0\nassert solution.minimumMoves([[0, 7, 1], [7, 8, 7], [5, 1, 0]]) == 4\nassert solution.minimumMoves([[7, 5, 8], [0, 2, 9], [5, 7, 4]]) == 1\nassert solution.minimumMoves([[2, 9, 8], [2, 2, 1], [0, 6, 8]]) == 2\nassert solution.minimumMoves([[4, 5, 1], [4, 5, 2], [1, 4, 2]]) == 0\nassert solution.minimumMoves([[1, 7, 4], [0, 7, 1], [1, 5, 9]]) == 2\nassert solution.minimumMoves([[3, 0, 8], [5, 7, 7], [5, 5, 2]]) == 1\nassert solution.minimumMoves([[1, 3, 7], [2, 1, 3], [3, 0, 8]]) == 2\nassert solution.minimumMoves([[8, 4, 9], [0, 7, 0], [2, 1, 9]]) == 4\nassert solution.minimumMoves([[7, 7, 5], [7, 1, 8], [4, 6, 8]]) == 0\nassert solution.minimumMoves([[7, 9, 7], [2, 8, 1], [4, 6, 5]]) == 0\nassert solution.minimumMoves([[3, 0, 3], [6, 6, 4], [9, 5, 6]]) == 1\nassert solution.minimumMoves([[4, 4, 6], [1, 2, 2], [4, 8, 8]]) == 0\nassert solution.minimumMoves([[8, 9, 0], [2, 9, 1], [9, 3, 2]]) == 2\nassert solution.minimumMoves([[5, 8, 5], [1, 8, 4], [5, 2, 0]]) == 4\nassert solution.minimumMoves([[2, 2, 7], [7, 8, 2], [0, 7, 3]]) == 2\nassert solution.minimumMoves([[1, 0, 8], [3, 1, 6], [1, 0, 3]]) == 4\nassert solution.minimumMoves([[3, 5, 2], [0, 7, 8], [6, 6, 0]]) == 5\nassert solution.minimumMoves([[6, 8, 3], [2, 7, 4], [8, 9, 6]]) == 0\nassert solution.minimumMoves([[3, 9, 7], [7, 9, 6], [7, 5, 8]]) == 0\nassert solution.minimumMoves([[5, 4, 9], [5, 0, 4], [6, 9, 4]]) == 2\nassert solution.minimumMoves([[7, 7, 3], [2, 8, 6], [1, 4, 6]]) == 0\nassert solution.minimumMoves([[8, 6, 5], [4, 3, 1], [7, 7, 7]]) == 0\nassert solution.minimumMoves([[9, 4, 6], [2, 7, 6], [7, 9, 8]]) == 0\nassert solution.minimumMoves([[4, 8, 2], [4, 5, 3], [5, 9, 1]]) == 0\nassert solution.minimumMoves([[2, 6, 6], [0, 8, 6], [5, 6, 4]]) == 1\nassert solution.minimumMoves([[4, 0, 3], [3, 0, 3], [9, 0, 2]]) == 6\nassert solution.minimumMoves([[4, 5, 3], [3, 7, 1], [5, 5, 9]]) == 0\nassert solution.minimumMoves([[5, 7, 4], [0, 4, 9], [1, 0, 2]]) == 4\nassert solution.minimumMoves([[1, 0, 9], [1, 8, 3], [6, 1, 3]]) == 1\nassert solution.minimumMoves([[7, 0, 5], [2, 1, 6], [1, 8, 2]]) == 1\nassert solution.minimumMoves([[8, 8, 6], [8, 5, 3], [8, 4, 8]]) == 0\nassert solution.minimumMoves([[7, 9, 3], [8, 4, 4], [3, 2, 3]]) == 0\nassert solution.minimumMoves([[9, 2, 2], [9, 9, 5], [5, 2, 3]]) == 0\nassert solution.minimumMoves([[8, 0, 1], [3, 3, 2], [9, 1, 8]]) == 1\nassert solution.minimumMoves([[3, 9, 9], [6, 1, 3], [6, 1, 0]]) == 4\nassert solution.minimumMoves([[2, 8, 7], [8, 9, 6], [4, 7, 4]]) == 0\nassert solution.minimumMoves([[1, 1, 6], [9, 0, 1], [8, 2, 1]]) == 2\nassert solution.minimumMoves([[6, 6, 8], [2, 2, 3], [9, 5, 5]]) == 0\nassert solution.minimumMoves([[6, 7, 2], [4, 9, 2], [2, 9, 8]]) == 0\nassert solution.minimumMoves([[6, 2, 4], [3, 2, 8], [9, 8, 2]]) == 0\nassert solution.minimumMoves([[4, 2, 1], [9, 1, 4], [9, 9, 6]]) == 0\nassert solution.minimumMoves([[2, 9, 6], [4, 3, 6], [3, 5, 8]]) == 0\nassert solution.minimumMoves([[2, 0, 6], [6, 9, 6], [5, 3, 0]]) == 3\nassert solution.minimumMoves([[2, 7, 6], [8, 5, 2], [3, 2, 6]]) == 0\nassert solution.minimumMoves([[0, 5, 6], [0, 0, 3], [2, 0, 2]]) == 6\nassert solution.minimumMoves([[8, 4, 9], [0, 8, 5], [6, 5, 9]]) == 1\nassert solution.minimumMoves([[0, 4, 9], [6, 6, 7], [4, 1, 8]]) == 1\nassert solution.minimumMoves([[0, 1, 1], [5, 4, 8], [2, 5, 6]]) == 1\nassert solution.minimumMoves([[2, 0, 3], [2, 7, 2], [3, 1, 6]]) == 1\nassert solution.minimumMoves([[5, 4, 7], [9, 0, 4], [4, 9, 9]]) == 2\nassert solution.minimumMoves([[1, 1, 0], [4, 3, 8], [1, 1, 9]]) == 3\nassert solution.minimumMoves([[1, 9, 7], [9, 1, 1], [5, 7, 6]]) == 0\nassert solution.minimumMoves([[8, 9, 9], [9, 0, 6], [5, 0, 1]]) == 5\nassert solution.minimumMoves([[1, 3, 0], [5, 0, 7], [7, 6, 8]]) == 2\nassert solution.minimumMoves([[3, 9, 7], [4, 0, 9], [0, 8, 4]]) == 4\nassert solution.minimumMoves([[6, 9, 1], [3, 8, 2], [2, 3, 4]]) == 0\nassert solution.minimumMoves([[0, 3, 2], [0, 1, 7], [8, 2, 1]]) == 3\nassert solution.minimumMoves([[8, 8, 5], [9, 6, 9], [8, 3, 7]]) == 0\nassert solution.minimumMoves([[9, 3, 4], [5, 8, 7], [4, 8, 9]]) == 0\nassert solution.minimumMoves([[1, 0, 0], [6, 3, 5], [1, 8, 0]]) == 8\nassert solution.minimumMoves([[1, 0, 3], [9, 8, 8], [1, 4, 8]]) == 1\nassert solution.minimumMoves([[3, 5, 2], [5, 5, 8], [6, 4, 2]]) == 0\nassert solution.minimumMoves([[1, 3, 8], [4, 0, 1], [7, 9, 0]]) == 4\nassert solution.minimumMoves([[9, 5, 3], [4, 6, 1], [1, 2, 2]]) == 0\nassert solution.minimumMoves([[4, 8, 8], [7, 2, 0], [7, 9, 7]]) == 3\nassert solution.minimumMoves([[3, 7, 3], [7, 4, 4], [6, 1, 4]]) == 0\nassert solution.minimumMoves([[3, 5, 8], [6, 1, 3], [0, 4, 4]]) == 2\nassert solution.minimumMoves([[4, 2, 8], [9, 6, 4], [6, 5, 2]]) == 0\nassert solution.minimumMoves([[7, 8, 6], [1, 9, 7], [2, 2, 1]]) == 0",
  "inefficient_solution": "class Solution:\n    def minimumMoves(self, grid: List[List[int]]) -> int:\n        def cal(a: tuple, b: tuple) -> int:\n            return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n        left, right = [], []\n        for i in range(3):\n            for j in range(3):\n                if grid[i][j] == 0:\n                    left.append((i, j))\n                else:\n                    for _ in range(grid[i][j] - 1):\n                        right.append((i, j))\n                        right.append((i, j))\n                        right.append((i, j))\n                        right.append((i, j))\n                        right.append((i, j))\n                        right.append((i, j))\n                        right.append((i, j))\n                        right.append((i, j))\n\n        n = len(left)\n        f = [inf] * (1 << (n * 8))\n        f[0] = 0\n        for i in range(1, 1 << (n * 8)):\n            k = i.bit_count()\n            for j in range(n):\n                if i >> j & 1:\n                    for _ in range(8):\n                        f[i] = min(f[i], f[i ^ (1 << (j * 8 + _))] + cal(left[k - 1], right[j * 8 + _]))\n        return f[-1]",
  "is_python": true
}