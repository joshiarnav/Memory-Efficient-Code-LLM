{
  "problem_idx": 433,
  "task_name": "Minimum Genetic Mutation",
  "markdown_description": "\nA gene string can be represented by an 8-character long string, with choices from `'A'`, `'C'`, `'G'`, and `'T'`.\n\n\nSuppose we need to investigate a mutation from a gene string `startGene` to a gene string `endGene` where one mutation is defined as one single character changed in the gene string.\n\n\n* For example, `\"AACCGGTT\" --> \"AACCGGTA\"` is one mutation.\n\n\nThere is also a gene bank `bank` that records all the valid gene mutations. A gene must be in `bank` to make it a valid gene string.\n\n\nGiven the two gene strings `startGene` and `endGene` and the gene bank `bank`, return *the minimum number of mutations needed to mutate from* `startGene` *to* `endGene`. If there is no such a mutation, return `-1`.\n\n\nNote that the starting point is assumed to be valid, so it might not be included in the bank.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** startGene = \"AACCGGTT\", endGene = \"AACCGGTA\", bank = [\"AACCGGTA\"]\n**Output:** 1\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** startGene = \"AACCGGTT\", endGene = \"AAACGGTA\", bank = [\"AACCGGTA\",\"AACCGCTA\",\"AAACGGTA\"]\n**Output:** 2\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `0 <= bank.length <= 10`\n* `startGene.length == endGene.length == bank[i].length == 8`\n* `startGene`, `endGene`, and `bank[i]` consist of only the characters `['A', 'C', 'G', 'T']`.\n\n\n",
  "canonical_solution": "class Solution:\n    def minMutation(self, start: str, end: str, bank: List[str]) -> int:\n        s = set(bank)\n        q = deque([(start, 0)])\n        mp = {'A': 'TCG', 'T': 'ACG', 'C': 'ATG', 'G': 'ATC'}\n        while q:\n            t, step = q.popleft()\n            if t == end:\n                return step\n            for i, v in enumerate(t):\n                for j in mp[v]:\n                    next = t[:i] + j + t[i + 1 :]\n                    if next in s:\n                        q.append((next, step + 1))\n                        s.remove(next)\n        return -1\n",
  "test_case_generator": "\nimport random\n\nclass Solution:\n    def minMutation(self, start: str, end: str, bank: List[str]) -> int:\n        s = set(bank)\n        q = deque([(start, 0)])\n        mp = {'A': 'TCG', 'T': 'ACG', 'C': 'ATG', 'G': 'ATC'}\n        while q:\n            t, step = q.popleft()\n            if t == end:\n                return step\n            for i, v in enumerate(t):\n                for j in mp[v]:\n                    next = t[:i] + j + t[i + 1 :]\n                    if next in s:\n                        q.append((next, step + 1))\n                        s.remove(next)\n        return -1\n\ndef generate_test_case():\n    solution = Solution()\n\n    # Generate random start and end genes\n    startGene = \"\".join(random.choices([\"A\", \"C\", \"G\", \"T\"], k=8))\n    endGene = \"\".join(random.choices([\"A\", \"C\", \"G\", \"T\"], k=8))\n\n    # Generate random bank length and bank genes\n    bank_length = random.randint(0, 10)\n    bank = [\"\".join(random.choices([\"A\", \"C\", \"G\", \"T\"], k=8)) for _ in range(bank_length)]\n\n    # Calculate the expected result using the provided Solution class\n    expected_result = solution.minMutation(startGene, endGene, bank)\n\n    return startGene, endGene, bank, expected_result\n\ndef test_generated_test_cases(num_tests):\n    test_case_generator_results = []\n    for i in range(num_tests):\n        startGene, endGene, bank, expected_result = generate_test_case()\n        solution = Solution()\n        assert solution.minMutation(startGene, endGene, bank) == expected_result\n        print(f\"assert solution.minMutation(\\\"{startGene}\\\", \\\"{endGene}\\\", {bank}) == {expected_result}\")\n        test_case_generator_results.append(\n            f\"assert solution.minMutation(\\\"{startGene}\\\", \\\"{endGene}\\\", {bank}) == {expected_result}\"\n        )  # You can find that we construct the test case in the same format as the example\n    return test_case_generator_results\n\nif __name__ == \"__main__\":\n    num_tests = 100  # You can change this to generate more test cases\n    test_case_generator_results = test_generated_test_cases(num_tests)\n",
  "test_case": "assert solution.minMutation(\"TTCATTGC\", \"TCAAACGT\", ['GGCCGATG', 'TCTTCCAC', 'AGGCATGA', 'AAAAGCCG', 'AAGCTACC', 'ATGCGGTA', 'ACACATCT', 'ACTTTTCT', 'CCTCGTGA']) == -1\nassert solution.minMutation(\"CGGAGCCG\", \"TCTGTCTA\", ['AACAAGCT', 'AGCGGTCT']) == -1\nassert solution.minMutation(\"CTCAATAT\", \"GCGTAAAG\", ['ACGTAAGT', 'CTGTTTCA', 'CACAGATC', 'CACGTTAA', 'TATGCGAT', 'CTGTGCGG', 'TTCGGGCA', 'ACTGCCCT']) == -1\nassert solution.minMutation(\"ATCAAGGC\", \"TCTTAAGT\", ['CGGACAAA', 'ATGGCATC']) == -1\nassert solution.minMutation(\"ATGTATTC\", \"ATCACGAT\", ['AACAGCGA', 'CCCAGCGG', 'GACCCGGA']) == -1\nassert solution.minMutation(\"TTCCGGTG\", \"CCCGCAGT\", ['ACTTCGAT', 'TATTGGGT']) == -1\nassert solution.minMutation(\"CCCGCCCA\", \"TATCTTTT\", ['GAAAGTAG', 'GAAGCAGG']) == -1\nassert solution.minMutation(\"CCGTGTCT\", \"ACTAGGCG\", []) == -1\nassert solution.minMutation(\"GCTCTGAG\", \"ATCGCAGA\", ['ATAAAACA', 'GTGGCAGA', 'ATGACTCG', 'AGGGGCTA', 'GAGCCGTG', 'AGCCGGAC', 'CGGATGGC']) == -1\nassert solution.minMutation(\"ACTTAGCT\", \"TCATACCT\", ['CAGCTCAA', 'CTAGATTC']) == -1\nassert solution.minMutation(\"ATAGCCCG\", \"CTGATCTT\", ['AACAGCCC', 'GTCAGCTC', 'ATCTTATT', 'AACTTGTG', 'GGTAACCA', 'GGCATTTC', 'GCTCGGGT', 'CTATTCGT', 'TACTAAGA', 'ATCCCGAA']) == -1\nassert solution.minMutation(\"CCTGGGTA\", \"GACTGTTT\", []) == -1\nassert solution.minMutation(\"AAAACGCC\", \"GGTCCATC\", ['AAAACGTT', 'ACATGGGC', 'CACTAGCG']) == -1\nassert solution.minMutation(\"CCTGCGAT\", \"GTGCTTCT\", ['AACAGCCC']) == -1\nassert solution.minMutation(\"TGTTCAGA\", \"GCCCCCCC\", ['TGCCCGCG', 'GCGTCTTA', 'GGACGAGT', 'TCCTGGCG', 'GCTTCCAA', 'CGCTTGCG', 'TTTGCTTG', 'AAGAAACC', 'GAGGGCAG', 'CGCGCAAA']) == -1\nassert solution.minMutation(\"TCGTGCTG\", \"CTAAATTA\", []) == -1\nassert solution.minMutation(\"TCTAGTTG\", \"TCCCCGAA\", ['CCAGGCGT', 'GACTAGAC', 'ACCCTCGA', 'ACGCAGCT', 'TCGTCGCA', 'ACCTTCCT', 'GGAAGTCC', 'CGCCCTCG', 'TCCGAACA', 'ATGCCAGC']) == -1\nassert solution.minMutation(\"GCGACCAT\", \"TGGCTGGT\", ['GACTAAGT', 'GTCCTGTG', 'ATCGTATG', 'TTGCCGCC', 'CCTGCAGG', 'GAATTATG']) == -1\nassert solution.minMutation(\"CTGCAGGA\", \"CGCATGGT\", ['TCATGCGT', 'AGCGGACC', 'GATCGCCC', 'GAAAGCTA']) == -1\nassert solution.minMutation(\"CCCTATTA\", \"CCGGTGCC\", []) == -1\nassert solution.minMutation(\"AACAGTGA\", \"TGGCGTTA\", ['TGAACCAG', 'GAGGGCGA', 'GGGGTGTG', 'GCAATGGG', 'CCACATTG', 'AATCTATG', 'GCGCGGGT', 'GTCCGGAT', 'CAAGCGCG', 'GGGTGAAT']) == -1\nassert solution.minMutation(\"GTAAAGAA\", \"CAGTGCTC\", []) == -1\nassert solution.minMutation(\"GCTTGTAG\", \"GGTAAACC\", ['AGTAACGC', 'GCTGTCAT', 'CAGTTGCC', 'ATTTGGAG', 'CTCCTCCG', 'GGCCACCG', 'CTGATCCA', 'CGTGTTTG', 'ACTCGCCG']) == -1\nassert solution.minMutation(\"GTGCGAGT\", \"GTTTATTC\", ['GCGGATTT', 'CAACAAGA', 'CGTTCGCG', 'TAGATAGG', 'CGGTACAC', 'CACGATGG']) == -1\nassert solution.minMutation(\"CTCCGGCA\", \"CATTAGCA\", ['CCAAAGAC', 'TAAAGTTG', 'TGAGCATC', 'GTGCTAAG', 'GCTCAACT', 'GTCTCGCG', 'TTTGTTGG', 'CGCCTATC']) == -1\nassert solution.minMutation(\"GAAAAATA\", \"TGCCCGAT\", ['GAAGCACC', 'CAAGTTGG', 'CTCCGTTA', 'TTAGTCGG', 'AGTATTTG', 'ACTCCCTC']) == -1\nassert solution.minMutation(\"ACTGGGGT\", \"ACACAACA\", ['GCTACCTG', 'ACACCTGC', 'CGTGACCG', 'GGTCAGGA']) == -1\nassert solution.minMutation(\"CCGGCCTC\", \"ATGTCTAG\", ['AGCGAAAG', 'CGCTTCAG', 'AATGTTTA', 'TGATTGTG', 'TTGAGGAA', 'TATCCTGC', 'CTCCTCAG']) == -1\nassert solution.minMutation(\"CGGTCAGA\", \"ATGACTAG\", ['CTTCAAAC']) == -1\nassert solution.minMutation(\"GAGAAGCG\", \"TCAGGTGT\", ['ATGGTCAC', 'TCTTTGTA', 'GATAGAGT', 'TAGCGAGC', 'CTGGGTTA', 'GGAACTGG', 'CGTGCCAT', 'CGCTTAAC', 'CCGCCACC', 'AGTCAACG']) == -1\nassert solution.minMutation(\"AGACTGCA\", \"GAACTTAG\", ['GATTCACA', 'GGGTTCCT', 'GAAGACCA', 'TCTTAGTC', 'CTTCCTAT', 'CAGGGCGC', 'GTTGTACG']) == -1\nassert solution.minMutation(\"TGCATGCA\", \"CCTCCCTG\", []) == -1\nassert solution.minMutation(\"TTCCCGAT\", \"TGGCACTT\", ['ATACTATC', 'CGTCGCAT', 'GGAACACT', 'GGAACGCC', 'TCCGAAGC', 'GATTGCGT', 'AGCCGGGA', 'CAGATTAG', 'GGGCACGC', 'AAAGCCCT']) == -1\nassert solution.minMutation(\"CCCGTAAG\", \"TATTTATG\", []) == -1\nassert solution.minMutation(\"ACTTATAG\", \"ACTCGTAA\", []) == -1\nassert solution.minMutation(\"GGCGAGCG\", \"CCGAAGGC\", ['CCGATCTA', 'CTAGAAAC', 'CGTGACAA', 'GAATGGCG', 'CAGGACCT', 'TCGCTAGC', 'ACAGAAGA']) == -1\nassert solution.minMutation(\"AAGTAGTA\", \"CGCCATGG\", ['TCCCCTGT', 'ATAGATTG', 'GTGTAGAG', 'ATGCCCGT', 'TAGGTCTT', 'ATGCAGGC', 'CGTTACTT', 'CATGCAGC']) == -1\nassert solution.minMutation(\"GAGCCCCT\", \"CCGTGACG\", ['GCATGTAG']) == -1\nassert solution.minMutation(\"TCTCGGTA\", \"ATCATTTA\", ['AGAATATT', 'AGTTCCTG', 'ACACTCCA', 'CGCAGATA', 'GAAGAGGA', 'TAAACCAA', 'GGAATGCC', 'CGTTCCGA', 'TATTGGCG']) == -1\nassert solution.minMutation(\"ATTGCAGC\", \"GGTGCGTC\", ['TAGCCACA', 'AACTATGC']) == -1\nassert solution.minMutation(\"GTTTTGCC\", \"TAACGCGA\", ['AATACCCC', 'AGAAGCAC', 'TCCTATGA', 'CGCGGGCG', 'CGAAGTTG', 'CCCGAATC', 'TGACTTGT', 'CTTCAAGG', 'GTCCTATT', 'GCAACCGA']) == -1\nassert solution.minMutation(\"AGACAATG\", \"TGGACTTG\", ['TATAGAGA', 'ATGGGGTC', 'CGGGTTCG', 'ATCTGTCC', 'ACCGTCCG', 'TCTATAAC', 'ATATCTAG']) == -1\nassert solution.minMutation(\"AACTGCAA\", \"ACCTTGCG\", []) == -1\nassert solution.minMutation(\"CGCGAACA\", \"ACCGGGTA\", ['TGAGAATT', 'ACAACTGT', 'CCGCGAGT', 'ACCTCCGA', 'CAACAGGG', 'TTGGATCC', 'GCCAGTAC', 'GCACACCT']) == -1\nassert solution.minMutation(\"AATAAGGG\", \"GCTCCCGA\", ['ACTACAGT', 'CCCCTCGA', 'TATATTCT', 'GTGGTAAT', 'TTTGCAGA']) == -1\nassert solution.minMutation(\"CGATCCGG\", \"CCTCTTAT\", ['CAAGAACT', 'CAAACTGC', 'GGTACTCG', 'TCAACATT', 'ATTCCACA', 'TAGAGGCC', 'AGGTTTCT', 'CATTGGAT', 'CTTTCAAG', 'GGCAGAAA']) == -1\nassert solution.minMutation(\"TTCGTTGG\", \"TTGTAGTC\", ['GTCTAAGA', 'GCCCATAA', 'TAACAATT', 'CTTGGTCC', 'CGCATAGC', 'GGGGCCGT', 'ATACGAAG', 'TATCACTT', 'GCGTGTCG']) == -1\nassert solution.minMutation(\"CTTCGTAG\", \"ACACTCGA\", ['ACTTGGCG', 'GAAACATA', 'GCCGAATC', 'CGGCGCAC', 'ACCAATGA', 'GGGCACAA', 'TCAGAGCT', 'CATTAGCT', 'GTGCGCCA']) == -1\nassert solution.minMutation(\"ATCCATCG\", \"GCAGCGTA\", ['AAACAGCA', 'ATTTATCA']) == -1\nassert solution.minMutation(\"GGTGGCCG\", \"TGCCTTAA\", ['CGTAGGCT', 'ACTGTACC', 'GGCGACCT', 'CAGTCTGA', 'GCAGCACG', 'GCTACGGT', 'CTGAGACG']) == -1\nassert solution.minMutation(\"GCCTATAA\", \"CTTCATTT\", ['AGTGCTTT', 'ACCTTCCC', 'GGCTGAAA', 'GAGTATAT', 'TAGCGCAG', 'CCGATAGA', 'CCGCGAAT', 'GACTATTG', 'AACACACG']) == -1\nassert solution.minMutation(\"GTATGAAG\", \"CGTGGCTA\", ['AGTAACGT', 'TAGGGAGC', 'GGCCACCG', 'CATCTATC', 'TGAAGAAA', 'ACAGAAAG', 'GCTTTAGT', 'TAAAAGCG', 'CGAGCAAT', 'AAAGAGCC']) == -1\nassert solution.minMutation(\"CCACTGCG\", \"AACTCCGG\", ['TGCAGAGG', 'AACCTATG', 'ATAGGCGC', 'AAAAAAAG', 'CAGATGAT', 'AGTACGCA']) == -1\nassert solution.minMutation(\"AGTCTCTA\", \"GTATTCAG\", ['TAGAGGAT', 'TGATGGTC', 'GAGGGTTT', 'TAGACATC', 'TGGCCATC', 'ACACTGTA', 'GCCAGAAC', 'CGGTATAG', 'TTACGTAA']) == -1\nassert solution.minMutation(\"ACTTCTAA\", \"CACCTCAT\", ['TACGAAAG', 'TGAGAGCC', 'CTGAAAAT', 'CGTCAGCC']) == -1\nassert solution.minMutation(\"AACGCGAA\", \"CAAGTGAC\", ['CGGTCTTA', 'AGCGGCAG', 'ATTTGGCT', 'CATCCACA', 'GTTTCACG']) == -1\nassert solution.minMutation(\"AGTGCGAC\", \"TCCCAGCA\", ['GGACTTAT', 'GTCTGTTC', 'ACGTATGC', 'GCCCCGTC', 'ATGAGACA', 'GCAAATTA', 'AGTCGGTT', 'AGAACCTC', 'ATGTCAGA', 'ACTCAATC']) == -1\nassert solution.minMutation(\"TTTGGTGT\", \"TCTGCTAT\", ['CAGTGCGG', 'TGGGTAGT', 'CTAGAGCG', 'ACGCGGAG', 'CCTAAGAT', 'GTGGCCCA']) == -1\nassert solution.minMutation(\"TACGTAAT\", \"ATGGATAC\", ['GTGCCCTT', 'CTTTTGGT', 'TGAGCTAC', 'TCCAAGGT', 'TACGCGAT', 'CTCACTAT', 'AATCGTCC', 'TCATACTC']) == -1\nassert solution.minMutation(\"TGTTCGAA\", \"CTATTCAG\", ['GTACGCCC', 'TAGTAATT']) == -1\nassert solution.minMutation(\"ATGTGAGA\", \"GAATCTTT\", ['CGTCGAGT', 'TTGGGTTG', 'CTGCGTCG', 'CCCCGCGG', 'GAAACTAA', 'GACACATT', 'TGGGATAT', 'ACGAAGTC']) == -1\nassert solution.minMutation(\"GGGAGACC\", \"CGGTCACG\", ['GTATTGCG', 'ATTTTTTT', 'ACCACTCG', 'CTACCGCG', 'TCAACTCC']) == -1\nassert solution.minMutation(\"ATCTCCTC\", \"GCAGGAAA\", ['TATAGCTA', 'GGCGGAAT', 'ACGCACTG', 'AGCTCGAA', 'GGCGTCCA', 'GGTTCACC', 'ATACCGTG', 'GGTCAGTG']) == -1\nassert solution.minMutation(\"GAGTCGCG\", \"CCAGGTGA\", ['ATTGACAT', 'GAGTAGAC', 'CCAATTGT', 'GTACGGAT', 'GTGACGGT', 'GATAATGC', 'GAATCGCA', 'ACTGTGTA', 'GCCAGAAG']) == -1\nassert solution.minMutation(\"AGTTCTGA\", \"CAGTCAGT\", ['GACGAAGT', 'CTCGATTC', 'AGCAGTAC', 'ATGTCAGG', 'GTGTAATG', 'AAGTAAGC', 'TCCTCGTG', 'ATCCAGTC']) == -1\nassert solution.minMutation(\"TTGTCCAC\", \"TCAAACGA\", ['AGACGTCG', 'GTCCTACG', 'GCCCCTTA', 'ACCTTCCT', 'ATAATGTT', 'CGGCTTGC']) == -1\nassert solution.minMutation(\"AGGAAGCC\", \"AACTATAG\", ['GTCAGTCT', 'GTACGTCT', 'AATGAACT', 'AGATTCAT', 'ACCTGAGC']) == -1\nassert solution.minMutation(\"AACGCAGC\", \"TGCAAAAA\", ['CGCACCAA', 'ATGGAAAT', 'TCTTCATG', 'ACCTATTG', 'TACTTGCT', 'TCGATCGA', 'AGTAGCCC']) == -1\nassert solution.minMutation(\"CTGGGGCC\", \"GAAATTGG\", ['TCGGCCAT']) == -1\nassert solution.minMutation(\"GGACTTAA\", \"TGGAGGTT\", ['GACCGATA', 'GAAGAAAC', 'TCGGGACT', 'GTCGGGAA', 'GACTGTGG', 'TATCGCTA', 'TTAGGGGG', 'CTTCAGTA', 'CCTGATAA', 'GCAGCCTC']) == -1\nassert solution.minMutation(\"GATTGCAT\", \"ACGGACTC\", ['TATCATCA', 'TGCAGTGA', 'CGGACTTT']) == -1\nassert solution.minMutation(\"CAGGGTGG\", \"CGCACAGC\", ['GTTGTGCG', 'GCACCAAG', 'AAGTCCCA', 'CTAAAGTT', 'ACGAGTCG', 'CGGCGCTT', 'TTTGGGAA', 'TTACAGGC', 'ACTCAGCC', 'GTTGGGCA']) == -1\nassert solution.minMutation(\"GGGAGCCG\", \"AGTGGAAC\", ['CTTTCGCC', 'GGGACATA', 'CGATAGCC', 'TTGAGGCA', 'TGAGTTTG', 'GCCAGTAC', 'CACAAGTT', 'ATTGATAT', 'TACACTTC']) == -1\nassert solution.minMutation(\"TCCACGCG\", \"GTAAAATA\", ['GAACACTT', 'GGGCCGAC', 'TGAGTCAA', 'GGATACTA', 'TGGGACTT']) == -1\nassert solution.minMutation(\"GCACGAAG\", \"GTCCTGGT\", ['TTAATTCC', 'CATTACCT', 'AGCCTGCT', 'CGTGAGAC']) == -1\nassert solution.minMutation(\"TCCGCTCA\", \"AGGACGTT\", ['TCGGATGA']) == -1\nassert solution.minMutation(\"AGCGGATT\", \"AAGCGTAA\", ['ACATCGTT']) == -1\nassert solution.minMutation(\"CGCAGGTC\", \"TAGAAAAT\", ['AAATTGGT', 'AGGGGTCT', 'TGACCAGA', 'TTCGGCTT', 'AAGGGTTC', 'CCCAGCAT', 'TAGGCGGG', 'CTGGTACT', 'GCAATCAT']) == -1\nassert solution.minMutation(\"GAAACTCA\", \"TGCGGATA\", ['TGCCATCG', 'CTTATACG', 'GACGGGAA', 'ATCCGAAA', 'AACAGTTT', 'TTCCCCAA']) == -1\nassert solution.minMutation(\"CGCCGATA\", \"ACGATAAA\", ['AGCAAACA', 'TCGCAACC', 'GCTTGAGA', 'CAAGGCCT', 'AGCCGATG']) == -1\nassert solution.minMutation(\"TTAATAAC\", \"GTGGAGGG\", ['ACGTATCG', 'CTTATGTT']) == -1\nassert solution.minMutation(\"GCGTTTGC\", \"TGGGAGGA\", ['ACATGAGA', 'CCATCGTC', 'AGCGGATT', 'AAAAGACG', 'CATTTTGC', 'ACACCTAA', 'TAGCAAGA', 'AACTTTTT']) == -1\nassert solution.minMutation(\"GCATCAGT\", \"GCAGACCT\", ['GAGCTATA', 'CCACTCTT', 'CAAAGGAT', 'TCGCCCCT']) == -1\nassert solution.minMutation(\"CTGATCTC\", \"GATTTGGC\", ['TGTGATAT', 'AGCCCTTG', 'ACCACGGA', 'CAGGCGTA', 'ACATATCT', 'TGGGGGAG', 'TCGGTAAA', 'AGCCACGA', 'GAATCTCA']) == -1\nassert solution.minMutation(\"GCCTGTGT\", \"AGGGCATC\", ['TAAAGCCA', 'TTTCTGGC', 'AGAGGTAA', 'GCCTACCG', 'TAAGCGGT', 'AATCGGCC']) == -1\nassert solution.minMutation(\"AGGGCGTG\", \"ACGCACTT\", ['GTGCATTC', 'ACCATCAC']) == -1\nassert solution.minMutation(\"GTGACTTA\", \"ATTATCGT\", ['AGCCACGA', 'CAGCAAGC', 'TATAGGCC', 'ATCGCCTA', 'CGCTCCCA', 'ACATAAGT', 'TGAGACTC', 'TCCATGTG', 'GCGGAGCT', 'GTTGAAAA']) == -1\nassert solution.minMutation(\"TACGAGGG\", \"GCGGGCTT\", ['TTCACGGA', 'CTTTCGTT', 'TCGAACCA', 'CTAAAGAT', 'GCGACGTC']) == -1\nassert solution.minMutation(\"TGCATCAG\", \"CCCAGCTT\", ['CGTGCTCA', 'CTTGTGGC', 'TTAGATTT']) == -1\nassert solution.minMutation(\"ACCTTGTA\", \"AGGTGGCC\", ['CCCAGGGT', 'GATACATC', 'GTACTTTT', 'GGTGATCC', 'CGGCTTTG']) == -1\nassert solution.minMutation(\"TGTGTTGC\", \"CTCAGGCC\", ['CCAATAAG', 'GTCGCGAC', 'AAGTGCTC', 'GGACAGGC', 'GCTCTCTG']) == -1\nassert solution.minMutation(\"AGGTGAAA\", \"CCTCCCTC\", ['GCAGCCTA', 'GAAGATCT']) == -1\nassert solution.minMutation(\"TTCATGCC\", \"GGGCTCTT\", ['CACAGTTC', 'GACGCCAT', 'CTTACGAG', 'CGACATAC', 'GCTACAAC', 'CGTACAAG', 'TGACCCGG', 'GGCGTGCG', 'GGTATCGC']) == -1\nassert solution.minMutation(\"CCGGGGTC\", \"ACCTCAAT\", ['CGGCCGTC', 'TAGGGGAC', 'CCGACTGA', 'CAAGTAAG', 'TGATCTCC', 'AGGTATCG', 'GGGTTACA']) == -1\nassert solution.minMutation(\"GTCAGTGA\", \"TTTCATGG\", ['GGGTGCAA', 'TATGTCGC', 'ACTCTGAT', 'CAGAATTC', 'TCTGTCAG', 'AATGGCAC', 'GTCCTCGA', 'AAGCGAGC']) == -1\nassert solution.minMutation(\"AAACTGTG\", \"CACCTTTT\", ['ATCTCGAA', 'TTCACTCC', 'TCGTAGGA']) == -1\nassert solution.minMutation(\"CCGTGACG\", \"TCCAGTGT\", []) == -1\nassert solution.minMutation(\"CAGAGGAA\", \"TTTTTCGA\", ['AATGCGCC', 'TTTTGGTC', 'CCACTTAT', 'TCACACGG', 'TTTTGCTA', 'TCTTCGTA', 'AAGACAAG', 'ATGATCTC', 'TGGTGATT']) == -1\nassert solution.minMutation(\"AGGACTAA\", \"GTCCTACA\", ['CAAAAGTA', 'CACACGAC']) == -1\nassert solution.minMutation(\"AATGCTAT\", \"GGTAGATT\", ['GATAATTC', 'TCTCGAGC', 'CCTCCAGG', 'GCTACGTG', 'GGACGTTT', 'TTACGATG', 'TACAAACT', 'CCGCGTAG', 'TTGCGCAA', 'GCACGTGT']) == -1",
  "inefficient_solution": "class Solution:\n    def minMutation(self, start: str, end: str, bank: List[str]) -> int:\n        s = set(bank)\n        q = []\n        for _ in range(10000):\n            for _ in range(10000):\n                t = start\n                for i in range(len(t)):\n                    for v in 'ATCG':\n                        t = t[:i] + v + t[i + 1:]\n                        if t in s:\n                            q.append((t, 0))\n                            s.remove(t)\n            if q:\n                t, step = q.pop()\n                if t == end:\n                    return step\n                for i in range(len(t)):\n                    for v in 'ATCG':\n                        next = t[:i] + v + t[i + 1:]\n                        if next in s:\n                            q.append((next, step + 1))\n                            s.remove(next)\n        return -1",
  "is_python": true
}