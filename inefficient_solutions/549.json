{
  "problem_idx": 549,
  "task_name": "Binary Tree Longest Consecutive Sequence II",
  "markdown_description": "\nGiven the `root` of a binary tree, return *the length of the longest consecutive path in the tree*.\n\n\nA consecutive path is a path where the values of the consecutive nodes in the path differ by one. This path can be either increasing or decreasing.\n\n\n* For example, `[1,2,3,4]` and `[4,3,2,1]` are both considered valid, but the path `[1,2,4,3]` is not valid.\n\n\nOn the other hand, the path can be in the child-Parent-child order, where not necessarily be parent-child order.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0500-0599/0549.Binary%20Tree%20Longest%20Consecutive%20Sequence%20II/images/consec2-1-tree.jpg)\n\n```\n\n**Input:** root = [1,2,3]\n**Output:** 2\n**Explanation:** The longest consecutive path is [1, 2] or [2, 1].\n\n```\n\n**Example 2:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0500-0599/0549.Binary%20Tree%20Longest%20Consecutive%20Sequence%20II/images/consec2-2-tree.jpg)\n\n```\n\n**Input:** root = [2,1,3]\n**Output:** 3\n**Explanation:** The longest consecutive path is [1, 2, 3] or [3, 2, 1].\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* The number of nodes in the tree is in the range `[1, 3 * 104]`.\n* `-3 * 104 <= Node.val <= 3 * 104`\n\n\n",
  "canonical_solution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestConsecutive(self, root: TreeNode) -> int:\n        def dfs(root):\n            if root is None:\n                return [0, 0]\n            nonlocal ans\n            incr = decr = 1\n            i1, d1 = dfs(root.left)\n            i2, d2 = dfs(root.right)\n            if root.left:\n                if root.left.val + 1 == root.val:\n                    incr = i1 + 1\n                if root.left.val - 1 == root.val:\n                    decr = d1 + 1\n            if root.right:\n                if root.right.val + 1 == root.val:\n                    incr = max(incr, i2 + 1)\n                if root.right.val - 1 == root.val:\n                    decr = max(decr, d2 + 1)\n            ans = max(ans, incr + decr - 1)\n            return [incr, decr]\n\n        ans = 0\n        dfs(root)\n        return ans\n",
  "test_case_generator": "\nimport random\n\n# Generate random binary tree\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef generate_binary_tree(nodes):\n    if nodes == 0:\n        return None\n    \n    root_val = random.randint(-30000, 30000)\n    root = TreeNode(root_val)\n    \n    if nodes == 1:\n        return root\n    \n    left_nodes = random.randint(0, nodes-1)\n    right_nodes = nodes - 1 - left_nodes\n    \n    root.left = generate_binary_tree(left_nodes)\n    root.right = generate_binary_tree(right_nodes)\n    \n    return root\n\nclass Solution:\n    def longestConsecutive(self, root: TreeNode) -> int:\n        def dfs(root):\n            if root is None:\n                return [0, 0]\n            nonlocal ans\n            incr = decr = 1\n            i1, d1 = dfs(root.left)\n            i2, d2 = dfs(root.right)\n            if root.left:\n                if root.left.val + 1 == root.val:\n                    incr = i1 + 1\n                if root.left.val - 1 == root.val:\n                    decr = d1 + 1\n            if root.right:\n                if root.right.val + 1 == root.val:\n                    incr = max(incr, i2 + 1)\n                if root.right.val - 1 == root.val:\n                    decr = max(decr, d2 + 1)\n            ans = max(ans, incr + decr - 1)\n            return [incr, decr]\n\n        ans = 0\n        dfs(root)\n        return ans\n\ndef generate_test_case():\n    solution = Solution()\n    \n    # Generate random binary tree\n    root = generate_binary_tree(random.randint(1, 10))\n    \n    # Calculate the expected result using the provided Solution class\n    expected_result = solution.longestConsecutive(root)\n\n    return root, expected_result\n\ndef test_generated_test_cases(num_tests):\n    test_case_generator_results = []\n    for i in range(num_tests):\n        root, expected_result = generate_test_case()\n        solution = Solution()\n        assert solution.longestConsecutive(root) == expected_result\n        print(f\"assert solution.longestConsecutive({root}) == {expected_result}\")\n        test_case_generator_results.append(f\"assert solution.longestConsecutive({root}) == {expected_result}\") # You can find that we construct the test case in the same format as the example\n    return test_case_generator_results\n\nif __name__ == \"__main__\":\n    num_tests = 100  # You can change this to generate more test cases\n    test_case_generator_results = test_generated_test_cases(num_tests)\n",
  "test_case": "assert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a076a10>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09d010>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a076650>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09d010>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a076610>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09d190>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09cf90>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09d050>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09cf90>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a076a10>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09cf90>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd89fddbd0>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09cf50>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a076a10>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09cf50>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09cf90>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09d450>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09cf50>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09cf10>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09d310>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09d050>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09cfd0>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09d250>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09d590>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09d6d0>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09d410>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09d690>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09d650>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09d710>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09d890>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09d7d0>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09d950>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09da50>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09d010>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09d810>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09dad0>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09dc10>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09d790>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09d910>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09d8d0>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09ddd0>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09d9d0>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09dd10>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09e0d0>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09de50>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09ded0>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09d990>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09df10>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09dd50>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09df90>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09e190>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09e410>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09e350>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09e490>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09e390>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09e4d0>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09e650>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09e750>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09e310>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09e6d0>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09e710>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09e8d0>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09e590>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09dfd0>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09e1d0>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09e850>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09ead0>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09ec10>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09eb10>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09e890>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09e210>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09ea10>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09ed90>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09ed50>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09ee90>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09ef50>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09ea90>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09efd0>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09e810>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09f010>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09f210>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09f290>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09f190>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09f110>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09f050>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09f090>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09f6d0>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09f390>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09f550>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09f610>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09f490>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09f790>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09f690>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09f410>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09f750>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09f8d0>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09f590>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09f850>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09fad0>) == 1\nassert solution.longestConsecutive(<__main__.TreeNode object at 0x7fbd8a09f350>) == 1",
  "inefficient_solution": "class Solution:\n    def longestConsecutive(self, root: TreeNode) -> int:\n        def dfs(root):\n            if root is None:\n                return [0] * 1000\n            ans = [0] * 1000\n            incr = decr = 1\n            i1 = dfs(root.left)\n            i2 = dfs(root.right)\n            if root.left:\n                for j in range(root.left.val - root.val, 0, -1):\n                    if i1[j] == 0:\n                        break\n                    if root.left.val + j == root.val:\n                        incr = max(incr, i1[j] + 1)\n                    if root.left.val - j == root.val:\n                        decr = max(decr, i1[j + 1] + 1)\n            if root.right:\n                for j in range(root.right.val - root.val, 0, -1):\n                    if i2[j] == 0:\n                        break\n                    if root.right.val + j == root.val:\n                        incr = max(incr, i2[j] + 1)\n                    if root.right.val - j == root.val:\n                        decr = max(decr, i2[j + 1] + 1)\n            ans[incr] = 1\n            ans[decr] = 1\n            ans[incr + decr - 1] = 1\n            return ans\n\n        ans = [0] * 1000\n        dfs(root)\n        max_val = max(ans)\n        for i in range(len(ans)):\n            if ans[i] == max_val:\n                return i",
  "is_python": true
}