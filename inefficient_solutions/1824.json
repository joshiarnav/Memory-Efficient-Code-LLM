{
  "problem_idx": 1824,
  "task_name": "Minimum Sideway Jumps",
  "markdown_description": "\nThere is a **3 lane road** of length `n` that consists of `n + 1` **points** labeled from `0` to `n`. A frog **starts** at point `0` in the **second** laneand wants to jump to point `n`. However, there could be obstacles along the way.\n\n\nYou are given an array `obstacles` of length `n + 1` where each `obstacles[i]` (**ranging from 0 to 3**) describes an obstacle on the lane `obstacles[i]` at point `i`. If `obstacles[i] == 0`, there are no obstacles at point `i`. There will be **at most one** obstacle in the 3 lanes at each point.\n\n\n* For example, if `obstacles[2] == 1`, then there is an obstacle on lane 1 at point 2.\n\n\nThe frog can only travel from point `i` to point `i + 1` on the same lane if there is not an obstacle on the lane at point `i + 1`. To avoid obstacles, the frog can also perform a **side jump** to jump to **another** lane (even if they are not adjacent) at the **same** point if there is no obstacle on the new lane.\n\n\n* For example, the frog can jump from lane 3 at point 3 to lane 1 at point 3.\n\n\nReturn *the **minimum number of side jumps** the frog needs to reach **any lane** at point n starting from lane `2` at point 0.*\n\n\n**Note:** There will be no obstacles on points `0` and `n`.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1800-1899/1824.Minimum%20Sideway%20Jumps/images/ic234-q3-ex1.png)\n\n```\n\n**Input:** obstacles = [0,1,2,3,0]\n**Output:** 2 \n**Explanation:** The optimal solution is shown by the arrows above. There are 2 side jumps (red arrows).\nNote that the frog can jump over obstacles only when making side jumps (as shown at point 2).\n\n```\n\n**Example 2:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1800-1899/1824.Minimum%20Sideway%20Jumps/images/ic234-q3-ex2.png)\n\n```\n\n**Input:** obstacles = [0,1,1,3,3,0]\n**Output:** 0\n**Explanation:** There are no obstacles on lane 2. No side jumps are required.\n\n```\n\n**Example 3:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1800-1899/1824.Minimum%20Sideway%20Jumps/images/ic234-q3-ex3.png)\n\n```\n\n**Input:** obstacles = [0,2,1,0,3,0]\n**Output:** 2\n**Explanation:** The optimal solution is shown by the arrows above. There are 2 side jumps.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `obstacles.length == n + 1`\n* `1 <= n <= 5 * 105`\n* `0 <= obstacles[i] <= 3`\n* `obstacles[0] == obstacles[n] == 0`\n\n\n",
  "canonical_solution": "class Solution:\n    def minSideJumps(self, obstacles: List[int]) -> int:\n        f = [1, 0, 1]\n        for v in obstacles[1:]:\n            for j in range(3):\n                if v == j + 1:\n                    f[j] = inf\n                    break\n            x = min(f) + 1\n            for j in range(3):\n                if v != j + 1:\n                    f[j] = min(f[j], x)\n        return min(f)\n",
  "test_case_generator": "\nimport random\n\nclass Solution:\n    def minSideJumps(self, obstacles):\n        f = [1, 0, 1]\n        for v in obstacles[1:]:\n            for j in range(3):\n                if v == j + 1:\n                    f[j] = inf\n                    break\n            x = min(f) + 1\n            for j in range(3):\n                if v != j + 1:\n                    f[j] = min(f[j], x)\n        return min(f)\n\ndef generate_test_case():\n    solution = Solution()\n\n    # Generate random obstacles list\n    obstacles = random.choices([0, 1, 2, 3], k=random.randint(2, 10))\n\n    # Calculate the expected result using the provided Solution class\n    expected_result = solution.minSideJumps(obstacles)\n\n    return obstacles, expected_result\n\ndef test_generated_test_cases(num_tests):\n    test_case_generator_results = []\n    for i in range(num_tests):\n        obstacles, expected_result = generate_test_case()\n        solution = Solution()\n        assert solution.minSideJumps(obstacles) == expected_result\n        print(f\"assert solution.minSideJumps({obstacles}) == {expected_result}\")\n        test_case_generator_results.append(f\"assert solution.minSideJumps({obstacles}) == {expected_result}\") # You can find that we construct the test case in the same format as the example\n    return test_case_generator_results\n\nif __name__ == \"__main__\":\n    num_tests = 100  # You can change this to generate more test cases\n    test_case_generator_results = test_generated_test_cases(num_tests)\n",
  "test_case": "assert solution.minSideJumps([2, 2, 3, 1, 3, 0, 0]) == 2\nassert solution.minSideJumps([1, 2, 1, 0, 3, 0, 1, 2, 1, 0]) == 3\nassert solution.minSideJumps([0, 1, 1, 3, 0, 2, 2]) == 1\nassert solution.minSideJumps([2, 2, 0]) == 1\nassert solution.minSideJumps([0, 1, 3, 3, 3, 1]) == 0\nassert solution.minSideJumps([1, 3, 1, 0]) == 0\nassert solution.minSideJumps([0, 0]) == 0\nassert solution.minSideJumps([2, 0, 3, 3, 2, 1]) == 2\nassert solution.minSideJumps([1, 0, 1, 1, 3]) == 0\nassert solution.minSideJumps([2, 1, 2, 3, 1, 1, 3, 2, 3]) == 4\nassert solution.minSideJumps([1, 0, 0, 1, 0, 1, 1, 2, 1, 2]) == 1\nassert solution.minSideJumps([1, 3, 1, 0, 2, 2, 2, 3, 3, 3]) == 1\nassert solution.minSideJumps([3, 3, 3, 2, 1, 1]) == 2\nassert solution.minSideJumps([2, 0, 0, 0, 2, 3, 3, 0, 0, 3]) == 1\nassert solution.minSideJumps([2, 0, 1, 0, 3, 1]) == 0\nassert solution.minSideJumps([3, 0, 0, 3, 1, 2, 1, 0, 2, 0]) == 1\nassert solution.minSideJumps([3, 0, 0, 1, 1, 3, 1]) == 0\nassert solution.minSideJumps([0, 0, 1, 1]) == 0\nassert solution.minSideJumps([1, 2, 2, 0, 1, 0]) == 1\nassert solution.minSideJumps([3, 1, 1, 2, 1, 0, 0, 0, 3]) == 2\nassert solution.minSideJumps([2, 0, 1, 2, 1, 0, 1, 2, 1, 1]) == 1\nassert solution.minSideJumps([0, 1, 2, 2, 0, 0, 1, 3, 2]) == 3\nassert solution.minSideJumps([0, 1, 0, 1, 0, 1]) == 0\nassert solution.minSideJumps([1, 3, 1, 3, 2, 1]) == 2\nassert solution.minSideJumps([2, 1, 3, 1, 3]) == 0\nassert solution.minSideJumps([0, 0, 1, 0, 0, 3, 2, 3, 2, 2]) == 1\nassert solution.minSideJumps([1, 1, 0, 2, 0, 1]) == 1\nassert solution.minSideJumps([1, 3, 3, 0, 2, 1, 0, 2]) == 1\nassert solution.minSideJumps([0, 1, 2, 3, 3, 2, 1]) == 3\nassert solution.minSideJumps([1, 1]) == 0\nassert solution.minSideJumps([0, 0, 2, 0, 2, 3, 3]) == 1\nassert solution.minSideJumps([3, 2, 3, 1, 1, 3, 1]) == 2\nassert solution.minSideJumps([1, 3]) == 0\nassert solution.minSideJumps([3, 3]) == 0\nassert solution.minSideJumps([1, 0, 1, 0, 2, 3, 2, 2]) == 1\nassert solution.minSideJumps([1, 1, 3, 2, 0, 0, 3, 1, 3, 3]) == 2\nassert solution.minSideJumps([1, 3, 1, 1, 3, 1, 2, 3, 3, 1]) == 3\nassert solution.minSideJumps([1, 3]) == 0\nassert solution.minSideJumps([3, 1, 3, 2, 0, 2, 3, 3, 2]) == 1\nassert solution.minSideJumps([2, 2, 3, 2]) == 1\nassert solution.minSideJumps([2, 3]) == 0\nassert solution.minSideJumps([2, 2, 2, 1, 3, 0, 3, 0]) == 2\nassert solution.minSideJumps([0, 1, 0, 3, 3, 0, 1, 1]) == 0\nassert solution.minSideJumps([1, 0, 2, 1]) == 1\nassert solution.minSideJumps([3, 0, 3, 0, 0, 1, 1]) == 0\nassert solution.minSideJumps([3, 0, 2, 2, 3, 3, 3, 0, 1]) == 2\nassert solution.minSideJumps([0, 2, 1]) == 1\nassert solution.minSideJumps([2, 3, 3, 2, 3, 2, 2, 3]) == 1\nassert solution.minSideJumps([2, 0, 2]) == 1\nassert solution.minSideJumps([1, 0, 3, 0, 0, 1, 1, 3]) == 0\nassert solution.minSideJumps([2, 0, 1]) == 0\nassert solution.minSideJumps([3, 0, 2, 0, 2, 0]) == 1\nassert solution.minSideJumps([2, 3, 1, 3, 1, 2, 3, 0]) == 2\nassert solution.minSideJumps([2, 1, 1, 3]) == 0\nassert solution.minSideJumps([2, 1, 1, 3]) == 0\nassert solution.minSideJumps([2, 0, 3, 3, 3, 2]) == 1\nassert solution.minSideJumps([0, 1, 1, 2, 2, 0, 1]) == 1\nassert solution.minSideJumps([1, 2, 3, 0, 1, 0, 0, 1, 1, 0]) == 2\nassert solution.minSideJumps([1, 1, 0, 0, 2, 3, 1, 3, 0]) == 2\nassert solution.minSideJumps([1, 0, 1, 2, 1, 1, 3, 1, 2]) == 3\nassert solution.minSideJumps([0, 1, 1, 1, 1, 3, 3, 0, 1, 2]) == 1\nassert solution.minSideJumps([2, 3, 1, 0, 2, 2, 1, 1]) == 1\nassert solution.minSideJumps([3, 1]) == 0\nassert solution.minSideJumps([0, 2, 2, 3, 2, 1, 0, 0, 2, 1]) == 2\nassert solution.minSideJumps([0, 2, 0, 0, 2, 3, 3]) == 1\nassert solution.minSideJumps([2, 1, 0, 1, 2, 3]) == 2\nassert solution.minSideJumps([0, 3, 2, 1, 1]) == 2\nassert solution.minSideJumps([3, 3, 0, 3, 2, 2, 0, 2, 3, 1]) == 2\nassert solution.minSideJumps([2, 2, 3, 3, 3, 2]) == 1\nassert solution.minSideJumps([0, 1]) == 0\nassert solution.minSideJumps([1, 2, 2, 3, 0]) == 1\nassert solution.minSideJumps([1, 3, 2, 2]) == 1\nassert solution.minSideJumps([1, 3, 0, 1, 3, 0, 2, 2, 1, 3]) == 2\nassert solution.minSideJumps([1, 0, 0, 3, 1]) == 0\nassert solution.minSideJumps([0, 0, 1]) == 0\nassert solution.minSideJumps([1, 1]) == 0\nassert solution.minSideJumps([2, 2, 2]) == 1\nassert solution.minSideJumps([2, 0, 3, 2, 1, 2, 1, 1]) == 2\nassert solution.minSideJumps([3, 0, 0]) == 0\nassert solution.minSideJumps([2, 3, 0, 3, 3, 3]) == 0\nassert solution.minSideJumps([1, 1]) == 0\nassert solution.minSideJumps([3, 3, 3, 1, 1, 0]) == 0\nassert solution.minSideJumps([3, 3, 2]) == 1\nassert solution.minSideJumps([3, 2, 1, 0, 0, 3, 2, 3, 0]) == 2\nassert solution.minSideJumps([0, 0, 3]) == 0\nassert solution.minSideJumps([2, 1, 3, 1, 0, 3]) == 0\nassert solution.minSideJumps([3, 2, 0, 2, 1, 0]) == 1\nassert solution.minSideJumps([1, 2, 0, 1, 3]) == 2\nassert solution.minSideJumps([3, 3]) == 0\nassert solution.minSideJumps([3, 1, 1, 1, 1, 1, 3, 2, 1, 1]) == 2\nassert solution.minSideJumps([1, 3, 2]) == 1\nassert solution.minSideJumps([2, 1, 0, 2, 1]) == 1\nassert solution.minSideJumps([0, 2, 0, 1, 0, 1]) == 1\nassert solution.minSideJumps([3, 2, 2]) == 1\nassert solution.minSideJumps([3, 1]) == 0\nassert solution.minSideJumps([0, 1, 2]) == 1\nassert solution.minSideJumps([1, 2, 3, 2, 3, 0, 0, 0]) == 1\nassert solution.minSideJumps([0, 2, 1, 3, 2, 0, 0]) == 3\nassert solution.minSideJumps([1, 3, 3, 0, 0, 3, 3, 1, 3]) == 0\nassert solution.minSideJumps([1, 2, 0, 0, 2, 2, 1, 3, 0]) == 2",
  "inefficient_solution": "class Solution:\n    def minSideJumps(self, obstacles: List[int]) -> int:\n        n = len(obstacles)\n        dp = [[float('inf')] * 4 for _ in range(n + 1)]\n        dp[0][2] = 0\n        for i in range(n):\n            for j in range(4):\n                dp[i + 1][j] = min(dp[i + 1])\n                if obstacles[i] == j + 1:\n                    dp[i + 1][j] = float('inf')\n                elif j not in (obstacles[i], obstacles[i] - 1, obstacles[i] + 1):\n                    dp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + 1)\n        return min(dp[n])",
  "is_python": true
}