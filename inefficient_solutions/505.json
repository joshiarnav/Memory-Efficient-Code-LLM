{
  "problem_idx": 505,
  "task_name": "The Maze II",
  "markdown_description": "\nThere is a ball in a `maze` with empty spaces (represented as `0`) and walls (represented as `1`). The ball can go through the empty spaces by rolling **up, down, left or right**, but it won't stop rolling until hitting a wall. When the ball stops, it could choose the next direction.\n\n\nGiven the `m x n` `maze`, the ball's `start` position and the `destination`, where `start = [startrow, startcol]` and `destination = [destinationrow, destinationcol]`, return *the shortest **distance** for the ball to stop at the destination*. If the ball cannot stop at `destination`, return `-1`.\n\n\nThe **distance** is the number of **empty spaces** traveled by the ball from the start position (excluded) to the destination (included).\n\n\nYou may assume that **the borders of the maze are all walls** (see examples).\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0500-0599/0505.The%20Maze%20II/images/maze1-1-grid.jpg)\n\n```\n\n**Input:** maze = [[0,0,1,0,0],[0,0,0,0,0],[0,0,0,1,0],[1,1,0,1,1],[0,0,0,0,0]], start = [0,4], destination = [4,4]\n**Output:** 12\n**Explanation:** One possible way is : left -> down -> left -> down -> right -> down -> right.\nThe length of the path is 1 + 1 + 3 + 1 + 2 + 2 + 2 = 12.\n\n```\n\n**Example 2:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0500-0599/0505.The%20Maze%20II/images/maze1-2-grid.jpg)\n\n```\n\n**Input:** maze = [[0,0,1,0,0],[0,0,0,0,0],[0,0,0,1,0],[1,1,0,1,1],[0,0,0,0,0]], start = [0,4], destination = [3,2]\n**Output:** -1\n**Explanation:** There is no way for the ball to stop at the destination. Notice that you can pass through the destination but you cannot stop there.\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** maze = [[0,0,0,0,0],[1,1,0,0,1],[0,0,0,0,0],[0,1,0,0,1],[0,1,0,0,0]], start = [4,3], destination = [0,1]\n**Output:** -1\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `m == maze.length`\n* `n == maze[i].length`\n* `1 <= m, n <= 100`\n* `maze[i][j]` is `0` or `1`.\n* `start.length == 2`\n* `destination.length == 2`\n* `0 <= startrow, destinationrow < m`\n* `0 <= startcol, destinationcol < n`\n* Both the ball and the destination exist in an empty space, and they will not be in the same position initially.\n* The maze contains **at least 2 empty spaces**.\n\n\n",
  "canonical_solution": "class Solution:\n    def shortestDistance(\n        self, maze: List[List[int]], start: List[int], destination: List[int]\n    ) -> int:\n        m, n = len(maze), len(maze[0])\n        dirs = (-1, 0, 1, 0, -1)\n        si, sj = start\n        di, dj = destination\n        q = deque([(si, sj)])\n        dist = [[inf] * n for _ in range(m)]\n        dist[si][sj] = 0\n        while q:\n            i, j = q.popleft()\n            for a, b in pairwise(dirs):\n                x, y, k = i, j, dist[i][j]\n                while 0 <= x + a < m and 0 <= y + b < n and maze[x + a][y + b] == 0:\n                    x, y, k = x + a, y + b, k + 1\n                if k < dist[x][y]:\n                    dist[x][y] = k\n                    q.append((x, y))\n        return -1 if dist[di][dj] == inf else dist[di][dj]\n",
  "test_case_generator": "\n# Test case generator\ndef generate_test_case():\n    solution = Solution()\n    \n    # Generate random maze\n    m = random.randint(2, 6)\n    n = random.randint(2, 6)\n    maze = [[random.choice([0, 1]) for _ in range(n)] for _ in range(m)]\n    \n    # Generate random start and destination positions\n    start = [random.randint(0, m-1), random.randint(0, n-1)]\n    destination = [random.randint(0, m-1), random.randint(0, n-1)]\n    \n    # Calculate the expected result using the provided Solution class\n    expected_result = solution.shortestDistance(maze, start, destination)\n\n    return maze, start, destination, expected_result\n\ndef test_generated_test_cases(num_tests):\n    test_case_generator_results = []\n    for i in range(num_tests):\n        maze, start, destination, expected_result = generate_test_case()\n        solution = Solution()\n        assert solution.shortestDistance(maze, start, destination) == expected_result\n        print(f\"assert solution.shortestDistance({maze}, {start}, {destination}) == {expected_result}\")\n        test_case_generator_results.append(f\"assert solution.shortestDistance({maze}, {start}, {destination}) == {expected_result}\") # You can find that we construct the test case in the same format as the example\n    return test_case_generator_results\n\nif __name__ == \"__main__\":\n    num_tests = 100  # You can change this to generate more test cases\n    test_case_generator_results = test_generated_test_cases(num_tests)\n",
  "test_case": "assert solution.shortestDistance([[0, 0, 0, 1], [0, 1, 1, 0], [1, 1, 0, 0], [0, 0, 1, 1]], [3, 0], [1, 1]) == -1\nassert solution.shortestDistance([[1, 0, 0, 1], [0, 0, 1, 0], [0, 0, 0, 1], [1, 0, 1, 0], [1, 1, 1, 0]], [1, 3], [4, 2]) == -1\nassert solution.shortestDistance([[0, 1, 1, 1, 0, 0], [0, 1, 0, 1, 0, 0], [0, 1, 0, 1, 0, 1], [1, 1, 0, 1, 1, 1]], [2, 1], [0, 1]) == -1\nassert solution.shortestDistance([[0, 0], [1, 1], [1, 0], [0, 0]], [3, 1], [1, 1]) == -1\nassert solution.shortestDistance([[1, 1], [0, 1], [0, 1], [1, 0], [1, 0]], [4, 0], [1, 0]) == -1\nassert solution.shortestDistance([[1, 0], [1, 0], [1, 1], [1, 0], [1, 1]], [0, 1], [1, 0]) == -1\nassert solution.shortestDistance([[1, 1, 0, 0, 1, 0], [1, 0, 1, 1, 1, 0], [1, 1, 0, 1, 1, 1]], [2, 2], [0, 0]) == -1\nassert solution.shortestDistance([[0, 1], [0, 0], [0, 1], [1, 1], [0, 1], [1, 1]], [4, 1], [4, 1]) == 0\nassert solution.shortestDistance([[1, 1], [1, 0]], [1, 0], [0, 1]) == -1\nassert solution.shortestDistance([[1, 0], [0, 0], [0, 1], [0, 1], [1, 0], [1, 0]], [0, 1], [4, 0]) == -1\nassert solution.shortestDistance([[1, 1, 1, 0, 0], [1, 1, 0, 0, 0], [1, 0, 0, 1, 0]], [2, 2], [2, 3]) == -1\nassert solution.shortestDistance([[0, 0], [0, 1], [1, 1], [1, 0], [1, 0], [0, 1]], [4, 1], [3, 0]) == -1\nassert solution.shortestDistance([[1, 0, 1], [0, 0, 1], [0, 0, 0], [0, 1, 0], [0, 0, 1]], [2, 2], [2, 0]) == 2\nassert solution.shortestDistance([[0, 1, 1, 1], [0, 1, 1, 0], [0, 0, 0, 0], [1, 1, 0, 0], [0, 0, 0, 1]], [4, 0], [4, 1]) == -1\nassert solution.shortestDistance([[1, 1, 0, 0], [0, 1, 1, 1], [0, 0, 0, 0], [0, 1, 1, 1], [0, 0, 0, 1], [0, 0, 1, 0]], [1, 3], [3, 0]) == -1\nassert solution.shortestDistance([[0, 0], [1, 0], [0, 1]], [1, 1], [2, 1]) == -1\nassert solution.shortestDistance([[0, 1, 1, 1, 0, 1], [0, 1, 1, 1, 1, 0], [1, 1, 0, 1, 0, 0], [0, 0, 1, 1, 1, 0], [0, 0, 0, 0, 1, 1]], [3, 4], [0, 3]) == -1\nassert solution.shortestDistance([[0, 1, 0, 0, 1, 0], [0, 1, 1, 1, 1, 0]], [0, 2], [0, 5]) == -1\nassert solution.shortestDistance([[1, 1], [0, 0], [1, 0], [0, 1], [1, 1]], [3, 1], [3, 1]) == 0\nassert solution.shortestDistance([[1, 1, 0, 1], [0, 0, 1, 1]], [0, 0], [0, 3]) == -1\nassert solution.shortestDistance([[0, 0], [1, 1], [0, 0], [1, 1], [1, 0], [0, 0]], [5, 1], [5, 1]) == 0\nassert solution.shortestDistance([[1, 1, 1, 1], [1, 0, 1, 0], [1, 0, 1, 0], [0, 1, 1, 1]], [2, 2], [1, 2]) == -1\nassert solution.shortestDistance([[1, 0, 1, 1, 0], [1, 0, 1, 1, 0], [1, 1, 0, 1, 1], [0, 1, 0, 1, 0], [1, 0, 0, 1, 0]], [3, 4], [2, 0]) == -1\nassert solution.shortestDistance([[1, 0, 1, 0, 1], [0, 0, 1, 1, 1], [1, 0, 1, 1, 0]], [1, 1], [1, 2]) == -1\nassert solution.shortestDistance([[1, 1, 0], [1, 0, 0], [1, 1, 0]], [2, 2], [0, 0]) == -1\nassert solution.shortestDistance([[1, 0, 0, 1, 0], [0, 1, 0, 0, 0], [1, 0, 1, 0, 0]], [2, 3], [0, 4]) == 3\nassert solution.shortestDistance([[1, 1], [0, 0], [0, 0], [1, 0], [1, 1]], [3, 1], [0, 0]) == -1\nassert solution.shortestDistance([[1, 1, 1], [0, 1, 1], [1, 0, 0], [1, 0, 0], [1, 0, 0], [1, 1, 1]], [0, 1], [2, 1]) == -1\nassert solution.shortestDistance([[1, 1, 0], [0, 0, 1], [0, 0, 1]], [1, 0], [2, 1]) == 2\nassert solution.shortestDistance([[1, 0, 1, 1], [1, 0, 0, 1], [1, 0, 0, 0], [0, 0, 1, 1], [1, 1, 1, 0]], [4, 0], [1, 1]) == -1\nassert solution.shortestDistance([[1, 1], [0, 0], [0, 1], [0, 0], [1, 1]], [2, 1], [1, 0]) == 2\nassert solution.shortestDistance([[0, 0, 1], [0, 0, 1], [1, 1, 0], [1, 0, 1]], [1, 0], [1, 0]) == 0\nassert solution.shortestDistance([[0, 0, 0, 0], [0, 0, 1, 0], [1, 1, 0, 0], [1, 0, 0, 0], [1, 0, 1, 1], [1, 1, 1, 0]], [0, 3], [0, 0]) == 3\nassert solution.shortestDistance([[0, 1], [0, 0]], [0, 1], [0, 1]) == 0\nassert solution.shortestDistance([[0, 0], [1, 1], [0, 0], [0, 1], [0, 0], [1, 0]], [2, 1], [2, 1]) == 0\nassert solution.shortestDistance([[0, 0], [1, 1], [1, 1], [0, 0], [0, 1]], [3, 1], [0, 0]) == -1\nassert solution.shortestDistance([[1, 1, 0], [0, 1, 0], [0, 0, 0], [0, 0, 0]], [1, 1], [0, 0]) == -1\nassert solution.shortestDistance([[0, 0, 1, 1], [1, 1, 1, 0]], [0, 2], [0, 1]) == 3\nassert solution.shortestDistance([[0, 0, 1, 1, 1, 1], [0, 0, 0, 1, 0, 0], [0, 1, 0, 1, 1, 0], [0, 1, 0, 1, 1, 0], [1, 1, 1, 0, 0, 0], [0, 1, 1, 1, 1, 0]], [2, 4], [4, 0]) == -1\nassert solution.shortestDistance([[1, 0, 0, 1, 1, 1], [0, 0, 0, 1, 1, 1], [0, 0, 0, 1, 1, 1], [1, 1, 0, 0, 1, 0], [0, 0, 0, 1, 0, 0]], [1, 1], [4, 0]) == 6\nassert solution.shortestDistance([[0, 0], [0, 1], [0, 0], [0, 1], [1, 1]], [2, 1], [0, 0]) == 3\nassert solution.shortestDistance([[1, 1, 0, 0, 1, 0], [1, 1, 1, 0, 1, 1], [0, 1, 1, 0, 0, 1], [1, 1, 1, 0, 1, 1], [0, 1, 0, 1, 1, 1]], [3, 4], [0, 5]) == -1\nassert solution.shortestDistance([[0, 0, 1, 1, 1, 1], [1, 0, 1, 0, 0, 1]], [0, 0], [1, 5]) == -1\nassert solution.shortestDistance([[1, 1, 0, 0], [1, 0, 1, 0], [1, 1, 1, 1], [0, 0, 0, 1], [0, 1, 1, 0], [0, 0, 1, 1]], [5, 3], [1, 0]) == -1\nassert solution.shortestDistance([[0, 0, 0], [1, 1, 1], [1, 1, 1], [1, 0, 1]], [1, 0], [3, 0]) == -1\nassert solution.shortestDistance([[0, 1, 1, 1, 1], [1, 0, 0, 0, 0]], [1, 4], [0, 0]) == -1\nassert solution.shortestDistance([[1, 1, 0, 1, 1, 1], [1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1]], [2, 4], [0, 2]) == 4\nassert solution.shortestDistance([[1, 1, 1, 1, 0], [0, 1, 0, 1, 0], [1, 0, 0, 0, 0], [1, 1, 0, 1, 1], [0, 0, 0, 1, 0]], [3, 0], [0, 3]) == -1\nassert solution.shortestDistance([[0, 0, 0], [1, 1, 1], [0, 1, 1], [1, 0, 1], [1, 1, 0]], [3, 1], [0, 0]) == -1\nassert solution.shortestDistance([[0, 0, 0], [0, 1, 1], [1, 1, 1], [0, 0, 0], [0, 1, 1], [0, 1, 0]], [5, 0], [3, 2]) == 4\nassert solution.shortestDistance([[1, 0], [1, 1]], [1, 0], [1, 1]) == -1\nassert solution.shortestDistance([[0, 1], [1, 0]], [0, 1], [1, 0]) == -1\nassert solution.shortestDistance([[1, 0, 1, 0, 1, 1], [0, 1, 1, 0, 1, 1]], [0, 2], [1, 3]) == 2\nassert solution.shortestDistance([[1, 1], [0, 1], [1, 1], [0, 1], [1, 0]], [2, 0], [2, 0]) == 0\nassert solution.shortestDistance([[0, 0, 0, 1, 0], [0, 1, 1, 0, 0]], [1, 4], [1, 1]) == -1\nassert solution.shortestDistance([[1, 1, 0], [0, 1, 1], [1, 0, 0], [0, 1, 1]], [0, 1], [3, 2]) == -1\nassert solution.shortestDistance([[1, 0, 0], [0, 0, 1], [1, 0, 1], [1, 1, 0]], [3, 1], [1, 1]) == -1\nassert solution.shortestDistance([[0, 0, 0, 0], [0, 1, 1, 0], [0, 0, 1, 0], [0, 0, 1, 0], [1, 1, 1, 0], [0, 1, 1, 0]], [4, 0], [1, 3]) == -1\nassert solution.shortestDistance([[0, 1, 1, 0, 1], [1, 0, 1, 0, 1]], [1, 3], [0, 3]) == 1\nassert solution.shortestDistance([[1, 1, 1, 0, 1, 1], [0, 1, 1, 0, 0, 0], [0, 1, 1, 1, 1, 1], [0, 1, 1, 1, 0, 1], [1, 1, 0, 1, 0, 0]], [0, 0], [1, 5]) == -1\nassert solution.shortestDistance([[1, 1, 1, 0, 0], [0, 0, 1, 1, 0], [0, 0, 1, 1, 1], [0, 1, 0, 1, 0]], [3, 2], [2, 0]) == -1\nassert solution.shortestDistance([[1, 0, 0, 1, 0], [1, 1, 0, 1, 1], [0, 1, 0, 0, 0]], [1, 3], [0, 4]) == -1\nassert solution.shortestDistance([[0, 0, 0], [1, 1, 1], [0, 1, 1], [0, 1, 1], [0, 0, 0], [1, 1, 1]], [5, 0], [5, 2]) == -1\nassert solution.shortestDistance([[1, 1, 1, 1, 1], [0, 1, 1, 0, 1]], [1, 1], [0, 1]) == -1\nassert solution.shortestDistance([[1, 1, 1], [0, 0, 1], [0, 1, 0], [1, 1, 1], [1, 0, 0]], [1, 0], [3, 2]) == -1\nassert solution.shortestDistance([[1, 0, 0, 1, 0, 0], [1, 0, 1, 0, 1, 1]], [1, 4], [0, 1]) == -1\nassert solution.shortestDistance([[1, 0], [1, 1], [0, 0]], [0, 0], [2, 1]) == -1\nassert solution.shortestDistance([[1, 1, 0, 0, 0], [1, 1, 1, 1, 1]], [0, 1], [0, 2]) == 5\nassert solution.shortestDistance([[1, 0], [1, 1], [0, 1], [0, 1]], [1, 1], [1, 0]) == -1\nassert solution.shortestDistance([[1, 1, 0, 1, 0, 0], [0, 0, 1, 0, 0, 1], [1, 1, 0, 0, 1, 1], [1, 1, 1, 0, 1, 1], [0, 0, 1, 0, 1, 1]], [4, 4], [4, 1]) == -1\nassert solution.shortestDistance([[1, 0, 1, 0], [1, 1, 1, 0], [0, 0, 0, 0], [0, 1, 0, 0]], [2, 0], [3, 3]) == 4\nassert solution.shortestDistance([[1, 0, 1, 0, 1], [0, 0, 0, 1, 1]], [0, 0], [0, 2]) == -1\nassert solution.shortestDistance([[1, 1, 1, 0, 1], [1, 0, 0, 0, 0], [1, 0, 0, 0, 1], [0, 1, 0, 0, 1], [1, 1, 0, 1, 0], [0, 1, 1, 1, 0]], [4, 0], [5, 0]) == 1\nassert solution.shortestDistance([[0, 0, 0, 1], [1, 0, 1, 0], [1, 1, 0, 0]], [0, 0], [0, 2]) == 2\nassert solution.shortestDistance([[1, 1, 1, 0], [0, 1, 1, 0], [0, 1, 1, 0], [0, 0, 0, 1]], [1, 3], [0, 2]) == -1\nassert solution.shortestDistance([[1, 1, 1], [1, 0, 0], [1, 1, 0], [0, 0, 0], [1, 0, 0], [0, 0, 0]], [1, 2], [4, 2]) == -1\nassert solution.shortestDistance([[0, 1, 0], [0, 0, 1], [1, 0, 1], [1, 1, 0], [0, 1, 0]], [1, 0], [1, 1]) == 1\nassert solution.shortestDistance([[0, 0, 0, 0, 0], [1, 0, 1, 0, 1], [1, 0, 1, 0, 1], [0, 1, 0, 1, 0], [1, 1, 0, 0, 0], [0, 0, 1, 1, 0]], [3, 1], [2, 2]) == -1\nassert solution.shortestDistance([[1, 0, 1, 1, 0], [1, 1, 1, 1, 1]], [1, 1], [1, 2]) == -1\nassert solution.shortestDistance([[1, 0, 1, 1], [0, 1, 1, 1]], [0, 2], [1, 3]) == -1\nassert solution.shortestDistance([[1, 1, 0], [1, 0, 0], [0, 1, 0], [1, 0, 1], [1, 0, 1]], [2, 0], [4, 0]) == -1\nassert solution.shortestDistance([[0, 1, 0], [1, 1, 0], [1, 0, 0], [1, 0, 0], [1, 1, 0], [1, 0, 1]], [0, 2], [3, 0]) == -1\nassert solution.shortestDistance([[0, 1, 0], [1, 1, 0]], [0, 0], [1, 2]) == -1\nassert solution.shortestDistance([[0, 1, 1, 0], [0, 0, 1, 1], [1, 1, 1, 0], [1, 1, 0, 1]], [1, 2], [2, 0]) == -1\nassert solution.shortestDistance([[0, 0, 1, 1, 0], [1, 0, 1, 1, 1], [0, 0, 1, 1, 0], [1, 0, 0, 1, 0]], [0, 4], [3, 0]) == -1\nassert solution.shortestDistance([[0, 0, 1, 1], [1, 1, 1, 1], [0, 0, 1, 1], [1, 0, 0, 0], [1, 0, 0, 0], [1, 0, 1, 1]], [0, 1], [5, 3]) == -1\nassert solution.shortestDistance([[0, 0, 0, 0, 1, 0], [1, 0, 0, 0, 0, 1], [1, 0, 1, 0, 0, 1], [0, 0, 1, 0, 0, 1], [1, 0, 0, 1, 1, 1]], [4, 5], [2, 0]) == -1\nassert solution.shortestDistance([[1, 1, 0, 0], [1, 1, 0, 0], [0, 0, 1, 0]], [1, 3], [1, 2]) == 1\nassert solution.shortestDistance([[1, 0], [1, 0], [1, 0], [0, 1], [0, 0], [0, 1]], [4, 1], [4, 1]) == 0\nassert solution.shortestDistance([[0, 1], [0, 1]], [0, 0], [1, 1]) == -1\nassert solution.shortestDistance([[0, 1, 1, 1], [1, 1, 1, 1], [0, 1, 0, 1], [1, 0, 0, 0], [0, 1, 1, 1]], [3, 0], [3, 2]) == -1\nassert solution.shortestDistance([[1, 0, 0, 1, 0], [1, 0, 1, 0, 0], [0, 0, 1, 1, 0], [0, 0, 0, 1, 0], [0, 1, 0, 1, 1]], [4, 2], [3, 2]) == 1\nassert solution.shortestDistance([[0, 0, 0], [0, 0, 0], [1, 0, 1], [0, 0, 0], [0, 1, 0], [0, 0, 1]], [5, 0], [5, 0]) == 0\nassert solution.shortestDistance([[1, 0], [0, 1], [0, 0], [0, 0], [0, 0], [0, 0]], [1, 1], [0, 0]) == -1\nassert solution.shortestDistance([[0, 0, 0, 0], [0, 0, 1, 0]], [1, 3], [1, 3]) == 0\nassert solution.shortestDistance([[1, 1, 1, 1, 1, 1], [1, 0, 0, 0, 0, 1], [0, 1, 0, 0, 0, 0], [1, 0, 0, 1, 1, 1]], [1, 0], [0, 5]) == -1\nassert solution.shortestDistance([[0, 0, 1], [1, 1, 0], [0, 1, 0], [0, 1, 1], [1, 1, 0]], [4, 1], [1, 0]) == -1\nassert solution.shortestDistance([[0, 1, 1, 0], [1, 0, 0, 0], [0, 1, 0, 1], [1, 0, 0, 0], [1, 1, 0, 0]], [4, 2], [3, 0]) == -1\nassert solution.shortestDistance([[1, 0], [0, 1], [1, 1], [1, 1], [1, 1], [0, 0]], [1, 0], [3, 1]) == -1\nassert solution.shortestDistance([[1, 0, 0, 1, 0, 1], [1, 1, 0, 1, 0, 0], [0, 0, 0, 1, 0, 1], [0, 0, 0, 1, 0, 0]], [1, 3], [1, 0]) == -1",
  "inefficient_solution": "class Solution:\n    def shortestDistance(\n        self, maze: List[List[int]], start: List[int], destination: List[int]\n    ) -> int:\n        m, n = len(maze), len(maze[0])\n        dirs = (-1, 0, 1, 0, -1)\n        si, sj = start\n        di, dj = destination\n        dist = [[float('inf')] * (n * 100) for _ in range(m * 100)]\n        q = deque([(si * 100 + sj, 0)])\n        while q:\n            i, j = divmod(q.popleft(), 100)\n            for a, b in pairwise(dirs):\n                x, y, k = i, j, dist[i][j]\n                while 0 <= x + a < m and 0 <= y + b < n and maze[x + a][y + b] == 0:\n                    x, y, k = x + a, y + b, k + 1\n                if k < dist[x * 100 + y]:\n                    dist[x * 100 + y] = k\n                    q.append((x * 100 + y, k))\n        return -1 if dist[di * 100 + dj] == float('inf') else dist[di * 100 + dj]",
  "is_python": true
}