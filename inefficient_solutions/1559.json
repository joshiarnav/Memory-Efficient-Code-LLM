{
  "problem_idx": 1559,
  "task_name": "Detect Cycles in ",
  "markdown_description": "\nGiven a 2D array of characters `grid` of size `m x n`, you need to find if there exists any cycle consisting of the **same value** in `grid`.\n\n\nA cycle is a path of **length 4 or more** in the grid that starts and ends at the same cell. From a given cell, you can move to one of the cells adjacent to it - in one of the four directions (up, down, left, or right), if it has the **same value** of the current cell.\n\n\nAlso, you cannot move to the cell that you visited in your last move. For example, the cycle `(1, 1) -> (1, 2) -> (1, 1)` is invalid because from `(1, 2)` we visited `(1, 1)` which was the last visited cell.\n\n\nReturn `true` if any cycle of the same value exists in `grid`, otherwise, return `false`.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n**![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1500-1599/1559.Detect%20Cycles%20in%202D%20Grid/images/1.png)**\n\n\n\n```\n\n**Input:** grid = [[\"a\",\"a\",\"a\",\"a\"],[\"a\",\"b\",\"b\",\"a\"],[\"a\",\"b\",\"b\",\"a\"],[\"a\",\"a\",\"a\",\"a\"]]\n**Output:** true\n**Explanation:** There are two valid cycles shown in different colors in the image below:\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1500-1599/1559.Detect%20Cycles%20in%202D%20Grid/images/11.png)\n\n```\n\n**Example 2:**\n\n\n**![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1500-1599/1559.Detect%20Cycles%20in%202D%20Grid/images/22.png)**\n\n\n\n```\n\n**Input:** grid = [[\"c\",\"c\",\"c\",\"a\"],[\"c\",\"d\",\"c\",\"c\"],[\"c\",\"c\",\"e\",\"c\"],[\"f\",\"c\",\"c\",\"c\"]]\n**Output:** true\n**Explanation:** There is only one valid cycle highlighted in the image below:\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1500-1599/1559.Detect%20Cycles%20in%202D%20Grid/images/2.png)\n\n```\n\n**Example 3:**\n\n\n**![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1500-1599/1559.Detect%20Cycles%20in%202D%20Grid/images/3.png)**\n\n\n\n```\n\n**Input:** grid = [[\"a\",\"b\",\"b\"],[\"b\",\"z\",\"b\"],[\"b\",\"b\",\"a\"]]\n**Output:** false\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `m == grid.length`\n* `n == grid[i].length`\n* `1 <= m, n <= 500`\n* `grid` consists only of lowercase English letters.\n\n\n",
  "canonical_solution": "class Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        def find(x):\n            if p[x] != x:\n                p[x] = find(p[x])\n            return p[x]\n\n        m, n = len(grid), len(grid[0])\n        p = list(range(m * n))\n        for i in range(m):\n            for j in range(n):\n                for a, b in [[0, 1], [1, 0]]:\n                    x, y = i + a, j + b\n                    if x < m and y < n and grid[x][y] == grid[i][j]:\n                        if find(x * n + y) == find(i * n + j):\n                            return True\n                        p[find(x * n + y)] = find(i * n + j)\n        return False\n",
  "test_case_generator": "\nimport random\n\nclass Solution:\n    def containsCycle(self, grid):\n        '''\n        grid: List[List[str]]\n        return: bool\n        '''\n        def find(x):\n            if p[x] != x:\n                p[x] = find(p[x])\n            return p[x]\n\n        m, n = len(grid), len(grid[0])\n        p = list(range(m * n))\n        for i in range(m):\n            for j in range(n):\n                for a, b in [[0, 1], [1, 0]]:\n                    x, y = i + a, j + b\n                    if x < m and y < n and grid[x][y] == grid[i][j]:\n                        if find(x * n + y) == find(i * n + j):\n                            return True\n                        p[find(x * n + y)] = find(i * n + j)\n        return False\n\ndef generate_test_case():\n    solution = Solution()\n    \n    # Generate random m and n\n    m = random.randint(1, 10)\n    n = random.randint(1, 10)\n    \n    # Generate random grid\n    grid = []\n    for _ in range(m):\n        row = [random.choice('abcdefghijklmnopqrstuvwxyz') for _ in range(n)]\n        grid.append(row)\n\n    # Calculate the expected result using the provided Solution class\n    expected_result = solution.containsCycle(grid)\n\n    return grid, expected_result\n\ndef test_generated_test_cases(num_tests):\n    test_case_generator_results = []\n    for i in range(num_tests):\n        grid, expected_result = generate_test_case()\n        solution = Solution()\n        assert solution.containsCycle(grid) == expected_result\n        if expected_result:\n            print(f\"assert solution.containsCycle({grid}) == True\")\n            test_case_generator_results.append(f\"assert solution.containsCycle({grid}) == True\\n\") # You can find that we construct the test case in the same format as the example\n    return test_case_generator_results\n\nif __name__ == \"__main__\":\n    num_tests = 100  # You can change this to generate more test cases\n    test_case_generator_results = test_generated_test_cases(num_tests)\n",
  "test_case": "",
  "inefficient_solution": "class Solution:\n    def containsCycle(self, grid):\n        m, n = len(grid), len(grid[0])\n        chars = [[[] for _ in range(n)] for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                chars[i][j] = [grid[i][j]]\n                if i > 0 and grid[i][j] == grid[i-1][j]:\n                    chars[i][j].append(grid[i-1][j])\n                if j > 0 and grid[i][j] == grid[i][j-1]:\n                    chars[i][j].append(grid[i][j-1])\n        for i in range(m):\n            for j in range(n):\n                if len(chars[i][j]) > 2:\n                    for a, b in [[0, 1], [1, 0]]:\n                        x, y = i + a, j + b\n                        if x < m and y < n:\n                            curr = [(i, j)]\n                            while (x, y) != (i, j):\n                                if grid[x][y] == grid[i][j]:\n                                    curr.append((x, y))\n                                    if (x, y) in curr[:-3]:\n                                        return True\n                                    if x > 0 and grid[x][y] == grid[x-1][y]:\n                                        curr.append((x-1, y))\n                                    if y > 0 and grid[x][y] == grid[x][y-1]:\n                                        curr.append((x, y-1))\n                                    if x < m-1 and grid[x][y] == grid[x+1][y]:\n                                        curr.append((x+1, y))\n                                    if y < n-1 and grid[x][y] == grid[x][y+1]:\n                                        curr.append((x, y+1))\n                                else:\n                                    break\n                                x, y = curr[-1]\n                            else:\n                                return True\n        return False",
  "is_python": true
}