{
  "problem_idx": 556,
  "task_name": "Next Greater Element III",
  "markdown_description": "\nGiven a positive integer `n`, find *the smallest integer which has exactly the same digits existing in the integer* `n` *and is greater in value than* `n`. If no such positive integer exists, return `-1`.\n\n\n**Note** that the returned integer should fit in **32-bit integer**, if there is a valid answer but it does not fit in **32-bit integer**, return `-1`.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n**Input:** n = 12\n**Output:** 21\n\n```\n**Example 2:**\n\n\n\n```\n**Input:** n = 21\n**Output:** -1\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= n <= 231 - 1`\n\n\n",
  "canonical_solution": "class Solution:\n    def nextGreaterElement(self, n: int) -> int:\n        cs = list(str(n))\n        n = len(cs)\n        i, j = n - 2, n - 1\n        while i >= 0 and cs[i] >= cs[i + 1]:\n            i -= 1\n        if i < 0:\n            return -1\n        while cs[i] >= cs[j]:\n            j -= 1\n        cs[i], cs[j] = cs[j], cs[i]\n        cs[i + 1 :] = cs[i + 1 :][::-1]\n        ans = int(''.join(cs))\n        return -1 if ans > 2**31 - 1 else ans\n",
  "test_case_generator": "\nimport random\n\nclass Solution:\n    def nextGreaterElement(self, n):\n        cs = list(str(n))\n        n = len(cs)\n        i, j = n - 2, n - 1\n        while i >= 0 and cs[i] >= cs[i + 1]:\n            i -= 1\n        if i < 0:\n            return -1\n        while cs[i] >= cs[j]:\n            j -= 1\n        cs[i], cs[j] = cs[j], cs[i]\n        cs[i + 1 :] = cs[i + 1 :][::-1]\n        ans = int(''.join(cs))\n        return -1 if ans > 2**31 - 1 else ans\n\n\ndef generate_test_case():\n    solution = Solution()\n\n    # Generate a random positive integer\n    n = random.randint(1, 2**31 - 1)\n\n    # Calculate the expected result using the provided Solution class\n    expected_result = solution.nextGreaterElement(n)\n\n    return n, expected_result\n\n\ndef test_generated_test_cases(num_tests):\n    test_case_generator_results = []\n    for i in range(num_tests):\n        n, expected_result = generate_test_case()\n        solution = Solution()\n        assert solution.nextGreaterElement(n) == expected_result\n        print(f\"assert solution.nextGreaterElement({n}) == {expected_result}\")\n        test_case_generator_results.append(\n            f\"assert solution.nextGreaterElement({n}) == {expected_result}\"\n        )  # You can find that we construct the test case in the same format as the example\n    return test_case_generator_results\n\n\nif __name__ == \"__main__\":\n    num_tests = 100  # You can change this to generate more test cases\n    test_case_generator_results = test_generated_test_cases(num_tests)\n",
  "test_case": "assert solution.nextGreaterElement(1668534853) == 1668535348\nassert solution.nextGreaterElement(1453125337) == 1453125373\nassert solution.nextGreaterElement(45813937) == 45813973\nassert solution.nextGreaterElement(1168053561) == 1168053615\nassert solution.nextGreaterElement(1481235521) == 1481251235\nassert solution.nextGreaterElement(955650576) == 955650657\nassert solution.nextGreaterElement(2033815173) == 2033815317\nassert solution.nextGreaterElement(209512817) == 209512871\nassert solution.nextGreaterElement(1366884461) == 1366884614\nassert solution.nextGreaterElement(1793734911) == 1793739114\nassert solution.nextGreaterElement(1431731904) == 1431731940\nassert solution.nextGreaterElement(228591746) == 228591764\nassert solution.nextGreaterElement(344587319) == 344587391\nassert solution.nextGreaterElement(229003558) == 229003585\nassert solution.nextGreaterElement(1918931819) == 1918931891\nassert solution.nextGreaterElement(800180649) == 800180694\nassert solution.nextGreaterElement(1727632780) == 1727632807\nassert solution.nextGreaterElement(766515673) == 766515736\nassert solution.nextGreaterElement(1670339822) == 1670382239\nassert solution.nextGreaterElement(260601497) == 260601749\nassert solution.nextGreaterElement(227581756) == 227581765\nassert solution.nextGreaterElement(2098666626) == 2098666662\nassert solution.nextGreaterElement(1825604586) == 1825604658\nassert solution.nextGreaterElement(2132501915) == 2132501951\nassert solution.nextGreaterElement(1463330243) == 1463330324\nassert solution.nextGreaterElement(1769087294) == 1769087429\nassert solution.nextGreaterElement(59587476) == 59587647\nassert solution.nextGreaterElement(424743103) == 424743130\nassert solution.nextGreaterElement(1731959743) == 1731973459\nassert solution.nextGreaterElement(684715570) == 684715705\nassert solution.nextGreaterElement(1918920682) == 1918920826\nassert solution.nextGreaterElement(481951719) == 481951791\nassert solution.nextGreaterElement(1754297444) == 1754424479\nassert solution.nextGreaterElement(213205677) == 213205767\nassert solution.nextGreaterElement(415639041) == 415639104\nassert solution.nextGreaterElement(572507556) == 572507565\nassert solution.nextGreaterElement(1721408463) == 1721408634\nassert solution.nextGreaterElement(1382938296) == 1382938629\nassert solution.nextGreaterElement(840128346) == 840128364\nassert solution.nextGreaterElement(867316733) == 867317336\nassert solution.nextGreaterElement(716590593) == 716590935\nassert solution.nextGreaterElement(1815216880) == 1815218068\nassert solution.nextGreaterElement(1966731490) == 1966731904\nassert solution.nextGreaterElement(1674089534) == 1674089543\nassert solution.nextGreaterElement(394921367) == 394921376\nassert solution.nextGreaterElement(560430113) == 560430131\nassert solution.nextGreaterElement(31585949) == 31585994\nassert solution.nextGreaterElement(58125406) == 58125460\nassert solution.nextGreaterElement(1916299410) == 1916401299\nassert solution.nextGreaterElement(532401994) == 532404199\nassert solution.nextGreaterElement(1748996043) == 1748996304\nassert solution.nextGreaterElement(1485144036) == 1485144063\nassert solution.nextGreaterElement(224160259) == 224160295\nassert solution.nextGreaterElement(935070825) == 935070852\nassert solution.nextGreaterElement(1524544361) == 1524544613\nassert solution.nextGreaterElement(176306475) == 176306547\nassert solution.nextGreaterElement(1270432209) == 1270432290\nassert solution.nextGreaterElement(882552521) == 882555122\nassert solution.nextGreaterElement(1375411847) == 1375411874\nassert solution.nextGreaterElement(1239983796) == 1239983967\nassert solution.nextGreaterElement(528947379) == 528947397\nassert solution.nextGreaterElement(1870267961) == 1870269167\nassert solution.nextGreaterElement(1732860831) == 1732861038\nassert solution.nextGreaterElement(970235434) == 970235443\nassert solution.nextGreaterElement(157408117) == 157408171\nassert solution.nextGreaterElement(1813995684) == 1813995846\nassert solution.nextGreaterElement(1207211564) == 1207211645\nassert solution.nextGreaterElement(144698011) == 144698101\nassert solution.nextGreaterElement(94535502) == 94535520\nassert solution.nextGreaterElement(33160599) == 33160959\nassert solution.nextGreaterElement(255076075) == 255076507\nassert solution.nextGreaterElement(1772153475) == 1772153547\nassert solution.nextGreaterElement(11064880) == 11068048\nassert solution.nextGreaterElement(1217572927) == 1217572972\nassert solution.nextGreaterElement(283822409) == 283822490\nassert solution.nextGreaterElement(2132426891) == 2132426918\nassert solution.nextGreaterElement(445549195) == 445549519\nassert solution.nextGreaterElement(1820128594) == 1820128945\nassert solution.nextGreaterElement(1565437019) == 1565437091\nassert solution.nextGreaterElement(940303854) == 940304358\nassert solution.nextGreaterElement(1481018658) == 1481018685\nassert solution.nextGreaterElement(1709134440) == 1709140344\nassert solution.nextGreaterElement(43331892) == 43331928\nassert solution.nextGreaterElement(820891929) == 820891992\nassert solution.nextGreaterElement(672356054) == 672356405\nassert solution.nextGreaterElement(1189118707) == 1189118770\nassert solution.nextGreaterElement(241209278) == 241209287\nassert solution.nextGreaterElement(845483837) == 845483873\nassert solution.nextGreaterElement(1012494240) == 1012494402\nassert solution.nextGreaterElement(514447195) == 514447519\nassert solution.nextGreaterElement(258204687) == 258204768\nassert solution.nextGreaterElement(2085136531) == 2085151336\nassert solution.nextGreaterElement(1980382393) == 1980382933\nassert solution.nextGreaterElement(775470006) == 775470060\nassert solution.nextGreaterElement(1711498303) == 1711498330\nassert solution.nextGreaterElement(1455546129) == 1455546192\nassert solution.nextGreaterElement(1446770849) == 1446770894\nassert solution.nextGreaterElement(1969253962) == 1969256239\nassert solution.nextGreaterElement(2019170402) == 2019170420\nassert solution.nextGreaterElement(297274285) == 297274528",
  "inefficient_solution": "class Solution:\n    def nextGreaterElement(self, n: int) -> int:\n        # Convert the number to a list of integers with 1 million elements each\n        n_list = [int(d) for d in str(n)] * 1000000\n        \n        # Convert each integer in the list to a string and store them in a new list\n        str_list = [str(d) for d in n_list]\n        \n        # Create a list of tuples where each tuple contains a string and its index\n        str_index_list = [(s, i) for i, s in enumerate(str_list)]\n        \n        # Sort the list of tuples based on the strings\n        str_index_list.sort(key=lambda x: x[0])\n        \n        # Initialize variables to keep track of the current index and the previous character\n        i, prev_char = 0, -1\n        \n        # Iterate over the sorted list of tuples\n        while i < len(str_index_list):\n            # If the current string is the same as the previous character, increment the index\n            if str_index_list[i][0] == '0':\n                i += 1\n            # If the current string is greater than the previous character, swap them and increment the index\n            elif str_index_list[i][0] > prev_char:\n                prev_char, str_index_list[i] = str_index_list[i], (prev_char, i)\n                i += 1\n            # Otherwise, increment the index\n            else:\n                i += 1\n        \n        # Initialize a list to store the result\n        result = []\n        \n        # Initialize variables to keep track of the current index and the previous character\n        i, prev_char = 0, -1\n        \n        # Iterate over the sorted list of tuples\n        while i < len(str_index_list):\n            # If the current string is the same as the previous character, append the character to the result\n            if str_index_list[i][0] == '0':\n                result.append(int(str_index_list[i][0]))\n            # If the current string is greater than the previous character, append the character to the result and increment the index\n            elif str_index_list[i][0] > prev_char:\n                result.append(int(str_index_list[i][0]))\n                prev_char = str_index_list[i][0]\n                i += 1\n            # Otherwise, increment the index\n            else:\n                i += 1\n        \n        # Join the characters in the result list to form a string\n        result_str = ''.join(map(str, result))\n        \n        # Initialize a list to store the final result\n        final_result = []\n        \n        # Iterate over the characters in the result string\n        for char in result_str:\n            # Append the character to the final result list 1000000 times\n            final_result.extend([int(char)] * 1000000)\n        \n        # Join the characters in the final result list to form a string\n        final_result_str = ''.join(map(str, final_result))\n        \n        # Convert the final result string to an integer and return it\n        return int(final_result_str)",
  "is_python": true
}