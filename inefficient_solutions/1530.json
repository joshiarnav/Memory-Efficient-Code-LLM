{
  "problem_idx": 1530,
  "task_name": "Number of Good Leaf Nodes Pairs",
  "markdown_description": "\nYou are given the `root` of a binary tree and an integer `distance`. A pair of two different **leaf** nodes of a binary tree is said to be good if the length of **the shortest path** between them is less than or equal to `distance`.\n\n\nReturn *the number of good leaf node pairs* in the tree.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1500-1599/1530.Number%20of%20Good%20Leaf%20Nodes%20Pairs/images/e1.jpg)\n\n```\n\n**Input:** root = [1,2,3,null,4], distance = 3\n**Output:** 1\n**Explanation:** The leaf nodes of the tree are 3 and 4 and the length of the shortest path between them is 3. This is the only good pair.\n\n```\n\n**Example 2:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1500-1599/1530.Number%20of%20Good%20Leaf%20Nodes%20Pairs/images/e2.jpg)\n\n```\n\n**Input:** root = [1,2,3,4,5,6,7], distance = 3\n**Output:** 2\n**Explanation:** The good pairs are [4,5] and [6,7] with shortest path = 2. The pair [4,6] is not good because the length of ther shortest path between them is 4.\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** root = [7,1,4,6,null,5,3,null,null,null,null,null,2], distance = 3\n**Output:** 1\n**Explanation:** The only good pair is [2,5].\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* The number of nodes in the `tree` is in the range `[1, 210].`\n* `1 <= Node.val <= 100`\n* `1 <= distance <= 10`\n\n\n",
  "canonical_solution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def countPairs(self, root: TreeNode, distance: int) -> int:\n        def dfs(root, cnt, i):\n            if root is None or i >= distance:\n                return\n            if root.left is None and root.right is None:\n                cnt[i] += 1\n                return\n            dfs(root.left, cnt, i + 1)\n            dfs(root.right, cnt, i + 1)\n\n        if root is None:\n            return 0\n        ans = self.countPairs(root.left, distance) + self.countPairs(\n            root.right, distance\n        )\n        cnt1 = Counter()\n        cnt2 = Counter()\n        dfs(root.left, cnt1, 1)\n        dfs(root.right, cnt2, 1)\n\n        for k1, v1 in cnt1.items():\n            for k2, v2 in cnt2.items():\n                if k1 + k2 <= distance:\n                    ans += v1 * v2\n        return ans\n",
  "test_case_generator": "\nimport random\n\nclass Solution:\n    def countPairs(self, root, distance):\n        def dfs(root, cnt, i):\n            if root is None or i >= distance:\n                return\n            if root.left is None and root.right is None:\n                cnt[i] += 1\n                return\n            dfs(root.left, cnt, i + 1)\n            dfs(root.right, cnt, i + 1)\n\n        if root is None:\n            return 0\n        ans = self.countPairs(root.left, distance) + self.countPairs(\n            root.right, distance\n        )\n        cnt1 = Counter()\n        cnt2 = Counter()\n        dfs(root.left, cnt1, 1)\n        dfs(root.right, cnt2, 1)\n\n        for k1, v1 in cnt1.items():\n            for k2, v2 in cnt2.items():\n                if k1 + k2 <= distance:\n                    ans += v1 * v2\n        return ans\n\ndef generate_test_case():\n    solution = Solution()\n\n    # Generate random binary tree\n    root = generate_tree(random.randint(1, 10))\n  \n    # Generate random distance\n    distance = random.randint(1, 10)\n\n    # Calculate the expected result using the provided Solution class\n    expected_result = solution.countPairs(root, distance)\n\n    return root, distance, expected_result\n\ndef generate_tree(nodes):\n    def helper(node_values, index):\n        if index >= len(node_values) or node_values[index] is None:\n            return None\n        node = TreeNode(node_values[index])\n        node.left = helper(node_values, 2 * index + 1)\n        node.right = helper(node_values, 2 * index + 2)\n        return node\n    \n    node_values = []\n    for i in range(nodes):\n        if random.randint(0, 1) == 0:\n            node_values.append(random.randint(1, 100))\n        else:\n            node_values.append(None)\n    \n    return helper(node_values, 0)\n\ndef test_generated_test_cases(num_tests):\n    test_case_generator_results = []\n    for i in range(num_tests):\n        root, distance, expected_result = generate_test_case()\n        solution = Solution()\n        assert solution.countPairs(root, distance) == expected_result\n        if expected_result != 0:\n            print(f\"assert solution.countPairs({root}, {distance}) == {expected_result}\")\n            test_case_generator_results.append(f\"assert solution.countPairs({root}, {distance}) == {expected_result}\")\n    return test_case_generator_results\n\nif __name__ == \"__main__\":\n    num_tests = 100  # You can change this to generate more test cases\n    test_case_generator_results = test_generated_test_cases(num_tests)\n",
  "test_case": "assert solution.countPairs(<__main__.TreeNode object at 0x7f5858aaf4d0>, 8) == 1\nassert solution.countPairs(<__main__.TreeNode object at 0x7f5858b0d450>, 7) == 1\nassert solution.countPairs(<__main__.TreeNode object at 0x7f5858b0e150>, 9) == 1\nassert solution.countPairs(<__main__.TreeNode object at 0x7f5858b0e1d0>, 10) == 1\nassert solution.countPairs(<__main__.TreeNode object at 0x7f5858b0f090>, 9) == 1\nassert solution.countPairs(<__main__.TreeNode object at 0x7f5858b0f090>, 3) == 1\nassert solution.countPairs(<__main__.TreeNode object at 0x7f5858b0f110>, 5) == 3\nassert solution.countPairs(<__main__.TreeNode object at 0x7f5858b0e750>, 9) == 1\nassert solution.countPairs(<__main__.TreeNode object at 0x7f5858b0f790>, 2) == 1\nassert solution.countPairs(<__main__.TreeNode object at 0x7f5858b0fe50>, 9) == 1\nassert solution.countPairs(<__main__.TreeNode object at 0x7f5858b20050>, 5) == 1\nassert solution.countPairs(<__main__.TreeNode object at 0x7f5858b20050>, 9) == 1\nassert solution.countPairs(<__main__.TreeNode object at 0x7f5858b20050>, 9) == 1\nassert solution.countPairs(<__main__.TreeNode object at 0x7f5858b20090>, 5) == 1\nassert solution.countPairs(<__main__.TreeNode object at 0x7f5858b20090>, 6) == 1",
  "inefficient_solution": "",
  "is_python": true
}