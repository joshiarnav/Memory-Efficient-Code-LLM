{
  "problem_idx": 216,
  "task_name": "Combination Sum III",
  "markdown_description": "\nFind all valid combinations of `k` numbers that sum up to `n` such that the following conditions are true:\n\n\n* Only numbers `1` through `9` are used.\n* Each number is used **at most once**.\n\n\nReturn *a list of all possible valid combinations*. The list must not contain the same combination twice, and the combinations may be returned in any order.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** k = 3, n = 7\n**Output:** [[1,2,4]]\n**Explanation:**\n1 + 2 + 4 = 7\nThere are no other valid combinations.\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** k = 3, n = 9\n**Output:** [[1,2,6],[1,3,5],[2,3,4]]\n**Explanation:**\n1 + 2 + 6 = 9\n1 + 3 + 5 = 9\n2 + 3 + 4 = 9\nThere are no other valid combinations.\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** k = 4, n = 1\n**Output:** []\n**Explanation:** There are no valid combinations.\nUsing 4 different numbers in the range [1,9], the smallest sum we can get is 1+2+3+4 = 10 and since 10 > 1, there are no valid combination.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `2 <= k <= 9`\n* `1 <= n <= 60`\n\n\n",
  "canonical_solution": "class Solution:\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\n        def dfs(i: int, s: int):\n            if s == 0:\n                if len(t) == k:\n                    ans.append(t[:])\n                return\n            if i > 9 or i > s or len(t) >= k:\n                return\n            t.append(i)\n            dfs(i + 1, s - i)\n            t.pop()\n            dfs(i + 1, s)\n\n        ans = []\n        t = []\n        dfs(1, n)\n        return ans\n",
  "test_case_generator": "\nimport random\n\nclass Solution:\n    def combinationSum3(self, k, n):\n        def dfs(i, s):\n            if s == 0:\n                if len(t) == k:\n                    ans.append(t[:])\n                return\n            if i > 9 or i > s or len(t) >= k:\n                return\n            t.append(i)\n            dfs(i + 1, s - i)\n            t.pop()\n            dfs(i + 1, s)\n\n        ans = []\n        t = []\n        dfs(1, n)\n        return ans\n    \n\ndef generate_test_case():\n    solution = Solution()\n    \n    # Generate random values for k and n\n    k = random.randint(2, 9)\n    n = random.randint(1, 60)\n\n    # Calculate the expected result using the provided Solution class\n    expected_result = solution.combinationSum3(k, n)\n\n    return k, n, expected_result\n\ndef test_generated_test_cases(num_tests):\n    test_case_generator_results = []\n    for i in range(num_tests):\n        k, n, expected_result = generate_test_case()\n        solution = Solution()\n        assert solution.combinationSum3(k, n) == expected_result\n        if len(expected_result) != 0:\n            print(f\"assert solution.combinationSum3({k}, {n}) == {expected_result}\")\n            test_case_generator_results.append(f\"assert solution.combinationSum3({k}, {n}) == {expected_result}\") # You can find that we construct the test case in the same format as the example\n    return test_case_generator_results\n\nif __name__ == \"__main__\":\n    num_tests = 100  # You can change this to generate more test cases\n    test_case_generator_results = test_generated_test_cases(num_tests)\n",
  "test_case": "assert solution.combinationSum3(4, 22) == [[1, 4, 8, 9], [1, 5, 7, 9], [1, 6, 7, 8], [2, 3, 8, 9], [2, 4, 7, 9], [2, 5, 6, 9], [2, 5, 7, 8], [3, 4, 6, 9], [3, 4, 7, 8], [3, 5, 6, 8], [4, 5, 6, 7]]\nassert solution.combinationSum3(4, 26) == [[2, 7, 8, 9], [3, 6, 8, 9], [4, 5, 8, 9], [4, 6, 7, 9], [5, 6, 7, 8]]\nassert solution.combinationSum3(7, 34) == [[1, 2, 3, 4, 7, 8, 9], [1, 2, 3, 5, 6, 8, 9], [1, 2, 4, 5, 6, 7, 9], [1, 3, 4, 5, 6, 7, 8]]\nassert solution.combinationSum3(3, 17) == [[1, 7, 9], [2, 6, 9], [2, 7, 8], [3, 5, 9], [3, 6, 8], [4, 5, 8], [4, 6, 7]]\nassert solution.combinationSum3(3, 6) == [[1, 2, 3]]\nassert solution.combinationSum3(4, 27) == [[3, 7, 8, 9], [4, 6, 8, 9], [5, 6, 7, 9]]\nassert solution.combinationSum3(3, 7) == [[1, 2, 4]]\nassert solution.combinationSum3(4, 30) == [[6, 7, 8, 9]]\nassert solution.combinationSum3(3, 19) == [[2, 8, 9], [3, 7, 9], [4, 6, 9], [4, 7, 8], [5, 6, 8]]\nassert solution.combinationSum3(2, 4) == [[1, 3]]\nassert solution.combinationSum3(4, 20) == [[1, 2, 8, 9], [1, 3, 7, 9], [1, 4, 6, 9], [1, 4, 7, 8], [1, 5, 6, 8], [2, 3, 6, 9], [2, 3, 7, 8], [2, 4, 5, 9], [2, 4, 6, 8], [2, 5, 6, 7], [3, 4, 5, 8], [3, 4, 6, 7]]\nassert solution.combinationSum3(2, 7) == [[1, 6], [2, 5], [3, 4]]\nassert solution.combinationSum3(5, 21) == [[1, 2, 3, 6, 9], [1, 2, 3, 7, 8], [1, 2, 4, 5, 9], [1, 2, 4, 6, 8], [1, 2, 5, 6, 7], [1, 3, 4, 5, 8], [1, 3, 4, 6, 7], [2, 3, 4, 5, 7]]\nassert solution.combinationSum3(7, 40) == [[1, 4, 5, 6, 7, 8, 9], [2, 3, 5, 6, 7, 8, 9]]\nassert solution.combinationSum3(3, 11) == [[1, 2, 8], [1, 3, 7], [1, 4, 6], [2, 3, 6], [2, 4, 5]]\nassert solution.combinationSum3(4, 24) == [[1, 6, 8, 9], [2, 5, 8, 9], [2, 6, 7, 9], [3, 4, 8, 9], [3, 5, 7, 9], [3, 6, 7, 8], [4, 5, 6, 9], [4, 5, 7, 8]]\nassert solution.combinationSum3(5, 17) == [[1, 2, 3, 4, 7], [1, 2, 3, 5, 6]]\nassert solution.combinationSum3(4, 13) == [[1, 2, 3, 7], [1, 2, 4, 6], [1, 3, 4, 5]]\nassert solution.combinationSum3(4, 22) == [[1, 4, 8, 9], [1, 5, 7, 9], [1, 6, 7, 8], [2, 3, 8, 9], [2, 4, 7, 9], [2, 5, 6, 9], [2, 5, 7, 8], [3, 4, 6, 9], [3, 4, 7, 8], [3, 5, 6, 8], [4, 5, 6, 7]]\nassert solution.combinationSum3(2, 7) == [[1, 6], [2, 5], [3, 4]]\nassert solution.combinationSum3(7, 29) == [[1, 2, 3, 4, 5, 6, 8]]\nassert solution.combinationSum3(2, 11) == [[2, 9], [3, 8], [4, 7], [5, 6]]",
  "inefficient_solution": "class Solution:\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\n        def dfs(i: int, s: int, t: list, ans: list):\n            if s == 0:\n                if len(t) == k:\n                    ans.append(t[:])\n                return\n            if i > 9 or i > s or len(t) >= k:\n                return\n            temp_t = t + [i]\n            temp_ans = ans + [temp_t]\n            dfs(i + 1, s - i, temp_t, temp_ans)\n            dfs(i + 1, s, t, ans)\n\n        ans = []\n        dfs(1, n, [], ans)\n        return ans",
  "is_python": true
}