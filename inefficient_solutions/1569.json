{
  "problem_idx": 1569,
  "task_name": "Number of Ways to Reorder Array to Get Same BST",
  "markdown_description": "\nGiven an array `nums` that represents a permutation of integers from `1` to `n`. We are going to construct a binary search tree (BST) by inserting the elements of `nums` in order into an initially empty BST. Find the number of different ways to reorder `nums` so that the constructed BST is identical to that formed from the original array `nums`.\n\n\n* For example, given `nums = [2,1,3]`, we will have 2 as the root, 1 as a left child, and 3 as a right child. The array `[2,3,1]` also yields the same BST but `[3,2,1]` yields a different BST.\n\n\nReturn *the number of ways to reorder* `nums` *such that the BST formed is identical to the original BST formed from* `nums`.\n\n\nSince the answer may be very large, **return it modulo** `109 + 7`.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1500-1599/1569.Number%20of%20Ways%20to%20Reorder%20Array%20to%20Get%20Same%20BST/images/bb.png)\n\n```\n\n**Input:** nums = [2,1,3]\n**Output:** 1\n**Explanation:** We can reorder nums to be [2,3,1] which will yield the same BST. There are no other ways to reorder nums which will yield the same BST.\n\n```\n\n**Example 2:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1500-1599/1569.Number%20of%20Ways%20to%20Reorder%20Array%20to%20Get%20Same%20BST/images/ex1.png)\n\n```\n\n**Input:** nums = [3,4,5,1,2]\n**Output:** 5\n**Explanation:** The following 5 arrays will yield the same BST: \n[3,1,2,4,5]\n[3,1,4,2,5]\n[3,1,4,5,2]\n[3,4,1,2,5]\n[3,4,1,5,2]\n\n```\n\n**Example 3:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1500-1599/1569.Number%20of%20Ways%20to%20Reorder%20Array%20to%20Get%20Same%20BST/images/ex4.png)\n\n```\n\n**Input:** nums = [1,2,3]\n**Output:** 0\n**Explanation:** There are no other orderings of nums that will yield the same BST.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= nums.length <= 1000`\n* `1 <= nums[i] <= nums.length`\n* All integers in `nums` are **distinct**.\n\n\n",
  "canonical_solution": "class Solution:\n    def numOfWays(self, nums: List[int]) -> int:\n        def dfs(nums):\n            if len(nums) < 2:\n                return 1\n            left = [x for x in nums if x < nums[0]]\n            right = [x for x in nums if x > nums[0]]\n            m, n = len(left), len(right)\n            a, b = dfs(left), dfs(right)\n            return (((c[m + n][m] * a) % mod) * b) % mod\n\n        n = len(nums)\n        mod = 10**9 + 7\n        c = [[0] * n for _ in range(n)]\n        c[0][0] = 1\n        for i in range(1, n):\n            c[i][0] = 1\n            for j in range(1, i + 1):\n                c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod\n        return (dfs(nums) - 1 + mod) % mod\n",
  "test_case_generator": "\nimport random\n\nclass Solution:\n    def numOfWays(self, nums):\n        def dfs(nums):\n            if len(nums) < 2:\n                return 1\n            left = [x for x in nums if x < nums[0]]\n            right = [x for x in nums if x > nums[0]]\n            m, n = len(left), len(right)\n            a, b = dfs(left), dfs(right)\n            return (((c[m + n][m] * a) % mod) * b) % mod\n\n        n = len(nums)\n        mod = 10**9 + 7\n        c = [[0] * n for _ in range(n)]\n        c[0][0] = 1\n        for i in range(1, n):\n            c[i][0] = 1\n            for j in range(1, i + 1):\n                c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod\n        return (dfs(nums) - 1 + mod) % mod\n\ndef generate_test_case():\n    solution = Solution()\n    \n    # Generate random numbers list\n    nums = random.sample(range(1, 11), random.randint(2, 10))\n\n    # Calculate the expected result using the provided Solution class\n    expected_result = solution.numOfWays(nums)\n\n    return nums, expected_result\n\ndef test_generated_test_cases(num_tests):\n    test_case_generator_results = []\n    for i in range(num_tests):\n        nums, expected_result = generate_test_case()\n        solution = Solution()\n        assert solution.numOfWays(nums) == expected_result\n        print(f\"assert solution.numOfWays({nums}) == {expected_result}\")\n        test_case_generator_results.append(f\"assert solution.numOfWays({nums}) == {expected_result}\") # You can find that we construct the test case in the same format as the example\n    return test_case_generator_results\n\nif __name__ == \"__main__\":\n    num_tests = 100  # You can change this to generate more test cases\n    test_case_generator_results = test_generated_test_cases(num_tests)\n",
  "test_case": "assert solution.numOfWays([10, 5, 3, 8, 7, 4, 2]) == 19\nassert solution.numOfWays([5, 1, 2, 4, 10, 6, 9, 8, 7]) == 55\nassert solution.numOfWays([2, 5, 1, 3, 7, 10]) == 14\nassert solution.numOfWays([4, 3, 9, 5, 6]) == 3\nassert solution.numOfWays([5, 8]) == 0\nassert solution.numOfWays([6, 10, 4, 3, 2, 5, 8]) == 44\nassert solution.numOfWays([10, 1, 9, 7]) == 0\nassert solution.numOfWays([7, 5, 2, 10, 6, 3]) == 14\nassert solution.numOfWays([2, 1, 4, 9, 5, 6, 7, 10, 3, 8]) == 314\nassert solution.numOfWays([10, 3, 7, 5]) == 0\nassert solution.numOfWays([2, 10, 4, 7, 9, 1, 3, 5, 6]) == 119\nassert solution.numOfWays([7, 6]) == 0\nassert solution.numOfWays([8, 7, 2, 9, 5, 3, 1, 6, 10, 4]) == 539\nassert solution.numOfWays([10, 2, 6, 4, 3, 5, 9, 1]) == 47\nassert solution.numOfWays([9, 10, 5, 2, 4, 8, 1, 7, 6, 3]) == 944\nassert solution.numOfWays([1, 3, 9, 7, 8, 5]) == 1\nassert solution.numOfWays([8, 5, 9, 6, 7, 3, 4, 10, 2, 1]) == 1619\nassert solution.numOfWays([9, 4, 10, 1, 5, 7]) == 14\nassert solution.numOfWays([10, 4]) == 0\nassert solution.numOfWays([6, 7, 4, 10, 5]) == 5\nassert solution.numOfWays([2, 8, 1, 7, 3, 5, 9]) == 23\nassert solution.numOfWays([1, 9, 6, 7, 4]) == 1\nassert solution.numOfWays([7, 4, 9, 5, 10, 1, 8]) == 79\nassert solution.numOfWays([5, 8, 3, 10, 7, 2, 9]) == 44\nassert solution.numOfWays([3, 4, 5, 6, 2, 1, 8, 10, 7]) == 55\nassert solution.numOfWays([6, 5, 1, 7, 2, 4, 9, 8, 3, 10]) == 251\nassert solution.numOfWays([7, 6, 4, 1]) == 0\nassert solution.numOfWays([4, 1, 7, 5, 8]) == 7\nassert solution.numOfWays([10, 2, 7, 9, 4, 8]) == 2\nassert solution.numOfWays([3, 10, 5, 2]) == 2\nassert solution.numOfWays([6, 7, 9, 10, 4, 1, 3, 8]) == 69\nassert solution.numOfWays([1, 8, 4, 5, 3, 2, 7]) == 5\nassert solution.numOfWays([3, 9, 4]) == 0\nassert solution.numOfWays([9, 3, 4, 6, 8, 2, 1, 10]) == 69\nassert solution.numOfWays([6, 2, 5, 7, 3, 4, 8, 10]) == 34\nassert solution.numOfWays([2, 7]) == 0\nassert solution.numOfWays([1, 8, 5]) == 0\nassert solution.numOfWays([6, 9, 4, 2, 3, 8, 7]) == 19\nassert solution.numOfWays([10, 9, 1, 7, 3, 6, 8, 2, 4, 5]) == 23\nassert solution.numOfWays([8, 9, 2, 10, 1, 4, 5, 3]) == 167\nassert solution.numOfWays([4, 1, 3, 8, 6, 10, 9, 5, 2, 7]) == 1679\nassert solution.numOfWays([1, 9, 7]) == 0\nassert solution.numOfWays([2, 5, 3, 7]) == 1\nassert solution.numOfWays([10, 6]) == 0\nassert solution.numOfWays([4, 7, 8, 2, 6, 10, 9]) == 23\nassert solution.numOfWays([9, 7, 2, 1, 8, 3]) == 7\nassert solution.numOfWays([5, 4, 10, 6, 3, 2, 1, 8]) == 34\nassert solution.numOfWays([3, 6, 5, 4, 9, 1, 8, 10, 7, 2]) == 1619\nassert solution.numOfWays([1, 9, 3, 10, 8, 4, 6, 5]) == 5\nassert solution.numOfWays([4, 6, 2, 8, 1, 5]) == 19\nassert solution.numOfWays([7, 5, 4, 6, 3, 8, 1, 10, 9, 2]) == 419\nassert solution.numOfWays([1, 10, 4, 8, 7, 2, 3, 9, 6]) == 44\nassert solution.numOfWays([8, 9, 6]) == 1\nassert solution.numOfWays([6, 5, 4, 2, 8, 3, 7, 10, 9]) == 209\nassert solution.numOfWays([1, 8, 10, 5, 9, 7]) == 5\nassert solution.numOfWays([7, 10, 6]) == 1\nassert solution.numOfWays([7, 9, 6, 8, 1, 2, 4]) == 14\nassert solution.numOfWays([3, 8, 7]) == 0\nassert solution.numOfWays([10, 2, 3, 4, 8, 7]) == 0\nassert solution.numOfWays([8, 9]) == 0\nassert solution.numOfWays([5, 10, 3]) == 1\nassert solution.numOfWays([6, 5, 8, 3, 1, 4, 7]) == 29\nassert solution.numOfWays([9, 3, 4]) == 0\nassert solution.numOfWays([1, 2, 3, 4, 6, 9, 7, 5, 10, 8]) == 14\nassert solution.numOfWays([3, 8, 6]) == 0\nassert solution.numOfWays([2, 5, 1, 10]) == 2\nassert solution.numOfWays([8, 5]) == 0\nassert solution.numOfWays([6, 4, 1, 5, 3, 8, 2, 9]) == 83\nassert solution.numOfWays([3, 5, 10, 8]) == 0\nassert solution.numOfWays([4, 5, 2, 1, 8]) == 5\nassert solution.numOfWays([4, 2, 10, 5]) == 2\nassert solution.numOfWays([6, 10, 2, 8, 3, 1, 7, 4]) == 104\nassert solution.numOfWays([4, 7, 10, 8, 2, 1, 6, 9]) == 83\nassert solution.numOfWays([3, 6, 8, 2]) == 2\nassert solution.numOfWays([8, 3, 7, 2]) == 1\nassert solution.numOfWays([9, 1, 2, 10, 8, 4, 7, 6]) == 6\nassert solution.numOfWays([5, 2, 1, 7, 8, 10, 4, 3, 6]) == 629\nassert solution.numOfWays([10, 2, 1, 9, 3]) == 2\nassert solution.numOfWays([10, 4, 6, 1]) == 1\nassert solution.numOfWays([2, 8, 5, 3, 9, 4, 7, 10, 6]) == 125\nassert solution.numOfWays([1, 9, 2, 7, 4, 6, 8]) == 2\nassert solution.numOfWays([8, 10, 5, 9, 1, 2, 6, 4, 3, 7]) == 539\nassert solution.numOfWays([3, 2, 7, 10, 9, 5, 8, 4, 6]) == 319\nassert solution.numOfWays([8, 4, 9, 2, 3, 7, 10, 6, 5, 1]) == 1439\nassert solution.numOfWays([2, 5, 1, 9, 7]) == 3\nassert solution.numOfWays([1, 6, 4]) == 0\nassert solution.numOfWays([2, 3, 7, 8, 6, 4, 10]) == 5\nassert solution.numOfWays([7, 3, 9, 4, 10, 5, 2, 1]) == 125\nassert solution.numOfWays([2, 1, 8]) == 1\nassert solution.numOfWays([4, 8, 5, 10, 2, 1, 3, 7]) == 209\nassert solution.numOfWays([7, 6, 1]) == 0\nassert solution.numOfWays([5, 10, 7, 4, 2, 1, 9, 3]) == 69\nassert solution.numOfWays([9, 7, 3, 6]) == 0\nassert solution.numOfWays([10, 1, 4, 5, 7, 6]) == 0\nassert solution.numOfWays([5, 8, 7, 1, 10, 9, 4, 3]) == 104\nassert solution.numOfWays([3, 10, 2, 9, 8, 4]) == 4\nassert solution.numOfWays([6, 3, 10, 1]) == 2\nassert solution.numOfWays([6, 5, 10]) == 1\nassert solution.numOfWays([2, 4]) == 0\nassert solution.numOfWays([2, 3, 6, 7, 1, 10, 8]) == 5",
  "inefficient_solution": "class Solution:\n    def numOfWays(self, nums: List[int]) -> int:\n        def dfs(nums, memo):\n            if len(nums) < 2:\n                return 1\n            if (len(nums), nums[0]) in memo:\n                return memo[(len(nums), nums[0])]\n            left = [x for x in nums if x < nums[0]]\n            right = [x for x in nums if x > nums[0]]\n            m, n = len(left), len(right)\n            a, b = dfs(left, memo), dfs(right, memo)\n            ans = (((c[m + n][m] * a) % mod) * b) % mod\n            memo[(len(nums), nums[0])] = ans\n            return ans\n\n        n = len(nums)\n        mod = 10**9 + 7\n        c = [[[0 for _ in range(n)] for _ in range(n)] for _ in range(n)]\n        c[0][0][0] = 1\n        for i in range(1, n):\n            for j in range(i):\n                for k in range(j + 1):\n                    c[i][j][k] = (c[i - 1][j][k] + c[i - 1][j - 1][k] + c[i - 1][j][k - 1]) % mod\n        return (dfs(nums, {}) - 1 + mod) % mod",
  "is_python": true
}