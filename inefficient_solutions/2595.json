{
  "problem_idx": 2595,
  "task_name": "Number of Even and Odd Bits",
  "markdown_description": "\nYou are given a **positive** integer `n`.\n\n\nLet `even` denote the number of even indices in the binary representation of `n` (**0-indexed**) with value `1`.\n\n\nLet `odd` denote the number of odd indices in the binary representation of `n` (**0-indexed**) with value `1`.\n\n\nReturn *an integer array* `answer` *where* `answer = [even, odd]`.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** n = 17\n**Output:** [2,0]\n**Explanation:** The binary representation of 17 is 10001. \nIt contains 1 on the 0th and 4th indices. \nThere are 2 even and 0 odd indices.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** n = 2\n**Output:** [0,1]\n**Explanation:** The binary representation of 2 is 10.\nIt contains 1 on the 1st index. \nThere are 0 even and 1 odd indices.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= n <= 1000`\n\n\n",
  "canonical_solution": "class Solution:\n    def evenOddBit(self, n: int) -> List[int]:\n        mask = 0x5555\n        even = (n & mask).bit_count()\n        odd = (n & ~mask).bit_count()\n        return [even, odd]\n",
  "test_case_generator": "\nimport random\n\nclass Solution:\n    def evenOddBit(self, n):\n        mask = 0x5555\n        even = (n & mask).bit_count()\n        odd = (n & ~mask).bit_count()\n        return [even, odd]\n\ndef generate_test_case():\n    solution = Solution()\n    \n    # Generate a random n\n    n = random.randint(1, 1000)\n\n    # Calculate the expected result using the provided Solution class\n    expected_result = solution.evenOddBit(n)\n\n    return n, expected_result\n\ndef test_generated_test_cases(num_tests):\n    test_case_generator_results = []\n    for i in range(num_tests):\n        n, expected_result = generate_test_case()\n        solution = Solution()\n        assert solution.evenOddBit(n) == expected_result\n        print(f\"assert solution.evenOddBit({n}) == {expected_result}\")\n        test_case_generator_results.append(f\"assert solution.evenOddBit({n}) == {expected_result}\")\n    return test_case_generator_results\n\nif __name__ == \"__main__\":\n    num_tests = 100  # You can change this to generate more test cases\n    test_case_generator_results = test_generated_test_cases(num_tests)\n",
  "test_case": "assert solution.evenOddBit(384) == [1, 1]\nassert solution.evenOddBit(62) == [2, 3]\nassert solution.evenOddBit(95) == [4, 2]\nassert solution.evenOddBit(233) == [2, 3]\nassert solution.evenOddBit(469) == [5, 1]\nassert solution.evenOddBit(622) == [2, 4]\nassert solution.evenOddBit(30) == [2, 2]\nassert solution.evenOddBit(76) == [2, 1]\nassert solution.evenOddBit(761) == [3, 4]\nassert solution.evenOddBit(837) == [4, 1]\nassert solution.evenOddBit(831) == [4, 4]\nassert solution.evenOddBit(1) == [1, 0]\nassert solution.evenOddBit(128) == [0, 1]\nassert solution.evenOddBit(569) == [2, 3]\nassert solution.evenOddBit(133) == [2, 1]\nassert solution.evenOddBit(997) == [4, 3]\nassert solution.evenOddBit(987) == [4, 4]\nassert solution.evenOddBit(209) == [3, 1]\nassert solution.evenOddBit(401) == [3, 1]\nassert solution.evenOddBit(634) == [2, 4]\nassert solution.evenOddBit(348) == [4, 1]\nassert solution.evenOddBit(603) == [3, 3]\nassert solution.evenOddBit(25) == [2, 1]\nassert solution.evenOddBit(269) == [3, 1]\nassert solution.evenOddBit(960) == [2, 2]\nassert solution.evenOddBit(931) == [2, 4]\nassert solution.evenOddBit(616) == [1, 3]\nassert solution.evenOddBit(849) == [4, 1]\nassert solution.evenOddBit(76) == [2, 1]\nassert solution.evenOddBit(607) == [4, 3]\nassert solution.evenOddBit(130) == [0, 2]\nassert solution.evenOddBit(856) == [3, 2]\nassert solution.evenOddBit(294) == [2, 2]\nassert solution.evenOddBit(522) == [0, 3]\nassert solution.evenOddBit(642) == [0, 3]\nassert solution.evenOddBit(577) == [2, 1]\nassert solution.evenOddBit(693) == [3, 3]\nassert solution.evenOddBit(389) == [3, 1]\nassert solution.evenOddBit(757) == [4, 3]\nassert solution.evenOddBit(53) == [3, 1]\nassert solution.evenOddBit(565) == [3, 2]\nassert solution.evenOddBit(235) == [2, 4]\nassert solution.evenOddBit(916) == [3, 2]\nassert solution.evenOddBit(857) == [4, 2]\nassert solution.evenOddBit(874) == [2, 4]\nassert solution.evenOddBit(153) == [2, 2]\nassert solution.evenOddBit(162) == [0, 3]\nassert solution.evenOddBit(393) == [2, 2]\nassert solution.evenOddBit(865) == [3, 2]\nassert solution.evenOddBit(955) == [3, 5]\nassert solution.evenOddBit(208) == [2, 1]\nassert solution.evenOddBit(881) == [4, 2]\nassert solution.evenOddBit(22) == [2, 1]\nassert solution.evenOddBit(904) == [1, 3]\nassert solution.evenOddBit(208) == [2, 1]\nassert solution.evenOddBit(908) == [2, 3]\nassert solution.evenOddBit(893) == [5, 3]\nassert solution.evenOddBit(368) == [3, 1]\nassert solution.evenOddBit(745) == [2, 4]\nassert solution.evenOddBit(650) == [0, 4]\nassert solution.evenOddBit(741) == [3, 3]\nassert solution.evenOddBit(278) == [3, 1]\nassert solution.evenOddBit(984) == [3, 3]\nassert solution.evenOddBit(974) == [3, 4]\nassert solution.evenOddBit(856) == [3, 2]\nassert solution.evenOddBit(833) == [3, 1]\nassert solution.evenOddBit(246) == [3, 3]\nassert solution.evenOddBit(498) == [3, 3]\nassert solution.evenOddBit(571) == [2, 4]\nassert solution.evenOddBit(275) == [3, 1]\nassert solution.evenOddBit(727) == [4, 3]\nassert solution.evenOddBit(809) == [2, 3]\nassert solution.evenOddBit(150) == [2, 2]\nassert solution.evenOddBit(446) == [3, 4]\nassert solution.evenOddBit(254) == [3, 4]\nassert solution.evenOddBit(11) == [1, 2]\nassert solution.evenOddBit(427) == [2, 4]\nassert solution.evenOddBit(668) == [2, 3]\nassert solution.evenOddBit(301) == [3, 2]\nassert solution.evenOddBit(19) == [2, 1]\nassert solution.evenOddBit(33) == [1, 1]\nassert solution.evenOddBit(214) == [3, 2]\nassert solution.evenOddBit(232) == [1, 3]\nassert solution.evenOddBit(437) == [4, 2]\nassert solution.evenOddBit(962) == [2, 3]\nassert solution.evenOddBit(404) == [3, 1]\nassert solution.evenOddBit(125) == [4, 2]\nassert solution.evenOddBit(143) == [2, 3]\nassert solution.evenOddBit(97) == [2, 1]\nassert solution.evenOddBit(607) == [4, 3]\nassert solution.evenOddBit(149) == [3, 1]\nassert solution.evenOddBit(979) == [4, 3]\nassert solution.evenOddBit(725) == [4, 2]\nassert solution.evenOddBit(282) == [2, 2]\nassert solution.evenOddBit(591) == [3, 3]\nassert solution.evenOddBit(497) == [4, 2]\nassert solution.evenOddBit(782) == [2, 3]\nassert solution.evenOddBit(735) == [4, 4]\nassert solution.evenOddBit(260) == [2, 0]\nassert solution.evenOddBit(23) == [3, 1]",
  "inefficient_solution": "class Solution:\n    def evenOddBit(self, n: int) -> List[int]:\n        binary = bin(n)[2:]\n        even = []\n        odd = []\n        even_count = 0\n        odd_count = 0\n        for i, char in enumerate(binary):\n            if char == '1' and i % 2 == 0:\n                even.append(i)\n            elif char == '1' and i % 2 != 0:\n                odd.append(i)\n        for index in even:\n            even_count += 1\n        for index in odd:\n            odd_count += 1\n        return [even_count, odd_count]",
  "is_python": true
}