{
  "problem_idx": 936,
  "task_name": "Stamping The Sequence",
  "markdown_description": "\nYou are given two strings `stamp` and `target`. Initially, there is a string `s` of length `target.length` with all `s[i] == '?'`.\n\n\nIn one turn, you can place `stamp` over `s` and replace every letter in the `s` with the corresponding letter from `stamp`.\n\n\n* For example, if `stamp = \"abc\"` and `target = \"abcba\"`, then `s` is `\"?????\"` initially. In one turn you can:\n\t+ place `stamp` at index `0` of `s` to obtain `\"abc??\"`,\n\t+ place `stamp` at index `1` of `s` to obtain `\"?abc?\"`, or\n\t+ place `stamp` at index `2` of `s` to obtain `\"??abc\"`.\n Note that `stamp` must be fully contained in the boundaries of `s` in order to stamp (i.e., you cannot place `stamp` at index `3` of `s`).\n\n\nWe want to convert `s` to `target` using **at most** `10 * target.length` turns.\n\n\nReturn *an array of the index of the left-most letter being stamped at each turn*. If we cannot obtain `target` from `s` within `10 * target.length` turns, return an empty array.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** stamp = \"abc\", target = \"ababc\"\n**Output:** [0,2]\n**Explanation:** Initially s = \"?????\".\n- Place stamp at index 0 to get \"abc??\".\n- Place stamp at index 2 to get \"ababc\".\n[1,0,2] would also be accepted as an answer, as well as some other answers.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** stamp = \"abca\", target = \"aabcaca\"\n**Output:** [3,0,1]\n**Explanation:** Initially s = \"???????\".\n- Place stamp at index 3 to get \"???abca\".\n- Place stamp at index 0 to get \"abcabca\".\n- Place stamp at index 1 to get \"aabcaca\".\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= stamp.length <= target.length <= 1000`\n* `stamp` and `target` consist of lowercase English letters.\n\n\n",
  "canonical_solution": "class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        m, n = len(stamp), len(target)\n        indeg = [m] * (n - m + 1)\n        q = deque()\n        g = [[] for _ in range(n)]\n        for i in range(n - m + 1):\n            for j, c in enumerate(stamp):\n                if target[i + j] == c:\n                    indeg[i] -= 1\n                    if indeg[i] == 0:\n                        q.append(i)\n                else:\n                    g[i + j].append(i)\n        ans = []\n        vis = [False] * n\n        while q:\n            i = q.popleft()\n            ans.append(i)\n            for j in range(m):\n                if not vis[i + j]:\n                    vis[i + j] = True\n                    for k in g[i + j]:\n                        indeg[k] -= 1\n                        if indeg[k] == 0:\n                            q.append(k)\n        return ans[::-1] if all(vis) else []\n",
  "test_case_generator": "\nimport random\n\nclass Solution:\n    def movesToStamp(self, stamp: str, target: str):\n        m, n = len(stamp), len(target)\n        indeg = [m] * (n - m + 1)\n        q = deque()\n        g = [[] for _ in range(n)]\n        for i in range(n - m + 1):\n            for j, c in enumerate(stamp):\n                if target[i + j] == c:\n                    indeg[i] -= 1\n                    if indeg[i] == 0:\n                        q.append(i)\n                else:\n                    g[i + j].append(i)\n        ans = []\n        vis = [False] * n\n        while q:\n            i = q.popleft()\n            ans.append(i)\n            for j in range(m):\n                if not vis[i + j]:\n                    vis[i + j] = True\n                    for k in g[i + j]:\n                        indeg[k] -= 1\n                        if indeg[k] == 0:\n                            q.append(k)\n        return ans[::-1] if all(vis) else []\n\ndef generate_test_case():\n    solution = Solution()\n    \n    # Generate random strings\n    stamp_length = random.randint(1, 10)\n    stamp = ''.join(random.choices(string.ascii_lowercase, k=stamp_length))\n    \n    target_length = random.randint(stamp_length, 10)\n    target = ''.join(random.choices(string.ascii_lowercase, k=target_length))\n\n    expected_result = solution.movesToStamp(stamp, target)\n\n    return stamp, target, expected_result\n\ndef test_generated_test_cases(num_tests):\n    test_case_generator_results = []\n    for i in range(num_tests):\n        stamp, target, expected_result = generate_test_case()\n        solution = Solution()\n        assert solution.movesToStamp(stamp, target) == expected_result\n        if len(expected_result) != 0:\n            print(f\"assert solution.movesToStamp('{stamp}', '{target}') == {expected_result}\")\n            test_case_generator_results.append(f\"assert solution.movesToStamp('{stamp}', '{target}') == {expected_result}\")\n    return test_case_generator_results\n\nif __name__ == \"__main__\":\n    num_tests = 100\n    test_case_generator_results = test_generated_test_cases(num_tests)\n",
  "test_case": "",
  "inefficient_solution": "class Solution:\n    def movesToStamp(self, stamp, target):\n        m, n = len(stamp), len(target)\n        indeg = [m] * (n - m + 1)\n        q = []\n        g = [[] for _ in range(n)]\n        for i in range(n - m + 1):\n            for j, c in enumerate(stamp):\n                if target[i + j] == c:\n                    indeg[i] -= 1\n                    if indeg[i] == 0:\n                        q.append(i)\n                else:\n                    g[i + j].append(i)\n        ans = []\n        vis = [False] * (n * 100)\n        while True:\n            for i in range(len(q)):\n                stamp_idx = q.pop(0)\n                ans.append(stamp_idx)\n                for j in range(m):\n                    if not vis[stamp_idx * 100 + (j + 1)]:\n                        vis[stamp_idx * 100 + (j + 1)] = True\n                        for k in g[stamp_idx + j]:\n                            indeg[k] -= 1\n                            if indeg[k] == 0:\n                                q.append(k)\n            if all(vis[stamp_idx * 100 + 1] for stamp_idx in range(n - m + 1)):\n                break\n            if not q:\n                return []\n        return ans[::-1]",
  "is_python": true
}