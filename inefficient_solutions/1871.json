{
  "problem_idx": 1871,
  "task_name": "Jump Game VII",
  "markdown_description": "\nYou are given a **0-indexed** binary string `s` and two integers `minJump` and `maxJump`. In the beginning, you are standing at index `0`, which is equal to `'0'`. You can move from index `i` to index `j` if the following conditions are fulfilled:\n\n\n* `i + minJump <= j <= min(i + maxJump, s.length - 1)`, and\n* `s[j] == '0'`.\n\n\nReturn `true` *if you can reach index* `s.length - 1` *in* `s`*, or* `false` *otherwise.*\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** s = \"011010\", minJump = 2, maxJump = 3\n**Output:** true\n**Explanation:**\nIn the first step, move from index 0 to index 3. \nIn the second step, move from index 3 to index 5.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** s = \"01101110\", minJump = 2, maxJump = 3\n**Output:** false\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `2 <= s.length <= 105`\n* `s[i]` is either `'0'` or `'1'`.\n* `s[0] == '0'`\n* `1 <= minJump <= maxJump < s.length`\n\n\n",
  "canonical_solution": "class Solution:\n    def canReach(self, s: str, minJump: int, maxJump: int) -> bool:\n        n = len(s)\n        pre = [0] * (n + 1)\n        pre[1] = 1\n        f = [True] + [False] * (n - 1)\n        for i in range(1, n):\n            if s[i] == \"0\":\n                l, r = max(0, i - maxJump), i - minJump\n                f[i] = l <= r and pre[r + 1] - pre[l] > 0\n            pre[i + 1] = pre[i] + f[i]\n        return f[-1]\n",
  "test_case_generator": "\nimport random\n\nclass Solution:\n    def canReach(self, s: str, minJump: int, maxJump: int) -> bool:\n        n = len(s)\n        pre = [0] * (n + 1)\n        pre[1] = 1\n        f = [True] + [False] * (n - 1)\n        for i in range(1, n):\n            if s[i] == \"0\":\n                l, r = max(0, i - maxJump), i - minJump\n                f[i] = l <= r and pre[r + 1] - pre[l] > 0\n            pre[i + 1] = pre[i] + f[i]\n        return f[-1]\n\ndef generate_test_case():\n    solution = Solution()\n\n    # Generate random binary string\n    s = \"\".join(random.choices([\"0\", \"1\"], k=random.randint(2, 10)))\n\n    # Generate random minJump and maxJump\n    minJump = random.randint(1, len(s) - 1)\n    maxJump = random.randint(minJump, len(s) - 1)\n\n    # Calculate the expected result using the provided Solution class\n    expected_result = solution.canReach(s, minJump, maxJump)\n\n    return s, minJump, maxJump, expected_result\n\ndef test_generated_test_cases(num_tests):\n    test_case_generator_results = []\n    for i in range(num_tests):\n        s, minJump, maxJump, expected_result = generate_test_case()\n        solution = Solution()\n        assert solution.canReach(s, minJump, maxJump) == expected_result\n        print(f\"assert solution.canReach({s}, {minJump}, {maxJump}) == {expected_result}\")\n        test_case_generator_results.append(f\"assert solution.canReach({s}, {minJump}, {maxJump}) == {expected_result}\")\n    return test_case_generator_results\n\nif __name__ == \"__main__\":\n    num_tests = 100  # You can change this to generate more test cases\n    test_case_generator_results = test_generated_test_cases(num_tests)\n",
  "test_case": "assert solution.canReach(11011100, 4, 5) == False\nassert solution.canReach(110000, 4, 5) == True\nassert solution.canReach(10101, 1, 2) == False\nassert solution.canReach(1100, 3, 3) == True\nassert solution.canReach(01101101, 6, 6) == False\nassert solution.canReach(011, 2, 2) == False\nassert solution.canReach(0110, 1, 3) == True\nassert solution.canReach(0101011, 4, 5) == False\nassert solution.canReach(1111100, 4, 6) == True\nassert solution.canReach(01100, 2, 4) == True\nassert solution.canReach(1001100110, 9, 9) == True\nassert solution.canReach(010011101, 7, 7) == False\nassert solution.canReach(0100111110, 3, 3) == False\nassert solution.canReach(01, 1, 1) == False\nassert solution.canReach(00010110, 4, 6) == False\nassert solution.canReach(0010110111, 4, 4) == False\nassert solution.canReach(11010, 4, 4) == True\nassert solution.canReach(1011101000, 7, 7) == False\nassert solution.canReach(00011111, 7, 7) == False\nassert solution.canReach(001011110, 7, 7) == False\nassert solution.canReach(10111111, 5, 6) == False\nassert solution.canReach(100001, 3, 5) == False\nassert solution.canReach(11001, 1, 3) == False\nassert solution.canReach(0100001011, 8, 9) == False\nassert solution.canReach(0111, 2, 2) == False\nassert solution.canReach(11101110, 2, 2) == False\nassert solution.canReach(000, 2, 2) == True\nassert solution.canReach(01, 1, 1) == False\nassert solution.canReach(111, 2, 2) == False\nassert solution.canReach(00, 1, 1) == True\nassert solution.canReach(00001110, 2, 6) == True\nassert solution.canReach(00110010, 2, 5) == True\nassert solution.canReach(01, 1, 1) == False\nassert solution.canReach(100111001, 4, 8) == False\nassert solution.canReach(0000, 1, 1) == True\nassert solution.canReach(1110100110, 1, 7) == True\nassert solution.canReach(1011101111, 3, 7) == False\nassert solution.canReach(111, 2, 2) == False\nassert solution.canReach(0100, 1, 2) == True\nassert solution.canReach(1111011111, 7, 9) == False\nassert solution.canReach(0111100, 2, 2) == False\nassert solution.canReach(0010, 1, 3) == True\nassert solution.canReach(100001010, 1, 5) == True\nassert solution.canReach(01110, 1, 2) == False\nassert solution.canReach(10101, 4, 4) == False\nassert solution.canReach(001110, 1, 1) == False\nassert solution.canReach(000000100, 2, 5) == True\nassert solution.canReach(0001000, 4, 4) == False\nassert solution.canReach(101, 2, 2) == False\nassert solution.canReach(1101100, 4, 5) == False\nassert solution.canReach(0101, 2, 3) == False\nassert solution.canReach(11001, 3, 3) == False\nassert solution.canReach(11100100, 5, 7) == True\nassert solution.canReach(01110101, 7, 7) == False\nassert solution.canReach(000001110, 3, 3) == False\nassert solution.canReach(11110101, 3, 3) == False\nassert solution.canReach(1011001, 4, 5) == False\nassert solution.canReach(101111011, 8, 8) == False\nassert solution.canReach(01000110, 6, 6) == False\nassert solution.canReach(00000, 1, 1) == True\nassert solution.canReach(0111, 2, 3) == False\nassert solution.canReach(010001110, 6, 8) == True\nassert solution.canReach(0010101000, 8, 9) == True\nassert solution.canReach(00101000, 1, 3) == True\nassert solution.canReach(01011, 1, 3) == False\nassert solution.canReach(1111, 1, 1) == False\nassert solution.canReach(00, 1, 1) == True\nassert solution.canReach(11, 1, 1) == False\nassert solution.canReach(111111, 2, 3) == False\nassert solution.canReach(10110000, 4, 7) == True\nassert solution.canReach(11, 1, 1) == False\nassert solution.canReach(101110010, 6, 6) == False\nassert solution.canReach(11001, 3, 4) == False\nassert solution.canReach(11, 1, 1) == False\nassert solution.canReach(011, 2, 2) == False\nassert solution.canReach(0100110, 6, 6) == True\nassert solution.canReach(0011, 1, 2) == False\nassert solution.canReach(101100, 1, 1) == False\nassert solution.canReach(010000111, 2, 8) == False\nassert solution.canReach(10101, 4, 4) == False\nassert solution.canReach(1110, 2, 3) == True\nassert solution.canReach(1010, 1, 3) == True\nassert solution.canReach(010, 2, 2) == True\nassert solution.canReach(0001100, 2, 4) == True\nassert solution.canReach(1111110, 2, 4) == False\nassert solution.canReach(01101, 1, 2) == False\nassert solution.canReach(1010, 1, 3) == True\nassert solution.canReach(010011, 4, 5) == False\nassert solution.canReach(010010, 2, 3) == True\nassert solution.canReach(0111101000, 1, 9) == True\nassert solution.canReach(10111, 4, 4) == False\nassert solution.canReach(1100001, 4, 5) == False\nassert solution.canReach(1001010, 3, 3) == False\nassert solution.canReach(11111, 4, 4) == False\nassert solution.canReach(00000101, 4, 5) == False\nassert solution.canReach(11, 1, 1) == False\nassert solution.canReach(100111, 4, 5) == False\nassert solution.canReach(01, 1, 1) == False\nassert solution.canReach(01, 1, 1) == False\nassert solution.canReach(110, 2, 2) == True",
  "inefficient_solution": "class Solution:\n    def canReach(self, s: str, minJump: int, maxJump: int) -> bool:\n        n = len(s)\n        reachable = [False] * (n * 2)  # double the size of the string\n        for i in range(n):\n            reachable[i * 2] = s[i] == \"0\"  # store the value at each index\n        for i in range(n - 1):  # iterate for each index in the string\n            for j in range(max(0, i - maxJump), i - minJump + 1):  # find reachable indices\n                if reachable[j * 2] and s[i] == \"0\":  # check if reachable and s[i] is '0'\n                    reachable[i * 2 + 1] = True  # mark the current index as reachable\n        return reachable[-1]  # return the last index",
  "is_python": true
}