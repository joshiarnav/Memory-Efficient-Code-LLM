{
  "problem_idx": 995,
  "task_name": "Minimum Number of K Consecutive Bit Flips",
  "markdown_description": "\nYou are given a binary array `nums` and an integer `k`.\n\n\nA **k-bit flip** is choosing a **subarray** of length `k` from `nums` and simultaneously changing every `0` in the subarray to `1`, and every `1` in the subarray to `0`.\n\n\nReturn *the minimum number of **k-bit flips** required so that there is no* `0` *in the array*. If it is not possible, return `-1`.\n\n\nA **subarray** is a **contiguous** part of an array.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** nums = [0,1,0], k = 1\n**Output:** 2\n**Explanation:** Flip nums[0], then flip nums[2].\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** nums = [1,1,0], k = 2\n**Output:** -1\n**Explanation:** No matter how we flip subarrays of size 2, we cannot make the array become [1,1,1].\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** nums = [0,0,0,1,0,1,1,0], k = 3\n**Output:** 3\n**Explanation:** \nFlip nums[0],nums[1],nums[2]: nums becomes [1,1,1,1,0,1,1,0]\nFlip nums[4],nums[5],nums[6]: nums becomes [1,1,1,1,1,0,0,0]\nFlip nums[5],nums[6],nums[7]: nums becomes [1,1,1,1,1,1,1,1]\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= nums.length <= 105`\n* `1 <= k <= nums.length`\n\n\n",
  "canonical_solution": "class Solution:\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        d = [0] * (n + 1)\n        ans = s = 0\n        for i, x in enumerate(nums):\n            s += d[i]\n            if x % 2 == s % 2:\n                if i + k > n:\n                    return -1\n                d[i] += 1\n                d[i + k] -= 1\n                s += 1\n                ans += 1\n        return ans\n",
  "test_case_generator": "\nimport random\n\nclass Solution:\n    def minKBitFlips(self, nums, k):\n        n = len(nums)\n        d = [0] * (n + 1)\n        ans = s = 0\n        for i, x in enumerate(nums):\n            s += d[i]\n            if x % 2 == s % 2:\n                if i + k > n:\n                    return -1\n                d[i] += 1\n                d[i + k] -= 1\n                s += 1\n                ans += 1\n        return ans\n\ndef generate_test_case():\n    solution = Solution()\n    \n    # Generate random numbers list\n    nums = random.choices([0, 1], k=random.randint(1, 10))\n    \n    # Generate a random k value\n    k = random.randint(1, len(nums))\n    \n    # Calculate the expected result using the provided Solution class\n    expected_result = solution.minKBitFlips(nums, k)\n\n    return nums, k, expected_result\n\ndef test_generated_test_cases(num_tests):\n    test_case_generator_results = []\n    for i in range(num_tests):\n        nums, k, expected_result = generate_test_case()\n        solution = Solution()\n        assert solution.minKBitFlips(nums, k) == expected_result\n        if expected_result != -1:\n            print(f\"assert solution.minKBitFlips({nums}, {k}) == {expected_result}\")\n            test_case_generator_results.append(f\"assert solution.minKBitFlips({nums}, {k}) == {expected_result}\") # You can find that we construct the test case in the same format as the example\n        else:\n            print(f\"assert solution.minKBitFlips({nums}, {k}) == -1\") # You can find that we construct the test case in the same format as the example\n            test_case_generator_results.append(f\"assert solution.minKBitFlips({nums}, {k}) == -1\") # You can find that we construct the test case in the same format as the example\n\n    return test_case_generator_results\n\nif __name__ == \"__main__\":\n    num_tests = 100  # You can change this to generate more test cases\n    test_case_generator_results = test_generated_test_cases(num_tests)\n",
  "test_case": "assert solution.minKBitFlips([1], 1) == 0\nassert solution.minKBitFlips([1, 1, 0], 2) == -1\nassert solution.minKBitFlips([0, 1, 0, 1, 0, 1], 6) == -1\nassert solution.minKBitFlips([0, 0, 0, 0, 0, 0, 0, 1], 4) == -1\nassert solution.minKBitFlips([0, 1], 2) == -1\nassert solution.minKBitFlips([1, 0, 1, 1, 0, 1, 1], 1) == 2\nassert solution.minKBitFlips([1, 0, 0], 1) == 2\nassert solution.minKBitFlips([0], 1) == 1\nassert solution.minKBitFlips([1], 1) == 0\nassert solution.minKBitFlips([0, 1, 1, 0, 1, 0, 1, 0], 3) == -1\nassert solution.minKBitFlips([0, 0, 1, 1, 0], 4) == -1\nassert solution.minKBitFlips([0, 0, 0, 1, 0], 3) == -1\nassert solution.minKBitFlips([0, 0], 2) == 1\nassert solution.minKBitFlips([1, 1], 2) == 0\nassert solution.minKBitFlips([1, 0, 1, 1, 1], 2) == -1\nassert solution.minKBitFlips([1], 1) == 0\nassert solution.minKBitFlips([0, 1, 0, 0, 1, 0, 0, 1], 2) == -1\nassert solution.minKBitFlips([1, 0], 1) == 1\nassert solution.minKBitFlips([0, 0, 1, 0, 1, 1, 0], 1) == 4\nassert solution.minKBitFlips([1, 1], 2) == 0\nassert solution.minKBitFlips([0, 0, 0, 0, 1, 0, 1, 0], 3) == 4\nassert solution.minKBitFlips([1], 1) == 0\nassert solution.minKBitFlips([1, 0, 1, 1, 0], 3) == 2\nassert solution.minKBitFlips([0, 1, 0, 1, 1, 0, 1, 0], 6) == -1\nassert solution.minKBitFlips([0, 0, 1, 1, 0, 0], 3) == -1\nassert solution.minKBitFlips([0], 1) == 1\nassert solution.minKBitFlips([0, 0, 1, 0, 0, 1], 6) == -1\nassert solution.minKBitFlips([1, 0, 0, 1], 1) == 2\nassert solution.minKBitFlips([1, 0, 1, 0, 0, 0, 0, 0, 0], 7) == -1\nassert solution.minKBitFlips([0, 0, 1, 1, 0, 1, 0], 6) == -1\nassert solution.minKBitFlips([1, 1, 1, 0, 1, 1, 1, 1], 2) == -1\nassert solution.minKBitFlips([1, 0, 0, 1, 0, 1], 6) == -1\nassert solution.minKBitFlips([1, 0, 0], 1) == 2\nassert solution.minKBitFlips([1, 0, 0, 1, 0, 1, 1, 1], 5) == -1\nassert solution.minKBitFlips([0, 0, 0, 1, 0, 1, 1, 1], 8) == -1\nassert solution.minKBitFlips([0, 0, 1], 3) == -1\nassert solution.minKBitFlips([1, 0, 1], 3) == -1\nassert solution.minKBitFlips([1, 1, 0, 0, 1, 0, 1, 0, 1], 5) == -1\nassert solution.minKBitFlips([1, 1, 0, 0, 0, 0, 0, 0, 0, 0], 9) == -1\nassert solution.minKBitFlips([1, 0, 0, 1, 1, 1, 0, 1, 1, 0], 7) == -1\nassert solution.minKBitFlips([0, 1, 0, 1, 1, 1, 0], 2) == -1\nassert solution.minKBitFlips([0, 1, 0, 1, 0, 0], 6) == -1\nassert solution.minKBitFlips([0, 0, 1], 3) == -1\nassert solution.minKBitFlips([1, 0, 1, 0, 1, 0, 0, 1], 4) == -1\nassert solution.minKBitFlips([1, 1, 1, 1, 1, 0, 0], 4) == -1\nassert solution.minKBitFlips([1], 1) == 0\nassert solution.minKBitFlips([0, 1, 1, 1, 1, 1, 1, 0, 0], 9) == -1\nassert solution.minKBitFlips([0, 1, 1, 1, 0, 1, 1, 0], 7) == -1\nassert solution.minKBitFlips([0, 1, 0, 1, 0], 2) == -1\nassert solution.minKBitFlips([1, 1, 0], 2) == -1\nassert solution.minKBitFlips([1, 0, 0, 0], 1) == 3\nassert solution.minKBitFlips([1, 1, 0, 0, 0, 1, 1, 0, 0], 4) == -1\nassert solution.minKBitFlips([1, 1, 0, 0, 1, 0, 0, 1, 1, 0], 5) == 3\nassert solution.minKBitFlips([0, 0, 0, 0], 1) == 4\nassert solution.minKBitFlips([0, 1, 1, 0, 1, 0], 5) == -1\nassert solution.minKBitFlips([1, 0, 1, 1, 1, 1, 1, 1, 0, 0], 4) == -1\nassert solution.minKBitFlips([0, 1, 0, 1, 1, 0, 0, 0, 1], 7) == -1\nassert solution.minKBitFlips([1, 1, 1], 2) == 0\nassert solution.minKBitFlips([0, 1, 0, 1], 1) == 2\nassert solution.minKBitFlips([0, 1, 1, 1, 1, 1, 0, 1, 0, 1], 10) == -1\nassert solution.minKBitFlips([1, 1, 0, 1, 1, 1, 0, 1, 0], 9) == -1\nassert solution.minKBitFlips([1, 1, 1, 1, 0, 0, 0, 0], 1) == 4\nassert solution.minKBitFlips([0, 1, 0, 1, 0, 0, 0, 1], 5) == -1\nassert solution.minKBitFlips([1, 1, 0, 1, 1], 3) == -1\nassert solution.minKBitFlips([0, 0, 0, 1, 1, 0, 1, 1, 1], 1) == 4\nassert solution.minKBitFlips([0, 0, 0], 1) == 3\nassert solution.minKBitFlips([1, 0, 1, 1], 3) == -1\nassert solution.minKBitFlips([0, 1], 1) == 1\nassert solution.minKBitFlips([0], 1) == 1\nassert solution.minKBitFlips([0, 1, 1, 1, 0, 1], 5) == -1\nassert solution.minKBitFlips([0], 1) == 1\nassert solution.minKBitFlips([0], 1) == 1\nassert solution.minKBitFlips([0], 1) == 1\nassert solution.minKBitFlips([1, 0, 0], 2) == 1\nassert solution.minKBitFlips([0, 1, 1, 1, 1, 0], 2) == 5\nassert solution.minKBitFlips([0, 0, 1, 1, 0], 3) == -1\nassert solution.minKBitFlips([1, 1, 0, 1, 1, 0], 2) == 3\nassert solution.minKBitFlips([1, 0, 0, 0, 0, 0, 1, 0, 1], 8) == -1\nassert solution.minKBitFlips([1, 0, 0, 1, 0], 5) == -1\nassert solution.minKBitFlips([1], 1) == 0\nassert solution.minKBitFlips([1, 1, 0], 3) == -1\nassert solution.minKBitFlips([1, 0, 1, 1], 1) == 1\nassert solution.minKBitFlips([0], 1) == 1\nassert solution.minKBitFlips([1], 1) == 0\nassert solution.minKBitFlips([0, 0, 0, 0, 1, 0], 1) == 5\nassert solution.minKBitFlips([1, 1, 1, 1, 1, 0, 1], 5) == -1\nassert solution.minKBitFlips([1, 0, 0], 1) == 2\nassert solution.minKBitFlips([1, 0, 0, 0], 2) == -1\nassert solution.minKBitFlips([0, 1, 0], 3) == -1\nassert solution.minKBitFlips([0, 1, 1, 1, 0, 1], 6) == -1\nassert solution.minKBitFlips([1], 1) == 0\nassert solution.minKBitFlips([1, 0, 1, 0], 4) == -1\nassert solution.minKBitFlips([1, 0, 0, 1, 1], 5) == -1\nassert solution.minKBitFlips([1, 0, 0, 0, 0, 1, 1, 1], 1) == 4\nassert solution.minKBitFlips([1, 1, 1, 1, 0, 0, 1, 0, 0], 3) == 2\nassert solution.minKBitFlips([1, 0, 0, 1, 1, 0], 3) == -1\nassert solution.minKBitFlips([0, 1, 1, 1, 1], 1) == 1\nassert solution.minKBitFlips([0, 0, 1], 2) == 1\nassert solution.minKBitFlips([1, 1], 1) == 0\nassert solution.minKBitFlips([1, 1, 0, 1, 0, 1], 5) == -1",
  "inefficient_solution": "class Solution:\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\n        max_memory = 2**32 - 1\n        d = [0] * max_memory\n        ans = s = 0\n        for i, x in enumerate(nums):\n            s += d[i]\n            if x % 2 == s % 2:\n                if i + k > max_memory:\n                    return -1\n                d[i] = 1\n                d[i + k] = -1\n                s += 1\n                ans += 1\n                d = [j for j in d]  # allocate new memory\n        return ans",
  "is_python": true
}