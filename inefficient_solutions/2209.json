{
  "problem_idx": 2209,
  "task_name": "Minimum White Tiles After Covering With Carpets",
  "markdown_description": "\nYou are given a **0-indexed binary** string `floor`, which represents the colors of tiles on a floor:\n\n\n* `floor[i] = '0'` denotes that the `ith` tile of the floor is colored **black**.\n* On the other hand, `floor[i] = '1'` denotes that the `ith` tile of the floor is colored **white**.\n\n\nYou are also given `numCarpets` and `carpetLen`. You have `numCarpets` **black** carpets, each of length `carpetLen` tiles. Cover the tiles with the given carpets such that the number of **white** tiles still visible is **minimum**. Carpets may overlap one another.\n\n\nReturn *the **minimum** number of white tiles still visible.*\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2200-2299/2209.Minimum%20White%20Tiles%20After%20Covering%20With%20Carpets/images/ex1-1.png)\n\n```\n\n**Input:** floor = \"10110101\", numCarpets = 2, carpetLen = 2\n**Output:** 2\n**Explanation:** \nThe figure above shows one way of covering the tiles with the carpets such that only 2 white tiles are visible.\nNo other way of covering the tiles with the carpets can leave less than 2 white tiles visible.\n\n```\n\n**Example 2:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2200-2299/2209.Minimum%20White%20Tiles%20After%20Covering%20With%20Carpets/images/ex2.png)\n\n```\n\n**Input:** floor = \"11111\", numCarpets = 2, carpetLen = 3\n**Output:** 0\n**Explanation:** \nThe figure above shows one way of covering the tiles with the carpets such that no white tiles are visible.\nNote that the carpets are able to overlap one another.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= carpetLen <= floor.length <= 1000`\n* `floor[i]` is either `'0'` or `'1'`.\n* `1 <= numCarpets <= 1000`\n\n\n",
  "canonical_solution": "class Solution:\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\n        @cache\n        def dfs(i, j):\n            if i >= n:\n                return 0\n            if floor[i] == '0':\n                return dfs(i + 1, j)\n            if j == 0:\n                return s[-1] - s[i]\n            return min(1 + dfs(i + 1, j), dfs(i + carpetLen, j - 1))\n\n        n = len(floor)\n        s = [0] * (n + 1)\n        for i, c in enumerate(floor):\n            s[i + 1] = s[i] + int(c == '1')\n        ans = dfs(0, numCarpets)\n        dfs.cache_clear()\n        return ans\n",
  "test_case_generator": "\nimport random\n\nclass Solution:\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\n        @cache\n        def dfs(i, j):\n            if i >= n:\n                return 0\n            if floor[i] == '0':\n                return dfs(i + 1, j)\n            if j == 0:\n                return s[-1] - s[i]\n            return min(1 + dfs(i + 1, j), dfs(i + carpetLen, j - 1))\n\n        n = len(floor)\n        s = [0] * (n + 1)\n        for i, c in enumerate(floor):\n            s[i + 1] = s[i] + int(c == '1')\n        ans = dfs(0, numCarpets)\n        dfs.cache_clear()\n        return ans\n\ndef generate_test_case():\n    solution = Solution()\n\n    # Generate floor string\n    floor_len = random.randint(1, 10)\n    floor = ''.join([random.choice(['0', '1']) for _ in range(floor_len)])\n\n    # Generate numCarpets and carpetLen\n    numCarpets = random.randint(1, 10)\n    carpetLen = random.randint(1, floor_len)\n\n    # Calculate the expected result using the provided Solution class\n    expected_result = solution.minimumWhiteTiles(floor, numCarpets, carpetLen)\n\n    return floor, numCarpets, carpetLen, expected_result\n\ndef test_generated_test_cases(num_tests):\n    test_case_generator_results = []\n    for i in range(num_tests):\n        floor, numCarpets, carpetLen, expected_result = generate_test_case()\n        solution = Solution()\n        assert solution.minimumWhiteTiles(floor, numCarpets, carpetLen) == expected_result\n        print(f'assert solution.minimumWhiteTiles(\"{floor}\", {numCarpets}, {carpetLen}) == {expected_result}')\n        test_case_generator_results.append(f'assert solution.minimumWhiteTiles(\"{floor}\", {numCarpets}, {carpetLen}) == {expected_result}')\n    return test_case_generator_results\n\nif __name__ == \"__main__\":\n    num_tests = 100  # You can change this to generate more test cases\n    test_case_generator_results = test_generated_test_cases(num_tests)\n",
  "test_case": "assert solution.minimumWhiteTiles(\"101\", 6, 3) == 0\nassert solution.minimumWhiteTiles(\"111110\", 8, 3) == 0\nassert solution.minimumWhiteTiles(\"0000\", 6, 4) == 0\nassert solution.minimumWhiteTiles(\"0100\", 8, 3) == 0\nassert solution.minimumWhiteTiles(\"00\", 9, 1) == 0\nassert solution.minimumWhiteTiles(\"11100010\", 6, 7) == 0\nassert solution.minimumWhiteTiles(\"11111101\", 4, 4) == 0\nassert solution.minimumWhiteTiles(\"101110\", 8, 3) == 0\nassert solution.minimumWhiteTiles(\"01\", 9, 2) == 0\nassert solution.minimumWhiteTiles(\"0100\", 7, 3) == 0\nassert solution.minimumWhiteTiles(\"110110111\", 8, 1) == 0\nassert solution.minimumWhiteTiles(\"1110011101\", 10, 6) == 0\nassert solution.minimumWhiteTiles(\"01\", 2, 1) == 0\nassert solution.minimumWhiteTiles(\"0\", 3, 1) == 0\nassert solution.minimumWhiteTiles(\"10000\", 3, 2) == 0\nassert solution.minimumWhiteTiles(\"100111101\", 6, 3) == 0\nassert solution.minimumWhiteTiles(\"11011\", 5, 1) == 0\nassert solution.minimumWhiteTiles(\"100111\", 6, 5) == 0\nassert solution.minimumWhiteTiles(\"0100100000\", 9, 8) == 0\nassert solution.minimumWhiteTiles(\"0011\", 5, 4) == 0\nassert solution.minimumWhiteTiles(\"0011000100\", 10, 9) == 0\nassert solution.minimumWhiteTiles(\"0010100\", 9, 6) == 0\nassert solution.minimumWhiteTiles(\"11\", 2, 1) == 0\nassert solution.minimumWhiteTiles(\"1111101\", 3, 5) == 0\nassert solution.minimumWhiteTiles(\"01011111\", 3, 7) == 0\nassert solution.minimumWhiteTiles(\"11111100\", 7, 7) == 0\nassert solution.minimumWhiteTiles(\"10\", 8, 1) == 0\nassert solution.minimumWhiteTiles(\"0101000001\", 3, 4) == 0\nassert solution.minimumWhiteTiles(\"11010010\", 7, 3) == 0\nassert solution.minimumWhiteTiles(\"0000111\", 4, 2) == 0\nassert solution.minimumWhiteTiles(\"11100\", 3, 4) == 0\nassert solution.minimumWhiteTiles(\"111111\", 3, 1) == 3\nassert solution.minimumWhiteTiles(\"1100100100\", 9, 2) == 0\nassert solution.minimumWhiteTiles(\"011\", 3, 3) == 0\nassert solution.minimumWhiteTiles(\"010111111\", 4, 4) == 0\nassert solution.minimumWhiteTiles(\"0\", 1, 1) == 0\nassert solution.minimumWhiteTiles(\"00\", 8, 2) == 0\nassert solution.minimumWhiteTiles(\"1101111011\", 7, 6) == 0\nassert solution.minimumWhiteTiles(\"00001\", 5, 2) == 0\nassert solution.minimumWhiteTiles(\"100\", 8, 1) == 0\nassert solution.minimumWhiteTiles(\"101010\", 10, 6) == 0\nassert solution.minimumWhiteTiles(\"00110111\", 1, 8) == 0\nassert solution.minimumWhiteTiles(\"1010001\", 6, 5) == 0\nassert solution.minimumWhiteTiles(\"1\", 4, 1) == 0\nassert solution.minimumWhiteTiles(\"01001\", 8, 5) == 0\nassert solution.minimumWhiteTiles(\"1111001000\", 8, 2) == 0\nassert solution.minimumWhiteTiles(\"1111011101\", 10, 6) == 0\nassert solution.minimumWhiteTiles(\"101\", 8, 2) == 0\nassert solution.minimumWhiteTiles(\"100\", 2, 1) == 0\nassert solution.minimumWhiteTiles(\"001\", 1, 3) == 0\nassert solution.minimumWhiteTiles(\"1110111\", 9, 4) == 0\nassert solution.minimumWhiteTiles(\"100101\", 5, 1) == 0\nassert solution.minimumWhiteTiles(\"011010\", 2, 1) == 1\nassert solution.minimumWhiteTiles(\"0\", 1, 1) == 0\nassert solution.minimumWhiteTiles(\"1\", 6, 1) == 0\nassert solution.minimumWhiteTiles(\"000011\", 7, 2) == 0\nassert solution.minimumWhiteTiles(\"00101111\", 8, 1) == 0\nassert solution.minimumWhiteTiles(\"1000101101\", 7, 5) == 0\nassert solution.minimumWhiteTiles(\"111001\", 6, 2) == 0\nassert solution.minimumWhiteTiles(\"10110001\", 5, 6) == 0\nassert solution.minimumWhiteTiles(\"0101101010\", 7, 10) == 0\nassert solution.minimumWhiteTiles(\"10101111\", 10, 7) == 0\nassert solution.minimumWhiteTiles(\"1000\", 1, 1) == 0\nassert solution.minimumWhiteTiles(\"1110000001\", 5, 9) == 0\nassert solution.minimumWhiteTiles(\"1001010\", 6, 4) == 0\nassert solution.minimumWhiteTiles(\"00110\", 5, 3) == 0\nassert solution.minimumWhiteTiles(\"0\", 10, 1) == 0\nassert solution.minimumWhiteTiles(\"10\", 3, 1) == 0\nassert solution.minimumWhiteTiles(\"110011\", 7, 5) == 0\nassert solution.minimumWhiteTiles(\"001010100\", 6, 4) == 0\nassert solution.minimumWhiteTiles(\"010\", 7, 2) == 0\nassert solution.minimumWhiteTiles(\"001001110\", 2, 9) == 0\nassert solution.minimumWhiteTiles(\"110110\", 9, 4) == 0\nassert solution.minimumWhiteTiles(\"1111\", 9, 4) == 0\nassert solution.minimumWhiteTiles(\"00\", 6, 2) == 0\nassert solution.minimumWhiteTiles(\"1\", 4, 1) == 0\nassert solution.minimumWhiteTiles(\"0001\", 10, 4) == 0\nassert solution.minimumWhiteTiles(\"11000010\", 3, 4) == 0\nassert solution.minimumWhiteTiles(\"001\", 8, 1) == 0\nassert solution.minimumWhiteTiles(\"10\", 7, 1) == 0\nassert solution.minimumWhiteTiles(\"000110000\", 5, 7) == 0\nassert solution.minimumWhiteTiles(\"1011001\", 7, 5) == 0\nassert solution.minimumWhiteTiles(\"010\", 2, 3) == 0\nassert solution.minimumWhiteTiles(\"0100110\", 8, 4) == 0\nassert solution.minimumWhiteTiles(\"101110\", 8, 4) == 0\nassert solution.minimumWhiteTiles(\"0\", 7, 1) == 0\nassert solution.minimumWhiteTiles(\"1\", 8, 1) == 0\nassert solution.minimumWhiteTiles(\"0\", 4, 1) == 0\nassert solution.minimumWhiteTiles(\"1010\", 6, 1) == 0\nassert solution.minimumWhiteTiles(\"000\", 10, 3) == 0\nassert solution.minimumWhiteTiles(\"100010\", 4, 5) == 0\nassert solution.minimumWhiteTiles(\"100010\", 1, 3) == 1\nassert solution.minimumWhiteTiles(\"00000\", 2, 1) == 0\nassert solution.minimumWhiteTiles(\"011011111\", 9, 9) == 0\nassert solution.minimumWhiteTiles(\"0\", 4, 1) == 0\nassert solution.minimumWhiteTiles(\"00000001\", 5, 8) == 0\nassert solution.minimumWhiteTiles(\"010000\", 6, 1) == 0\nassert solution.minimumWhiteTiles(\"000101\", 9, 1) == 0\nassert solution.minimumWhiteTiles(\"01110011\", 1, 2) == 3\nassert solution.minimumWhiteTiles(\"1\", 7, 1) == 0",
  "inefficient_solution": "class Solution:\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\n        n = len(floor)\n        tiles = [0] * n\n        for i in range(n):\n            tiles[i] = int(floor[i] == '1')\n        carpets = [0] * (n + 1)\n        for i, tile in enumerate(tiles):\n            carpets[i+1] = carpets[i] + tile\n        overlaps = [[0] * (n + 1) for _ in range(numCarpets + 1)]\n        for i in range(numCarpets):\n            for j in range(carpetLen, n + 1):\n                overlaps[i+1][j] = overlaps[i][j - carpetLen] + 1\n        white_tiles = [0] * (n + 1)\n        for i in range(1, n + 1):\n            white_tiles[i] = s[-1] - s[i - 1]\n        min_white = float('inf')\n        for i in range(numCarpets + 1):\n            for j in range(carpetLen, n + 1):\n                min_white = min(min_white, white_tiles[j] + overlaps[i][j])\n        return min_white",
  "is_python": true
}