{
  "problem_idx": 2002,
  "task_name": "Maximum Product of the Length of Two Palindromic Subsequences",
  "markdown_description": "\nGiven a string `s`, find two **disjoint palindromic subsequences** of `s` such that the **product** of their lengths is **maximized**. The two subsequences are **disjoint** if they do not both pick a character at the same index.\n\n\nReturn *the **maximum** possible **product** of the lengths of the two palindromic subsequences*.\n\n\nA **subsequence** is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters. A string is **palindromic** if it reads the same forward and backward.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![example-1](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2000-2099/2002.Maximum%20Product%20of%20the%20Length%20of%20Two%20Palindromic%20Subsequences/images/two-palindromic-subsequences.png)\n\n```\n\n**Input:** s = \"leetcodecom\"\n**Output:** 9\n**Explanation**: An optimal solution is to choose \"ete\" for the 1st subsequence and \"cdc\" for the 2nd subsequence.\nThe product of their lengths is: 3 * 3 = 9.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** s = \"bb\"\n**Output:** 1\n**Explanation**: An optimal solution is to choose \"b\" (the first character) for the 1st subsequence and \"b\" (the second character) for the 2nd subsequence.\nThe product of their lengths is: 1 * 1 = 1.\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** s = \"accbcaxxcxx\"\n**Output:** 25\n**Explanation**: An optimal solution is to choose \"accca\" for the 1st subsequence and \"xxcxx\" for the 2nd subsequence.\nThe product of their lengths is: 5 * 5 = 25.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `2 <= s.length <= 12`\n* `s` consists of lowercase English letters only.\n\n\n",
  "canonical_solution": "class Solution:\n    def maxProduct(self, s: str) -> int:\n        n = len(s)\n        p = [True] * (1 << n)\n        for k in range(1, 1 << n):\n            i, j = 0, n - 1\n            while i < j:\n                while i < j and (k >> i & 1) == 0:\n                    i += 1\n                while i < j and (k >> j & 1) == 0:\n                    j -= 1\n                if i < j and s[i] != s[j]:\n                    p[k] = False\n                    break\n                i, j = i + 1, j - 1\n        ans = 0\n        for i in range(1, 1 << n):\n            if p[i]:\n                mx = ((1 << n) - 1) ^ i\n                j = mx\n                a = i.bit_count()\n                while j:\n                    if p[j]:\n                        b = j.bit_count()\n                        ans = max(ans, a * b)\n                    j = (j - 1) & mx\n        return ans\n",
  "test_case_generator": "\ndef generate_test_case():\n    # Generate a random string\n    s_length = random.randint(2, 12)\n    s = ''.join(random.choices(string.ascii_lowercase, k=s_length))\n    \n    # Calculate the expected result using the provided Solution class\n    solution = Solution()\n    expected_result = solution.maxProduct(s)\n\n    return s, expected_result\n\ndef test_generated_test_cases(num_tests):\n    test_case_generator_results = []\n    for i in range(num_tests):\n        s, expected_result = generate_test_case()\n        solution = Solution()\n        assert solution.maxProduct(s) == expected_result\n        test_case_generator_results.append(f\"assert solution.maxProduct('{s}') == {expected_result}\")\n    return test_case_generator_results\n\nif __name__ == \"__main__\":\n    num_tests = 100  # You can change this to generate more test cases\n    test_case_generator_results = test_generated_test_cases(num_tests)\n",
  "test_case": "assert solution.maxProduct('mbbc') == 2\nassert solution.maxProduct('bzl') == 1\nassert solution.maxProduct('bedir') == 1\nassert solution.maxProduct('fs') == 1\nassert solution.maxProduct('ly') == 1\nassert solution.maxProduct('eytmc') == 1\nassert solution.maxProduct('fei') == 1\nassert solution.maxProduct('hkv') == 1\nassert solution.maxProduct('ehpwvy') == 1\nassert solution.maxProduct('kodzbtaqznfz') == 3\nassert solution.maxProduct('uohtbvisdmve') == 3\nassert solution.maxProduct('gfsbshjlsnjx') == 9\nassert solution.maxProduct('dzt') == 1\nassert solution.maxProduct('gqgvvjlhwxqf') == 8\nassert solution.maxProduct('gs') == 1\nassert solution.maxProduct('gnbxjjuuo') == 4\nassert solution.maxProduct('snrryxssrrbi') == 15\nassert solution.maxProduct('yphyeykrchop') == 15\nassert solution.maxProduct('nzjb') == 1\nassert solution.maxProduct('lvc') == 1\nassert solution.maxProduct('hjctyusyvm') == 3\nassert solution.maxProduct('sftdk') == 1\nassert solution.maxProduct('eci') == 1\nassert solution.maxProduct('ytyevzhvbv') == 9\nassert solution.maxProduct('ujctl') == 1\nassert solution.maxProduct('vlmvfuothf') == 9\nassert solution.maxProduct('zawvat') == 3\nassert solution.maxProduct('iq') == 1\nassert solution.maxProduct('ounpvmmuuzhd') == 6\nassert solution.maxProduct('kociwouwsoi') == 15\nassert solution.maxProduct('jsimquyulice') == 9\nassert solution.maxProduct('rirbk') == 3\nassert solution.maxProduct('zupgeipz') == 9\nassert solution.maxProduct('xvxnimsgdd') == 6\nassert solution.maxProduct('ihkhrgav') == 3\nassert solution.maxProduct('bbc') == 2\nassert solution.maxProduct('uffrkhftcc') == 6\nassert solution.maxProduct('nasnpi') == 3\nassert solution.maxProduct('hfttlii') == 4\nassert solution.maxProduct('zgqrnkzn') == 9\nassert solution.maxProduct('adso') == 1\nassert solution.maxProduct('swavnxgrtxfl') == 3\nassert solution.maxProduct('qxhchjcgvot') == 6\nassert solution.maxProduct('nujinsbn') == 3\nassert solution.maxProduct('ainvjewdizo') == 3\nassert solution.maxProduct('rbxbv') == 3\nassert solution.maxProduct('ddqgjdkrpa') == 3\nassert solution.maxProduct('wpevqunsdlq') == 3\nassert solution.maxProduct('rifaoyspnp') == 3\nassert solution.maxProduct('nbkhqqc') == 2\nassert solution.maxProduct('tfcvnbtell') == 6\nassert solution.maxProduct('pnakqocjjfyc') == 6\nassert solution.maxProduct('zftar') == 1\nassert solution.maxProduct('hjekoft') == 1\nassert solution.maxProduct('nutitr') == 3\nassert solution.maxProduct('gyugudf') == 6\nassert solution.maxProduct('wgbgghbmvmq') == 12\nassert solution.maxProduct('hbnja') == 1\nassert solution.maxProduct('inafmvaypfeh') == 9\nassert solution.maxProduct('ll') == 1\nassert solution.maxProduct('ftntwfak') == 9\nassert solution.maxProduct('xikltprcriz') == 9\nassert solution.maxProduct('rypxcg') == 1\nassert solution.maxProduct('jfbvyjl') == 3\nassert solution.maxProduct('foywj') == 1\nassert solution.maxProduct('gpgejyzr') == 3\nassert solution.maxProduct('jzxvafckb') == 1\nassert solution.maxProduct('ooqkatvptgqs') == 10\nassert solution.maxProduct('xoswxiqsfw') == 9\nassert solution.maxProduct('jbqnr') == 1\nassert solution.maxProduct('vzxaojnuyjn') == 9\nassert solution.maxProduct('jnhmeflkqs') == 1\nassert solution.maxProduct('fcphehylg') == 3\nassert solution.maxProduct('duuyz') == 2\nassert solution.maxProduct('lvxkaurggent') == 2\nassert solution.maxProduct('ksrchdp') == 1\nassert solution.maxProduct('rdpdmn') == 3\nassert solution.maxProduct('xqqun') == 2\nassert solution.maxProduct('pckqwbcdcvks') == 9\nassert solution.maxProduct('bigbt') == 3\nassert solution.maxProduct('yefesuxl') == 3\nassert solution.maxProduct('xwphxj') == 3\nassert solution.maxProduct('xhrrwz') == 2\nassert solution.maxProduct('ustbsvs') == 3\nassert solution.maxProduct('owbtlovxji') == 3\nassert solution.maxProduct('lux') == 1\nassert solution.maxProduct('vvzmsavi') == 3\nassert solution.maxProduct('qmcu') == 1\nassert solution.maxProduct('xliqf') == 1\nassert solution.maxProduct('zqxopazo') == 9\nassert solution.maxProduct('krmzc') == 1\nassert solution.maxProduct('tldvdwtzy') == 9\nassert solution.maxProduct('oufqmswlk') == 1\nassert solution.maxProduct('nar') == 1\nassert solution.maxProduct('kdapahlqm') == 3\nassert solution.maxProduct('eysb') == 1\nassert solution.maxProduct('ikhzoqgnfaz') == 3\nassert solution.maxProduct('flfcvfz') == 3\nassert solution.maxProduct('plvccwylyc') == 12\nassert solution.maxProduct('jahhdncztj') == 6",
  "inefficient_solution": "class Solution:\n    def maxProduct(self, s: str) -> int:\n        n = len(s)\n        p = [[[False for _ in range(26)] for _ in range(26)] for _ in range(1 << n)]\n        for k in range(1, 1 << n):\n            i, j = 0, n - 1\n            while i < j:\n                while i < j and (k >> i & 1) == 0:\n                    i += 1\n                while i < j and (k >> j & 1) == 0:\n                    j -= 1\n                if i < j and s[i] != s[j]:\n                    p[k][0][0] = False\n                    break\n                i, j = i + 1, j - 1\n        dp = [[0 for _ in range(26)] for _ in range(1 << n)]\n        for i in range(1, 1 << n):\n            for c in range(26):\n                if not p[i][c][c]:\n                    continue\n                if i == 1:\n                    dp[i][c] = 1\n                else:\n                    for j in range(i):\n                        if j > 0 and (i >> j - 1 & 1) == 0:\n                            continue\n                        if p[i - (1 << (j - 1))][c][ord(s[j - 1]) - ord('a')]:\n                            dp[i][c] = max(dp[i][c], dp[i - (1 << (j - 1))][c] + 1)\n        ans = 0\n        for i in range(1, 1 << n):\n            for c1 in range(26):\n                if not p[i][c1][c1]:\n                    continue\n                for j in range(1, 1 << n):\n                    for c2 in range(26):\n                        if not p[j][c2][c2]:\n                            continue\n                        if i & j:\n                            continue\n                        if p[i | j][c1][c2]:\n                            ans = max(ans, dp[i][c1] * dp[j][c2])\n        return ans",
  "is_python": true
}