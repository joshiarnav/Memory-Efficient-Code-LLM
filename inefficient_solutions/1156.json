{
  "problem_idx": 1156,
  "task_name": "Swap For Longest Repeated Character Substring",
  "markdown_description": "\nYou are given a string `text`. You can swap two of the characters in the `text`.\n\n\nReturn *the length of the longest substring with repeated characters*.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** text = \"ababa\"\n**Output:** 3\n**Explanation:** We can swap the first 'b' with the last 'a', or the last 'b' with the first 'a'. Then, the longest repeated character substring is \"aaa\" with length 3.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** text = \"aaabaaa\"\n**Output:** 6\n**Explanation:** Swap 'b' with the last 'a' (or the first 'a'), and we get longest repeated character substring \"aaaaaa\" with length 6.\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** text = \"aaaaa\"\n**Output:** 5\n**Explanation:** No need to swap, longest repeated character substring is \"aaaaa\" with length is 5.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= text.length <= 2 * 104`\n* `text` consist of lowercase English characters only.\n\n\n",
  "canonical_solution": "class Solution:\n    def maxRepOpt1(self, text: str) -> int:\n        cnt = Counter(text)\n        n = len(text)\n        ans = i = 0\n        while i < n:\n            j = i\n            while j < n and text[j] == text[i]:\n                j += 1\n            l = j - i\n            k = j + 1\n            while k < n and text[k] == text[i]:\n                k += 1\n            r = k - j - 1\n            ans = max(ans, min(l + r + 1, cnt[text[i]]))\n            i = j\n        return ans\n",
  "test_case_generator": "\nimport random\n\n# Test case generator\ndef generate_test_case():\n    solution = Solution()\n    \n    # Generate random text with lowercase English characters\n    text = \"\".join(random.choices(string.ascii_lowercase, k=random.randint(1, 11)))\n\n    # Calculate the expected result using the provided Solution class\n    expected_result = solution.maxRepOpt1(text)\n\n    return text, expected_result\n\ndef test_generated_test_cases(num_tests):\n    test_case_generator_results = []\n    for i in range(num_tests):\n        text, expected_result = generate_test_case()\n        solution = Solution()\n        assert solution.maxRepOpt1(text) == expected_result\n        print(f\"assert solution.maxRepOpt1({text}) == {expected_result}\")\n        test_case_generator_results.append(f\"assert solution.maxRepOpt1({text}) == {expected_result}\") # You can find that we construct the test case in the same format as the example\n    return test_case_generator_results\n\nif __name__ == \"__main__\":\n    num_tests = 100  # You can change this to generate more test cases\n    test_case_generator_results = test_generated_test_cases(num_tests)\n",
  "test_case": "assert solution.maxRepOpt1(aq) == 1\nassert solution.maxRepOpt1(mbescb) == 2\nassert solution.maxRepOpt1(etpcz) == 1\nassert solution.maxRepOpt1(fd) == 1\nassert solution.maxRepOpt1(qeghqetutix) == 2\nassert solution.maxRepOpt1(xlfa) == 1\nassert solution.maxRepOpt1(ndmys) == 1\nassert solution.maxRepOpt1(jfzx) == 1\nassert solution.maxRepOpt1(j) == 1\nassert solution.maxRepOpt1(kwtack) == 2\nassert solution.maxRepOpt1(bonh) == 1\nassert solution.maxRepOpt1(cixjiqdv) == 2\nassert solution.maxRepOpt1(gbqlseudvp) == 1\nassert solution.maxRepOpt1(m) == 1\nassert solution.maxRepOpt1(kn) == 1\nassert solution.maxRepOpt1(pqi) == 1\nassert solution.maxRepOpt1(gthnvu) == 1\nassert solution.maxRepOpt1(slufn) == 1\nassert solution.maxRepOpt1(jmwr) == 1\nassert solution.maxRepOpt1(wacljyllsca) == 3\nassert solution.maxRepOpt1(nzvamphkjjn) == 2\nassert solution.maxRepOpt1(daikiaqejv) == 2\nassert solution.maxRepOpt1(w) == 1\nassert solution.maxRepOpt1(pms) == 1\nassert solution.maxRepOpt1(xcjgsyn) == 1\nassert solution.maxRepOpt1(kuqmu) == 2\nassert solution.maxRepOpt1(an) == 1\nassert solution.maxRepOpt1(hbyj) == 1\nassert solution.maxRepOpt1(wfoh) == 1\nassert solution.maxRepOpt1(rv) == 1\nassert solution.maxRepOpt1(efksqbazzx) == 2\nassert solution.maxRepOpt1(ptq) == 1\nassert solution.maxRepOpt1(nyrhuva) == 1\nassert solution.maxRepOpt1(y) == 1\nassert solution.maxRepOpt1(mhab) == 1\nassert solution.maxRepOpt1(xbedl) == 1\nassert solution.maxRepOpt1(amkdbvy) == 1\nassert solution.maxRepOpt1(wh) == 1\nassert solution.maxRepOpt1(hu) == 1\nassert solution.maxRepOpt1(yoqf) == 1\nassert solution.maxRepOpt1(nvdndaacr) == 2\nassert solution.maxRepOpt1(dcifda) == 2\nassert solution.maxRepOpt1(rhnoiynouz) == 2\nassert solution.maxRepOpt1(xfyckumhbi) == 1\nassert solution.maxRepOpt1(x) == 1\nassert solution.maxRepOpt1(gbrklpranye) == 2\nassert solution.maxRepOpt1(iasgzvnmt) == 1\nassert solution.maxRepOpt1(ki) == 1\nassert solution.maxRepOpt1(fu) == 1\nassert solution.maxRepOpt1(bgibjff) == 2\nassert solution.maxRepOpt1(xwktljatjx) == 2\nassert solution.maxRepOpt1(hfo) == 1\nassert solution.maxRepOpt1(c) == 1\nassert solution.maxRepOpt1(vq) == 1\nassert solution.maxRepOpt1(mvgv) == 2\nassert solution.maxRepOpt1(yeimbabzw) == 2\nassert solution.maxRepOpt1(zxkpg) == 1\nassert solution.maxRepOpt1(qaovcpjn) == 1\nassert solution.maxRepOpt1(lepdjpbt) == 2\nassert solution.maxRepOpt1(djdsvgnac) == 2\nassert solution.maxRepOpt1(i) == 1\nassert solution.maxRepOpt1(bji) == 1\nassert solution.maxRepOpt1(jcguvxqpyy) == 2\nassert solution.maxRepOpt1(prwluk) == 1\nassert solution.maxRepOpt1(aocb) == 1\nassert solution.maxRepOpt1(tkcwgsphw) == 2\nassert solution.maxRepOpt1(uisbv) == 1\nassert solution.maxRepOpt1(uijryh) == 1\nassert solution.maxRepOpt1(zkdmfxewvr) == 1\nassert solution.maxRepOpt1(xgzm) == 1\nassert solution.maxRepOpt1(g) == 1\nassert solution.maxRepOpt1(gexljk) == 1\nassert solution.maxRepOpt1(pv) == 1\nassert solution.maxRepOpt1(lf) == 1\nassert solution.maxRepOpt1(sgfjmwopqqx) == 2\nassert solution.maxRepOpt1(bltstxe) == 2\nassert solution.maxRepOpt1(czdgpmjok) == 1\nassert solution.maxRepOpt1(brhb) == 2\nassert solution.maxRepOpt1(mjix) == 1\nassert solution.maxRepOpt1(ktm) == 1\nassert solution.maxRepOpt1(c) == 1\nassert solution.maxRepOpt1(yhuqtctikne) == 2\nassert solution.maxRepOpt1(aqvyfyxfsn) == 2\nassert solution.maxRepOpt1(db) == 1\nassert solution.maxRepOpt1(vscrslsjr) == 3\nassert solution.maxRepOpt1(fckdezu) == 1\nassert solution.maxRepOpt1(zo) == 1\nassert solution.maxRepOpt1(fbbceyvsje) == 2\nassert solution.maxRepOpt1(mey) == 1\nassert solution.maxRepOpt1(ntqumvx) == 1\nassert solution.maxRepOpt1(n) == 1\nassert solution.maxRepOpt1(sqruzoio) == 2\nassert solution.maxRepOpt1(uapflryvwm) == 1\nassert solution.maxRepOpt1(nukp) == 1\nassert solution.maxRepOpt1(vzwywbxaf) == 2\nassert solution.maxRepOpt1(esmigseufwh) == 2\nassert solution.maxRepOpt1(w) == 1\nassert solution.maxRepOpt1(aetve) == 2\nassert solution.maxRepOpt1(swhq) == 1\nassert solution.maxRepOpt1(aq) == 1",
  "inefficient_solution": "class Solution:\n    def maxRepOpt1(self, text: str) -> int:\n        cnt = {}\n        for char in text:\n            if char in cnt:\n                cnt[char] += 1\n            else:\n                cnt[char] = 1\n        n = len(text)\n        ans = 0\n        for i in range(n):\n            j = i\n            while j < n and text[j] == text[i]:\n                j += 1\n            l = j - i\n            k = j\n            while k < n and text[k] == text[i]:\n                k += 1\n            r = k - j - 1\n            temp = []\n            for char in cnt:\n                if char != text[i]:\n                    temp.append(cnt[char])\n                else:\n                    temp.append(min(l + r + 1, cnt[char]))\n            ans = max(ans, max(temp))\n            i = j\n        return ans",
  "is_python": true
}