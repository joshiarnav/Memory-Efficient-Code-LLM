{
  "problem_idx": 191,
  "task_name": "Number of ",
  "markdown_description": "\nWrite a function that takes\u00a0the binary representation of an unsigned integer and returns the number of '1' bits it has (also known as the [Hamming weight](http://en.wikipedia.org/wiki/Hamming_weight)).\n\n\n**Note:**\n\n\n* Note that in some languages, such as Java, there is no unsigned integer type. In this case, the input will be given as a signed integer type. It should not affect your implementation, as the integer's internal binary representation is the same, whether it is signed or unsigned.\n* In Java, the compiler represents the signed integers using [2's complement notation](https://en.wikipedia.org/wiki/Two%27s_complement). Therefore, in **Example 3**, the input represents the signed integer. `-3`.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** n = 00000000000000000000000000001011\n**Output:** 3\n**Explanation:** The input binary string **00000000000000000000000000001011** has a total of three '1' bits.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** n = 00000000000000000000000010000000\n**Output:** 1\n**Explanation:** The input binary string **00000000000000000000000010000000** has a total of one '1' bit.\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** n = 11111111111111111111111111111101\n**Output:** 31\n**Explanation:** The input binary string **11111111111111111111111111111101** has a total of thirty one '1' bits.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* The input must be a **binary string** of length `32`.\n\n\n\u00a0\n\n\n**Follow up:** If this function is called many times, how would you optimize it?\n\n",
  "canonical_solution": "class Solution:\n    def hammingWeight(self, n: int) -> int:\n        ans = 0\n        while n:\n            n &= n - 1\n            ans += 1\n        return ans\n",
  "test_case_generator": "\nimport random\n\nclass Solution:\n    def hammingWeight(self, n: int) -> int:\n        ans = 0\n        while n:\n            n &= n - 1\n            ans += 1\n        return ans\n\ndef generate_test_case():\n    solution = Solution()\n    \n    # Generate a random binary string of length 32\n    n = \"\".join([random.choice([\"0\", \"1\"]) for _ in range(32)])\n    n = int(n, 2)\n    \n    # Calculate the expected result using the provided Solution class\n    expected_result = solution.hammingWeight(n)\n\n    return n, expected_result\n\ndef test_generated_test_cases(num_tests):\n    test_case_generator_results = []\n    for i in range(num_tests):\n        n, expected_result = generate_test_case()\n        solution = Solution()\n        assert solution.hammingWeight(n) == expected_result\n        print(f\"assert solution.hammingWeight({n}) == {expected_result}\")\n        test_case_generator_results.append(f\"assert solution.hammingWeight({n}) == {expected_result}\") # You can find that we construct the test case in the same format as the example\n    return test_case_generator_results\n\nif __name__ == \"__main__\":\n    num_tests = 100  # You can change this to generate more test cases\n    test_case_generator_results = test_generated_test_cases(num_tests)\n",
  "test_case": "assert solution.hammingWeight(814405580) == 15\nassert solution.hammingWeight(882414284) == 13\nassert solution.hammingWeight(1243866809) == 16\nassert solution.hammingWeight(2689230663) == 14\nassert solution.hammingWeight(261510955) == 17\nassert solution.hammingWeight(1982333774) == 13\nassert solution.hammingWeight(1717426966) == 18\nassert solution.hammingWeight(1660102825) == 15\nassert solution.hammingWeight(3478992390) == 17\nassert solution.hammingWeight(1302439111) == 15\nassert solution.hammingWeight(1113155351) == 15\nassert solution.hammingWeight(951769302) == 17\nassert solution.hammingWeight(2534334617) == 15\nassert solution.hammingWeight(1223529932) == 16\nassert solution.hammingWeight(711371118) == 16\nassert solution.hammingWeight(31515169) == 10\nassert solution.hammingWeight(2352740246) == 19\nassert solution.hammingWeight(1581722322) == 16\nassert solution.hammingWeight(2418762366) == 15\nassert solution.hammingWeight(676682445) == 15\nassert solution.hammingWeight(3662013265) == 16\nassert solution.hammingWeight(2253685919) == 14\nassert solution.hammingWeight(914882409) == 20\nassert solution.hammingWeight(2363669504) == 12\nassert solution.hammingWeight(3095427048) == 15\nassert solution.hammingWeight(869977458) == 18\nassert solution.hammingWeight(1871051415) == 20\nassert solution.hammingWeight(2678622774) == 16\nassert solution.hammingWeight(1298448861) == 16\nassert solution.hammingWeight(3235812173) == 16\nassert solution.hammingWeight(2008426162) == 18\nassert solution.hammingWeight(389550445) == 14\nassert solution.hammingWeight(2574640063) == 21\nassert solution.hammingWeight(717116674) == 14\nassert solution.hammingWeight(2819452710) == 15\nassert solution.hammingWeight(2844478004) == 14\nassert solution.hammingWeight(3454971238) == 20\nassert solution.hammingWeight(3276618933) == 17\nassert solution.hammingWeight(1884296552) == 11\nassert solution.hammingWeight(1029760971) == 18\nassert solution.hammingWeight(1557428511) == 18\nassert solution.hammingWeight(1171079115) == 19\nassert solution.hammingWeight(3265719236) == 16\nassert solution.hammingWeight(1668940079) == 15\nassert solution.hammingWeight(3776344889) == 16\nassert solution.hammingWeight(2394788139) == 17\nassert solution.hammingWeight(2210427489) == 12\nassert solution.hammingWeight(2256175648) == 11\nassert solution.hammingWeight(122895287) == 18\nassert solution.hammingWeight(3567419082) == 17\nassert solution.hammingWeight(3000932753) == 17\nassert solution.hammingWeight(3404448083) == 17\nassert solution.hammingWeight(3931718850) == 14\nassert solution.hammingWeight(601231517) == 14\nassert solution.hammingWeight(3877833328) == 14\nassert solution.hammingWeight(3493091163) == 16\nassert solution.hammingWeight(463433395) == 20\nassert solution.hammingWeight(532431995) == 18\nassert solution.hammingWeight(2304932160) == 12\nassert solution.hammingWeight(3384604778) == 18\nassert solution.hammingWeight(2691795538) == 12\nassert solution.hammingWeight(1161306120) == 8\nassert solution.hammingWeight(1457931244) == 17\nassert solution.hammingWeight(1467685167) == 19\nassert solution.hammingWeight(1115118146) == 14\nassert solution.hammingWeight(1681508242) == 15\nassert solution.hammingWeight(3099432914) == 19\nassert solution.hammingWeight(3054078827) == 16\nassert solution.hammingWeight(1806365577) == 18\nassert solution.hammingWeight(3119602047) == 21\nassert solution.hammingWeight(4033670780) == 19\nassert solution.hammingWeight(3572847297) == 16\nassert solution.hammingWeight(2418691280) == 11\nassert solution.hammingWeight(2699621662) == 16\nassert solution.hammingWeight(1704903310) == 16\nassert solution.hammingWeight(1385746278) == 16\nassert solution.hammingWeight(3782981875) == 20\nassert solution.hammingWeight(2971095487) == 18\nassert solution.hammingWeight(3984575230) == 24\nassert solution.hammingWeight(4085573919) == 18\nassert solution.hammingWeight(3244948202) == 18\nassert solution.hammingWeight(455666890) == 15\nassert solution.hammingWeight(607489545) == 12\nassert solution.hammingWeight(267730129) == 18\nassert solution.hammingWeight(2157293858) == 11\nassert solution.hammingWeight(4044445881) == 15\nassert solution.hammingWeight(1362522643) == 14\nassert solution.hammingWeight(1262114146) == 15\nassert solution.hammingWeight(461497987) == 14\nassert solution.hammingWeight(1994685515) == 18\nassert solution.hammingWeight(444698428) == 14\nassert solution.hammingWeight(973731982) == 15\nassert solution.hammingWeight(757714219) == 16\nassert solution.hammingWeight(834806502) == 13\nassert solution.hammingWeight(4099865743) == 21\nassert solution.hammingWeight(779507893) == 17\nassert solution.hammingWeight(1781727398) == 12\nassert solution.hammingWeight(524576540) == 15\nassert solution.hammingWeight(560840716) == 11\nassert solution.hammingWeight(3620627339) == 19",
  "inefficient_solution": "class Solution:\n    def hammingWeight(self, n: int) -> int:\n        bits = []\n        while n:\n            bits.append(n % 2)\n            n = n // 2\n        count = 0\n        for bit in bits:\n            if bit == 1:\n                count += 1\n            # Create a new list to store the next iteration's bits\n            next_bits = []\n            for i in range(len(bits)):\n                next_bits.append(bits[i])\n        return count",
  "is_python": true
}