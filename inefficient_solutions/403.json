{
  "problem_idx": 403,
  "task_name": "Frog Jump",
  "markdown_description": "\nA frog is crossing a river. The river is divided into some number of units, and at each unit, there may or may not exist a stone. The frog can jump on a stone, but it must not jump into the water.\n\n\nGiven a list of `stones`\u00a0positions (in units) in sorted **ascending order**, determine if the frog can cross the river by landing on the last stone. Initially, the frog is on the first stone and assumes the first jump must be `1` unit.\n\n\nIf the frog's last jump was `k` units, its next jump must be either `k - 1`, `k`, or `k + 1` units. The frog can only jump in the forward direction.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** stones = [0,1,3,5,6,8,12,17]\n**Output:** true\n**Explanation:** The frog can jump to the last stone by jumping 1 unit to the 2nd stone, then 2 units to the 3rd stone, then 2 units to the 4th stone, then 3 units to the 6th stone, 4 units to the 7th stone, and 5 units to the 8th stone.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** stones = [0,1,2,3,4,8,9,11]\n**Output:** false\n**Explanation:** There is no way to jump to the last stone as the gap between the 5th and 6th stone is too large.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `2 <= stones.length <= 2000`\n* `0 <= stones[i] <= 231 - 1`\n* `stones[0] == 0`\n* `stones`\u00a0is sorted in a strictly increasing order.\n\n\n",
  "canonical_solution": "class Solution:\n    def canCross(self, stones: List[int]) -> bool:\n        @cache\n        def dfs(i, k):\n            if i == n - 1:\n                return True\n            for j in range(k - 1, k + 2):\n                if j > 0 and stones[i] + j in pos and dfs(pos[stones[i] + j], j):\n                    return True\n            return False\n\n        n = len(stones)\n        pos = {s: i for i, s in enumerate(stones)}\n        return dfs(0, 0)\n",
  "test_case_generator": "\nimport random\nfrom functools import cache\nfrom typing import List\n\nclass Solution:\n    def canCross(self, stones: List[int]) -> bool:\n        @cache\n        def dfs(i, k):\n            if i == n - 1:\n                return True\n            for j in range(k - 1, k + 2):\n                if j > 0 and stones[i] + j in pos and dfs(pos[stones[i] + j], j):\n                    return True\n            return False\n\n        n = len(stones)\n        pos = {s: i for i, s in enumerate(stones)}\n        return dfs(0, 0)\n\n\ndef generate_test_case():\n    solution = Solution()\n\n    # Generate a list of stone positions in sorted ascending order\n    stones = sorted(random.sample(range(1, 201), random.randint(2, 10)))\n\n    # Calculate the expected result using the provided Solution class\n    expected_result = solution.canCross(stones)\n\n    return stones, expected_result\n\n\ndef test_generated_test_cases(num_tests):\n    test_case_generator_results = []\n\n    for i in range(num_tests):\n        stones, expected_result = generate_test_case()\n        solution = Solution()\n        assert solution.canCross(stones) == expected_result\n        test_case_generator_results.append(f\"assert solution.canCross({stones}) == {expected_result}\")\n\n    return test_case_generator_results\n\n\nif __name__ == \"__main__\":\n    num_tests = 100\n    test_case_generator_results = test_generated_test_cases(num_tests)\n",
  "test_case": "assert solution.canCross([149, 165]) == False\nassert solution.canCross([19, 25, 34, 50, 53, 86, 116]) == False\nassert solution.canCross([21, 24, 115, 133, 183]) == False\nassert solution.canCross([11, 64, 70, 86, 90, 99, 109, 114, 121, 158]) == False\nassert solution.canCross([26, 45, 50, 70, 103, 127, 185, 200]) == False\nassert solution.canCross([60, 173, 196]) == False\nassert solution.canCross([77, 170]) == False\nassert solution.canCross([59, 194]) == False\nassert solution.canCross([33, 59, 114, 183]) == False\nassert solution.canCross([32, 34, 60, 68, 94]) == False\nassert solution.canCross([8, 13, 30, 85, 92]) == False\nassert solution.canCross([90, 166]) == False\nassert solution.canCross([31, 71, 74, 90, 99, 100, 137, 191, 200]) == False\nassert solution.canCross([93, 168]) == False\nassert solution.canCross([14, 39, 54, 86, 138, 195, 196]) == False\nassert solution.canCross([5, 94, 129, 155, 169, 171, 184, 193, 199]) == False\nassert solution.canCross([12, 23, 34, 71, 129, 161, 167, 190, 195]) == False\nassert solution.canCross([16, 73, 80, 82, 140, 151, 159, 172, 180, 199]) == False\nassert solution.canCross([3, 34, 54, 56, 107, 108]) == False\nassert solution.canCross([3, 123, 129, 151, 164, 165, 185]) == False\nassert solution.canCross([5, 74, 115, 168]) == False\nassert solution.canCross([8, 25, 56, 69, 126, 166]) == False\nassert solution.canCross([142, 168]) == False\nassert solution.canCross([58, 77, 99, 168, 169, 186]) == False\nassert solution.canCross([10, 26, 35, 53, 63, 112]) == False\nassert solution.canCross([15, 56, 58, 73, 86, 119, 199]) == False\nassert solution.canCross([3, 5, 61, 102, 109, 130, 172]) == False\nassert solution.canCross([43, 138, 188]) == False\nassert solution.canCross([3, 9, 18, 51, 74, 150, 187]) == False\nassert solution.canCross([81, 161, 166]) == False\nassert solution.canCross([25, 39, 70, 83, 140, 144, 145, 146, 182]) == False\nassert solution.canCross([53, 93, 147, 166, 186, 195]) == False\nassert solution.canCross([19, 36, 133, 141, 150]) == False\nassert solution.canCross([30, 38, 58, 75, 121, 161, 168, 186]) == False\nassert solution.canCross([45, 52, 70, 75, 158, 161, 184]) == False\nassert solution.canCross([6, 44, 50, 81, 82, 99, 102, 132, 156, 193]) == False\nassert solution.canCross([64, 108]) == False\nassert solution.canCross([41, 81, 139, 197]) == False\nassert solution.canCross([18, 133, 154, 159, 198]) == False\nassert solution.canCross([34, 55, 64, 90, 144, 174, 176]) == False\nassert solution.canCross([11, 15, 46, 65, 92, 96, 101, 140, 162, 196]) == False\nassert solution.canCross([4, 8, 18, 45, 67, 100, 153, 192, 195]) == False\nassert solution.canCross([5, 34, 99, 112, 124, 164, 191, 199]) == False\nassert solution.canCross([24, 32, 36, 69, 77, 99, 175, 178, 182, 186]) == False\nassert solution.canCross([5, 15, 67, 135]) == False\nassert solution.canCross([65, 69, 86, 126, 135, 140, 168, 177]) == False\nassert solution.canCross([72, 73, 120]) == False\nassert solution.canCross([1, 75, 144, 175, 187]) == False\nassert solution.canCross([62, 99, 112, 114, 133, 141, 157, 171]) == False\nassert solution.canCross([1, 15, 98, 131, 138, 141, 142, 174, 175]) == False\nassert solution.canCross([65, 68, 130, 157]) == False\nassert solution.canCross([6, 20, 59, 75, 78, 134, 146, 155]) == False\nassert solution.canCross([50, 85]) == False\nassert solution.canCross([13, 51, 53, 62, 70, 72, 78, 191, 200]) == False\nassert solution.canCross([6, 58, 118, 123, 170, 175]) == False\nassert solution.canCross([18, 55, 63, 127, 131, 143]) == False\nassert solution.canCross([48, 85, 104, 135, 165]) == False\nassert solution.canCross([25, 33, 63, 72, 91, 107, 132, 139, 163, 179]) == False\nassert solution.canCross([94, 109, 132, 142, 170, 171, 178, 180, 181, 183]) == False\nassert solution.canCross([18, 35, 90, 95, 103, 146]) == False\nassert solution.canCross([54, 125, 128]) == False\nassert solution.canCross([41, 48, 82, 119]) == False\nassert solution.canCross([21, 24, 43, 45, 140, 141, 161, 176]) == False\nassert solution.canCross([68, 153]) == False\nassert solution.canCross([6, 16, 47, 56, 102, 167]) == False\nassert solution.canCross([28, 93, 144]) == False\nassert solution.canCross([12, 23, 31, 54, 87, 109, 140, 150, 173, 195]) == False\nassert solution.canCross([21, 62, 96, 130]) == False\nassert solution.canCross([17, 25, 35, 49, 109, 111, 120, 173]) == False\nassert solution.canCross([54, 57, 132, 155]) == False\nassert solution.canCross([15, 42, 94, 109, 128, 156, 177, 200]) == False\nassert solution.canCross([4, 106, 178, 200]) == False\nassert solution.canCross([116, 165]) == False\nassert solution.canCross([43, 66, 81, 117, 127, 131, 132, 155, 168, 182]) == False\nassert solution.canCross([41, 72, 102, 104, 140, 153, 156, 161, 178]) == False\nassert solution.canCross([3, 29, 30, 38, 97, 126, 181, 185, 192]) == False\nassert solution.canCross([9, 83, 99, 103, 137, 173, 194]) == False\nassert solution.canCross([75, 117]) == False\nassert solution.canCross([101, 159]) == False\nassert solution.canCross([40, 70, 79, 83, 164]) == False\nassert solution.canCross([21, 72, 108, 116, 138]) == False\nassert solution.canCross([5, 68, 81, 122, 161]) == False\nassert solution.canCross([37, 38, 46, 70, 122, 146, 152, 176, 198]) == False\nassert solution.canCross([30, 52, 88, 106, 109, 118, 134, 149, 152, 185]) == False\nassert solution.canCross([43, 76, 119]) == False\nassert solution.canCross([44, 46, 56, 60, 72, 136, 170, 171, 189]) == False\nassert solution.canCross([15, 114, 118, 148, 182, 183]) == False\nassert solution.canCross([177, 189]) == False\nassert solution.canCross([5, 12, 27, 31, 99, 110, 141, 146, 186]) == False\nassert solution.canCross([17, 31, 34, 74, 90, 116, 129, 136]) == False\nassert solution.canCross([46, 104, 165, 183]) == False\nassert solution.canCross([10, 81, 88, 108, 114, 144, 173]) == False\nassert solution.canCross([78, 96, 103, 108, 138, 183]) == False\nassert solution.canCross([12, 44, 164]) == False\nassert solution.canCross([111, 147, 191]) == False\nassert solution.canCross([91, 160, 163]) == False\nassert solution.canCross([12, 49, 91, 135, 144, 146, 163, 197]) == False\nassert solution.canCross([32, 63, 85, 107, 117, 153, 183, 189]) == False\nassert solution.canCross([1, 43, 64, 70, 153, 192]) == False\nassert solution.canCross([76, 77, 103, 138]) == False",
  "inefficient_solution": "def canCross(self, stones: List[int]) -> bool:\n    mem = [[None for _ in range(1001)] for _ in range(2001)]\n    def dfs(i, k):\n        if i == len(stones) - 1:\n            return True\n        if mem[i][k] is None:\n            for j in range(max(0, k - 2), k + 3):\n                if j > 0 and stones[i] + j in stones and dfs(stones.index(stones[i] + j), j):\n                    mem[i][k] = True\n                    return True\n            mem[i][k] = False\n        return mem[i][k]\n\n    return dfs(0, 0)",
  "is_python": true
}