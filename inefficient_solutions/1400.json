{
  "problem_idx": 1400,
  "task_name": "Construct K Palindrome Strings",
  "markdown_description": "\nGiven a string `s` and an integer `k`, return `true` *if you can use all the characters in* `s` *to construct* `k` *palindrome strings or* `false` *otherwise*.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** s = \"annabelle\", k = 2\n**Output:** true\n**Explanation:** You can construct two palindromes using all characters in s.\nSome possible constructions \"anna\" + \"elble\", \"anbna\" + \"elle\", \"anellena\" + \"b\"\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** s = \"leetcode\", k = 3\n**Output:** false\n**Explanation:** It is impossible to construct 3 palindromes using all the characters of s.\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** s = \"true\", k = 4\n**Output:** true\n**Explanation:** The only possible solution is to put each character in a separate string.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= s.length <= 105`\n* `s` consists of lowercase English letters.\n* `1 <= k <= 105`\n\n\n",
  "canonical_solution": "class Solution:\n    def canConstruct(self, s: str, k: int) -> bool:\n        if len(s) < k:\n            return False\n        cnt = Counter(s)\n        return sum(v & 1 for v in cnt.values()) <= k\n",
  "test_case_generator": "\n\nimport random\n\nclass Solution:\n    def canConstruct(self, s: str, k: int) -> bool:\n        if len(s) < k:\n            return False\n        cnt = Counter(s)\n        return sum(v & 1 for v in cnt.values()) <= k\n\ndef generate_test_case():\n    solution = Solution()\n\n    # Generate random string\n    s = ''.join(random.choices(string.ascii_lowercase, k=random.randint(1, 10)))\n\n    # Generate a random k value\n    k = random.randint(1, 10)\n\n    # Calculate the expected result using the provided Solution class\n    expected_result = solution.canConstruct(s, k)\n\n    return s, k, expected_result\n\ndef test_generated_test_cases(num_tests):\n    test_case_generator_results = []\n    for i in range(num_tests):\n        s, k, expected_result = generate_test_case()\n        solution = Solution()\n        assert solution.canConstruct(s, k) == expected_result\n        test_case_generator_results.append(f\"assert solution.canConstruct('{s}', {k}) == {expected_result}\")\n    return test_case_generator_results\n\nif __name__ == \"__main__\":\n    num_tests = 100  # You can change this to generate more test cases\n    test_case_generator_results = test_generated_test_cases(num_tests)\n",
  "test_case": "assert solution.canConstruct('lxbotad', 5) == False\nassert solution.canConstruct('dph', 3) == True\nassert solution.canConstruct('cjlki', 1) == False\nassert solution.canConstruct('edwlz', 5) == True\nassert solution.canConstruct('au', 2) == True\nassert solution.canConstruct('itxgwzxla', 7) == True\nassert solution.canConstruct('nhnvxllvc', 5) == True\nassert solution.canConstruct('jpfirfjc', 5) == True\nassert solution.canConstruct('qgxzqpl', 2) == False\nassert solution.canConstruct('yrlcnwsot', 10) == False\nassert solution.canConstruct('gfqmr', 2) == False\nassert solution.canConstruct('jkfuelrt', 7) == False\nassert solution.canConstruct('lwh', 9) == False\nassert solution.canConstruct('nauvdhleqm', 6) == False\nassert solution.canConstruct('tfxbu', 6) == False\nassert solution.canConstruct('cf', 5) == False\nassert solution.canConstruct('leorzrgit', 8) == True\nassert solution.canConstruct('kfrjajiokr', 5) == True\nassert solution.canConstruct('edvl', 4) == True\nassert solution.canConstruct('uvwgltaqce', 2) == False\nassert solution.canConstruct('khzfncklg', 8) == True\nassert solution.canConstruct('nkrw', 5) == False\nassert solution.canConstruct('zbzq', 4) == True\nassert solution.canConstruct('ssqgnhtal', 9) == True\nassert solution.canConstruct('e', 8) == False\nassert solution.canConstruct('dfnezmqje', 9) == True\nassert solution.canConstruct('oi', 1) == False\nassert solution.canConstruct('ftkeyamyi', 10) == False\nassert solution.canConstruct('ydzw', 3) == False\nassert solution.canConstruct('zgxdq', 3) == False\nassert solution.canConstruct('rhhsm', 10) == False\nassert solution.canConstruct('eb', 9) == False\nassert solution.canConstruct('uiuivu', 10) == False\nassert solution.canConstruct('pdswofllti', 3) == False\nassert solution.canConstruct('u', 7) == False\nassert solution.canConstruct('nf', 4) == False\nassert solution.canConstruct('xn', 4) == False\nassert solution.canConstruct('r', 4) == False\nassert solution.canConstruct('lehr', 7) == False\nassert solution.canConstruct('rsfyc', 7) == False\nassert solution.canConstruct('f', 3) == False\nassert solution.canConstruct('xk', 5) == False\nassert solution.canConstruct('zd', 10) == False\nassert solution.canConstruct('xhsil', 9) == False\nassert solution.canConstruct('u', 2) == False\nassert solution.canConstruct('gxudq', 1) == False\nassert solution.canConstruct('lggaq', 6) == False\nassert solution.canConstruct('gch', 2) == False\nassert solution.canConstruct('uu', 1) == True\nassert solution.canConstruct('nsokmdbfw', 5) == False\nassert solution.canConstruct('oo', 2) == True\nassert solution.canConstruct('hgd', 4) == False\nassert solution.canConstruct('iasci', 4) == True\nassert solution.canConstruct('ewlbou', 4) == False\nassert solution.canConstruct('mzotevdywm', 1) == False\nassert solution.canConstruct('jeosxjqx', 10) == False\nassert solution.canConstruct('z', 6) == False\nassert solution.canConstruct('m', 6) == False\nassert solution.canConstruct('x', 5) == False\nassert solution.canConstruct('vbwxe', 6) == False\nassert solution.canConstruct('czwy', 2) == False\nassert solution.canConstruct('t', 3) == False\nassert solution.canConstruct('ecwbc', 2) == False\nassert solution.canConstruct('n', 1) == True\nassert solution.canConstruct('gchhqdvtk', 1) == False\nassert solution.canConstruct('mph', 6) == False\nassert solution.canConstruct('tzeygswnn', 7) == True\nassert solution.canConstruct('kiiivt', 6) == True\nassert solution.canConstruct('opvzfmtz', 9) == False\nassert solution.canConstruct('muydulrhj', 4) == False\nassert solution.canConstruct('qcgvob', 10) == False\nassert solution.canConstruct('mhyv', 2) == False\nassert solution.canConstruct('fm', 6) == False\nassert solution.canConstruct('nlkfga', 2) == False\nassert solution.canConstruct('wgwhcyss', 4) == True\nassert solution.canConstruct('nfvcibrw', 9) == False\nassert solution.canConstruct('v', 2) == False\nassert solution.canConstruct('hpbza', 5) == True\nassert solution.canConstruct('b', 1) == True\nassert solution.canConstruct('fbv', 3) == True\nassert solution.canConstruct('eg', 6) == False\nassert solution.canConstruct('xpmxhhny', 9) == False\nassert solution.canConstruct('cdzecweb', 7) == True\nassert solution.canConstruct('hgyutlzrwz', 9) == True\nassert solution.canConstruct('alcq', 8) == False\nassert solution.canConstruct('ylkxfce', 8) == False\nassert solution.canConstruct('gte', 3) == True\nassert solution.canConstruct('etd', 9) == False\nassert solution.canConstruct('ahdkgdqbq', 9) == True\nassert solution.canConstruct('kjcvmfas', 9) == False\nassert solution.canConstruct('ewu', 5) == False\nassert solution.canConstruct('dtxgtflw', 3) == False\nassert solution.canConstruct('xjqhi', 9) == False\nassert solution.canConstruct('txcqbgo', 6) == False\nassert solution.canConstruct('yszqnlxyd', 1) == False\nassert solution.canConstruct('lhznhzokzm', 5) == False\nassert solution.canConstruct('evjvdsbz', 4) == False\nassert solution.canConstruct('gsjxryogf', 7) == True\nassert solution.canConstruct('cys', 6) == False\nassert solution.canConstruct('byutz', 3) == False",
  "inefficient_solution": "class Solution:\n    def canConstruct(self, s: str, k: int) -> bool:\n        if len(s) < k:\n            return False\n        chars = list(s)\n        for i in range(len(s)):\n            for j in range(i+1, len(s)):\n                is_palindrome = True\n                for char in chars:\n                    if char not in chars:\n                        is_palindrome = False\n                        break\n                    if chars.count(char) % 2 != 0:\n                        is_palindrome = False\n                        break\n                if is_palindrome:\n                    chars = [char for char in chars if char not in chars[i]]\n                    i = len(s) - 1\n                    j = len(s) - 2\n                    break\n            if is_palindrome:\n                break\n        return len(chars) <= k",
  "is_python": true
}