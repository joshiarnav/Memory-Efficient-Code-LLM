{
  "problem_idx": 1055,
  "task_name": "Shortest Way to Form String",
  "markdown_description": "\nA **subsequence** of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., `\"ace\"` is a subsequence of `\"abcde\"` while `\"aec\"` is not).\n\n\nGiven two strings `source` and `target`, return *the minimum number of **subsequences** of* `source` *such that their concatenation equals* `target`. If the task is impossible, return `-1`.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** source = \"abc\", target = \"abcbc\"\n**Output:** 2\n**Explanation:** The target \"abcbc\" can be formed by \"abc\" and \"bc\", which are subsequences of source \"abc\".\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** source = \"abc\", target = \"acdbc\"\n**Output:** -1\n**Explanation:** The target string cannot be constructed from the subsequences of source string due to the character \"d\" in target string.\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** source = \"xyz\", target = \"xzyxz\"\n**Output:** 3\n**Explanation:** The target string can be constructed as follows \"xz\" + \"y\" + \"xz\".\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= source.length, target.length <= 1000`\n* `source` and `target` consist of lowercase English letters.\n\n\n",
  "canonical_solution": "class Solution:\n    def shortestWay(self, source: str, target: str) -> int:\n        def f(i, j):\n            while i < m and j < n:\n                if source[i] == target[j]:\n                    j += 1\n                i += 1\n            return j\n\n        m, n = len(source), len(target)\n        ans = j = 0\n        while j < n:\n            k = f(0, j)\n            if k == j:\n                return -1\n            j = k\n            ans += 1\n        return ans\n",
  "test_case_generator": "\nimport random\n\nclass Solution:\n    def shortestWay(self, source: str, target: str) -> int:\n        def f(i, j):\n            while i < m and j < n:\n                if source[i] == target[j]:\n                    j += 1\n                i += 1\n            return j\n\n        m, n = len(source), len(target)\n        ans = j = 0\n        while j < n:\n            k = f(0, j)\n            if k == j:\n                return -1\n            j = k\n            ans += 1\n        return ans\n\ndef generate_test_case():\n    solution = Solution()\n    \n    # Generate random source string\n    source = ''.join(random.choices(string.ascii_lowercase, k=random.randint(1, 10)))\n    # Generate random target string\n    target = ''.join(random.choices(string.ascii_lowercase, k=random.randint(1, 10)))\n\n    # Calculate the expected result using the provided Solution class\n    expected_result = solution.shortestWay(source, target)\n\n    return source, target, expected_result\n\n\ndef test_generated_test_cases(num_tests):\n    test_case_generator_results = []\n    for i in range(num_tests):\n        source, target, expected_result = generate_test_case()\n        solution = Solution()\n        assert solution.shortestWay(source, target) == expected_result\n        print(f\"assert solution.shortestWay('{source}', '{target}') == {expected_result}\")\n        test_case_generator_results.append(f\"assert solution.shortestWay('{source}', '{target}') == {expected_result}\") # You can find that we construct the test case in the same format as the example\n    return test_case_generator_results\n\nif __name__ == \"__main__\":\n    num_tests = 100  # You can change this to generate more test cases\n    test_case_generator_results = test_generated_test_cases(num_tests)\n",
  "test_case": "assert solution.shortestWay('klfvtgn', 'ssjl') == -1\nassert solution.shortestWay('akfxrmqzw', 'xe') == -1\nassert solution.shortestWay('sot', 'o') == 1\nassert solution.shortestWay('cirbya', 'xzixjjdb') == -1\nassert solution.shortestWay('jpfzo', 'mq') == -1\nassert solution.shortestWay('vcswpj', 'yco') == -1\nassert solution.shortestWay('vxblmo', 'etlp') == -1\nassert solution.shortestWay('yjhibj', 'gtzvjapon') == -1\nassert solution.shortestWay('eczk', 'pis') == -1\nassert solution.shortestWay('k', 'cd') == -1\nassert solution.shortestWay('rq', 'kewy') == -1\nassert solution.shortestWay('wbu', 'nrndmvfn') == -1\nassert solution.shortestWay('hrlfq', 'cpivzw') == -1\nassert solution.shortestWay('rcmonspwtj', 'brifcrm') == -1\nassert solution.shortestWay('jqbukorzaf', 'oyparn') == -1\nassert solution.shortestWay('s', 'vfofr') == -1\nassert solution.shortestWay('kqj', 'phqo') == -1\nassert solution.shortestWay('ckgf', 'ibk') == -1\nassert solution.shortestWay('vwm', 'yvmtqv') == -1\nassert solution.shortestWay('xjaflyz', 'cqzyho') == -1\nassert solution.shortestWay('zwf', 'x') == -1\nassert solution.shortestWay('kuii', 'wgrvyi') == -1\nassert solution.shortestWay('zhu', 'ph') == -1\nassert solution.shortestWay('nkhzrne', 'sdh') == -1\nassert solution.shortestWay('fdvlvtscue', 'dzxgag') == -1\nassert solution.shortestWay('dhnf', 'xqi') == -1\nassert solution.shortestWay('a', 'tehhpnia') == -1\nassert solution.shortestWay('zrdpkg', 'cuggcnm') == -1\nassert solution.shortestWay('lmbbu', 'xsva') == -1\nassert solution.shortestWay('xyzred', 's') == -1\nassert solution.shortestWay('i', 'qdrct') == -1\nassert solution.shortestWay('pmcedginsb', 'x') == -1\nassert solution.shortestWay('jt', 'pxfbejx') == -1\nassert solution.shortestWay('juqmenvtf', 'ccbyjalras') == -1\nassert solution.shortestWay('gvxyqppta', 'bbgh') == -1\nassert solution.shortestWay('hxk', 'eytpw') == -1\nassert solution.shortestWay('qffe', 'xqcnqxiv') == -1\nassert solution.shortestWay('rxy', 'joyqybnm') == -1\nassert solution.shortestWay('vft', 'gdzctzlu') == -1\nassert solution.shortestWay('morr', 'rghp') == -1\nassert solution.shortestWay('oxe', 'lq') == -1\nassert solution.shortestWay('o', 'lgaxq') == -1\nassert solution.shortestWay('hqgpluyo', 'zgdptezlh') == -1\nassert solution.shortestWay('vakxtpivh', 'cqyk') == -1\nassert solution.shortestWay('aukb', 'bbecapg') == -1\nassert solution.shortestWay('lseirilbun', 'vdixt') == -1\nassert solution.shortestWay('mq', 'u') == -1\nassert solution.shortestWay('k', 'zepgikwmbz') == -1\nassert solution.shortestWay('fitngmory', 'hyar') == -1\nassert solution.shortestWay('oglqlguoc', 'ewwveq') == -1\nassert solution.shortestWay('uflohdtkjr', 'ttimecartl') == -1\nassert solution.shortestWay('pld', 'gxrm') == -1\nassert solution.shortestWay('fgn', 'ldzpbrvv') == -1\nassert solution.shortestWay('atojz', 'rvvzqoault') == -1\nassert solution.shortestWay('ylsaxp', 'bhqazgpe') == -1\nassert solution.shortestWay('bmziab', 'dx') == -1\nassert solution.shortestWay('iy', 'eligceoprm') == -1\nassert solution.shortestWay('fscuvspn', 'dhitidkym') == -1\nassert solution.shortestWay('k', 'zspopxczql') == -1\nassert solution.shortestWay('yrvhm', 'zce') == -1\nassert solution.shortestWay('wgtyy', 'hvvzyrh') == -1\nassert solution.shortestWay('qkjmgmau', 'vdboqlelv') == -1\nassert solution.shortestWay('fl', 'dzd') == -1\nassert solution.shortestWay('mtiw', 'cds') == -1\nassert solution.shortestWay('hy', 'yoegiccwd') == -1\nassert solution.shortestWay('kdhwg', 'waeiwwark') == -1\nassert solution.shortestWay('sxuunfbqdt', 'nikai') == -1\nassert solution.shortestWay('htncamt', 'md') == -1\nassert solution.shortestWay('hdkatjg', 'yoaeylpi') == -1\nassert solution.shortestWay('syttjj', 'ejbkezeq') == -1\nassert solution.shortestWay('kejjznxzt', 'ictzrhat') == -1\nassert solution.shortestWay('ayki', 'afyax') == -1\nassert solution.shortestWay('iftokkflwv', 'blzepav') == -1\nassert solution.shortestWay('ofxbmnksh', 'bfb') == 2\nassert solution.shortestWay('kbklvgkg', 'xeemkg') == -1\nassert solution.shortestWay('tfiucsaiul', 'nsbhcmiqym') == -1\nassert solution.shortestWay('g', 'axytagtvz') == -1\nassert solution.shortestWay('jgwrg', 'kjufi') == -1\nassert solution.shortestWay('njllqbn', 'dov') == -1\nassert solution.shortestWay('iyzyowgdtb', 'grtydprw') == -1\nassert solution.shortestWay('fuih', 'svweaaej') == -1\nassert solution.shortestWay('gahwskytid', 'pif') == -1\nassert solution.shortestWay('yzgmrwn', 'wn') == 1\nassert solution.shortestWay('dzj', 'noblxfzx') == -1\nassert solution.shortestWay('dv', 'mbbqwflxor') == -1\nassert solution.shortestWay('jyudm', 'e') == -1\nassert solution.shortestWay('dikqh', 'ib') == -1\nassert solution.shortestWay('t', 'oxwyl') == -1\nassert solution.shortestWay('zkaqp', 'wzffqut') == -1\nassert solution.shortestWay('ipbi', 'xqyxnkx') == -1\nassert solution.shortestWay('jotpr', 'rniduk') == -1\nassert solution.shortestWay('xregyzhlb', 'axfqtc') == -1\nassert solution.shortestWay('nshy', 'vmpqjez') == -1\nassert solution.shortestWay('kghmj', 'h') == 1\nassert solution.shortestWay('qjjvqfcn', 'ybnavsjqe') == -1\nassert solution.shortestWay('uawqwdvrh', 'xdegtjqx') == -1\nassert solution.shortestWay('ethpjvzx', 'sgbprx') == -1\nassert solution.shortestWay('vnccpm', 'ntya') == -1\nassert solution.shortestWay('jzufrtw', 'vhdkye') == -1\nassert solution.shortestWay('binywsinhz', 'uanu') == -1",
  "inefficient_solution": "class Solution:\n    def shortestWay(self, source: str, target: str) -> int:\n        m, n = len(source), len(target)\n        dp = [0] * (n + 1)\n        for i in range(n + 1):\n            dp[i] = [0] * (m + 1)\n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                if source[j - 1] == target[i - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = 0\n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                if dp[i][j] != 0:\n                    dp[i][j] = dp[i - 1][j] + 1\n        for i in range(1, n + 1):\n            if dp[i][m] != 0:\n                return i\n        return -1",
  "is_python": true
}