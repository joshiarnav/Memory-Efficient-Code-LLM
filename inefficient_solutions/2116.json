{
  "problem_idx": 2116,
  "task_name": "Check if a Parentheses String Can Be Valid",
  "markdown_description": "\nA parentheses string is a **non-empty** string consisting only of `'('` and `')'`. It is valid if **any** of the following conditions is **true**:\n\n\n* It is `()`.\n* It can be written as `AB` (`A` concatenated with `B`), where `A` and `B` are valid parentheses strings.\n* It can be written as `(A)`, where `A` is a valid parentheses string.\n\n\nYou are given a parentheses string `s` and a string `locked`, both of length `n`. `locked` is a binary string consisting only of `'0'`s and `'1'`s. For **each** index `i` of `locked`,\n\n\n* If `locked[i]` is `'1'`, you **cannot** change `s[i]`.\n* But if `locked[i]` is `'0'`, you **can** change `s[i]` to either `'('` or `')'`.\n\n\nReturn `true` *if you can make `s` a valid parentheses string*. Otherwise, return `false`.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2100-2199/2116.Check%20if%20a%20Parentheses%20String%20Can%20Be%20Valid/images/eg1.png)\n\n```\n\n**Input:** s = \"))()))\", locked = \"010100\"\n**Output:** true\n**Explanation:** locked[1] == '1' and locked[3] == '1', so we cannot change s[1] or s[3].\nWe change s[0] and s[4] to '(' while leaving s[2] and s[5] unchanged to make s valid.\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** s = \"()()\", locked = \"0000\"\n**Output:** true\n**Explanation:** We do not need to make any changes because s is already valid.\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** s = \")\", locked = \"0\"\n**Output:** false\n**Explanation:** locked permits us to change s[0]. \nChanging s[0] to either '(' or ')' will not make s valid.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `n == s.length == locked.length`\n* `1 <= n <= 105`\n* `s[i]` is either `'('` or `')'`.\n* `locked[i]` is either `'0'` or `'1'`.\n\n\n",
  "canonical_solution": "class Solution:\n    def canBeValid(self, s: str, locked: str) -> bool:\n        n = len(s)\n        if n & 1:\n            return False\n        x = 0\n        for i in range(n):\n            if s[i] == '(' or locked[i] == '0':\n                x += 1\n            elif x:\n                x -= 1\n            else:\n                return False\n        x = 0\n        for i in range(n - 1, -1, -1):\n            if s[i] == ')' or locked[i] == '0':\n                x += 1\n            elif x:\n                x -= 1\n            else:\n                return False\n        return True\n",
  "test_case_generator": "\nimport random\n\nclass Solution:\n    def canBeValid(self, s: str, locked: str) -> bool:\n        n = len(s)\n        if n & 1:\n            return False\n        x = 0\n        for i in range(n):\n            if s[i] == '(' or locked[i] == '0':\n                x += 1\n            elif x:\n                x -= 1\n            else:\n                return False\n        x = 0\n        for i in range(n - 1, -1, -1):\n            if s[i] == ')' or locked[i] == '0':\n                x += 1\n            elif x:\n                x -= 1\n            else:\n                return False\n        return True\n\ndef generate_test_case():\n    solution = Solution()\n    \n    # Generate a random parentheses string\n    s = random.choice([\"()\", \"(\"])\n    \n    # Generate a locked string\n    n = len(s)\n    locked = \"\"\n    for _ in range(n):\n        locked += random.choice([\"0\", \"1\"])\n    \n    # Calculate the expected result using the provided Solution class\n    expected_result = solution.canBeValid(s, locked)\n\n    return s, locked, expected_result\n\ndef test_generated_test_cases(num_tests):\n    test_case_generator_results = []\n    for i in range(num_tests):\n        s, locked, expected_result = generate_test_case()\n        solution = Solution()\n        assert solution.canBeValid(s, locked) == expected_result\n        print(f\"assert solution.canBeValid('{s}', '{locked}') == {expected_result}\")\n        test_case_generator_results.append(f\"assert solution.canBeValid('{s}', '{locked}') == {expected_result}\") # You can find that we construct the test case in the same format as the example\n    return test_case_generator_results\n\nif __name__ == \"__main__\":\n    num_tests = 100  # You can change this to generate more test cases\n    test_case_generator_results = test_generated_test_cases(num_tests)\n",
  "test_case": "assert solution.canBeValid('()', '01') == True\nassert solution.canBeValid('()', '00') == True\nassert solution.canBeValid('(', '1') == False\nassert solution.canBeValid('()', '00') == True\nassert solution.canBeValid('(', '1') == False\nassert solution.canBeValid('(', '0') == False\nassert solution.canBeValid('(', '1') == False\nassert solution.canBeValid('(', '1') == False\nassert solution.canBeValid('()', '10') == True\nassert solution.canBeValid('()', '01') == True\nassert solution.canBeValid('()', '11') == True\nassert solution.canBeValid('(', '0') == False\nassert solution.canBeValid('()', '00') == True\nassert solution.canBeValid('(', '1') == False\nassert solution.canBeValid('(', '1') == False\nassert solution.canBeValid('(', '1') == False\nassert solution.canBeValid('(', '0') == False\nassert solution.canBeValid('(', '0') == False\nassert solution.canBeValid('()', '11') == True\nassert solution.canBeValid('(', '0') == False\nassert solution.canBeValid('()', '00') == True\nassert solution.canBeValid('()', '11') == True\nassert solution.canBeValid('()', '01') == True\nassert solution.canBeValid('(', '1') == False\nassert solution.canBeValid('(', '1') == False\nassert solution.canBeValid('()', '10') == True\nassert solution.canBeValid('()', '10') == True\nassert solution.canBeValid('(', '0') == False\nassert solution.canBeValid('()', '10') == True\nassert solution.canBeValid('()', '01') == True\nassert solution.canBeValid('()', '00') == True\nassert solution.canBeValid('(', '0') == False\nassert solution.canBeValid('(', '1') == False\nassert solution.canBeValid('(', '0') == False\nassert solution.canBeValid('()', '00') == True\nassert solution.canBeValid('()', '10') == True\nassert solution.canBeValid('(', '0') == False\nassert solution.canBeValid('(', '0') == False\nassert solution.canBeValid('(', '1') == False\nassert solution.canBeValid('(', '0') == False\nassert solution.canBeValid('()', '10') == True\nassert solution.canBeValid('(', '0') == False\nassert solution.canBeValid('()', '01') == True\nassert solution.canBeValid('(', '0') == False\nassert solution.canBeValid('(', '1') == False\nassert solution.canBeValid('()', '11') == True\nassert solution.canBeValid('()', '10') == True\nassert solution.canBeValid('()', '00') == True\nassert solution.canBeValid('(', '0') == False\nassert solution.canBeValid('(', '0') == False\nassert solution.canBeValid('(', '1') == False\nassert solution.canBeValid('()', '00') == True\nassert solution.canBeValid('(', '1') == False\nassert solution.canBeValid('()', '11') == True\nassert solution.canBeValid('()', '11') == True\nassert solution.canBeValid('()', '00') == True\nassert solution.canBeValid('()', '11') == True\nassert solution.canBeValid('(', '0') == False\nassert solution.canBeValid('(', '1') == False\nassert solution.canBeValid('()', '00') == True\nassert solution.canBeValid('()', '10') == True\nassert solution.canBeValid('()', '11') == True\nassert solution.canBeValid('()', '10') == True\nassert solution.canBeValid('()', '00') == True\nassert solution.canBeValid('()', '11') == True\nassert solution.canBeValid('()', '01') == True\nassert solution.canBeValid('(', '1') == False\nassert solution.canBeValid('()', '10') == True\nassert solution.canBeValid('()', '11') == True\nassert solution.canBeValid('(', '1') == False\nassert solution.canBeValid('(', '1') == False\nassert solution.canBeValid('(', '0') == False\nassert solution.canBeValid('(', '1') == False\nassert solution.canBeValid('(', '0') == False\nassert solution.canBeValid('(', '1') == False\nassert solution.canBeValid('(', '0') == False\nassert solution.canBeValid('(', '0') == False\nassert solution.canBeValid('()', '10') == True\nassert solution.canBeValid('()', '10') == True\nassert solution.canBeValid('(', '1') == False\nassert solution.canBeValid('(', '1') == False\nassert solution.canBeValid('(', '1') == False\nassert solution.canBeValid('(', '0') == False\nassert solution.canBeValid('()', '01') == True\nassert solution.canBeValid('(', '0') == False\nassert solution.canBeValid('()', '00') == True\nassert solution.canBeValid('()', '11') == True\nassert solution.canBeValid('()', '00') == True\nassert solution.canBeValid('(', '1') == False\nassert solution.canBeValid('(', '1') == False\nassert solution.canBeValid('(', '0') == False\nassert solution.canBeValid('(', '1') == False\nassert solution.canBeValid('()', '11') == True\nassert solution.canBeValid('()', '11') == True\nassert solution.canBeValid('(', '0') == False\nassert solution.canBeValid('()', '11') == True\nassert solution.canBeValid('(', '1') == False\nassert solution.canBeValid('()', '11') == True\nassert solution.canBeValid('(', '0') == False\nassert solution.canBeValid('()', '00') == True",
  "inefficient_solution": "class Solution:\n    def canBeValid(self, s: str, locked: str) -> bool:\n        n = len(s)\n        if n & 1:\n            return False\n        locked_list = [int(i) for i in locked]\n        s_list = [i for i in s]\n        new_s = []\n        for i in range(n):\n            if locked_list[i] == 0:\n                new_s.append(0)\n            else:\n                new_s.append(s_list[i])\n        s_list = new_s\n        for i in range(n):\n            if s_list[i] == 1:\n                new_s.append(1)\n            elif s_list[i] == 2:\n                new_s.append(2)\n        s_list = new_s\n        x = 0\n        for i in range(n):\n            if s_list[i] == 1 or locked_list[i] == 0:\n                x += 1\n            elif x:\n                x -= 1\n            else:\n                return False\n        new_s = []\n        for i in range(n):\n            if s_list[i] == 1:\n                new_s.append(1)\n            elif s_list[i] == 2:\n                new_s.append(2)\n        s_list = new_s\n        x = 0\n        for i in range(n - 1, -1, -1):\n            if s_list[i] == 2 or locked_list[i] == 0:\n                x += 1\n            elif x:\n                x -= 1\n            else:\n                return False\n        return True",
  "is_python": true
}