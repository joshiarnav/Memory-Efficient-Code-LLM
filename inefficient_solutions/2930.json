{
  "problem_idx": 2930,
  "task_name": "Number of Strings Which Can Be Rearranged to Contain Substring",
  "markdown_description": "\nYou are given an integer `n`.\n\n\nA string `s` is called **good** if it contains only lowercase English characters **and** it is possible to rearrange the characters of `s` such that the new string contains `\"leet\"` as a **substring**.\n\n\nFor example:\n\n\n* The string `\"lteer\"` is good because we can rearrange it to form `\"leetr\"` .\n* `\"letl\"` is not good because we cannot rearrange it to contain `\"leet\"` as a substring.\n\n\nReturn *the **total** number of good strings of length* `n`.\n\n\nSince the answer may be large, return it **modulo** `109 + 7`.\n\n\nA **substring** is a contiguous sequence of characters within a string.\n\n\n\u00a0\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** n = 4\n**Output:** 12\n**Explanation:** The 12 strings which can be rearranged to have \"leet\" as a substring are: \"eelt\", \"eetl\", \"elet\", \"elte\", \"etel\", \"etle\", \"leet\", \"lete\", \"ltee\", \"teel\", \"tele\", and \"tlee\".\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** n = 10\n**Output:** 83943898\n**Explanation:** The number of strings with length 10 which can be rearranged to have \"leet\" as a substring is 526083947580. Hence the answer is 526083947580 % (109 + 7) = 83943898.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= n <= 105`\n\n\n",
  "canonical_solution": "class Solution:\n    def stringCount(self, n: int) -> int:\n        mod = 10**9 + 7\n        a = b = pow(25, n, mod)\n        c = pow(25, n, mod) + n * pow(25, n - 1, mod)\n        ab = pow(24, n, mod)\n        ac = bc = (pow(24, n, mod) + n * pow(24, n - 1, mod)) % mod\n        abc = (pow(23, n, mod) + n * pow(23, n - 1, mod)) % mod\n        tot = pow(26, n, mod)\n        return (tot - (a + b + c - ab - ac - bc + abc)) % mod\n",
  "test_case_generator": "\nimport random\n\nclass Solution:\n    def stringCount(self, n: int) -> int:\n        mod = 10**9 + 7\n        a = b = pow(25, n, mod)\n        c = pow(25, n, mod) + n * pow(25, n - 1, mod)\n        ab = pow(24, n, mod)\n        ac = bc = (pow(24, n, mod) + n * pow(24, n - 1, mod)) % mod\n        abc = (pow(23, n, mod) + n * pow(23, n - 1, mod)) % mod\n        tot = pow(26, n, mod)\n        return (tot - (a + b + c - ab - ac - bc + abc)) % mod\n",
  "test_case": "",
  "inefficient_solution": "class Solution:\n    def stringCount(self, n: int) -> int:\n        mod = 10**9 + 7\n        a = [0] * n\n        b = [0] * n\n        c = [0] * n\n        ab = [0] * n\n        ac = [0] * n\n        bc = [0] * n\n        abc = [0] * n\n        tot = [0] * n\n        for i in range(n):\n            for j in range(i + 1):\n                a[j] = (a[j] + pow(25, n - i - 1, mod)) % mod\n            for j in range(i + 1):\n                b[j] = (b[j] + pow(25, n - i - 1, mod) + (i + 1) * pow(25, n - i - 2, mod)) % mod\n            for j in range(i + 1):\n                c[j] = (c[j] + pow(25, n - i - 1, mod) + (i + 1) * pow(25, n - i - 2, mod) + (i + 1) * (i + 2) // 2 * pow(25, n - i - 3, mod)) % mod\n            for j in range(i + 1):\n                ab[j] = (ab[j] + pow(24, n - i - 1, mod) + (i + 1) * pow(24, n - i - 2, mod)) % mod\n            for j in range(i + 1):\n                ac[j] = (ac[j] + pow(24, n - i - 1, mod) + (i + 1) * pow(24, n - i - 2, mod) + (i + 1) * (i + 2) // 2 * pow(24, n - i - 3, mod)) % mod\n            for j in range(i + 1):\n                bc[j] = (bc[j] + pow(24, n - i - 1, mod) + (i + 1) * pow(24, n - i - 2, mod) + (i + 1) * (i + 2) // 2 * pow(24, n - i - 3, mod)) % mod\n            for j in range(i + 1):\n                abc[j] = (abc[j] + pow(23, n - i - 1, mod) + (i + 1) * pow(23, n - i - 2, mod) + (i + 1) * (i + 2) // 2 * pow(23, n - i - 3, mod)) % mod\n            for j in range(i + 1):\n                tot[j] = (tot[j] + pow(26, n - i - 1, mod)) % mod\n        return (tot[n - 1] - (a[n - 1] + b[n - 1] + c[n - 1] - ab[n - 1] - ac[n - 1] - bc[n - 1] + abc[n - 1])) % mod",
  "is_python": true
}