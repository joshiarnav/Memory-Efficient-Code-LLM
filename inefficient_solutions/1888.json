{
  "problem_idx": 1888,
  "task_name": "Minimum Number of Flips to Make the Binary String Alternating",
  "markdown_description": "\nYou are given a binary string `s`. You are allowed to perform two types of operations on the string in any sequence:\n\n\n* **Type-1: Remove** the character at the start of the string `s` and **append** it to the end of the string.\n* **Type-2: Pick** any character in `s` and **flip** its value, i.e., if its value is `'0'` it becomes `'1'` and vice-versa.\n\n\nReturn *the **minimum** number of **type-2** operations you need to perform* *such that* `s` *becomes **alternating**.*\n\n\nThe string is called **alternating** if no two adjacent characters are equal.\n\n\n* For example, the strings `\"010\"` and `\"1010\"` are alternating, while the string `\"0100\"` is not.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** s = \"111000\"\n**Output:** 2\n**Explanation**: Use the first operation two times to make s = \"100011\".\nThen, use the second operation on the third and sixth elements to make s = \"101010\".\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** s = \"010\"\n**Output:** 0\n**Explanation**: The string is already alternating.\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** s = \"1110\"\n**Output:** 1\n**Explanation**: Use the second operation on the second element to make s = \"1010\".\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= s.length <= 105`\n* `s[i]` is either `'0'` or `'1'`.\n\n\n",
  "canonical_solution": "class Solution:\n    def minFlips(self, s: str) -> int:\n        n = len(s)\n        target = \"01\"\n        cnt = sum(c != target[i & 1] for i, c in enumerate(s))\n        ans = min(cnt, n - cnt)\n        for i in range(n):\n            cnt -= s[i] != target[i & 1]\n            cnt += s[i] != target[(i + n) & 1]\n            ans = min(ans, cnt, n - cnt)\n        return ans\n",
  "test_case_generator": "\nimport random\n\nclass Solution:\n    def minFlips(self, s: str) -> int:\n        n = len(s)\n        target = \"01\"\n        cnt = sum(c != target[i & 1] for i, c in enumerate(s))\n        ans = min(cnt, n - cnt)\n        for i in range(n):\n            cnt -= s[i] != target[i & 1]\n            cnt += s[i] != target[(i + n) & 1]\n            ans = min(ans, cnt, n - cnt)\n        return ans\n\n\ndef generate_test_case():\n    solution = Solution()\n\n    # Generate a random string\n    s = \"\".join(random.choices([\"0\", \"1\"], k=random.randint(1, 10)))\n\n    # Calculate the expected result using the provided Solution class\n    expected_result = solution.minFlips(s)\n\n    return s, expected_result\n\n\ndef test_generated_test_cases(num_tests):\n    test_case_generator_results = []\n    for i in range(num_tests):\n        s, expected_result = generate_test_case()\n        solution = Solution()\n        assert solution.minFlips(s) == expected_result\n        print(f\"assert solution.minFlips({s}) == {expected_result}\")\n        test_case_generator_results.append(f\"assert solution.minFlips({s}) == {expected_result}\")\n    return test_case_generator_results\n\n\nif __name__ == \"__main__\":\n    num_tests = 100  # You can change this to generate more test cases\n    test_case_generator_results = test_generated_test_cases(num_tests)\n",
  "test_case": "assert solution.minFlips(0011100110) == 4\nassert solution.minFlips(111110) == 2\nassert solution.minFlips(000100) == 2\nassert solution.minFlips(11) == 1\nassert solution.minFlips(0110000111) == 4\nassert solution.minFlips(0110) == 2\nassert solution.minFlips(01010) == 0\nassert solution.minFlips(11010) == 0\nassert solution.minFlips(111100) == 3\nassert solution.minFlips(11011) == 1\nassert solution.minFlips(10001110) == 2\nassert solution.minFlips(010101100) == 1\nassert solution.minFlips(101) == 0\nassert solution.minFlips(101) == 0\nassert solution.minFlips(1) == 0\nassert solution.minFlips(111110) == 2\nassert solution.minFlips(01100) == 1\nassert solution.minFlips(1001110101) == 3\nassert solution.minFlips(00100111) == 4\nassert solution.minFlips(11) == 1\nassert solution.minFlips(11101) == 1\nassert solution.minFlips(0100) == 1\nassert solution.minFlips(10110) == 0\nassert solution.minFlips(1000) == 1\nassert solution.minFlips(1100001) == 2\nassert solution.minFlips(10101011) == 1\nassert solution.minFlips(100) == 0\nassert solution.minFlips(0001) == 1\nassert solution.minFlips(000110100) == 2\nassert solution.minFlips(1000011) == 2\nassert solution.minFlips(101000) == 1\nassert solution.minFlips(000011) == 3\nassert solution.minFlips(100101) == 2\nassert solution.minFlips(1) == 0\nassert solution.minFlips(11001011) == 3\nassert solution.minFlips(10010) == 0\nassert solution.minFlips(00) == 1\nassert solution.minFlips(100011100) == 2\nassert solution.minFlips(10) == 0\nassert solution.minFlips(110011) == 3\nassert solution.minFlips(1011000001) == 5\nassert solution.minFlips(101) == 0\nassert solution.minFlips(101) == 0\nassert solution.minFlips(1001001) == 2\nassert solution.minFlips(0010000) == 2\nassert solution.minFlips(1) == 0\nassert solution.minFlips(01) == 0\nassert solution.minFlips(0001100010) == 4\nassert solution.minFlips(110110) == 3\nassert solution.minFlips(11) == 1\nassert solution.minFlips(00011011) == 4\nassert solution.minFlips(111) == 1\nassert solution.minFlips(1) == 0\nassert solution.minFlips(0101100110) == 4\nassert solution.minFlips(011) == 0\nassert solution.minFlips(11110) == 1\nassert solution.minFlips(11100) == 1\nassert solution.minFlips(0) == 0\nassert solution.minFlips(1101010011) == 3\nassert solution.minFlips(1011011) == 1\nassert solution.minFlips(00) == 1\nassert solution.minFlips(1010) == 0\nassert solution.minFlips(000101) == 1\nassert solution.minFlips(111) == 1\nassert solution.minFlips(11101) == 1\nassert solution.minFlips(00) == 1\nassert solution.minFlips(0000011000) == 5\nassert solution.minFlips(010) == 0\nassert solution.minFlips(01001) == 0\nassert solution.minFlips(011) == 0\nassert solution.minFlips(10100111) == 3\nassert solution.minFlips(110010011) == 3\nassert solution.minFlips(10) == 0\nassert solution.minFlips(0) == 0\nassert solution.minFlips(01000) == 1\nassert solution.minFlips(101000) == 1\nassert solution.minFlips(111001) == 3\nassert solution.minFlips(11) == 1\nassert solution.minFlips(11001100) == 4\nassert solution.minFlips(00) == 1\nassert solution.minFlips(0001) == 1\nassert solution.minFlips(10) == 0\nassert solution.minFlips(1110011) == 2\nassert solution.minFlips(0) == 0\nassert solution.minFlips(10110000) == 3\nassert solution.minFlips(0010) == 1\nassert solution.minFlips(1011010) == 0\nassert solution.minFlips(10) == 0\nassert solution.minFlips(111100) == 3\nassert solution.minFlips(00011) == 1\nassert solution.minFlips(0) == 0\nassert solution.minFlips(01011111) == 2\nassert solution.minFlips(11001) == 1\nassert solution.minFlips(00011010) == 3\nassert solution.minFlips(101) == 0\nassert solution.minFlips(01) == 0\nassert solution.minFlips(001) == 0\nassert solution.minFlips(111110) == 2\nassert solution.minFlips(010010) == 3\nassert solution.minFlips(000010101) == 1",
  "inefficient_solution": "class Solution:\n    def minFlips(self, s: str) -> int:\n        n = len(s)\n        max_str = [\"0\" * n, \"1\" * n]\n        min_str = [\"0\" * n, \"1\" * n]\n        for i in range(n):\n            for s1 in max_str:\n                for s2 in min_str:\n                    if s[i] != s1[i & 1] and s[i] != s2[i & 1]:\n                        max_str.remove(s1)\n                        max_str.remove(s2)\n            for s1 in max_str:\n                for s2 in min_str:\n                    if s[i] != s1[(i + n) & 1] and s[i] != s2[(i + n) & 1]:\n                        min_str.remove(s1)\n                        min_str.remove(s2)\n            max_str = [\"0\" * n, \"1\" * n]\n            min_str = [\"0\" * n, \"1\" * n]\n        ans = n\n        for s1 in max_str:\n            for s2 in min_str:\n                cnt = 0\n                for i in range(n):\n                    if s[i] != s1[i & 1]:\n                        cnt += 1\n                    if s[i] != s2[i & 1]:\n                        cnt += 1\n                ans = min(ans, cnt)\n        return ans",
  "is_python": true
}