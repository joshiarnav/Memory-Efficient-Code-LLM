{
  "problem_idx": 2052,
  "task_name": "Minimum Cost to Separate Sentence Into Rows",
  "markdown_description": "\nYou are given a string `sentence` containing words separated by spaces, and an integer `k`. Your task is to separate `sentence` into **rows** where the number of characters in each row is **at most** `k`. You may assume that `sentence` does not begin or end with a space, and the words in `sentence` are separated by a single space.\n\n\nYou can split `sentence` into rows by inserting line breaks between words in `sentence`. A word **cannot** be split between two rows. Each word must be used exactly once, and the word order cannot be rearranged. Adjacent words in a row should be separated by a single space, and rows should not begin or end with spaces.\n\n\nThe **cost** of a row with length `n` is `(k - n)2`, and the **total cost** is the sum of the **costs** for all rows **except** the last one.\n\n\n* For example if `sentence = \"i love leetcode\"` and `k = 12`:\n\t+ Separating `sentence` into `\"i\"`, `\"love\"`, and `\"leetcode\"` has a cost of `(12 - 1)2 + (12 - 4)2 = 185`.\n\t+ Separating `sentence` into `\"i love\"`, and `\"leetcode\"` has a cost of `(12 - 6)2 = 36`.\n\t+ Separating `sentence` into `\"i\"`, and `\"love leetcode\"` is not possible because the length of `\"love leetcode\"` is greater than `k`.\n\n\nReturn *the **minimum** possible total cost of separating*`sentence` *into rows.*\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** sentence = \"i love leetcode\", k = 12\n**Output:** 36\n**Explanation:**\nSeparating sentence into \"i\", \"love\", and \"leetcode\" has a cost of (12 - 1)2 + (12 - 4)2 = 185.\nSeparating sentence into \"i love\", and \"leetcode\" has a cost of (12 - 6)2 = 36.\nSeparating sentence into \"i\", \"love leetcode\" is not possible because \"love leetcode\" has length 13.\n36 is the minimum possible total cost so return it.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** sentence = \"apples and bananas taste great\", k = 7\n**Output:** 21\n**Explanation**\nSeparating sentence into \"apples\", \"and\", \"bananas\", \"taste\", and \"great\" has a cost of (7 - 6)2 + (7 - 3)2 + (7 - 7)2 + (7 - 5)2 = 21.\n21 is the minimum possible total cost so return it.\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** sentence = \"a\", k = 5\n**Output:** 0\n**Explanation:**\nThe cost of the last row is not included in the total cost, and since there is only one row, return 0.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= sentence.length <= 5000`\n* `1 <= k <= 5000`\n* The length of each word in `sentence` is at most `k`.\n* `sentence` consists of only lowercase English letters and spaces.\n* `sentence` does not begin or end with a space.\n* Words in `sentence` are separated by a single space.\n\n\n",
  "canonical_solution": "class Solution:\n    def minimumCost(self, sentence: str, k: int) -> int:\n        @cache\n        def dfs(i):\n            if s[-1] - s[i] + n - i - 1 <= k:\n                return 0\n            ans, j = inf, i + 1\n            while j < n and (t := s[j] - s[i] + j - i - 1) <= k:\n                ans = min(ans, (k - t) ** 2 + dfs(j))\n                j += 1\n            return ans\n\n        t = [len(w) for w in sentence.split()]\n        n = len(t)\n        s = list(accumulate(t, initial=0))\n        return dfs(0)\n",
  "test_case_generator": "\nimport random\n\nclass Solution:\n    def minimumCost(self, sentence: str, k: int) -> int:\n        @cache\n        def dfs(i):\n            if s[-1] - s[i] + n - i - 1 <= k:\n                return 0\n            ans, j = inf, i + 1\n            while j < n and (t := s[j] - s[i] + j - i - 1) <= k:\n                ans = min(ans, (k - t) ** 2 + dfs(j))\n                j += 1\n            return ans\n\n        t = [len(w) for w in sentence.split()]\n        n = len(t)\n        s = list(accumulate(t, initial=0))\n        return dfs(0)\n\n\ndef generate_test_case():\n    solution = Solution()\n    \n    # Generate a random sentence\n    sentence = \" \".join([random.choice(string.ascii_lowercase) for _ in range(random.randint(1, 10))])\n    \n    # Generate a random value of k\n    k = random.randint(1, 10)\n\n    # Calculate the expected result using the provided Solution class\n    expected_result = solution.minimumCost(sentence, k)\n\n    return sentence, k, expected_result\n\ndef test_generated_test_cases(num_tests):\n    test_case_generator_results = []\n    for i in range(num_tests):\n        sentence, k, expected_result = generate_test_case()\n        solution = Solution()\n        assert solution.minimumCost(sentence, k) == expected_result\n        print(f\"assert solution.minimumCost('{sentence}', {k}) == {expected_result}\")\n        test_case_generator_results.append(f\"assert solution.minimumCost('{sentence}', {k}) == {expected_result}\") # You can find that we construct the test case in the same format as the example\n    return test_case_generator_results\n\nif __name__ == \"__main__\":\n    num_tests = 100  # You can change this to generate more test cases\n    test_case_generator_results = test_generated_test_cases(num_tests)\n",
  "test_case": "assert solution.minimumCost('u s a m d i g v', 1) == 0\nassert solution.minimumCost('r u p z u l', 8) == 1\nassert solution.minimumCost('h z a', 7) == 0\nassert solution.minimumCost('j b m d', 2) == 3\nassert solution.minimumCost('p f w g z x s b', 1) == 0\nassert solution.minimumCost('h p e r x b b m b j', 2) == 9\nassert solution.minimumCost('k m w h v b x', 2) == 6\nassert solution.minimumCost('h k a k', 6) == 1\nassert solution.minimumCost('z s f q x q e', 9) == 0\nassert solution.minimumCost('k e v t t z l l v', 8) == 2\nassert solution.minimumCost('c j', 7) == 0\nassert solution.minimumCost('y x n b c n v e x t', 4) == 4\nassert solution.minimumCost('a', 6) == 0\nassert solution.minimumCost('j t d z', 9) == 0\nassert solution.minimumCost('i p g t p u x a c d', 10) == 1\nassert solution.minimumCost('b i c v q c j t e b', 6) == 3\nassert solution.minimumCost('x w h i p', 4) == 2\nassert solution.minimumCost('r i x i o j l', 4) == 3\nassert solution.minimumCost('l e j', 7) == 0\nassert solution.minimumCost('n l m m t t d', 9) == 0\nassert solution.minimumCost('e i b k y n y x y', 4) == 4\nassert solution.minimumCost('w m y h a r d m', 7) == 0\nassert solution.minimumCost('e s q l b y m f u', 5) == 0\nassert solution.minimumCost('q n p y s q z e o', 4) == 4\nassert solution.minimumCost('v f t o q f', 1) == 0\nassert solution.minimumCost('l g y i w s t i', 4) == 3\nassert solution.minimumCost('j v r', 3) == 0\nassert solution.minimumCost('t j g n y', 6) == 1\nassert solution.minimumCost('q d e x z o k z o n', 10) == 1\nassert solution.minimumCost('i m', 1) == 0\nassert solution.minimumCost('u p d h', 3) == 0\nassert solution.minimumCost('y s x l l g i r p f', 8) == 2\nassert solution.minimumCost('i', 8) == 0\nassert solution.minimumCost('k t m t o', 4) == 2\nassert solution.minimumCost('z d v s y n i', 2) == 6\nassert solution.minimumCost('e b h q e u m j k g', 5) == 0\nassert solution.minimumCost('k g m p c u d p j m', 9) == 0\nassert solution.minimumCost('t c s w d', 1) == 0\nassert solution.minimumCost('l m', 6) == 0\nassert solution.minimumCost('z a f', 4) == 1\nassert solution.minimumCost('z z j i y y v y', 10) == 1\nassert solution.minimumCost('l', 9) == 0\nassert solution.minimumCost('c k i y u y w', 2) == 6\nassert solution.minimumCost('v p', 2) == 1\nassert solution.minimumCost('u y u f l c a e y', 2) == 8\nassert solution.minimumCost('w x f g y n', 7) == 0\nassert solution.minimumCost('e u j c', 3) == 0\nassert solution.minimumCost('v h e v', 5) == 0\nassert solution.minimumCost('q l m m q n q b z u', 3) == 0\nassert solution.minimumCost('j f v f p', 3) == 0\nassert solution.minimumCost('h v c h v c l b n', 9) == 0\nassert solution.minimumCost('d o v v', 7) == 0\nassert solution.minimumCost('r f e w c', 7) == 0\nassert solution.minimumCost('r', 6) == 0\nassert solution.minimumCost('d z k r n q', 9) == 0\nassert solution.minimumCost('o s', 10) == 0\nassert solution.minimumCost('y s j j y s q j', 6) == 2\nassert solution.minimumCost('i d w z j f', 4) == 2\nassert solution.minimumCost('z v x l', 10) == 0\nassert solution.minimumCost('d r', 1) == 0\nassert solution.minimumCost('p l l q t l', 2) == 5\nassert solution.minimumCost('f s d z n', 4) == 2\nassert solution.minimumCost('d i n x', 9) == 0\nassert solution.minimumCost('e v m c n w y j c h', 1) == 0\nassert solution.minimumCost('p', 10) == 0\nassert solution.minimumCost('o', 3) == 0\nassert solution.minimumCost('m v z l o m', 8) == 1\nassert solution.minimumCost('l', 2) == 0\nassert solution.minimumCost('v j g p e d z e d c', 9) == 0\nassert solution.minimumCost('g w o w', 3) == 0\nassert solution.minimumCost('k n j w v a', 1) == 0\nassert solution.minimumCost('y z', 3) == 0\nassert solution.minimumCost('j g l p u z d g', 4) == 3\nassert solution.minimumCost('e m b d b', 1) == 0\nassert solution.minimumCost('s g e a f f q b c', 5) == 0\nassert solution.minimumCost('f m b k v e v e i b', 1) == 0\nassert solution.minimumCost('p b m h f b q', 2) == 6\nassert solution.minimumCost('c m a o u z h s j', 6) == 2\nassert solution.minimumCost('n g r', 7) == 0\nassert solution.minimumCost('a p h z e w', 2) == 5\nassert solution.minimumCost('o n w', 6) == 0\nassert solution.minimumCost('m q v y t i d n x v', 4) == 4\nassert solution.minimumCost('e s a m q r x', 5) == 0\nassert solution.minimumCost('j e g t v l k', 10) == 1\nassert solution.minimumCost('f l l f f k', 4) == 2\nassert solution.minimumCost('c z g', 6) == 0\nassert solution.minimumCost('l', 3) == 0\nassert solution.minimumCost('k n l', 2) == 2\nassert solution.minimumCost('x p k h j h z v', 3) == 0\nassert solution.minimumCost('u v p s g', 7) == 0\nassert solution.minimumCost('k j g h', 8) == 0\nassert solution.minimumCost('j m j p t v', 3) == 0\nassert solution.minimumCost('u e v u', 10) == 0\nassert solution.minimumCost('p l r l t f', 4) == 2\nassert solution.minimumCost('c p', 7) == 0\nassert solution.minimumCost('l a i q u', 1) == 0\nassert solution.minimumCost('s p a f h e b z s k', 9) == 0\nassert solution.minimumCost('c x l d n f c', 10) == 1\nassert solution.minimumCost('p', 7) == 0\nassert solution.minimumCost('m p', 10) == 0",
  "inefficient_solution": "class Solution:\n    def minimumCost(self, sentence: str, k: int) -> int:\n        words = sentence.split()\n        n = len(words)\n        mem = [0]*(n+1)\n        for i in range(n):\n            mem[i+1] = mem[i] + len(words[i])\n        dp = [[0]*(k+1) for _ in range(n+1)]\n        for i in range(1, n+1):\n            for j in range(1, min(k, mem[i]) + 1):\n                dp[i][j] = min(dp[i-1][j], (k-j)**2 + dp[i-1][j-len(words[i-1])])\n        return dp[n][k]",
  "is_python": true
}