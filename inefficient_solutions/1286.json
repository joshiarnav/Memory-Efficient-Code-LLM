{
  "problem_idx": 1286,
  "task_name": "Iterator for Combination",
  "markdown_description": "\nDesign the `CombinationIterator` class:\n\n\n* `CombinationIterator(string characters, int combinationLength)` Initializes the object with a string `characters` of **sorted distinct** lowercase English letters and a number `combinationLength` as arguments.\n* `next()` Returns the next combination of length `combinationLength` in **lexicographical order**.\n* `hasNext()` Returns `true` if and only if there exists a next combination.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input**\n[\"CombinationIterator\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\"]\n[[\"abc\", 2], [], [], [], [], [], []]\n**Output**\n[null, \"ab\", true, \"ac\", true, \"bc\", false]\n\n**Explanation**\nCombinationIterator itr = new CombinationIterator(\"abc\", 2);\nitr.next();    // return \"ab\"\nitr.hasNext(); // return True\nitr.next();    // return \"ac\"\nitr.hasNext(); // return True\nitr.next();    // return \"bc\"\nitr.hasNext(); // return False\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= combinationLength <= characters.length <= 15`\n* All the characters of `characters` are **unique**.\n* At most `104` calls will be made to `next` and `hasNext`.\n* It is guaranteed that all calls of the function `next` are valid.\n\n\n",
  "canonical_solution": "class CombinationIterator:\n    def __init__(self, characters: str, combinationLength: int):\n        self.curr = (1 << len(characters)) - 1\n        self.size = combinationLength\n        self.cs = characters[::-1]\n\n    def next(self) -> str:\n        while self.curr >= 0 and self.curr.bit_count() != self.size:\n            self.curr -= 1\n        ans = []\n        for i in range(len(self.cs)):\n            if (self.curr >> i) & 1:\n                ans.append(self.cs[i])\n        self.curr -= 1\n        return ''.join(ans[::-1])\n\n    def hasNext(self) -> bool:\n        while self.curr >= 0 and self.curr.bit_count() != self.size:\n            self.curr -= 1\n        return self.curr >= 0\n\n\n# Your CombinationIterator object will be instantiated and called as such:\n# obj = CombinationIterator(characters, combinationLength)\n# param_1 = obj.next()\n# param_2 = obj.hasNext()\n",
  "test_case_generator": "\nimport random\n\nclass CombinationIteratorTestCaseGenerator:\n    def __init__(self):\n        self.test_case_number = 0\n\n    def generate_test_case(self):\n        obj = CombinationIterator(\"\", 0)\n        inputs = []\n        expected_output = None\n\n        # Randomly choose a length for the string of characters\n        combination_length = random.randint(1, 5)\n        # Randomly choose distinct characters of the string, and save the sorted string\n        characters = sorted(random.sample(\"abcdefghijklmnopqrstuvwxyz\", combination_length))\n\n        # Initialize the CombinationIterator object\n        obj.__init__(\"\".join(characters), combination_length)\n        inputs.append(\"\".join(characters))\n        inputs.append(combination_length)\n\n        # Randomly choose whether to call next() or hasNext(), and calculate the expected output\n        if random.choice([\"next\", \"hasNext\"]) == \"next\":\n            expected_output = obj.next()\n        else:\n            expected_output = obj.hasNext()\n\n        return inputs, expected_output\n\n    def generate_test_cases(self, num_test_cases):\n        test_cases = []\n        for _ in range(num_test_cases):\n            inputs, expected_output = self.generate_test_case()\n            self.test_case_number += 1\n            test_cases.append((inputs, expected_output))\n        return test_cases\n\n\nif __name__ == \"__main__\":\n    generator = CombinationIteratorTestCaseGenerator()\n    test_cases = generator.generate_test_cases(100)\n    for inputs, expected_output in test_cases:\n        print(f\"Test case #{generator.test_case_number}:\")\n        parameters = \", \".join([repr(param) for param in inputs])\n        print(f\"obj = CombinationIterator({parameters})\")\n        print(f\"Expected output: {expected_output}\\n\")\n",
  "test_case": "",
  "inefficient_solution": "class CombinationIterator:\n    def __init__(self, characters: str, combinationLength: int):\n        self.chars = list(characters)\n        self.combinationLength = combinationLength\n        self.combinations = []\n        self.index = 0\n\n        self.generate_combinations(0, '', self.combinationLength)\n        self.combinations.sort()\n\n    def next(self) -> str:\n        if not self.hasNext():\n            return None\n        return self.combinations[self.index]\n\n    def hasNext(self) -> bool:\n        return self.index < len(self.combinations)\n\n    def generate_combinations(self, start, current, remaining):\n        if remaining == 0:\n            self.combinations.append(current)\n        else:\n            for i in range(start, len(self.chars)):\n                self.generate_combinations(i + 1, current + self.chars[i], remaining - 1)",
  "is_python": true
}