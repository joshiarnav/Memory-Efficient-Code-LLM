{
  "problem_idx": 1650,
  "task_name": "Lowest Common Ancestor of a Binary Tree III",
  "markdown_description": "\nGiven two nodes of a\u00a0binary tree `p` and `q`, return *their\u00a0lowest common ancestor (LCA)*.\n\n\nEach node will have a reference to its parent node. The definition for `Node` is below:\n\n\n\n```\n\nclass Node {\n    public int val;\n    public Node left;\n    public Node right;\n    public Node parent;\n}\n\n```\n\nAccording to the **[definition of LCA on Wikipedia](https://en.wikipedia.org/wiki/Lowest_common_ancestor)**: \"The lowest common ancestor of two nodes p and q in a tree T is the lowest node that has both p and q as descendants (where we allow **a node to be a descendant of itself**).\"\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1600-1699/1650.Lowest%20Common%20Ancestor%20of%20a%20Binary%20Tree%20III/images/binarytree.png)\n\n```\n\n**Input:** root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\n**Output:** 3\n**Explanation:** The LCA of nodes 5 and 1 is 3.\n\n```\n\n**Example 2:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1600-1699/1650.Lowest%20Common%20Ancestor%20of%20a%20Binary%20Tree%20III/images/binarytree.png)\n\n```\n\n**Input:** root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\n**Output:** 5\n**Explanation:** The LCA of nodes 5 and 4 is 5 since a node can be a descendant of itself according to the LCA definition.\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** root = [1,2], p = 1, q = 2\n**Output:** 1\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* The number of nodes in the tree is in the range `[2, 105]`.\n* `-109 <= Node.val <= 109`\n* All `Node.val` are **unique**.\n* `p != q`\n* `p` and `q` exist in the tree.\n\n\n",
  "canonical_solution": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n        self.parent = None\n\"\"\"\n\n\nclass Solution:\n    def lowestCommonAncestor(self, p: 'Node', q: 'Node') -> 'Node':\n        a, b = p, q\n        while a != b:\n            a = a.parent if a.parent else q\n            b = b.parent if b.parent else p\n        return a\n",
  "test_case_generator": "\nimport random\n\nclass Solution:\n    def twoSum(self, nums, target):\n        hashtable = dict()\n        for i, num in enumerate(nums):\n            if target - num in hashtable:\n                return [hashtable[target - num], i]\n            hashtable[nums[i]] = i\n        return []\n\ndef generate_test_case():\n    # Generate random numbers list\n    nums = random.sample(range(1, 101), random.randint(2, 10))\n    \n    # Generate a random target sum\n    target = random.randint(1, 201)\n\n    # Calculate the expected result using the provided Solution class\n    solution = Solution()\n    expected_result = solution.twoSum(nums, target)\n\n    return nums, target, expected_result\n\ndef test_generated_test_cases(num_tests):\n    test_case_generator_results = []\n    for i in range(num_tests):\n        nums, target, expected_result = generate_test_case()\n        solution = Solution()\n        assert solution.twoSum(nums, target) == expected_result\n        if len(expected_result) != 0:\n            test_case_generator_results.append(f\"assert solution.twoSum({nums}, {target}) == {expected_result}\") \n\n    return test_case_generator_results\n\nif __name__ == \"__main__\":\n    num_tests = 100\n    test_case_generator_results = test_generated_test_cases(num_tests)\n    print(test_case_generator_results)\n",
  "test_case": "assert solution.twoSum([55, 98, 59, 97, 39, 14, 37], 114) == [0, 2]\nassert solution.twoSum([23, 74, 1, 91, 10], 165) == [1, 3]\nassert solution.twoSum([75, 2, 72, 39, 92, 8], 77) == [0, 1]\nassert solution.twoSum([58, 9, 81, 26, 12, 91, 57], 21) == [1, 4]\nassert solution.twoSum([30, 2, 12, 89, 58, 54, 66, 60, 73], 155) == [3, 6]\nassert solution.twoSum([38, 52, 80, 22, 46, 8, 71, 43, 45, 31], 46) == [0, 5]\nassert solution.twoSum([19, 24, 62, 46, 63, 49, 65, 58, 29], 87) == [1, 4]\nassert solution.twoSum([79, 67, 88, 52, 39, 82, 57, 16, 18, 5], 98) == [5, 7]",
  "inefficient_solution": "class Solution:\n    def lowestCommonAncestor(self, p: 'Node', q: 'Node') -> 'Node':\n        ancestors = []\n        current = p\n        while current:\n            ancestors.append(current)\n            current = current.parent\n\n        current = q\n        while current:\n            if current in ancestors:\n                return current\n            current = current.parent\n\n        return None",
  "is_python": true
}