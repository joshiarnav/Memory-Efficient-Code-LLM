{
  "problem_idx": 2359,
  "task_name": "Find Closest Node to Given Two Nodes",
  "markdown_description": "\nYou are given a **directed** graph of `n` nodes numbered from `0` to `n - 1`, where each node has **at most one** outgoing edge.\n\n\nThe graph is represented with a given **0-indexed** array `edges` of size `n`, indicating that there is a directed edge from node `i` to node `edges[i]`. If there is no outgoing edge from `i`, then `edges[i] == -1`.\n\n\nYou are also given two integers `node1` and `node2`.\n\n\nReturn *the **index** of the node that can be reached from both* `node1` *and* `node2`*, such that the **maximum** between the distance from* `node1` *to that node, and from* `node2` *to that node is **minimized***. If there are multiple answers, return the node with the **smallest** index, and if no possible answer exists, return `-1`.\n\n\nNote that `edges` may contain cycles.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2300-2399/2359.Find%20Closest%20Node%20to%20Given%20Two%20Nodes/images/graph4drawio-2.png)\n\n```\n\n**Input:** edges = [2,2,3,-1], node1 = 0, node2 = 1\n**Output:** 2\n**Explanation:** The distance from node 0 to node 2 is 1, and the distance from node 1 to node 2 is 1.\nThe maximum of those two distances is 1. It can be proven that we cannot get a node with a smaller maximum distance than 1, so we return node 2.\n\n```\n\n**Example 2:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2300-2399/2359.Find%20Closest%20Node%20to%20Given%20Two%20Nodes/images/graph4drawio-4.png)\n\n```\n\n**Input:** edges = [1,2,-1], node1 = 0, node2 = 2\n**Output:** 2\n**Explanation:** The distance from node 0 to node 2 is 2, and the distance from node 2 to itself is 0.\nThe maximum of those two distances is 2. It can be proven that we cannot get a node with a smaller maximum distance than 2, so we return node 2.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `n == edges.length`\n* `2 <= n <= 105`\n* `-1 <= edges[i] < n`\n* `edges[i] != i`\n* `0 <= node1, node2 < n`\n\n\n",
  "canonical_solution": "class Solution:\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\n        def dijkstra(i):\n            dist = [inf] * n\n            dist[i] = 0\n            q = [(0, i)]\n            while q:\n                i = heappop(q)[1]\n                for j in g[i]:\n                    if dist[j] > dist[i] + 1:\n                        dist[j] = dist[i] + 1\n                        heappush(q, (dist[j], j))\n            return dist\n\n        g = defaultdict(list)\n        for i, j in enumerate(edges):\n            if j != -1:\n                g[i].append(j)\n        n = len(edges)\n        d1 = dijkstra(node1)\n        d2 = dijkstra(node2)\n        ans, d = -1, inf\n        for i, (a, b) in enumerate(zip(d1, d2)):\n            if (t := max(a, b)) < d:\n                d = t\n                ans = i\n        return ans\n",
  "test_case_generator": "\nimport random\nfrom collections import defaultdict\nfrom heapq import heappop, heappush\nfrom typing import List\n\nclass Solution:\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\n        def dijkstra(i, edges, n, g):\n            inf = float('inf')\n            dist = [inf] * n\n            dist[i] = 0\n            q = [(0, i)]\n            while q:\n                i = heappop(q)[1]\n                for j in g[i]:\n                    if dist[j] > dist[i] + 1:\n                        dist[j] = dist[i] + 1\n                        heappush(q, (dist[j], j))\n            return dist\n\n        g = defaultdict(list)\n        for i, j in enumerate(edges):\n            if j != -1:\n                g[i].append(j)\n        n = len(edges)\n        d1 = dijkstra(node1, edges, n, g)\n        d2 = dijkstra(node2, edges, n, g)\n        ans, d = -1, inf\n        for i, (a, b) in enumerate(zip(d1, d2)):\n            if (t := max(a, b)) < d:\n                d = t\n                ans = i\n        return ans\n\ndef generate_test_case():\n    solution = Solution()\n\n    # Generate a random number of nodes\n    n = random.randint(2, 10)\n\n    # Generate edges with at most one outgoing edge\n    edges = []\n    for i in range(n):\n        if i < n - 1:\n            edges.append(i + 1)\n        else:\n            edges.append(-1)\n\n    # Generate random node1 and node2\n    node1 = random.randint(0, n - 1)\n    node2 = random.randint(0, n - 1)\n\n    # Calculate the expected result using the provided Solution class\n    expected_result = solution.closestMeetingNode(edges, node1, node2)\n\n    return edges, node1, node2, expected_result\n\ndef test_generated_test_cases(num_tests):\n    test_case_generator_results = []\n    for i in range(num_tests):\n        edges, node1, node2, expected_result = generate_test_case()\n        solution = Solution()\n        assert solution.closestMeetingNode(edges, node1, node2) == expected_result\n        test_case_generator_results.append(f\"assert solution.closestMeetingNode({edges}, {node1}, {node2}) == {expected_result}\")\n    return test_case_generator_results\n\nif __name__ == \"__main__\":\n    num_tests = 100\n    test_case_generator_results = test_generated_test_cases(num_tests)\n",
  "test_case": "assert solution.closestMeetingNode([1, 2, 3, 4, 5, 6, -1], 5, 3) == 5\nassert solution.closestMeetingNode([1, 2, 3, 4, 5, 6, -1], 4, 4) == 4\nassert solution.closestMeetingNode([1, 2, 3, 4, 5, 6, -1], 0, 0) == 0\nassert solution.closestMeetingNode([1, 2, 3, 4, -1], 2, 1) == 2\nassert solution.closestMeetingNode([1, 2, 3, 4, -1], 1, 2) == 2\nassert solution.closestMeetingNode([1, 2, 3, 4, 5, 6, 7, -1], 3, 3) == 3\nassert solution.closestMeetingNode([1, 2, 3, 4, -1], 3, 0) == 3\nassert solution.closestMeetingNode([1, 2, 3, -1], 0, 0) == 0\nassert solution.closestMeetingNode([1, 2, 3, 4, 5, 6, 7, 8, -1], 5, 7) == 7\nassert solution.closestMeetingNode([1, 2, 3, 4, 5, 6, 7, -1], 7, 4) == 7\nassert solution.closestMeetingNode([1, 2, 3, 4, 5, 6, 7, 8, 9, -1], 4, 8) == 8\nassert solution.closestMeetingNode([1, 2, 3, 4, 5, 6, -1], 3, 3) == 3\nassert solution.closestMeetingNode([1, 2, 3, 4, 5, 6, -1], 1, 6) == 6\nassert solution.closestMeetingNode([1, 2, -1], 1, 1) == 1\nassert solution.closestMeetingNode([1, 2, 3, 4, 5, 6, -1], 5, 2) == 5\nassert solution.closestMeetingNode([1, 2, 3, 4, 5, 6, 7, 8, -1], 1, 0) == 1\nassert solution.closestMeetingNode([1, 2, 3, 4, 5, 6, -1], 1, 1) == 1\nassert solution.closestMeetingNode([1, 2, -1], 1, 2) == 2\nassert solution.closestMeetingNode([1, 2, 3, 4, 5, -1], 0, 0) == 0\nassert solution.closestMeetingNode([1, 2, -1], 1, 0) == 1\nassert solution.closestMeetingNode([1, 2, 3, 4, 5, 6, -1], 5, 5) == 5\nassert solution.closestMeetingNode([1, 2, 3, 4, 5, 6, 7, -1], 6, 5) == 6\nassert solution.closestMeetingNode([1, 2, 3, 4, 5, 6, 7, 8, -1], 8, 5) == 8\nassert solution.closestMeetingNode([1, 2, 3, 4, 5, 6, -1], 2, 2) == 2\nassert solution.closestMeetingNode([1, 2, 3, 4, 5, 6, 7, 8, 9, -1], 6, 5) == 6\nassert solution.closestMeetingNode([1, 2, 3, -1], 3, 1) == 3\nassert solution.closestMeetingNode([1, 2, 3, 4, -1], 3, 1) == 3\nassert solution.closestMeetingNode([1, 2, 3, 4, 5, 6, 7, -1], 4, 6) == 6\nassert solution.closestMeetingNode([1, 2, 3, 4, -1], 4, 0) == 4\nassert solution.closestMeetingNode([1, 2, -1], 0, 2) == 2\nassert solution.closestMeetingNode([1, 2, 3, 4, 5, 6, 7, 8, -1], 7, 6) == 7\nassert solution.closestMeetingNode([1, 2, 3, 4, 5, 6, 7, 8, 9, -1], 1, 0) == 1\nassert solution.closestMeetingNode([1, -1], 1, 1) == 1\nassert solution.closestMeetingNode([1, 2, 3, -1], 0, 2) == 2\nassert solution.closestMeetingNode([1, 2, 3, 4, 5, -1], 0, 2) == 2\nassert solution.closestMeetingNode([1, 2, 3, 4, 5, 6, 7, 8, 9, -1], 2, 3) == 3\nassert solution.closestMeetingNode([1, 2, 3, -1], 0, 1) == 1\nassert solution.closestMeetingNode([1, 2, 3, 4, -1], 0, 2) == 2\nassert solution.closestMeetingNode([1, 2, -1], 2, 1) == 2\nassert solution.closestMeetingNode([1, 2, 3, 4, 5, -1], 2, 5) == 5\nassert solution.closestMeetingNode([1, 2, 3, 4, 5, -1], 3, 0) == 3\nassert solution.closestMeetingNode([1, 2, 3, 4, 5, 6, 7, 8, -1], 3, 0) == 3\nassert solution.closestMeetingNode([1, -1], 1, 0) == 1\nassert solution.closestMeetingNode([1, 2, 3, 4, 5, 6, 7, 8, -1], 4, 4) == 4\nassert solution.closestMeetingNode([1, 2, 3, 4, 5, -1], 5, 3) == 5\nassert solution.closestMeetingNode([1, 2, 3, 4, 5, 6, 7, 8, -1], 1, 5) == 5\nassert solution.closestMeetingNode([1, 2, -1], 0, 2) == 2\nassert solution.closestMeetingNode([1, 2, 3, -1], 1, 0) == 1\nassert solution.closestMeetingNode([1, 2, -1], 1, 1) == 1\nassert solution.closestMeetingNode([1, 2, 3, 4, 5, -1], 3, 3) == 3\nassert solution.closestMeetingNode([1, 2, 3, 4, 5, 6, 7, -1], 6, 6) == 6\nassert solution.closestMeetingNode([1, 2, 3, 4, 5, -1], 5, 0) == 5\nassert solution.closestMeetingNode([1, 2, 3, 4, 5, 6, 7, -1], 2, 0) == 2\nassert solution.closestMeetingNode([1, 2, 3, 4, 5, 6, 7, 8, 9, -1], 5, 6) == 6\nassert solution.closestMeetingNode([1, -1], 1, 1) == 1\nassert solution.closestMeetingNode([1, 2, 3, 4, -1], 0, 3) == 3\nassert solution.closestMeetingNode([1, 2, 3, 4, 5, 6, 7, 8, -1], 4, 1) == 4\nassert solution.closestMeetingNode([1, 2, 3, 4, 5, 6, 7, 8, -1], 0, 1) == 1\nassert solution.closestMeetingNode([1, 2, 3, 4, 5, 6, 7, -1], 0, 3) == 3\nassert solution.closestMeetingNode([1, 2, 3, 4, 5, 6, 7, 8, -1], 7, 8) == 8\nassert solution.closestMeetingNode([1, 2, 3, 4, -1], 2, 2) == 2\nassert solution.closestMeetingNode([1, 2, 3, 4, 5, 6, -1], 5, 1) == 5\nassert solution.closestMeetingNode([1, 2, 3, 4, 5, 6, 7, 8, -1], 2, 8) == 8\nassert solution.closestMeetingNode([1, 2, 3, 4, 5, -1], 0, 4) == 4\nassert solution.closestMeetingNode([1, 2, 3, 4, 5, 6, 7, 8, 9, -1], 5, 7) == 7\nassert solution.closestMeetingNode([1, 2, 3, 4, 5, 6, -1], 0, 2) == 2\nassert solution.closestMeetingNode([1, 2, 3, 4, 5, -1], 5, 4) == 5\nassert solution.closestMeetingNode([1, 2, 3, 4, 5, 6, 7, 8, -1], 2, 2) == 2\nassert solution.closestMeetingNode([1, 2, 3, 4, 5, 6, 7, 8, -1], 7, 7) == 7\nassert solution.closestMeetingNode([1, 2, 3, -1], 2, 1) == 2\nassert solution.closestMeetingNode([1, 2, 3, 4, 5, 6, 7, -1], 1, 2) == 2\nassert solution.closestMeetingNode([1, 2, 3, 4, 5, 6, -1], 0, 2) == 2\nassert solution.closestMeetingNode([1, 2, 3, 4, 5, 6, 7, -1], 3, 1) == 3\nassert solution.closestMeetingNode([1, 2, 3, 4, 5, 6, -1], 5, 6) == 6\nassert solution.closestMeetingNode([1, 2, 3, 4, 5, 6, 7, 8, 9, -1], 6, 5) == 6\nassert solution.closestMeetingNode([1, -1], 1, 0) == 1\nassert solution.closestMeetingNode([1, 2, -1], 1, 2) == 2\nassert solution.closestMeetingNode([1, 2, 3, 4, 5, 6, 7, 8, -1], 0, 1) == 1\nassert solution.closestMeetingNode([1, 2, 3, 4, 5, 6, 7, 8, 9, -1], 9, 6) == 9\nassert solution.closestMeetingNode([1, -1], 1, 1) == 1\nassert solution.closestMeetingNode([1, 2, -1], 2, 2) == 2\nassert solution.closestMeetingNode([1, 2, 3, 4, 5, 6, -1], 3, 4) == 4\nassert solution.closestMeetingNode([1, -1], 1, 1) == 1\nassert solution.closestMeetingNode([1, -1], 0, 0) == 0\nassert solution.closestMeetingNode([1, 2, 3, 4, 5, 6, 7, -1], 6, 1) == 6\nassert solution.closestMeetingNode([1, 2, 3, 4, 5, 6, 7, -1], 4, 7) == 7\nassert solution.closestMeetingNode([1, 2, 3, 4, 5, 6, -1], 5, 6) == 6\nassert solution.closestMeetingNode([1, 2, 3, 4, -1], 1, 4) == 4\nassert solution.closestMeetingNode([1, 2, 3, 4, 5, 6, -1], 6, 0) == 6\nassert solution.closestMeetingNode([1, 2, 3, 4, 5, 6, -1], 6, 5) == 6\nassert solution.closestMeetingNode([1, 2, 3, 4, 5, 6, -1], 1, 3) == 3\nassert solution.closestMeetingNode([1, -1], 0, 0) == 0\nassert solution.closestMeetingNode([1, 2, 3, 4, 5, 6, -1], 2, 5) == 5\nassert solution.closestMeetingNode([1, 2, -1], 0, 0) == 0\nassert solution.closestMeetingNode([1, 2, 3, 4, 5, 6, -1], 4, 4) == 4\nassert solution.closestMeetingNode([1, 2, 3, 4, 5, 6, -1], 2, 4) == 4\nassert solution.closestMeetingNode([1, 2, 3, 4, 5, 6, 7, 8, -1], 7, 4) == 7\nassert solution.closestMeetingNode([1, 2, 3, 4, 5, 6, -1], 6, 3) == 6\nassert solution.closestMeetingNode([1, -1], 1, 1) == 1\nassert solution.closestMeetingNode([1, 2, 3, 4, -1], 3, 4) == 4",
  "inefficient_solution": "class Solution:\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\n        g = [[] for _ in range(len(edges))]\n        for i, j in enumerate(edges):\n            if j != -1:\n                g[i].append(j)\n        n = len(edges)\n        dist1 = [n] * n\n        dist1[node1] = 0\n        q1 = [(0, node1)]\n        while q1:\n            dist, i = heappop(q1)\n            for j in g[i]:\n                if dist1[j] > dist + 1:\n                    dist1[j] = dist + 1\n                    heappush(q1, (dist + 1, j))\n        dist2 = [n] * n\n        dist2[node2] = 0\n        q2 = [(0, node2)]\n        while q2:\n            dist, i = heappop(q2)\n            for j in g[i]:\n                if dist2[j] > dist + 1:\n                    dist2[j] = dist + 1\n                    heappush(q2, (dist + 1, j))\n        ans, d = -1, n\n        for i in range(n):\n            if (t := max(dist1[i], dist2[i])) < d:\n                d = t\n                ans = i\n        return ans",
  "is_python": true
}