{
  "problem_idx": 490,
  "task_name": "The Maze",
  "markdown_description": "\nThere is a ball in a `maze` with empty spaces (represented as `0`) and walls (represented as `1`). The ball can go through the empty spaces by rolling **up, down, left or right**, but it won't stop rolling until hitting a wall. When the ball stops, it could choose the next direction.\n\n\nGiven the `m x n` `maze`, the ball's `start` position and the `destination`, where `start = [startrow, startcol]` and `destination = [destinationrow, destinationcol]`, return `true` if the ball can stop at the destination, otherwise return `false`.\n\n\nYou may assume that **the borders of the maze are all walls** (see examples).\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0400-0499/0490.The%20Maze/images/maze1-1-grid.jpg)\n\n```\n\n**Input:** maze = [[0,0,1,0,0],[0,0,0,0,0],[0,0,0,1,0],[1,1,0,1,1],[0,0,0,0,0]], start = [0,4], destination = [4,4]\n**Output:** true\n**Explanation:** One possible way is : left -> down -> left -> down -> right -> down -> right.\n\n```\n\n**Example 2:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0400-0499/0490.The%20Maze/images/maze1-2-grid.jpg)\n\n```\n\n**Input:** maze = [[0,0,1,0,0],[0,0,0,0,0],[0,0,0,1,0],[1,1,0,1,1],[0,0,0,0,0]], start = [0,4], destination = [3,2]\n**Output:** false\n**Explanation:** There is no way for the ball to stop at the destination. Notice that you can pass through the destination but you cannot stop there.\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** maze = [[0,0,0,0,0],[1,1,0,0,1],[0,0,0,0,0],[0,1,0,0,1],[0,1,0,0,0]], start = [4,3], destination = [0,1]\n**Output:** false\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `m == maze.length`\n* `n == maze[i].length`\n* `1 <= m, n <= 100`\n* `maze[i][j]` is `0` or `1`.\n* `start.length == 2`\n* `destination.length == 2`\n* `0 <= startrow, destinationrow <= m`\n* `0 <= startcol, destinationcol <= n`\n* Both the ball and the destination exist in an empty space, and they will not be in the same position initially.\n* The maze contains **at least 2 empty spaces**.\n\n\n",
  "canonical_solution": "class Solution:\n    def hasPath(\n        self, maze: List[List[int]], start: List[int], destination: List[int]\n    ) -> bool:\n        m, n = len(maze), len(maze[0])\n        q = deque([start])\n        rs, cs = start\n        vis = {(rs, cs)}\n        while q:\n            i, j = q.popleft()\n            for a, b in [[0, -1], [0, 1], [-1, 0], [1, 0]]:\n                x, y = i, j\n                while 0 <= x + a < m and 0 <= y + b < n and maze[x + a][y + b] == 0:\n                    x, y = x + a, y + b\n                if [x, y] == destination:\n                    return True\n                if (x, y) not in vis:\n                    vis.add((x, y))\n                    q.append((x, y))\n        return False\n",
  "test_case_generator": "\nimport random\nfrom collections import deque\nfrom typing import List\n\nclass Solution:\n    def hasPath(\n        self, maze: List[List[int]], start: List[int], destination: List[int]\n    ) -> bool:\n        m, n = len(maze), len(maze[0])\n        q = deque([start])\n        rs, cs = start\n        vis = {(rs, cs)}\n        while q:\n            i, j = q.popleft()\n            for a, b in [[0, -1], [0, 1], [-1, 0], [1, 0]]:\n                x, y = i, j\n                while 0 <= x + a < m and 0 <= y + b < n and maze[x + a][y + b] == 0:\n                    x, y = x + a, y + b\n                if [x, y] == destination:\n                    return True\n                if (x, y) not in vis:\n                    vis.add((x, y))\n                    q.append((x, y))\n        return False\n\ndef generate_test_case():\n    solution = Solution()\n    \n    # Generate random maze\n    m = random.randint(2, 10)\n    n = random.randint(2, 10)\n    maze = [[random.randint(0, 1) for _ in range(n)] for _ in range(m)]\n    \n    # Generate random start and destination\n    start = [random.randint(0, m-1), random.randint(0, n-1)]\n    destination = [random.randint(0, m-1), random.randint(0, n-1)]\n\n    # Calculate the expected result using the provided Solution class\n    expected_result = solution.hasPath(maze, start, destination)\n\n    return maze, start, destination, expected_result\n\ndef test_generated_test_cases(num_tests):\n    test_case_generator_results = []\n    for i in range(num_tests):\n        maze, start, destination, expected_result = generate_test_case()\n        solution = Solution()\n        assert solution.hasPath(maze, start, destination) == expected_result\n        if expected_result:\n            print(f\"assert solution.hasPath({maze}, {start}, {destination}) == {expected_result}\")\n            test_case_generator_results.append(f\"assert solution.hasPath({maze}, {start}, {destination}) == {expected_result}\") # You can find that we construct the test case in the same format as the example\n    return test_case_generator_results\n\nif __name__ == \"__main__\":\n    num_tests = 100  # You can change this to generate more test cases\n    test_case_generator_results = test_generated_test_cases(num_tests)\n",
  "test_case": "assert solution.hasPath([[1, 0, 1], [1, 1, 0], [0, 0, 1], [1, 0, 0]], [1, 1], [0, 1]) == True\nassert solution.hasPath([[1, 1, 0, 1, 1], [1, 0, 0, 0, 0], [0, 1, 1, 1, 0], [0, 1, 1, 1, 0], [1, 0, 1, 1, 1], [1, 0, 0, 0, 1]], [1, 2], [0, 2]) == True\nassert solution.hasPath([[0, 1, 0, 0, 1, 1], [1, 0, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 0]], [0, 1], [0, 2]) == True\nassert solution.hasPath([[1, 1, 1, 1, 0, 0, 0, 1, 0, 1], [1, 0, 0, 0, 1, 0, 1, 0, 1, 1]], [1, 7], [1, 7]) == True\nassert solution.hasPath([[0, 0, 0], [1, 1, 0], [1, 1, 1], [1, 0, 0], [0, 0, 1], [0, 1, 0], [1, 0, 1]], [2, 1], [3, 1]) == True\nassert solution.hasPath([[0, 0, 0, 1, 1], [0, 0, 1, 1, 1], [1, 1, 0, 1, 0]], [2, 0], [1, 1]) == True\nassert solution.hasPath([[1, 1], [1, 0], [0, 1]], [1, 0], [1, 1]) == True\nassert solution.hasPath([[1, 1], [0, 0]], [1, 0], [1, 0]) == True\nassert solution.hasPath([[0, 0], [1, 0], [0, 0], [0, 0], [0, 1], [0, 1]], [2, 0], [3, 0]) == True\nassert solution.hasPath([[0, 0, 0, 0, 1], [1, 0, 0, 1, 0], [1, 0, 0, 0, 1], [0, 0, 1, 1, 0], [1, 1, 1, 1, 0], [0, 1, 0, 0, 1], [1, 0, 0, 0, 1]], [2, 2], [2, 2]) == True\nassert solution.hasPath([[1, 0], [0, 0], [1, 0], [1, 1], [0, 0], [1, 1], [0, 0], [1, 1]], [0, 0], [0, 1]) == True\nassert solution.hasPath([[1, 1], [1, 0], [0, 0], [0, 1], [1, 1], [1, 0], [0, 1], [1, 0]], [3, 1], [2, 0]) == True\nassert solution.hasPath([[0, 1], [0, 1]], [0, 1], [0, 0]) == True\nassert solution.hasPath([[1, 0, 1, 0, 0], [0, 1, 0, 0, 0], [1, 0, 1, 0, 1], [0, 0, 0, 0, 1], [0, 1, 1, 1, 0]], [0, 3], [0, 3]) == True",
  "inefficient_solution": "class Solution:\n    def hasPath(\n        self, maze: List[List[int]], start: List[int], destination: List[int]\n    ) -> bool:\n        m, n = len(maze), len(maze[0])\n        visited = {}\n        queue = []\n        queue.append((start[0], start[1]))\n        while queue:\n            row, col = queue.pop(0)\n            if (row, col) in visited:\n                continue\n            visited[(row, col)] = True\n            if [row, col] == destination:\n                return True\n            for a, b in [[0, -1], [0, 1], [-1, 0], [1, 0]]:\n                x, y = row, col\n                while 0 <= x + a < m and 0 <= y + b < n and maze[x + a][y + b] == 0:\n                    x, y = x + a, y + b\n                    queue.append((x, y))\n            queue.append((row, col))\n        return False",
  "is_python": true
}