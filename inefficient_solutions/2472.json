{
  "problem_idx": 2472,
  "task_name": "Maximum Number of Non",
  "markdown_description": "\nYou are given a string `s` and a **positive** integer `k`.\n\n\nSelect a set of **non-overlapping** substrings from the string `s` that satisfy the following conditions:\n\n\n* The **length** of each substring is **at least** `k`.\n* Each substring is a **palindrome**.\n\n\nReturn *the **maximum** number of substrings in an optimal selection*.\n\n\nA **substring** is a contiguous sequence of characters within a string.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** s = \"abaccdbbd\", k = 3\n**Output:** 2\n**Explanation:** We can select the substrings underlined in s = \"**aba**cc**dbbd**\". Both \"aba\" and \"dbbd\" are palindromes and have a length of at least k = 3.\nIt can be shown that we cannot find a selection with more than two valid substrings.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** s = \"adbcda\", k = 2\n**Output:** 0\n**Explanation:** There is no palindrome substring of length at least 2 in the string.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= k <= s.length <= 2000`\n* `s` consists of lowercase English letters.\n\n\n",
  "canonical_solution": "class Solution:\n    def maxPalindromes(self, s: str, k: int) -> int:\n        @cache\n        def dfs(i):\n            if i >= n:\n                return 0\n            ans = dfs(i + 1)\n            for j in range(i + k - 1, n):\n                if dp[i][j]:\n                    ans = max(ans, 1 + dfs(j + 1))\n            return ans\n\n        n = len(s)\n        dp = [[True] * n for _ in range(n)]\n        for i in range(n - 1, -1, -1):\n            for j in range(i + 1, n):\n                dp[i][j] = s[i] == s[j] and dp[i + 1][j - 1]\n        ans = dfs(0)\n        dfs.cache_clear()\n        return ans\n",
  "test_case_generator": "\nimport random\n\nclass Solution:\n    def maxPalindromes(self, s: str, k: int) -> int:\n        @cache\n        def dfs(i):\n            if i >= n:\n                return 0\n            ans = dfs(i + 1)\n            for j in range(i + k - 1, n):\n                if dp[i][j]:\n                    ans = max(ans, 1 + dfs(j + 1))\n            return ans\n\n        n = len(s)\n        dp = [[True] * n for _ in range(n)]\n        for i in range(n - 1, -1, -1):\n            for j in range(i + 1, n):\n                dp[i][j] = s[i] == s[j] and dp[i + 1][j - 1]\n        ans = dfs(0)\n        dfs.cache_clear()\n        return ans\n\ndef generate_test_case():\n    solution = Solution()\n    \n    # Generate random string\n    s = ''.join(random.choices(string.ascii_lowercase, k=random.randint(1, 10)))\n    \n    # Generate random k value\n    k = random.randint(1, len(s))\n    \n    # Calculate the expected result using the provided Solution class\n    expected_result = solution.maxPalindromes(s, k)\n\n    return s, k, expected_result\n\ndef test_generated_test_cases(num_tests):\n    test_case_generator_results = []\n    for i in range(num_tests):\n        s, k, expected_result = generate_test_case()\n        solution = Solution()\n        assert solution.maxPalindromes(s, k) == expected_result\n        print(f\"assert solution.maxPalindromes('{s}', {k}) == {expected_result}\")\n        test_case_generator_results.append(f\"assert solution.maxPalindromes('{s}', {k}) == {expected_result}\")\n    return test_case_generator_results\n\nif __name__ == \"__main__\":\n    num_tests = 100  # You can change this to generate more test cases\n    test_case_generator_results = test_generated_test_cases(num_tests)\n",
  "test_case": "assert solution.maxPalindromes('kmckg', 4) == 0\nassert solution.maxPalindromes('ptcmnah', 2) == 0\nassert solution.maxPalindromes('y', 1) == 1\nassert solution.maxPalindromes('cghywg', 2) == 0\nassert solution.maxPalindromes('r', 1) == 1\nassert solution.maxPalindromes('zmwz', 4) == 0\nassert solution.maxPalindromes('kqfg', 4) == 0\nassert solution.maxPalindromes('ohi', 2) == 0\nassert solution.maxPalindromes('zungmg', 3) == 1\nassert solution.maxPalindromes('zbmqv', 1) == 5\nassert solution.maxPalindromes('kcipoptak', 1) == 9\nassert solution.maxPalindromes('mkoudumcc', 5) == 0\nassert solution.maxPalindromes('bog', 3) == 0\nassert solution.maxPalindromes('tg', 1) == 2\nassert solution.maxPalindromes('mebyd', 1) == 5\nassert solution.maxPalindromes('a', 1) == 1\nassert solution.maxPalindromes('crtf', 1) == 4\nassert solution.maxPalindromes('hbemtrctna', 8) == 0\nassert solution.maxPalindromes('wg', 1) == 2\nassert solution.maxPalindromes('vpfyvg', 1) == 6\nassert solution.maxPalindromes('vokoqdke', 8) == 0\nassert solution.maxPalindromes('amxbo', 2) == 0\nassert solution.maxPalindromes('clukwo', 2) == 0\nassert solution.maxPalindromes('qbjwkaz', 5) == 0\nassert solution.maxPalindromes('xr', 2) == 0\nassert solution.maxPalindromes('yfsytym', 7) == 0\nassert solution.maxPalindromes('orsko', 1) == 5\nassert solution.maxPalindromes('tkzyoqifrc', 5) == 0\nassert solution.maxPalindromes('gyxs', 3) == 0\nassert solution.maxPalindromes('rdcslow', 7) == 0\nassert solution.maxPalindromes('cghglwae', 5) == 0\nassert solution.maxPalindromes('ybzs', 1) == 4\nassert solution.maxPalindromes('nwlwb', 5) == 0\nassert solution.maxPalindromes('absfdypmu', 3) == 0\nassert solution.maxPalindromes('s', 1) == 1\nassert solution.maxPalindromes('mhsnecvwvj', 7) == 0\nassert solution.maxPalindromes('gxm', 2) == 0\nassert solution.maxPalindromes('zmitjlf', 3) == 0\nassert solution.maxPalindromes('epps', 1) == 4\nassert solution.maxPalindromes('pnfud', 2) == 0\nassert solution.maxPalindromes('tejxqumuwu', 6) == 0\nassert solution.maxPalindromes('bfrrmfttiy', 1) == 10\nassert solution.maxPalindromes('hezolsmt', 7) == 0\nassert solution.maxPalindromes('xbuqdxrk', 2) == 0\nassert solution.maxPalindromes('iirxhfcjks', 8) == 0\nassert solution.maxPalindromes('jpxe', 3) == 0\nassert solution.maxPalindromes('oobzvrl', 1) == 7\nassert solution.maxPalindromes('vccxlqt', 7) == 0\nassert solution.maxPalindromes('b', 1) == 1\nassert solution.maxPalindromes('vsnfvq', 5) == 0\nassert solution.maxPalindromes('wkuqffnpys', 7) == 0\nassert solution.maxPalindromes('nebhj', 3) == 0\nassert solution.maxPalindromes('awsyvwc', 6) == 0\nassert solution.maxPalindromes('invdipbykv', 1) == 10\nassert solution.maxPalindromes('axkx', 1) == 4\nassert solution.maxPalindromes('fgylyae', 3) == 1\nassert solution.maxPalindromes('olbwjal', 4) == 0\nassert solution.maxPalindromes('rwjkxrp', 1) == 7\nassert solution.maxPalindromes('yfcrsa', 2) == 0\nassert solution.maxPalindromes('yws', 3) == 0\nassert solution.maxPalindromes('yah', 2) == 0\nassert solution.maxPalindromes('bwuuiwvy', 8) == 0\nassert solution.maxPalindromes('fzd', 1) == 3\nassert solution.maxPalindromes('fojjvs', 5) == 0\nassert solution.maxPalindromes('z', 1) == 1\nassert solution.maxPalindromes('yogkll', 4) == 0\nassert solution.maxPalindromes('uzzb', 2) == 1\nassert solution.maxPalindromes('c', 1) == 1\nassert solution.maxPalindromes('txccytzydy', 10) == 0\nassert solution.maxPalindromes('dhyazqq', 6) == 0\nassert solution.maxPalindromes('xhaonutk', 3) == 0\nassert solution.maxPalindromes('p', 1) == 1\nassert solution.maxPalindromes('dombahrbb', 5) == 0\nassert solution.maxPalindromes('ej', 2) == 0\nassert solution.maxPalindromes('fsp', 2) == 0\nassert solution.maxPalindromes('pzesxlpuuz', 4) == 0\nassert solution.maxPalindromes('czox', 3) == 0\nassert solution.maxPalindromes('kyqa', 2) == 0\nassert solution.maxPalindromes('tzik', 2) == 0\nassert solution.maxPalindromes('duq', 1) == 3\nassert solution.maxPalindromes('guk', 3) == 0\nassert solution.maxPalindromes('srw', 1) == 3\nassert solution.maxPalindromes('bcmwv', 5) == 0\nassert solution.maxPalindromes('sztxuue', 5) == 0\nassert solution.maxPalindromes('xuzifwniq', 1) == 9\nassert solution.maxPalindromes('bofyem', 2) == 0\nassert solution.maxPalindromes('ydmcs', 1) == 5\nassert solution.maxPalindromes('ejwdl', 1) == 5\nassert solution.maxPalindromes('pr', 2) == 0\nassert solution.maxPalindromes('ivjef', 2) == 0\nassert solution.maxPalindromes('hgbcuvm', 4) == 0\nassert solution.maxPalindromes('vcgek', 5) == 0\nassert solution.maxPalindromes('xjdwdjpv', 4) == 1\nassert solution.maxPalindromes('orc', 2) == 0\nassert solution.maxPalindromes('hcu', 1) == 3\nassert solution.maxPalindromes('vbac', 3) == 0\nassert solution.maxPalindromes('mwvzyf', 3) == 0\nassert solution.maxPalindromes('fezkhruyj', 1) == 9\nassert solution.maxPalindromes('jba', 3) == 0\nassert solution.maxPalindromes('fr', 1) == 2",
  "inefficient_solution": "class Solution:\n    def maxPalindromes(self, s: str, k: int) -> int:\n        n = len(s)\n        dp = [[[False for _ in range(n)] for _ in range(n)] for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                dp[i][i][j] = s[i] == s[j]\n                for m in range(i + 1, j):\n                    dp[i][m][j] = s[i] == s[j] and dp[i + 1][m - 1][j - 1]\n\n        def dfs(i, cache):\n            if i >= n:\n                return 0\n            if (i, len(cache)) in cache:\n                return cache[(i, len(cache))]\n            ans = dfs(i + 1, cache)\n            for j in range(i + k - 1, n):\n                if dp[i][j][j]:\n                    ans = max(ans, 1 + dfs(j + 1, cache + [j]))\n            cache[(i, len(cache))] = ans\n            return ans\n\n        ans = dfs(0, [])\n        return ans",
  "is_python": true
}