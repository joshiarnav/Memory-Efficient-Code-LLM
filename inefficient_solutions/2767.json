{
  "problem_idx": 2767,
  "task_name": "Partition String Into Minimum Beautiful Substrings",
  "markdown_description": "\nGiven a binary string `s`, partition the string into one or more **substrings** such that each substring is **beautiful**.\n\n\nA string is **beautiful** if:\n\n\n* It doesn't contain leading zeros.\n* It's the **binary** representation of a number that is a power of `5`.\n\n\nReturn *the **minimum** number of substrings in such partition.* If it is impossible to partition the string `s` into beautiful substrings,\u00a0return `-1`.\n\n\nA **substring** is a contiguous sequence of characters in a string.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** s = \"1011\"\n**Output:** 2\n**Explanation:** We can paritition the given string into [\"101\", \"1\"].\n- The string \"101\" does not contain leading zeros and is the binary representation of integer 51 = 5.\n- The string \"1\" does not contain leading zeros and is the binary representation of integer 50 = 1.\nIt can be shown that 2 is the minimum number of beautiful substrings that s can be partitioned into.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** s = \"111\"\n**Output:** 3\n**Explanation:** We can paritition the given string into [\"1\", \"1\", \"1\"].\n- The string \"1\" does not contain leading zeros and is the binary representation of integer 50 = 1.\nIt can be shown that 3 is the minimum number of beautiful substrings that s can be partitioned into.\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** s = \"0\"\n**Output:** -1\n**Explanation:** We can not partition the given string into beautiful substrings.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= s.length <= 15`\n* `s[i]` is either `'0'` or `'1'`.\n\n\n",
  "canonical_solution": "class Solution:\n    def minimumBeautifulSubstrings(self, s: str) -> int:\n        @cache\n        def dfs(i: int) -> int:\n            if i >= n:\n                return 0\n            if s[i] == \"0\":\n                return inf\n            x = 0\n            ans = inf\n            for j in range(i, n):\n                x = x << 1 | int(s[j])\n                if x in ss:\n                    ans = min(ans, 1 + dfs(j + 1))\n            return ans\n\n        n = len(s)\n        x = 1\n        ss = {x}\n        for i in range(n):\n            x *= 5\n            ss.add(x)\n        ans = dfs(0)\n        return -1 if ans == inf else ans\n",
  "test_case_generator": "\nimport random\n\nclass Solution:\n    def minimumBeautifulSubstrings(self, s: str) -> int:\n        @cache\n        def dfs(i: int) -> int:\n            if i >= n:\n                return 0\n            if s[i] == \"0\":\n                return inf\n            x = 0\n            ans = inf\n            for j in range(i, n):\n                x = x << 1 | int(s[j])\n                if x in ss:\n                    ans = min(ans, 1 + dfs(j + 1))\n            return ans\n\n        n = len(s)\n        x = 1\n        ss = {x}\n        for i in range(n):\n            x *= 5\n            ss.add(x)\n        ans = dfs(0)\n        return -1 if ans == inf else ans\n\ndef generate_test_case():\n    solution = Solution()\n    \n    # Generate a random binary string\n    s = \"\".join(random.choices([\"0\", \"1\"], k=random.randint(1, 15)))\n\n    # Calculate the expected result using the provided Solution class\n    expected_result = solution.minimumBeautifulSubstrings(s)\n\n    return s, expected_result\n\ndef test_generated_test_cases(num_tests):\n    test_case_generator_results = []\n    for i in range(num_tests):\n        s, expected_result = generate_test_case()\n        solution = Solution()\n        assert solution.minimumBeautifulSubstrings(s) == expected_result\n        print(f'assert solution.minimumBeautifulSubstrings(\"{s}\") == {expected_result}')\n        test_case_generator_results.append(f'assert solution.minimumBeautifulSubstrings(\"{s}\") == {expected_result}')\n    return test_case_generator_results\n\nif __name__ == \"__main__\":\n    num_tests = 100\n    test_case_generator_results = test_generated_test_cases(num_tests)\n",
  "test_case": "assert solution.minimumBeautifulSubstrings(\"11111100100\") == -1\nassert solution.minimumBeautifulSubstrings(\"100101110110\") == -1\nassert solution.minimumBeautifulSubstrings(\"1010110100101\") == -1\nassert solution.minimumBeautifulSubstrings(\"11101\") == 3\nassert solution.minimumBeautifulSubstrings(\"0000\") == -1\nassert solution.minimumBeautifulSubstrings(\"0101110\") == -1\nassert solution.minimumBeautifulSubstrings(\"00\") == -1\nassert solution.minimumBeautifulSubstrings(\"1100110011\") == -1\nassert solution.minimumBeautifulSubstrings(\"10\") == -1\nassert solution.minimumBeautifulSubstrings(\"100\") == -1\nassert solution.minimumBeautifulSubstrings(\"00111010010\") == -1\nassert solution.minimumBeautifulSubstrings(\"011111101001001\") == -1\nassert solution.minimumBeautifulSubstrings(\"1\") == 1\nassert solution.minimumBeautifulSubstrings(\"000011111011010\") == -1\nassert solution.minimumBeautifulSubstrings(\"000011110\") == -1\nassert solution.minimumBeautifulSubstrings(\"10000\") == -1\nassert solution.minimumBeautifulSubstrings(\"101010110100\") == -1\nassert solution.minimumBeautifulSubstrings(\"01001000001\") == -1\nassert solution.minimumBeautifulSubstrings(\"111\") == 3\nassert solution.minimumBeautifulSubstrings(\"01011111100\") == -1\nassert solution.minimumBeautifulSubstrings(\"0\") == -1\nassert solution.minimumBeautifulSubstrings(\"01\") == -1\nassert solution.minimumBeautifulSubstrings(\"011\") == -1\nassert solution.minimumBeautifulSubstrings(\"110101011000100\") == -1\nassert solution.minimumBeautifulSubstrings(\"1011\") == 2\nassert solution.minimumBeautifulSubstrings(\"0111110111\") == -1\nassert solution.minimumBeautifulSubstrings(\"111000110011000\") == -1\nassert solution.minimumBeautifulSubstrings(\"0111\") == -1\nassert solution.minimumBeautifulSubstrings(\"100011100010\") == -1\nassert solution.minimumBeautifulSubstrings(\"0100001101\") == -1\nassert solution.minimumBeautifulSubstrings(\"1000011\") == -1\nassert solution.minimumBeautifulSubstrings(\"0\") == -1\nassert solution.minimumBeautifulSubstrings(\"011111\") == -1\nassert solution.minimumBeautifulSubstrings(\"0100\") == -1\nassert solution.minimumBeautifulSubstrings(\"10000010010\") == -1\nassert solution.minimumBeautifulSubstrings(\"01\") == -1\nassert solution.minimumBeautifulSubstrings(\"0001111000101\") == -1\nassert solution.minimumBeautifulSubstrings(\"010000110010\") == -1\nassert solution.minimumBeautifulSubstrings(\"01100001100\") == -1\nassert solution.minimumBeautifulSubstrings(\"00111\") == -1\nassert solution.minimumBeautifulSubstrings(\"110010\") == -1\nassert solution.minimumBeautifulSubstrings(\"01\") == -1\nassert solution.minimumBeautifulSubstrings(\"01000001100101\") == -1\nassert solution.minimumBeautifulSubstrings(\"101011110101\") == -1\nassert solution.minimumBeautifulSubstrings(\"111110\") == -1\nassert solution.minimumBeautifulSubstrings(\"1111\") == 4\nassert solution.minimumBeautifulSubstrings(\"0\") == -1\nassert solution.minimumBeautifulSubstrings(\"11011010101\") == -1\nassert solution.minimumBeautifulSubstrings(\"10\") == -1\nassert solution.minimumBeautifulSubstrings(\"0000\") == -1\nassert solution.minimumBeautifulSubstrings(\"010110101110\") == -1\nassert solution.minimumBeautifulSubstrings(\"0111000\") == -1\nassert solution.minimumBeautifulSubstrings(\"1011010000110\") == -1\nassert solution.minimumBeautifulSubstrings(\"00011010100111\") == -1\nassert solution.minimumBeautifulSubstrings(\"11010011001\") == -1\nassert solution.minimumBeautifulSubstrings(\"1\") == 1\nassert solution.minimumBeautifulSubstrings(\"0101011\") == -1\nassert solution.minimumBeautifulSubstrings(\"100100101\") == -1\nassert solution.minimumBeautifulSubstrings(\"11\") == 2\nassert solution.minimumBeautifulSubstrings(\"0110111\") == -1\nassert solution.minimumBeautifulSubstrings(\"00010010\") == -1\nassert solution.minimumBeautifulSubstrings(\"10011001100\") == -1\nassert solution.minimumBeautifulSubstrings(\"010011\") == -1\nassert solution.minimumBeautifulSubstrings(\"11\") == 2\nassert solution.minimumBeautifulSubstrings(\"00001111\") == -1\nassert solution.minimumBeautifulSubstrings(\"110000001100101\") == -1\nassert solution.minimumBeautifulSubstrings(\"00100010000\") == -1\nassert solution.minimumBeautifulSubstrings(\"0\") == -1\nassert solution.minimumBeautifulSubstrings(\"01001011111\") == -1\nassert solution.minimumBeautifulSubstrings(\"11111\") == 5\nassert solution.minimumBeautifulSubstrings(\"11011\") == 3\nassert solution.minimumBeautifulSubstrings(\"0010\") == -1\nassert solution.minimumBeautifulSubstrings(\"00011001001001\") == -1\nassert solution.minimumBeautifulSubstrings(\"1011010\") == -1\nassert solution.minimumBeautifulSubstrings(\"10010\") == -1\nassert solution.minimumBeautifulSubstrings(\"110001010000\") == -1\nassert solution.minimumBeautifulSubstrings(\"000111011011010\") == -1\nassert solution.minimumBeautifulSubstrings(\"0011111\") == -1\nassert solution.minimumBeautifulSubstrings(\"111\") == 3\nassert solution.minimumBeautifulSubstrings(\"110011\") == 2\nassert solution.minimumBeautifulSubstrings(\"100110110011100\") == -1\nassert solution.minimumBeautifulSubstrings(\"11000\") == -1\nassert solution.minimumBeautifulSubstrings(\"01000000010101\") == -1\nassert solution.minimumBeautifulSubstrings(\"00101101101\") == -1\nassert solution.minimumBeautifulSubstrings(\"0100000000\") == -1\nassert solution.minimumBeautifulSubstrings(\"1110101000000\") == -1\nassert solution.minimumBeautifulSubstrings(\"0011111010110\") == -1\nassert solution.minimumBeautifulSubstrings(\"1011001010\") == -1\nassert solution.minimumBeautifulSubstrings(\"11001010\") == -1\nassert solution.minimumBeautifulSubstrings(\"000111101\") == -1\nassert solution.minimumBeautifulSubstrings(\"0101010010010\") == -1\nassert solution.minimumBeautifulSubstrings(\"11111110010111\") == -1\nassert solution.minimumBeautifulSubstrings(\"011\") == -1\nassert solution.minimumBeautifulSubstrings(\"000111011100000\") == -1\nassert solution.minimumBeautifulSubstrings(\"010000\") == -1\nassert solution.minimumBeautifulSubstrings(\"1\") == 1\nassert solution.minimumBeautifulSubstrings(\"1\") == 1\nassert solution.minimumBeautifulSubstrings(\"010\") == -1\nassert solution.minimumBeautifulSubstrings(\"0111\") == -1\nassert solution.minimumBeautifulSubstrings(\"10110\") == -1",
  "inefficient_solution": "class Solution:\n    def minimumBeautifulSubstrings(self, s: str) -> int:\n        n = len(s)\n        dp = [0] * (n + 1)\n        for i in range(n):\n            dp[i + 1] = dp[i]\n            x = 0\n            for j in range(i, n):\n                x = x * 2 + (s[j] == '1')\n                for k in range(1, 4):\n                    target = 5 ** k\n                    if x >= target:\n                        dp[j + 1] = max(dp[j + 1], dp[i] + 1)\n                        break\n        if dp[n] == 0:\n            return -1\n        return dp[n]",
  "is_python": true
}