{
  "problem_idx": 872,
  "task_name": "Leaf",
  "markdown_description": "\nConsider all the leaves of a binary tree, from\u00a0left to right order, the values of those\u00a0leaves form a **leaf value sequence***.*\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0800-0899/0872.Leaf-Similar%20Trees/images/tree.png)\n\n\nFor example, in the given tree above, the leaf value sequence is `(6, 7, 4, 9, 8)`.\n\n\nTwo binary trees are considered *leaf-similar*\u00a0if their leaf value sequence is the same.\n\n\nReturn `true` if and only if the two given trees with head nodes `root1` and `root2` are leaf-similar.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0800-0899/0872.Leaf-Similar%20Trees/images/leaf-similar-1.jpg)\n\n```\n\n**Input:** root1 = [3,5,1,6,2,9,8,null,null,7,4], root2 = [3,5,1,6,7,4,2,null,null,null,null,null,null,9,8]\n**Output:** true\n\n```\n\n**Example 2:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0800-0899/0872.Leaf-Similar%20Trees/images/leaf-similar-2.jpg)\n\n```\n\n**Input:** root1 = [1,2,3], root2 = [1,3,2]\n**Output:** false\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* The number of nodes in each tree will be in the range `[1, 200]`.\n* Both of the given trees will have values in the range `[0, 200]`.\n\n\n",
  "canonical_solution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def leafSimilar(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> bool:\n        def dfs(root):\n            if root is None:\n                return []\n            ans = dfs(root.left) + dfs(root.right)\n            return ans or [root.val]\n\n        return dfs(root1) == dfs(root2)\n",
  "test_case_generator": "\nimport random\nfrom typing import Optional\nfrom collections import deque\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def leafSimilar(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> bool:\n        def dfs(root):\n            if root is None:\n                return []\n            ans = dfs(root.left) + dfs(root.right)\n            return ans or [root.val]\n\n        return dfs(root1) == dfs(root2)\n\n\ndef generate_test_case():\n    solution = Solution()\n    \n    # Generate random trees\n    root1 = generate_tree()\n    root2 = generate_tree()\n\n    # Calculate the expected result using the provided Solution class\n    expected_result = solution.leafSimilar(root1, root2)\n\n    return root1, root2, expected_result\n\n\ndef generate_tree():\n    values = random.sample(range(0, 201), random.randint(1, 200))\n\n    # Construct a binary tree using a deque\n    queue = deque()\n    root = TreeNode(values[0])\n    queue.append(root)\n\n    i = 1\n    while i < len(values):\n        node = queue.popleft()\n\n        left_value = values[i]\n        left_child = TreeNode(left_value)\n        node.left = left_child\n        queue.append(left_child)\n        i += 1\n\n        if i < len(values):\n            right_value = values[i]\n            right_child = TreeNode(right_value)\n            node.right = right_child\n            queue.append(right_child)\n            i += 1\n\n    return root\n\n\ndef test_generated_test_cases(num_tests):\n    test_case_generator_results = []\n    for _ in range(num_tests):\n        root1, root2, expected_result = generate_test_case()\n        solution = Solution()\n        assert solution.leafSimilar(root1, root2) == expected_result\n        print(f\"assert solution.leafSimilar(root1, root2) == {expected_result}\")\n        test_case_generator_results.append(f\"assert solution.leafSimilar(root1, root2) == {expected_result}\")\n    return test_case_generator_results\n\n\nif __name__ == \"__main__\":\n    num_tests = 100\n    test_case_generator_results = test_generated_test_cases(num_tests)\n",
  "test_case": "assert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False\nassert solution.leafSimilar(root1, root2) == False",
  "inefficient_solution": "class Solution:\n    def leafSimilar(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> bool:\n        def dfs(root):\n            if root is None:\n                return []\n            ans = []\n            stack = [(root, 0)]\n            while stack:\n                node, direction = stack.pop()\n                if node is not None:\n                    stack.append((node.left, 1))\n                    stack.append((node.right, 0))\n                    if node.left is None and node.right is None:\n                        if direction == 0:\n                            ans.append(node.val)\n                        else:\n                            ans.extend([node.val] * 10000)\n            return ans\n\n        return dfs(root1) == dfs(root2)",
  "is_python": true
}