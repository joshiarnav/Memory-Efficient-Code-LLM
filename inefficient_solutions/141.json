{
  "problem_idx": 141,
  "task_name": "Linked List Cycle",
  "markdown_description": "\nGiven `head`, the head of a linked list, determine if the linked list has a cycle in it.\n\n\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the\u00a0`next`\u00a0pointer. Internally, `pos`\u00a0is used to denote the index of the node that\u00a0tail's\u00a0`next`\u00a0pointer is connected to.\u00a0**Note that\u00a0`pos`\u00a0is not passed as a parameter**.\n\n\nReturn\u00a0`true` *if there is a cycle in the linked list*. Otherwise, return `false`.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0141.Linked%20List%20Cycle/images/circularlinkedlist.png)\n\n```\n\n**Input:** head = [3,2,0,-4], pos = 1\n**Output:** true\n**Explanation:** There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).\n\n```\n\n**Example 2:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0141.Linked%20List%20Cycle/images/circularlinkedlist_test2.png)\n\n```\n\n**Input:** head = [1,2], pos = 0\n**Output:** true\n**Explanation:** There is a cycle in the linked list, where the tail connects to the 0th node.\n\n```\n\n**Example 3:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0141.Linked%20List%20Cycle/images/circularlinkedlist_test3.png)\n\n```\n\n**Input:** head = [1], pos = -1\n**Output:** false\n**Explanation:** There is no cycle in the linked list.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* The number of the nodes in the list is in the range `[0, 104]`.\n* `-105 <= Node.val <= 105`\n* `pos` is `-1` or a **valid index** in the linked-list.\n\n\n\u00a0\n\n\n**Follow up:** Can you solve it using `O(1)` (i.e. constant) memory?\n\n\n",
  "canonical_solution": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\n\nclass Solution:\n    def hasCycle(self, head: ListNode) -> bool:\n        slow = fast = head\n        while fast and fast.next:\n            slow, fast = slow.next, fast.next.next\n            if slow == fast:\n                return True\n        return False\n",
  "test_case_generator": "\nimport random\n\n# Test case generator\ndef generate_test_case():\n    solution = Solution()\n\n    # Generate linked list nodes\n    nodes = [ListNode(val) for val in random.sample(range(-100000, 100001), random.randint(0, 10000))]\n\n    # Generate a random pos value\n    pos = random.randint(-1, len(nodes) - 1)\n\n    # Connect the nodes to form a linked list with a cycle\n    if pos != -1:\n        nodes[-1].next = nodes[pos]\n\n    # Calculate the expected result using the provided Solution class\n    expected_result = solution.hasCycle(nodes[0])\n\n    # Return the linked list head and the expected result\n    return nodes[0], expected_result\n\ndef test_generated_test_cases(num_tests):\n    test_case_generator_results = []\n    for i in range(num_tests):\n        head, expected_result = generate_test_case()\n        solution = Solution()\n        assert solution.hasCycle(head) == expected_result\n        print(f\"assert solution.hasCycle(head) == {expected_result}\")\n        test_case_generator_results.append(f\"assert solution.hasCycle(head) == {expected_result}\")\n    return test_case_generator_results\n\nif __name__ == \"__main__\":\n    num_tests = 100  # You can change this to generate more test cases\n    test_case_generator_results = test_generated_test_cases(num_tests)\n",
  "test_case": "assert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False\nassert solution.hasCycle(head) == False",
  "inefficient_solution": "class Solution:\n    def hasCycle(self, head: ListNode) -> bool:\n        slow = head\n        fast = head\n        visited = [slow]\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n            if slow == fast:\n                return True\n            if slow in visited:\n                return True\n            visited.append(slow)\n        return False",
  "is_python": true
}