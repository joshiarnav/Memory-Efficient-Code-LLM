{
  "problem_idx": 687,
  "task_name": "Longest Univalue Path",
  "markdown_description": "\nGiven the `root` of a binary tree, return *the length of the longest path, where each node in the path has the same value*. This path may or may not pass through the root.\n\n\n**The length of the path** between two nodes is represented by the number of edges between them.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0600-0699/0687.Longest%20Univalue%20Path/images/ex1.jpg)\n\n```\n\n**Input:** root = [5,4,5,1,1,null,5]\n**Output:** 2\n**Explanation:** The shown image shows that the longest path of the same value (i.e. 5).\n\n```\n\n**Example 2:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0600-0699/0687.Longest%20Univalue%20Path/images/ex2.jpg)\n\n```\n\n**Input:** root = [1,4,5,4,4,null,5]\n**Output:** 2\n**Explanation:** The shown image shows that the longest path of the same value (i.e. 4).\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* The number of nodes in the tree is in the range `[0, 104]`.\n* `-1000 <= Node.val <= 1000`\n* The depth of the tree will not exceed `1000`.\n\n\n",
  "canonical_solution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestUnivaluePath(self, root: TreeNode) -> int:\n        def dfs(root):\n            if root is None:\n                return 0\n            left, right = dfs(root.left), dfs(root.right)\n            left = left + 1 if root.left and root.left.val == root.val else 0\n            right = right + 1 if root.right and root.right.val == root.val else 0\n            nonlocal ans\n            ans = max(ans, left + right)\n            return max(left, right)\n\n        ans = 0\n        dfs(root)\n        return ans\n",
  "test_case_generator": "\ndef generate_test_case():\n    solution = Solution()\n    \n    # Generate the binary tree\n    # For simplicity, we generate a perfect binary tree with height 3\n    # Each node has a random value in the range [-1000, 1000]\n    root = TreeNode(random.randint(-1000, 1000))\n    root.left = TreeNode(random.randint(-1000, 1000))\n    root.right = TreeNode(random.randint(-1000, 1000))\n    root.left.left = TreeNode(random.randint(-1000, 1000))\n    root.left.right = TreeNode(random.randint(-1000, 1000))\n    root.right.left = TreeNode(random.randint(-1000, 1000))\n    root.right.right = TreeNode(random.randint(-1000, 1000))\n\n    # Calculate the expected result using the provided Solution class\n    expected_result = solution.longestUnivaluePath(root)\n\n    return root, expected_result\n\ndef test_generated_test_cases(num_tests):\n    test_case_generator_results = []\n    for i in range(num_tests):\n        root, expected_result = generate_test_case()\n        solution = Solution()\n        assert solution.longestUnivaluePath(root) == expected_result\n        print(f\"assert solution.longestUnivaluePath(root) == {expected_result}\")\n        test_case_generator_results.append(f\"assert solution.longestUnivaluePath(root) == {expected_result}\")\n    return test_case_generator_results\n\nif __name__ == \"__main__\":\n    num_tests = 100  # You can change this to generate more test cases\n    test_case_generator_results = test_generated_test_cases(num_tests)\n",
  "test_case": "assert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0\nassert solution.longestUnivaluePath(root) == 0",
  "inefficient_solution": "class Solution:\n    def longestUnivaluePath(self, root: TreeNode) -> int:\n        def dfs(root):\n            if root is None:\n                return\n            left = []\n            right = []\n            if root.left:\n                left_val = root.val\n                left_dfs = dfs(root.left)\n                left = [left_val] + left_dfs\n            if root.right:\n                right_val = root.val\n                right_dfs = dfs(root.right)\n                right = [right_val] + right_dfs\n            left_len = len(left)\n            right_len = len(right)\n            left = left_len * [root.val]\n            right = right_len * [root.val]\n            if root.left and root.left.val == root.val:\n                left = left + [root.val]\n            if root.right and root.right.val == root.val:\n                right = right + [root.val]\n            nonlocal ans\n            ans = max(ans, len(left), len(right))\n            return max(left, right)\n\n        ans = 0\n        dfs(root)\n        return ans",
  "is_python": true
}