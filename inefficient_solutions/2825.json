{
  "problem_idx": 2825,
  "task_name": "Make String a Subsequence Using Cyclic Increments",
  "markdown_description": "\nYou are given two **0-indexed** strings `str1` and `str2`.\n\n\nIn an operation, you select a **set** of indices in `str1`, and for each index `i` in the set, increment `str1[i]` to the next character **cyclically**. That is `'a'` becomes `'b'`, `'b'` becomes `'c'`, and so on, and `'z'` becomes `'a'`.\n\n\nReturn `true` *if it is possible to make* `str2` *a subsequence of* `str1` *by performing the operation **at most once***, *and* `false` *otherwise*.\n\n\n**Note:** A subsequence of a string is a new string that is formed from the original string by deleting some (possibly none) of the characters without disturbing the relative positions of the remaining characters.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** str1 = \"abc\", str2 = \"ad\"\n**Output:** true\n**Explanation:** Select index 2 in str1.\nIncrement str1[2] to become 'd'. \nHence, str1 becomes \"abd\" and str2 is now a subsequence. Therefore, true is returned.\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** str1 = \"zc\", str2 = \"ad\"\n**Output:** true\n**Explanation:** Select indices 0 and 1 in str1. \nIncrement str1[0] to become 'a'. \nIncrement str1[1] to become 'd'. \nHence, str1 becomes \"ad\" and str2 is now a subsequence. Therefore, true is returned.\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** str1 = \"ab\", str2 = \"d\"\n**Output:** false\n**Explanation:** In this example, it can be shown that it is impossible to make str2 a subsequence of str1 using the operation at most once. \nTherefore, false is returned.\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= str1.length <= 105`\n* `1 <= str2.length <= 105`\n* `str1` and `str2` consist of only lowercase English letters.\n\n\n",
  "canonical_solution": "class Solution:\n    def canMakeSubsequence(self, str1: str, str2: str) -> bool:\n        i = 0\n        for c in str1:\n            d = \"a\" if c == \"z\" else chr(ord(c) + 1)\n            if i < len(str2) and str2[i] in (c, d):\n                i += 1\n        return i == len(str2)\n",
  "test_case_generator": "\nimport random\n\nclass Solution:\n    def canMakeSubsequence(self, str1: str, str2: str) -> bool:\n        i = 0\n        for c in str1:\n            d = \"a\" if c == \"z\" else chr(ord(c) + 1)\n            if i < len(str2) and str2[i] in (c, d):\n                i += 1\n        return i == len(str2)\n\ndef generate_test_case():\n    solution = Solution()\n\n    # Generate random strings\n    str1 = ''.join(random.choices('abcdefghijklmnopqrstuvwxyz', k=random.randint(1, 10)))\n    str2 = ''.join(random.choices('abcdefghijklmnopqrstuvwxyz', k=random.randint(1, 10)))\n\n    # Calculate the expected result using the provided Solution class\n    expected_result = solution.canMakeSubsequence(str1, str2)\n\n    return str1, str2, expected_result\n\ndef test_generated_test_cases(num_tests):\n    test_case_generator_results = []\n    for i in range(num_tests):\n        str1, str2, expected_result = generate_test_case()\n        solution = Solution()\n        assert solution.canMakeSubsequence(str1, str2) == expected_result\n        print(f\"assert solution.canMakeSubsequence('{str1}', '{str2}') == {expected_result}\")\n        test_case_generator_results.append(f\"assert solution.canMakeSubsequence('{str1}', '{str2}') == {expected_result}\") \n\n    return test_case_generator_results\n\nif __name__ == \"__main__\":\n    num_tests = 100\n    test_case_generator_results = test_generated_test_cases(num_tests)\n",
  "test_case": "assert solution.canMakeSubsequence('gttxbgno', 'vjqaqimr') == False\nassert solution.canMakeSubsequence('wwilanrxne', 'ixrpnrqvvi') == False\nassert solution.canMakeSubsequence('qh', 'ljqo') == False\nassert solution.canMakeSubsequence('zurcssig', 'of') == False\nassert solution.canMakeSubsequence('lqjkpxe', 'pnfcgs') == False\nassert solution.canMakeSubsequence('fhcs', 'fkuh') == False\nassert solution.canMakeSubsequence('wsg', 'nzofeckwof') == False\nassert solution.canMakeSubsequence('aqk', 'vjrnq') == False\nassert solution.canMakeSubsequence('pognwl', 'jqqkklb') == False\nassert solution.canMakeSubsequence('iti', 'y') == False\nassert solution.canMakeSubsequence('xvoghkp', 'pzxfzutael') == False\nassert solution.canMakeSubsequence('cuhekwfh', 'iwdq') == False\nassert solution.canMakeSubsequence('slxmtoiw', 'dy') == False\nassert solution.canMakeSubsequence('heameu', 'ajhg') == False\nassert solution.canMakeSubsequence('vvkoa', 'iptt') == False\nassert solution.canMakeSubsequence('plmg', 'ipjjjd') == False\nassert solution.canMakeSubsequence('epvle', 'ybejf') == False\nassert solution.canMakeSubsequence('ryexztowdz', 'vz') == False\nassert solution.canMakeSubsequence('v', 'tet') == False\nassert solution.canMakeSubsequence('ok', 'mu') == False\nassert solution.canMakeSubsequence('qnjpvf', 'hcxnocexcu') == False\nassert solution.canMakeSubsequence('fd', 'xnrlqoqvgr') == False\nassert solution.canMakeSubsequence('apebffawgj', 'u') == False\nassert solution.canMakeSubsequence('ggzm', 'antit') == False\nassert solution.canMakeSubsequence('zkdtu', 'ozqqk') == False\nassert solution.canMakeSubsequence('rjiejir', 'mdfbqfuh') == False\nassert solution.canMakeSubsequence('zasokg', 'xwn') == False\nassert solution.canMakeSubsequence('inlsntgs', 'mdvnadlxio') == False\nassert solution.canMakeSubsequence('mdinool', 'pmo') == False\nassert solution.canMakeSubsequence('hhd', 'lg') == False\nassert solution.canMakeSubsequence('hlfwyxnng', 'hskbfauulx') == False\nassert solution.canMakeSubsequence('doujyrhvn', 'l') == False\nassert solution.canMakeSubsequence('ouehiov', 'wrg') == False\nassert solution.canMakeSubsequence('bb', 'xgjrmklw') == False\nassert solution.canMakeSubsequence('okfqw', 'rtwkgknwwp') == False\nassert solution.canMakeSubsequence('fgbne', 'lykftmnw') == False\nassert solution.canMakeSubsequence('pytzbcxex', 'hzzcdaytg') == False\nassert solution.canMakeSubsequence('hvcdwhobrt', 'apmq') == False\nassert solution.canMakeSubsequence('dwnfbsqvtv', 'gm') == False\nassert solution.canMakeSubsequence('vepwvlp', 'zfnxhdmg') == False\nassert solution.canMakeSubsequence('silfa', 'smfenu') == False\nassert solution.canMakeSubsequence('tcvunnieg', 'wzfvcvl') == False\nassert solution.canMakeSubsequence('jnawm', 'qnyaxe') == False\nassert solution.canMakeSubsequence('snhfcrq', 'qyewjn') == False\nassert solution.canMakeSubsequence('jkeezk', 'ok') == False\nassert solution.canMakeSubsequence('gljxekido', 'iwoipi') == False\nassert solution.canMakeSubsequence('ujwb', 'ltlu') == False\nassert solution.canMakeSubsequence('ena', 'liyv') == False\nassert solution.canMakeSubsequence('hursthqp', 'iewqsco') == False\nassert solution.canMakeSubsequence('xppajpc', 'vkqilrvm') == False\nassert solution.canMakeSubsequence('bajevco', 'r') == False\nassert solution.canMakeSubsequence('v', 'xzxtfjfw') == False\nassert solution.canMakeSubsequence('pmiezlfnb', 'hysvpliey') == False\nassert solution.canMakeSubsequence('t', 'ck') == False\nassert solution.canMakeSubsequence('kx', 'ycb') == False\nassert solution.canMakeSubsequence('d', 'gdrxsz') == False\nassert solution.canMakeSubsequence('sizd', 'tnmhblsll') == False\nassert solution.canMakeSubsequence('dun', 'jtmwh') == False\nassert solution.canMakeSubsequence('wih', 'uooy') == False\nassert solution.canMakeSubsequence('qalrlzbe', 'zflseixw') == False\nassert solution.canMakeSubsequence('v', 'ktisjuzjsl') == False\nassert solution.canMakeSubsequence('ho', 'upj') == False\nassert solution.canMakeSubsequence('ztvmakrk', 'a') == True\nassert solution.canMakeSubsequence('pwmzkpb', 'jfiprhj') == False\nassert solution.canMakeSubsequence('jgdu', 'eiiktghht') == False\nassert solution.canMakeSubsequence('gxye', 'gdoyrsyn') == False\nassert solution.canMakeSubsequence('simspnssr', 'ckxckob') == False\nassert solution.canMakeSubsequence('cnoujelw', 'gih') == False\nassert solution.canMakeSubsequence('qsqlswyhxq', 'ekwgodu') == False\nassert solution.canMakeSubsequence('alpj', 'etiinxdy') == False\nassert solution.canMakeSubsequence('mginrqnscl', 'ux') == False\nassert solution.canMakeSubsequence('hpte', 'jx') == False\nassert solution.canMakeSubsequence('g', 'nb') == False\nassert solution.canMakeSubsequence('wbge', 'qnqzz') == False\nassert solution.canMakeSubsequence('lak', 'evaqw') == False\nassert solution.canMakeSubsequence('eda', 'yjtrd') == False\nassert solution.canMakeSubsequence('ltomu', 'feluxj') == False\nassert solution.canMakeSubsequence('eh', 'stlndpdmq') == False\nassert solution.canMakeSubsequence('ubk', 'wh') == False\nassert solution.canMakeSubsequence('tnan', 'ccydrc') == False\nassert solution.canMakeSubsequence('ddizkuh', 'ay') == False\nassert solution.canMakeSubsequence('alrm', 'wdnqdob') == False\nassert solution.canMakeSubsequence('oywdnljlm', 'j') == True\nassert solution.canMakeSubsequence('hhenjrg', 'fwtqpjt') == False\nassert solution.canMakeSubsequence('ssvbd', 'zrnjr') == False\nassert solution.canMakeSubsequence('gynkq', 'myrnfzfikp') == False\nassert solution.canMakeSubsequence('g', 'yksps') == False\nassert solution.canMakeSubsequence('epuzsykj', 'txulobak') == False\nassert solution.canMakeSubsequence('jebmlu', 'awwfsopzj') == False\nassert solution.canMakeSubsequence('b', 'bnakdyojis') == False\nassert solution.canMakeSubsequence('zcb', 'xh') == False\nassert solution.canMakeSubsequence('d', 'pgscaxz') == False\nassert solution.canMakeSubsequence('wulygzopq', 'yzwad') == False\nassert solution.canMakeSubsequence('ryiqltrqx', 'ngp') == False\nassert solution.canMakeSubsequence('hbvkeim', 'rchsour') == False\nassert solution.canMakeSubsequence('epe', 'esk') == False\nassert solution.canMakeSubsequence('zraqtfiq', 'ddvownyya') == False\nassert solution.canMakeSubsequence('xbpbqoo', 'llyo') == False\nassert solution.canMakeSubsequence('jknthf', 'x') == False\nassert solution.canMakeSubsequence('hynhf', 'wcpztsei') == False",
  "inefficient_solution": "class Solution:\n    def canMakeSubsequence(self, str1: str, str2: str) -> bool:\n        char_map = {}\n        for i, c in enumerate(str1):\n            char_map[i] = chr(ord(c) + 1) if c != \"z\" else \"a\"\n        str1_count = {}\n        for c in str1:\n            str1_count[c] = str1_count.get(c, 0) + 1\n        str2_count = {}\n        for c in str2:\n            str2_count[c] = str2_count.get(c, 0) + 1\n        str1_freq = {c: str1_count.get(c, 0) for c in str2_count}\n        str1_freq[\"\"] = str1_count.get(\"\", 0)\n        str2_freq = {c: str2_count.get(c, 0) for c in str1_freq}\n        str1_max_freq = {}\n        for i, freq in str1_freq.items():\n            str1_max_freq[i] = max(str1_max_freq.get(i, 0), freq)\n        str2_max_freq = {}\n        for i, freq in str2_freq.items():\n            str2_max_freq[i] = max(str2_max_freq.get(i, 0), freq)\n        for i in range(len(str1)):\n            if str1_max_freq.get(i, 0) >= str2_max_freq.get(i, 0) + str2_max_freq.get((i+1) % len(str1), 0):\n                return True\n        return False",
  "is_python": true
}