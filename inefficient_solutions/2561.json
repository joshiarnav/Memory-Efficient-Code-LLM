{
  "problem_idx": 2561,
  "task_name": "Rearranging Fruits",
  "markdown_description": "\nYou have two fruit baskets containing `n` fruits each. You are given two **0-indexed** integer arrays `basket1` and `basket2` representing the cost of fruit in each basket. You want to make both baskets **equal**. To do so, you can use the following operation as many times as you want:\n\n\n* Chose two indices `i` and `j`, and swap the `ith`fruit of `basket1` with the `jth`\u00a0fruit of `basket2`.\n* The cost of the swap is `min(basket1[i],basket2[j])`.\n\n\nTwo baskets are considered equal if sorting them according to the fruit cost makes them exactly the same baskets.\n\n\nReturn *the minimum cost to make both the baskets equal or* `-1` *if impossible.*\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** basket1 = [4,2,2,2], basket2 = [1,4,1,2]\n**Output:** 1\n**Explanation:** Swap index 1 of basket1 with index 0 of basket2, which has cost 1. Now basket1 = [4,1,2,2] and basket2 = [2,4,1,2]. Rearranging both the arrays makes them equal.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** basket1 = [2,3,4,1], basket2 = [3,2,5,1]\n**Output:** -1\n**Explanation:** It can be shown that it is impossible to make both the baskets equal.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `basket1.length == basket2.length`\n* `1 <= basket1.length <= 105`\n* `1 <= basket1[i],basket2[i]\u00a0<= 109`\n\n\n",
  "canonical_solution": "class Solution:\n    def minCost(self, basket1: List[int], basket2: List[int]) -> int:\n        cnt = Counter()\n        for a, b in zip(basket1, basket2):\n            cnt[a] += 1\n            cnt[b] -= 1\n        mi = min(cnt)\n        nums = []\n        for x, v in cnt.items():\n            if v % 2:\n                return -1\n            nums.extend([x] * (abs(v) // 2))\n        nums.sort()\n        m = len(nums) // 2\n        return sum(min(x, mi * 2) for x in nums[:m])\n",
  "test_case_generator": "\nimport random\n\nclass Solution:\n    def minCost(self, basket1, basket2):\n        cnt = Counter()\n        for a, b in zip(basket1, basket2):\n            cnt[a] += 1\n            cnt[b] -= 1\n        mi = min(cnt)\n        nums = []\n        for x, v in cnt.items():\n            if v % 2:\n                return -1\n            nums.extend([x] * (abs(v) // 2))\n        nums.sort()\n        m = len(nums) // 2\n        return sum(min(x, mi * 2) for x in nums[:m])\n\ndef generate_test_case():\n    solution = Solution()\n\n    # Generate random numbers for basket1\n    basket1 = random.sample(range(1, 101), random.randint(2, 10))\n\n    # Generate random numbers for basket2\n    basket2 = random.sample(range(1, 101), random.randint(2, 10))\n\n    # Calculate the expected result using the provided Solution class\n    expected_result = solution.minCost(basket1, basket2)\n\n    return basket1, basket2, expected_result\n\ndef test_generated_test_cases(num_tests):\n    test_case_generator_results = []\n    for i in range(num_tests):\n        basket1, basket2, expected_result = generate_test_case()\n        solution = Solution()\n        assert solution.minCost(basket1, basket2) == expected_result\n        if expected_result != -1:\n            print(f\"assert solution.minCost({basket1}, {basket2}) == {expected_result}\")\n            test_case_generator_results.append(f\"assert solution.minCost({basket1}, {basket2}) == {expected_result}\")\n    return test_case_generator_results\n\nif __name__ == \"__main__\":\n    num_tests = 100  # You can change this to generate more test cases\n    test_case_generator_results = test_generated_test_cases(num_tests)\n",
  "test_case": "",
  "inefficient_solution": "class Solution:\n    def minCost(self, basket1: List[int], basket2: List[int]) -> int:\n        m1, m2 = {}, {}\n        for i, a in enumerate(basket1):\n            m1[i] = a\n        for i, b in enumerate(basket2):\n            m2[i] = b\n        cnt = {}\n        for a, b in zip(m1.values(), m2.values()):\n            if a not in cnt:\n                cnt[a] = 1\n            else:\n                cnt[a] += 1\n            if b not in cnt:\n                cnt[b] = 1\n            else:\n                cnt[b] += 1\n        if len(basket1) != len(basket2):\n            return -1\n        mi = 1000000000000000000  # assuming max cost is 1000000000000000000\n        for k, v in cnt.items():\n            if v % 2:\n                return -1\n            mi = min(mi, k)\n        nums = []\n        for k, v in cnt.items():\n            nums.extend([k] * (v // 2))\n        nums.sort()\n        m = len(nums) // 2\n        return sum(min(x, mi * 2) for x in nums[:m])",
  "is_python": true
}