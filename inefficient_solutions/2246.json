{
  "problem_idx": 2246,
  "task_name": "Longest Path With Different Adjacent Characters",
  "markdown_description": "\nYou are given a **tree** (i.e. a connected, undirected graph that has no cycles) **rooted** at node `0` consisting of `n` nodes numbered from `0` to `n - 1`. The tree is represented by a **0-indexed** array `parent` of size `n`, where `parent[i]` is the parent of node `i`. Since node `0` is the root, `parent[0] == -1`.\n\n\nYou are also given a string `s` of length `n`, where `s[i]` is the character assigned to node `i`.\n\n\nReturn *the length of the **longest path** in the tree such that no pair of **adjacent** nodes on the path have the same character assigned to them.*\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2200-2299/2246.Longest%20Path%20With%20Different%20Adjacent%20Characters/images/testingdrawio.png)\n\n```\n\n**Input:** parent = [-1,0,0,1,1,2], s = \"abacbe\"\n**Output:** 3\n**Explanation:** The longest path where each two adjacent nodes have different characters in the tree is the path: 0 -> 1 -> 3. The length of this path is 3, so 3 is returned.\nIt can be proven that there is no longer path that satisfies the conditions. \n\n```\n\n**Example 2:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2200-2299/2246.Longest%20Path%20With%20Different%20Adjacent%20Characters/images/graph2drawio.png)\n\n```\n\n**Input:** parent = [-1,0,0,0], s = \"aabc\"\n**Output:** 3\n**Explanation:** The longest path where each two adjacent nodes have different characters is the path: 2 -> 0 -> 3. The length of this path is 3, so 3 is returned.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `n == parent.length == s.length`\n* `1 <= n <= 105`\n* `0 <= parent[i] <= n - 1` for all `i >= 1`\n* `parent[0] == -1`\n* `parent` represents a valid tree.\n* `s` consists of only lowercase English letters.\n\n\n",
  "canonical_solution": "class Solution:\n    def longestPath(self, parent: List[int], s: str) -> int:\n        def dfs(i: int) -> int:\n            mx = 0\n            nonlocal ans\n            for j in g[i]:\n                x = dfs(j) + 1\n                if s[i] != s[j]:\n                    ans = max(ans, mx + x)\n                    mx = max(mx, x)\n            return mx\n\n        g = defaultdict(list)\n        for i in range(1, len(parent)):\n            g[parent[i]].append(i)\n        ans = 0\n        dfs(0)\n        return ans + 1\n",
  "test_case_generator": "\n# Test case generator\nclass Solution:\n    def longestPath(self, parent: List[int], s: str) -> int:\n        def dfs(i: int) -> int:\n            mx = 0\n            nonlocal ans\n            for j in g[i]:\n                x = dfs(j) + 1\n                if s[i] != s[j]:\n                    ans = max(ans, mx + x)\n                    mx = max(mx, x)\n            return mx\n\n        g = defaultdict(list)\n        for i in range(1, len(parent)):\n            g[parent[i]].append(i)\n        ans = 0\n        dfs(0)\n        return ans + 1\n\ndef generate_test_case():\n    solution = Solution()\n    \n    # Generate random parent list\n    parent = [-1] + random.choices(range(0, 101), k=random.randint(1, 10))\n    \n    # Generate random string\n    s = ''.join(random.choices(string.ascii_lowercase, k=len(parent)))\n\n    # Calculate the expected result using the provided Solution class\n    expected_result = solution.longestPath(parent, s)\n\n    return parent, s, expected_result\n\ndef test_generated_test_cases(num_tests):\n    test_case_generator_results = []\n    for i in range(num_tests):\n        parent, s, expected_result = generate_test_case()\n        solution = Solution()\n        assert solution.longestPath(parent, s) == expected_result\n        print(f\"assert solution.longestPath({parent}, '{s}') == {expected_result}\")\n        test_case_generator_results.append(f\"assert solution.longestPath({parent}, '{s}') == {expected_result}\") # You can find that we construct the test case in the same format as the example\n    return test_case_generator_results\n\nif __name__ == \"__main__\":\n    num_tests = 100  # You can change this to generate more test cases\n    test_case_generator_results = test_generated_test_cases(num_tests)\n",
  "test_case": "assert solution.longestPath([-1, 31], 'vr') == 1\nassert solution.longestPath([-1, 26, 36, 38, 9, 24, 62, 0], 'fjksrgvj') == 2\nassert solution.longestPath([-1, 53, 81, 58], 'mxmm') == 1\nassert solution.longestPath([-1, 4, 8, 67, 78, 32, 18, 53, 38, 17], 'pbtirlvzzx') == 1\nassert solution.longestPath([-1, 42, 39, 12, 1, 21], 'jerfnx') == 1\nassert solution.longestPath([-1, 49, 87, 11, 8, 1, 93, 16], 'cuxwibqt') == 1\nassert solution.longestPath([-1, 73, 34, 39, 93, 34, 74, 90], 'yqxpdzey') == 1\nassert solution.longestPath([-1, 55, 23], 'okm') == 1\nassert solution.longestPath([-1, 72, 47, 73, 18, 38, 36, 80], 'dkdoxwrw') == 1\nassert solution.longestPath([-1, 86, 95, 88, 22, 56], 'eecxdo') == 1\nassert solution.longestPath([-1, 45, 19, 50], 'dkfn') == 1\nassert solution.longestPath([-1, 30], 'vf') == 1\nassert solution.longestPath([-1, 84, 4], 'ucg') == 1\nassert solution.longestPath([-1, 35, 43], 'nor') == 1\nassert solution.longestPath([-1, 4, 39, 5, 97, 93, 4, 97, 87, 37, 46], 'gozaqgqdmlf') == 1\nassert solution.longestPath([-1, 98, 99, 1, 86, 92, 9], 'pxrmvse') == 1\nassert solution.longestPath([-1, 100, 22], 'zht') == 1\nassert solution.longestPath([-1, 36, 37, 41, 26, 53], 'irxhvl') == 1\nassert solution.longestPath([-1, 25, 44], 'mse') == 1\nassert solution.longestPath([-1, 63, 20, 81], 'bama') == 1\nassert solution.longestPath([-1, 78], 'td') == 1\nassert solution.longestPath([-1, 74, 35, 88, 36, 45, 54], 'xxwglkx') == 1\nassert solution.longestPath([-1, 48, 66, 53, 55, 96, 57], 'udejuvf') == 1\nassert solution.longestPath([-1, 81, 55, 29, 81, 5, 82, 40, 8, 17], 'rmqtncshlw') == 1\nassert solution.longestPath([-1, 54, 56, 45, 87], 'msnhj') == 1\nassert solution.longestPath([-1, 41, 4, 54, 12, 75, 19], 'ljoicoy') == 1\nassert solution.longestPath([-1, 22, 52, 63, 80, 69], 'wpwfsv') == 1\nassert solution.longestPath([-1, 17, 91], 'sox') == 1\nassert solution.longestPath([-1, 16, 16], 'olm') == 1\nassert solution.longestPath([-1, 81, 58, 5, 29], 'lalha') == 1\nassert solution.longestPath([-1, 2, 16, 99, 86, 22, 32, 84], 'ewozvnvo') == 1\nassert solution.longestPath([-1, 39, 27, 60, 41], 'euuxc') == 1\nassert solution.longestPath([-1, 58, 59, 83, 79, 8, 87, 32], 'hazplhjy') == 1\nassert solution.longestPath([-1, 50, 23, 39, 42, 42, 83, 13, 10], 'gwuisbnof') == 1\nassert solution.longestPath([-1, 44, 36, 33, 37, 0, 44], 'iknuwjm') == 2\nassert solution.longestPath([-1, 100, 48, 48, 47, 69], 'mjgtof') == 1\nassert solution.longestPath([-1, 13, 17, 79, 1, 19, 52, 75, 96], 'pfwvihuro') == 1\nassert solution.longestPath([-1, 29, 80, 71, 3, 18, 48, 99], 'mkqaigzc') == 1\nassert solution.longestPath([-1, 85, 58, 8, 100], 'ethtp') == 1\nassert solution.longestPath([-1, 30, 72, 76, 78], 'kiecw') == 1\nassert solution.longestPath([-1, 63, 24, 30, 90, 51, 47, 46], 'qtsbefgh') == 1\nassert solution.longestPath([-1, 34, 11, 30, 35, 97, 40], 'gypkxrg') == 1\nassert solution.longestPath([-1, 7, 79, 33, 48, 36, 28, 28, 15, 59, 57], 'ofqcdthtuhz') == 1\nassert solution.longestPath([-1, 55, 68, 80, 9], 'nghns') == 1\nassert solution.longestPath([-1, 33, 96, 25, 38, 22, 81], 'wpdpfta') == 1\nassert solution.longestPath([-1, 100, 65], 'fyf') == 1\nassert solution.longestPath([-1, 22], 'nw') == 1\nassert solution.longestPath([-1, 11, 20, 50, 87, 69, 33, 63, 82, 11], 'odedvaeweb') == 1\nassert solution.longestPath([-1, 31, 27, 30, 2], 'fjwbn') == 1\nassert solution.longestPath([-1, 13, 6, 23], 'tvor') == 1\nassert solution.longestPath([-1, 42, 85, 62, 70, 34, 68, 3], 'hkzjletz') == 1\nassert solution.longestPath([-1, 18, 2, 64, 35, 83, 9, 55, 82], 'mpkgazpvl') == 1\nassert solution.longestPath([-1, 45, 80, 45, 62, 90, 80], 'ngrdqbw') == 1\nassert solution.longestPath([-1, 60, 82, 37], 'esex') == 1\nassert solution.longestPath([-1, 10, 61, 48, 62, 87, 77, 9], 'xvkalmhb') == 1\nassert solution.longestPath([-1, 35, 8, 87, 33, 16], 'bsoygg') == 1\nassert solution.longestPath([-1, 58, 31, 5, 100, 7, 59, 90], 'hmcisjcs') == 1\nassert solution.longestPath([-1, 71, 1, 14, 78, 46, 5, 29, 68, 83, 53], 'igihjcehdip') == 1\nassert solution.longestPath([-1, 34], 'fw') == 1\nassert solution.longestPath([-1, 65, 80, 71, 66], 'pjnom') == 1\nassert solution.longestPath([-1, 55, 42, 4, 62], 'alqtv') == 1\nassert solution.longestPath([-1, 52, 91], 'jol') == 1\nassert solution.longestPath([-1, 57, 36, 4, 36, 0], 'kzqgbf') == 2\nassert solution.longestPath([-1, 57, 50, 95, 65, 73], 'xeanzf') == 1\nassert solution.longestPath([-1, 91, 86, 20, 4, 60, 5, 43, 33, 67, 86], 'liwssczswzw') == 1\nassert solution.longestPath([-1, 28, 59, 20], 'tjxn') == 1\nassert solution.longestPath([-1, 95, 93, 10, 20, 94, 21, 22], 'jbceihiq') == 1\nassert solution.longestPath([-1, 13, 98], 'wsj') == 1\nassert solution.longestPath([-1, 38, 1, 22, 91, 64], 'oitneb') == 1\nassert solution.longestPath([-1, 4, 78, 64, 86, 64, 35, 50, 91, 24, 92], 'xylrqtwnbbi') == 1\nassert solution.longestPath([-1, 56, 91, 34, 42, 99, 26], 'ojrqsuw') == 1\nassert solution.longestPath([-1, 16, 25, 15], 'cdgh') == 1\nassert solution.longestPath([-1, 62, 71], 'pqu') == 1\nassert solution.longestPath([-1, 52, 0, 1, 22, 86, 63], 'vlblynm') == 2\nassert solution.longestPath([-1, 79, 100, 62, 22, 34, 30, 18, 48, 12], 'vuqrnxjjjj') == 1\nassert solution.longestPath([-1, 88, 41, 23, 83], 'iqbfb') == 1\nassert solution.longestPath([-1, 100, 42, 89, 42], 'awkqj') == 1\nassert solution.longestPath([-1, 18, 54, 84, 91, 68, 38, 25], 'pqtlksfr') == 1\nassert solution.longestPath([-1, 46, 24], 'hoz') == 1\nassert solution.longestPath([-1, 89, 50, 21, 0, 37, 25, 22, 39, 82, 96], 'zkpairilaty') == 2\nassert solution.longestPath([-1, 41, 39, 9], 'exhq') == 1\nassert solution.longestPath([-1, 19, 34, 23, 82, 23], 'qwoypq') == 1\nassert solution.longestPath([-1, 39, 39, 4, 68, 4, 63, 69, 93, 98, 96], 'jipktvwybqj') == 1\nassert solution.longestPath([-1, 82, 91, 34], 'zdrk') == 1\nassert solution.longestPath([-1, 41, 75, 6], 'xhrj') == 1\nassert solution.longestPath([-1, 28, 33, 4, 65, 29], 'vrwljc') == 1\nassert solution.longestPath([-1, 6, 18, 72, 6, 47], 'zgewdo') == 1\nassert solution.longestPath([-1, 48, 97, 29, 28, 52, 98, 22, 49, 77, 17], 'nzvpxrxxubt') == 1\nassert solution.longestPath([-1, 98, 11, 86, 78, 37, 20, 6, 40], 'wpkarrkvf') == 1\nassert solution.longestPath([-1, 2, 94, 79], 'leqh') == 1\nassert solution.longestPath([-1, 63, 81, 57, 97, 12, 68], 'mwqrlre') == 1\nassert solution.longestPath([-1, 26, 20], 'pre') == 1\nassert solution.longestPath([-1, 68, 6, 50, 81], 'yevpm') == 1\nassert solution.longestPath([-1, 61, 8, 58, 65], 'qsngb') == 1\nassert solution.longestPath([-1, 97, 31, 62, 31, 15], 'mgitwx') == 1\nassert solution.longestPath([-1, 78, 90, 68, 40, 4, 91, 77, 71, 86, 22], 'yfmjpmbldco') == 1\nassert solution.longestPath([-1, 1], 'cu') == 1\nassert solution.longestPath([-1, 5, 36], 'mfy') == 1\nassert solution.longestPath([-1, 85, 68, 74, 49, 96, 72], 'ywhqfpf') == 1\nassert solution.longestPath([-1, 36, 17, 19], 'kbrq') == 1",
  "inefficient_solution": "class Solution:\n    def longestPath(self, parent: List[int], s: str) -> int:\n        n = len(parent)\n        nodes = [[] for _ in range(n)]\n        for i in range(1, n):\n            nodes[parent[i]].append(i)\n        nodes[0].append(-1)  # To avoid index out of range error\n\n        res = [0] * n\n        path_lengths = [0] * n\n        for i in range(n):\n            for j in nodes[i]:\n                path_lengths[j] = path_lengths[i] + 1\n            mx = 0\n            for j in nodes[i]:\n                if res[j] > mx:\n                    mx = res[j]\n            mx = max(mx, path_lengths[i])\n            res[i] = mx\n            mx = 0\n            for j in nodes[i]:\n                if s[i] != s[j]:\n                    mx = max(mx, path_lengths[j] + 1)\n            res[i] = max(res[i], mx)\n        return max(res)",
  "is_python": true
}