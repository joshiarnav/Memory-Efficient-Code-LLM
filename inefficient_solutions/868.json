{
  "problem_idx": 868,
  "task_name": "Binary Gap",
  "markdown_description": "\nGiven a positive integer `n`, find and return *the **longest distance** between any two **adjacent*** `1`*'s in the binary representation of* `n`*. If there are no two adjacent* `1`*'s, return* `0`*.*\n\n\nTwo `1`'s are **adjacent** if there are only `0`'s separating them (possibly no `0`'s). The **distance** between two `1`'s is the absolute difference between their bit positions. For example, the two `1`'s in `\"1001\"` have a distance of 3.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** n = 22\n**Output:** 2\n**Explanation:** 22 in binary is \"10110\".\nThe first adjacent pair of 1's is \"10110\" with a distance of 2.\nThe second adjacent pair of 1's is \"10110\" with a distance of 1.\nThe answer is the largest of these two distances, which is 2.\nNote that \"10110\" is not a valid pair since there is a 1 separating the two 1's underlined.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** n = 8\n**Output:** 0\n**Explanation:** 8 in binary is \"1000\".\nThere are not any adjacent pairs of 1's in the binary representation of 8, so we return 0.\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** n = 5\n**Output:** 2\n**Explanation:** 5 in binary is \"101\".\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= n <= 109`\n\n\n",
  "canonical_solution": "class Solution:\n    def binaryGap(self, n: int) -> int:\n        ans, j = 0, -1\n        for i in range(32):\n            if n & 1:\n                if j != -1:\n                    ans = max(ans, i - j)\n                j = i\n            n >>= 1\n        return ans\n",
  "test_case_generator": "\nimport random\n\nclass Solution:\n    def binaryGap(self, n: int) -> int:\n        ans, j = 0, -1\n        for i in range(32):\n            if n & 1:\n                if j != -1:\n                    ans = max(ans, i - j)\n                j = i\n            n >>= 1\n        return ans\n\n\ndef generate_test_case():\n    solution = Solution()\n    \n    # Generate a random positive integer\n    n = random.randint(1, 1000000000)\n\n    # Calculate the expected result using the provided Solution class\n    expected_result = solution.binaryGap(n)\n\n    return n, expected_result\n\n\ndef test_generated_test_cases(num_tests):\n    test_case_generator_results = []\n    for i in range(num_tests):\n        n, expected_result = generate_test_case()\n        solution = Solution()\n        assert solution.binaryGap(n) == expected_result\n        print(f\"assert solution.binaryGap({n}) == {expected_result}\")\n        test_case_generator_results.append(f\"assert solution.binaryGap({n}) == {expected_result}\") # You can find that we construct the test case in the same format as the example\n    return test_case_generator_results\n\n\nif __name__ == \"__main__\":\n    num_tests = 100  # You can change this to generate more test cases\n    test_case_generator_results = test_generated_test_cases(num_tests)\n",
  "test_case": "assert solution.binaryGap(926349811) == 3\nassert solution.binaryGap(811872529) == 6\nassert solution.binaryGap(808011905) == 7\nassert solution.binaryGap(1105707) == 5\nassert solution.binaryGap(340440132) == 4\nassert solution.binaryGap(966344987) == 6\nassert solution.binaryGap(657903710) == 6\nassert solution.binaryGap(964684559) == 5\nassert solution.binaryGap(129609256) == 4\nassert solution.binaryGap(13425049) == 3\nassert solution.binaryGap(11546824) == 7\nassert solution.binaryGap(435046963) == 4\nassert solution.binaryGap(896358749) == 3\nassert solution.binaryGap(354771602) == 4\nassert solution.binaryGap(94620860) == 4\nassert solution.binaryGap(441795232) == 5\nassert solution.binaryGap(931238150) == 7\nassert solution.binaryGap(432775948) == 5\nassert solution.binaryGap(848539596) == 3\nassert solution.binaryGap(527416695) == 2\nassert solution.binaryGap(249914372) == 8\nassert solution.binaryGap(977116044) == 4\nassert solution.binaryGap(648555900) == 6\nassert solution.binaryGap(305520502) == 4\nassert solution.binaryGap(509409365) == 5\nassert solution.binaryGap(978450098) == 4\nassert solution.binaryGap(570575931) == 8\nassert solution.binaryGap(722789678) == 4\nassert solution.binaryGap(518088967) == 6\nassert solution.binaryGap(990190002) == 6\nassert solution.binaryGap(978172444) == 5\nassert solution.binaryGap(462605611) == 3\nassert solution.binaryGap(626693047) == 3\nassert solution.binaryGap(109914799) == 4\nassert solution.binaryGap(77191879) == 4\nassert solution.binaryGap(527576443) == 4\nassert solution.binaryGap(251144002) == 6\nassert solution.binaryGap(419148638) == 4\nassert solution.binaryGap(970337158) == 5\nassert solution.binaryGap(239926384) == 4\nassert solution.binaryGap(44795692) == 5\nassert solution.binaryGap(556190089) == 5\nassert solution.binaryGap(461945049) == 4\nassert solution.binaryGap(225301921) == 5\nassert solution.binaryGap(76964606) == 4\nassert solution.binaryGap(748259369) == 6\nassert solution.binaryGap(221470965) == 6\nassert solution.binaryGap(819742039) == 5\nassert solution.binaryGap(684337719) == 4\nassert solution.binaryGap(839637717) == 6\nassert solution.binaryGap(895277575) == 7\nassert solution.binaryGap(489046778) == 5\nassert solution.binaryGap(717822543) == 4\nassert solution.binaryGap(395299093) == 4\nassert solution.binaryGap(921783356) == 5\nassert solution.binaryGap(361778383) == 6\nassert solution.binaryGap(290247234) == 5\nassert solution.binaryGap(138218420) == 6\nassert solution.binaryGap(799530764) == 5\nassert solution.binaryGap(12682771) == 6\nassert solution.binaryGap(613688374) == 5\nassert solution.binaryGap(77032729) == 4\nassert solution.binaryGap(602891369) == 4\nassert solution.binaryGap(453524357) == 6\nassert solution.binaryGap(907792614) == 5\nassert solution.binaryGap(133566555) == 6\nassert solution.binaryGap(187283145) == 3\nassert solution.binaryGap(723045495) == 4\nassert solution.binaryGap(94267621) == 4\nassert solution.binaryGap(117129592) == 6\nassert solution.binaryGap(807879077) == 7\nassert solution.binaryGap(9215878) == 5\nassert solution.binaryGap(924055059) == 5\nassert solution.binaryGap(171713543) == 8\nassert solution.binaryGap(909487014) == 4\nassert solution.binaryGap(132121644) == 11\nassert solution.binaryGap(577045086) == 7\nassert solution.binaryGap(791914381) == 4\nassert solution.binaryGap(975516424) == 5\nassert solution.binaryGap(575042230) == 4\nassert solution.binaryGap(290663954) == 5\nassert solution.binaryGap(261257926) == 4\nassert solution.binaryGap(324939384) == 4\nassert solution.binaryGap(40295431) == 8\nassert solution.binaryGap(740413489) == 7\nassert solution.binaryGap(679449120) == 5\nassert solution.binaryGap(11572762) == 5\nassert solution.binaryGap(398599652) == 5\nassert solution.binaryGap(559988778) == 9\nassert solution.binaryGap(646027634) == 7\nassert solution.binaryGap(392480507) == 4\nassert solution.binaryGap(69702290) == 5\nassert solution.binaryGap(822036573) == 5\nassert solution.binaryGap(57647621) == 7\nassert solution.binaryGap(109849796) == 5\nassert solution.binaryGap(950056655) == 6\nassert solution.binaryGap(948745956) == 4\nassert solution.binaryGap(95133657) == 3\nassert solution.binaryGap(628719043) == 5\nassert solution.binaryGap(605737775) == 6",
  "inefficient_solution": "class Solution:\n    def binaryGap(self, n: int) -> int:\n        str_n = str(n)\n        int_n = [int(i) for i in str_n]\n        len_n = len(int_n)\n        max_distance = 0\n        distances = []\n        for i in range(len_n):\n            if int_n[i] == 1:\n                if i != 0:\n                    distances.append(i - 1)\n                if i != len_n - 1:\n                    distances.append(len_n - i - 1)\n        if len(distances) > 0:\n            max_distance = max(distances)\n        return max_distance",
  "is_python": true
}