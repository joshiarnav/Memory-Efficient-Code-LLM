{
  "problem_idx": 1151,
  "task_name": "Minimum Swaps to Group All ",
  "markdown_description": "\nGiven a\u00a0binary array `data`, return\u00a0the minimum number of swaps required to group all `1`\u2019s present in the array together in **any place** in the array.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** data = [1,0,1,0,1]\n**Output:** 1\n**Explanation:** There are 3 ways to group all 1's together:\n[1,1,1,0,0] using 1 swap.\n[0,1,1,1,0] using 2 swaps.\n[0,0,1,1,1] using 1 swap.\nThe minimum is 1.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** data = [0,0,0,1,0]\n**Output:** 0\n**Explanation:** Since there is only one 1 in the array, no swaps are needed.\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** data = [1,0,1,0,1,0,0,1,1,0,1]\n**Output:** 3\n**Explanation:** One possible solution that uses 3 swaps is [0,0,0,0,0,1,1,1,1,1,1].\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= data.length <= 105`\n* `data[i]` is either `0` or `1`.\n\n\n",
  "canonical_solution": "class Solution:\n    def minSwaps(self, data: List[int]) -> int:\n        k = data.count(1)\n        t = sum(data[:k])\n        mx = t\n        for i in range(k, len(data)):\n            t += data[i]\n            t -= data[i - k]\n            mx = max(mx, t)\n        return k - mx\n",
  "test_case_generator": "\nimport random\n\nclass Solution:\n    def minSwaps(self, data):\n        k = data.count(1)\n        t = sum(data[:k])\n        mx = t\n        for i in range(k, len(data)):\n            t += data[i]\n            t -= data[i - k]\n            mx = max(mx, t)\n        return k - mx\n\ndef generate_test_case():\n    solution = Solution()\n    \n    # Generate random numbers list\n    data = random.choices([0, 1], k=random.randint(1, 10))\n\n    # Calculate the expected result using the provided Solution class\n    expected_result = solution.minSwaps(data)\n\n    return data, expected_result\n\ndef test_generated_test_cases(num_tests):\n    test_case_generator_results = []\n    for i in range(num_tests):\n        data, expected_result = generate_test_case()\n        solution = Solution()\n        assert solution.minSwaps(data) == expected_result\n        print(f\"assert solution.minSwaps({data}) == {expected_result}\")\n        test_case_generator_results.append(f\"assert solution.minSwaps({data}) == {expected_result}\") # You can find that we construct the test case in the same format as the example\n    return test_case_generator_results\n\nif __name__ == \"__main__\":\n    num_tests = 100  # You can change this to generate more test cases\n    test_case_generator_results = test_generated_test_cases(num_tests)\n",
  "test_case": "assert solution.minSwaps([0, 1, 1, 1, 0, 0, 1]) == 1\nassert solution.minSwaps([1, 1, 1, 0, 1, 0, 0]) == 1\nassert solution.minSwaps([0, 1]) == 0\nassert solution.minSwaps([1, 0, 0, 1, 0, 0, 1, 0]) == 2\nassert solution.minSwaps([0, 0, 1, 0, 1, 0]) == 1\nassert solution.minSwaps([0, 1, 0, 0, 0, 1, 0, 0, 1]) == 2\nassert solution.minSwaps([1, 0, 0, 1, 0, 0, 0, 0]) == 1\nassert solution.minSwaps([0, 0, 0, 1, 1]) == 0\nassert solution.minSwaps([0, 1, 0, 1, 0, 0, 1, 1, 1]) == 2\nassert solution.minSwaps([0, 1, 1, 0, 0, 1, 1]) == 2\nassert solution.minSwaps([1, 0, 0, 1]) == 1\nassert solution.minSwaps([0]) == 0\nassert solution.minSwaps([0, 1, 0]) == 0\nassert solution.minSwaps([1, 1, 1, 0, 1, 1, 0, 0]) == 1\nassert solution.minSwaps([1, 0, 0]) == 0\nassert solution.minSwaps([0]) == 0\nassert solution.minSwaps([0, 0, 0, 1, 1]) == 0\nassert solution.minSwaps([1, 1, 1, 1]) == 0\nassert solution.minSwaps([0, 1, 1, 0, 0, 0, 1, 0]) == 1\nassert solution.minSwaps([0, 1, 0, 0, 1, 1, 0, 1]) == 1\nassert solution.minSwaps([1, 0, 0, 1, 0]) == 1\nassert solution.minSwaps([0, 0, 0, 1, 1]) == 0\nassert solution.minSwaps([1, 0, 0, 1, 1, 1, 1, 1]) == 1\nassert solution.minSwaps([1, 0, 0, 0, 1, 1, 1, 1, 1, 0]) == 1\nassert solution.minSwaps([0, 0, 1, 0, 1]) == 1\nassert solution.minSwaps([1, 0, 1, 0, 1, 1, 1, 1, 1]) == 1\nassert solution.minSwaps([1, 0, 0, 1, 1, 1, 1]) == 1\nassert solution.minSwaps([0, 1, 0, 0, 0, 0, 0]) == 0\nassert solution.minSwaps([0, 0, 1, 0, 0, 1, 0]) == 1\nassert solution.minSwaps([0, 1, 0, 1, 1, 0]) == 1\nassert solution.minSwaps([0, 0, 1, 1, 1, 1]) == 0\nassert solution.minSwaps([0]) == 0\nassert solution.minSwaps([1, 1, 1, 0, 0, 0, 1]) == 1\nassert solution.minSwaps([0, 1, 0, 1, 0]) == 1\nassert solution.minSwaps([1, 0, 0, 1, 0, 1, 1, 1, 0]) == 1\nassert solution.minSwaps([1, 0, 0, 1, 0, 1, 1]) == 1\nassert solution.minSwaps([1, 0]) == 0\nassert solution.minSwaps([0, 0, 1, 1, 0, 1, 1, 1, 0]) == 1\nassert solution.minSwaps([0, 1, 1, 0, 0, 1, 0, 0, 1]) == 2\nassert solution.minSwaps([0, 0, 1, 1, 0, 0, 1, 1, 1]) == 2\nassert solution.minSwaps([1, 1, 0, 0, 1, 0]) == 1\nassert solution.minSwaps([1, 0, 1, 0, 1, 1, 1, 1]) == 1\nassert solution.minSwaps([0, 0, 1, 1, 1, 0, 0]) == 0\nassert solution.minSwaps([1, 1, 1, 0]) == 0\nassert solution.minSwaps([0, 1, 1, 0, 0, 0, 1, 1, 0, 1]) == 2\nassert solution.minSwaps([1, 1]) == 0\nassert solution.minSwaps([1, 1, 1, 1, 0, 0, 1]) == 1\nassert solution.minSwaps([1, 1, 1, 1, 1, 0, 1, 0, 0]) == 1\nassert solution.minSwaps([0, 0, 1, 1, 0, 0]) == 0\nassert solution.minSwaps([0, 0, 1, 0, 1, 1, 1]) == 1\nassert solution.minSwaps([1, 0, 0, 0]) == 0\nassert solution.minSwaps([0, 1, 1, 0, 0, 0, 1]) == 1\nassert solution.minSwaps([1, 1, 0, 1, 1, 0]) == 1\nassert solution.minSwaps([1, 0, 1, 1, 1, 0, 1, 0, 0]) == 1\nassert solution.minSwaps([1]) == 0\nassert solution.minSwaps([0, 0, 0, 0, 1, 0, 1, 1]) == 1\nassert solution.minSwaps([0, 1, 0, 1, 0, 0, 1, 1, 1, 0]) == 2\nassert solution.minSwaps([1, 0, 1, 1, 0]) == 1\nassert solution.minSwaps([0, 1, 1, 1, 0, 0, 0]) == 0\nassert solution.minSwaps([1, 1, 1, 0, 1, 0, 0, 1, 0, 1]) == 2\nassert solution.minSwaps([0]) == 0\nassert solution.minSwaps([1, 0, 0, 0, 1, 1, 1, 1, 0]) == 1\nassert solution.minSwaps([0, 1, 0, 0, 1, 0, 1, 0, 0]) == 1\nassert solution.minSwaps([0, 0, 0, 1, 0, 0]) == 0\nassert solution.minSwaps([1, 1, 1]) == 0\nassert solution.minSwaps([0, 1]) == 0\nassert solution.minSwaps([1, 1, 1, 0]) == 0\nassert solution.minSwaps([1]) == 0\nassert solution.minSwaps([1, 1]) == 0\nassert solution.minSwaps([0, 1, 1, 0, 1, 1, 0]) == 1\nassert solution.minSwaps([1, 0, 1, 1, 0, 1]) == 1\nassert solution.minSwaps([0, 1, 0, 0, 1]) == 1\nassert solution.minSwaps([1]) == 0\nassert solution.minSwaps([0]) == 0\nassert solution.minSwaps([0, 1, 1]) == 0\nassert solution.minSwaps([0, 0, 0]) == 0\nassert solution.minSwaps([1, 0, 1, 0]) == 1\nassert solution.minSwaps([0, 1, 1, 0, 0, 1, 1, 0]) == 2\nassert solution.minSwaps([1, 0, 1, 0]) == 1\nassert solution.minSwaps([1, 0, 1, 0, 1, 1, 0, 1, 0, 1]) == 2\nassert solution.minSwaps([1, 1, 1, 0, 1, 0]) == 1\nassert solution.minSwaps([0, 1, 1, 0, 1, 1, 0, 0]) == 1\nassert solution.minSwaps([0, 0, 0, 0, 0, 0, 0, 1]) == 0\nassert solution.minSwaps([1, 1, 0, 0, 0, 1, 0, 1, 1]) == 2\nassert solution.minSwaps([0, 0, 1, 1, 1, 0, 0, 0, 0, 1]) == 1\nassert solution.minSwaps([0, 0, 0, 0, 0]) == 0\nassert solution.minSwaps([0, 0, 1]) == 0\nassert solution.minSwaps([1, 1, 0, 1, 0, 0, 1, 0, 1, 1]) == 3\nassert solution.minSwaps([0, 1, 1, 0, 1, 0, 1, 0]) == 1\nassert solution.minSwaps([1, 1, 0, 0, 1, 0, 1, 1, 1]) == 2\nassert solution.minSwaps([1, 1, 0]) == 0\nassert solution.minSwaps([1, 1, 0, 0, 0]) == 0\nassert solution.minSwaps([1, 0, 0, 0, 1, 0, 1, 0]) == 1\nassert solution.minSwaps([1, 1, 0, 1, 0, 1, 0, 1, 0]) == 2\nassert solution.minSwaps([1, 1, 1]) == 0\nassert solution.minSwaps([1, 1, 1, 0]) == 0\nassert solution.minSwaps([1, 1, 1, 0]) == 0\nassert solution.minSwaps([0, 0, 1, 1, 1]) == 0\nassert solution.minSwaps([1, 1]) == 0\nassert solution.minSwaps([1, 0, 1, 0, 0, 1, 1, 1, 0, 1]) == 2",
  "inefficient_solution": "class Solution:\n    def minSwaps(self, data: List[int]) -> int:\n        all_ones = [1] * data.count(1)\n        all_zeros = [0] * len(data) - len(all_ones)\n        result = []\n        for i in range(len(data)):\n            temp = []\n            for j in range(len(data)):\n                if j < i:\n                    temp.append(data[j])\n                else:\n                    if j - i < len(all_ones):\n                        temp.append(all_ones[-(j - i)])\n                    else:\n                        temp.append(all_zeros[-(j - i) + len(all_ones)])\n            result.append(temp)\n        min_swaps = float('inf')\n        for arrangement in result:\n            swaps = 0\n            for i in range(len(arrangement)):\n                if arrangement[i] != 1:\n                    swaps += 1\n                    j = i\n                    while j < len(arrangement) and arrangement[j] != 1:\n                        j += 1\n                    if j == len(arrangement):\n                        break\n                    temp = arrangement[i:j+1]\n                    temp.sort()\n                    arrangement[i:j+1] = temp\n                    swaps += j - i\n            min_swaps = min(min_swaps, swaps)\n        return min_swaps",
  "is_python": true
}