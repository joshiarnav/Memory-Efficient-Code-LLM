{
  "problem_idx": 2258,
  "task_name": "Escape the Spreading Fire",
  "markdown_description": "\nYou are given a **0-indexed** 2D integer array `grid` of size `m x n` which represents a field. Each cell has one of three values:\n\n\n* `0` represents grass,\n* `1` represents fire,\n* `2` represents a wall that you and fire cannot pass through.\n\n\nYou are situated in the top-left cell, `(0, 0)`, and you want to travel to the safehouse at the bottom-right cell, `(m - 1, n - 1)`. Every minute, you may move to an **adjacent** grass cell. **After** your move, every fire cell will spread to all **adjacent** cells that are not walls.\n\n\nReturn *the **maximum** number of minutes that you can stay in your initial position before moving while still safely reaching the safehouse*. If this is impossible, return `-1`. If you can **always** reach the safehouse regardless of the minutes stayed, return `109`.\n\n\nNote that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse.\n\n\nA cell is **adjacent** to another cell if the former is directly north, east, south, or west of the latter (i.e., their sides are touching).\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2200-2299/2258.Escape%20the%20Spreading%20Fire/images/ex1new.jpg)\n\n```\n\n**Input:** grid = [[0,2,0,0,0,0,0],[0,0,0,2,2,1,0],[0,2,0,0,1,2,0],[0,0,2,2,2,0,2],[0,0,0,0,0,0,0]]\n**Output:** 3\n**Explanation:** The figure above shows the scenario where you stay in the initial position for 3 minutes.\nYou will still be able to safely reach the safehouse.\nStaying for more than 3 minutes will not allow you to safely reach the safehouse.\n```\n\n**Example 2:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2200-2299/2258.Escape%20the%20Spreading%20Fire/images/ex2new2.jpg)\n\n```\n\n**Input:** grid = [[0,0,0,0],[0,1,2,0],[0,2,0,0]]\n**Output:** -1\n**Explanation:** The figure above shows the scenario where you immediately move towards the safehouse.\nFire will spread to any cell you move towards and it is impossible to safely reach the safehouse.\nThus, -1 is returned.\n\n```\n\n**Example 3:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2200-2299/2258.Escape%20the%20Spreading%20Fire/images/ex3new.jpg)\n\n```\n\n**Input:** grid = [[0,0,0],[2,2,0],[1,2,0]]\n**Output:** 1000000000\n**Explanation:** The figure above shows the initial grid.\nNotice that the fire is contained by walls and you will always be able to safely reach the safehouse.\nThus, 109 is returned.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `m == grid.length`\n* `n == grid[i].length`\n* `2 <= m, n <= 300`\n* `4 <= m * n <= 2 * 104`\n* `grid[i][j]` is either `0`, `1`, or `2`.\n* `grid[0][0] == grid[m - 1][n - 1] == 0`\n\n\n",
  "canonical_solution": "class Solution:\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\n        def spread(q: Deque[int]) -> Deque[int]:\n            nq = deque()\n            while q:\n                i, j = q.popleft()\n                for a, b in pairwise(dirs):\n                    x, y = i + a, j + b\n                    if 0 <= x < m and 0 <= y < n and not fire[x][y] and grid[x][y] == 0:\n                        fire[x][y] = True\n                        nq.append((x, y))\n            return nq\n\n        def check(t: int) -> bool:\n            for i in range(m):\n                for j in range(n):\n                    fire[i][j] = False\n            q1 = deque()\n            for i, row in enumerate(grid):\n                for j, x in enumerate(row):\n                    if x == 1:\n                        fire[i][j] = True\n                        q1.append((i, j))\n            while t and q1:\n                q1 = spread(q1)\n                t -= 1\n            if fire[0][0]:\n                return False\n            q2 = deque([(0, 0)])\n            vis = [[False] * n for _ in range(m)]\n            vis[0][0] = True\n            while q2:\n                for _ in range(len(q2)):\n                    i, j = q2.popleft()\n                    if fire[i][j]:\n                        continue\n                    for a, b in pairwise(dirs):\n                        x, y = i + a, j + b\n                        if (\n                            0 <= x < m\n                            and 0 <= y < n\n                            and not vis[x][y]\n                            and not fire[x][y]\n                            and grid[x][y] == 0\n                        ):\n                            if x == m - 1 and y == n - 1:\n                                return True\n                            vis[x][y] = True\n                            q2.append((x, y))\n                q1 = spread(q1)\n            return False\n\n        m, n = len(grid), len(grid[0])\n        l, r = -1, m * n\n        dirs = (-1, 0, 1, 0, -1)\n        fire = [[False] * n for _ in range(m)]\n        while l < r:\n            mid = (l + r + 1) >> 1\n            if check(mid):\n                l = mid\n            else:\n                r = mid - 1\n        return int(1e9) if l == m * n else l\n",
  "test_case_generator": "\nimport random\n\nclass Solution:\n    def maximumMinutes(self, grid):\n        def spread(q):\n            nq = deque()\n            while q:\n                i, j = q.popleft()\n                for a, b in pairwise(dirs):\n                    x, y = i + a, j + b\n                    if 0 <= x < m and 0 <= y < n and not fire[x][y] and grid[x][y] == 0:\n                        fire[x][y] = True\n                        nq.append((x, y))\n            return nq\n\n        def check(t):\n            for i in range(m):\n                for j in range(n):\n                    fire[i][j] = False\n            q1 = deque()\n            for i, row in enumerate(grid):\n                for j, x in enumerate(row):\n                    if x == 1:\n                        fire[i][j] = True\n                        q1.append((i, j))\n            while t and q1:\n                q1 = spread(q1)\n                t -= 1\n            if fire[0][0]:\n                return False\n            q2 = deque([(0, 0)])\n            vis = [[False] * n for _ in range(m)]\n            vis[0][0] = True\n            while q2:\n                for _ in range(len(q2)):\n                    i, j = q2.popleft()\n                    if fire[i][j]:\n                        continue\n                    for a, b in pairwise(dirs):\n                        x, y = i + a, j + b\n                        if (\n                            0 <= x < m\n                            and 0 <= y < n\n                            and not vis[x][y]\n                            and not fire[x][y]\n                            and grid[x][y] == 0\n                        ):\n                            if x == m - 1 and y == n - 1:\n                                return True\n                            vis[x][y] = True\n                            q2.append((x, y))\n                q1 = spread(q1)\n            return False\n\n        m, n = len(grid), len(grid[0])\n        l, r = -1, m * n\n        dirs = (-1, 0, 1, 0, -1)\n        fire = [[False] * n for _ in range(m)]\n        while l < r:\n            mid = (l + r + 1) >> 1\n            if check(mid):\n                l = mid\n            else:\n                r = mid - 1\n        return int(1e9) if l == m * n else l\n\ndef generate_test_case():\n    solution = Solution()\n\n    # Generate random grid\n    m = random.randint(2, 5)\n    n = random.randint(2, 5)\n    grid = [[random.choice([0, 1, 2]) for _ in range(n)] for _ in range(m)]\n\n    # Calculate the expected result using the provided Solution class\n    expected_result = solution.maximumMinutes(grid)\n\n    return grid, expected_result\n\ndef test_generated_test_cases(num_tests):\n    test_case_generator_results = []\n    for i in range(num_tests):\n        grid, expected_result = generate_test_case()\n        solution = Solution()\n        assert solution.maximumMinutes(grid) == expected_result\n        print(f\"assert solution.maximumMinutes({grid}) == {expected_result}\")\n        test_case_generator_results.append(f\"assert solution.maximumMinutes({grid}) == {expected_result}\") # You can find that we construct the test case in the same format as the example\n    return test_case_generator_results\n\nif __name__ == \"__main__\":\n    num_tests = 100  # You can change this to generate more test cases\n    test_case_generator_results = test_generated_test_cases(num_tests)\n",
  "test_case": "assert solution.maximumMinutes([[0, 0], [1, 2], [1, 1]]) == -1\nassert solution.maximumMinutes([[0, 0], [1, 2], [1, 1], [0, 0]]) == -1\nassert solution.maximumMinutes([[0, 1, 2, 1, 0], [0, 0, 2, 2, 2], [2, 1, 1, 0, 2], [2, 2, 1, 1, 1], [1, 2, 0, 0, 2]]) == -1\nassert solution.maximumMinutes([[1, 2, 1, 1], [1, 1, 1, 0], [0, 1, 0, 0]]) == -1\nassert solution.maximumMinutes([[2, 2, 0, 1], [1, 0, 0, 0], [1, 2, 0, 1], [1, 1, 0, 0], [0, 2, 0, 2]]) == -1\nassert solution.maximumMinutes([[1, 2], [2, 1], [1, 0], [2, 2], [0, 2]]) == -1\nassert solution.maximumMinutes([[1, 2, 2, 2, 2], [1, 1, 1, 1, 1]]) == -1\nassert solution.maximumMinutes([[1, 1, 0, 1], [1, 1, 2, 1], [2, 0, 1, 2]]) == -1\nassert solution.maximumMinutes([[2, 1], [1, 2]]) == -1\nassert solution.maximumMinutes([[0, 2, 2, 1], [0, 1, 1, 2], [1, 1, 1, 1], [1, 2, 1, 0], [0, 1, 1, 2]]) == -1\nassert solution.maximumMinutes([[0, 1, 0, 0, 0], [1, 2, 1, 1, 2], [2, 1, 2, 2, 0], [0, 2, 0, 1, 1]]) == -1\nassert solution.maximumMinutes([[0, 2], [0, 1], [1, 2], [1, 0], [2, 2]]) == -1\nassert solution.maximumMinutes([[0, 1], [1, 0], [0, 1], [0, 2], [1, 1]]) == -1\nassert solution.maximumMinutes([[2, 1, 2, 1], [0, 2, 0, 0], [0, 1, 2, 2], [1, 0, 0, 0], [0, 2, 1, 0]]) == -1\nassert solution.maximumMinutes([[0, 0, 1, 2, 1], [2, 2, 1, 1, 0], [1, 0, 1, 0, 2], [2, 1, 0, 1, 2], [1, 2, 1, 2, 2]]) == -1\nassert solution.maximumMinutes([[2, 0], [2, 0], [0, 0], [1, 0]]) == -1\nassert solution.maximumMinutes([[2, 2], [2, 0], [2, 2], [1, 2], [2, 0]]) == -1\nassert solution.maximumMinutes([[1, 1], [0, 1], [0, 1], [1, 0]]) == -1\nassert solution.maximumMinutes([[1, 2, 2], [1, 0, 1], [2, 2, 0], [1, 1, 0]]) == -1\nassert solution.maximumMinutes([[2, 0, 1, 0], [0, 2, 0, 2], [0, 2, 2, 0]]) == -1\nassert solution.maximumMinutes([[2, 0, 0, 2, 0], [0, 0, 1, 2, 2], [1, 2, 2, 0, 2], [1, 0, 1, 0, 0], [1, 1, 2, 0, 0]]) == -1\nassert solution.maximumMinutes([[2, 0, 1, 0, 2], [0, 0, 0, 1, 1], [1, 1, 1, 0, 1], [1, 0, 0, 2, 0]]) == -1\nassert solution.maximumMinutes([[0, 1], [0, 0], [2, 0]]) == -1\nassert solution.maximumMinutes([[1, 2, 0], [0, 1, 0], [1, 1, 0], [2, 0, 2]]) == -1\nassert solution.maximumMinutes([[1, 2, 0, 2], [0, 0, 2, 1], [1, 2, 2, 2], [1, 0, 1, 2], [2, 0, 1, 2]]) == -1\nassert solution.maximumMinutes([[1, 1, 1, 0], [2, 0, 1, 0]]) == -1\nassert solution.maximumMinutes([[2, 1, 2], [1, 2, 1], [0, 0, 2], [1, 1, 1]]) == -1\nassert solution.maximumMinutes([[1, 2], [1, 2], [0, 1]]) == -1\nassert solution.maximumMinutes([[0, 2, 1, 1, 0], [1, 2, 2, 2, 0], [2, 1, 2, 2, 2], [2, 2, 0, 1, 2], [0, 1, 0, 1, 2]]) == -1\nassert solution.maximumMinutes([[1, 0], [1, 0]]) == -1\nassert solution.maximumMinutes([[0, 0, 2, 2], [2, 1, 2, 2]]) == -1\nassert solution.maximumMinutes([[0, 1, 0, 1, 1], [1, 0, 0, 1, 0], [1, 0, 1, 0, 0]]) == -1\nassert solution.maximumMinutes([[1, 2, 2], [1, 1, 2]]) == -1\nassert solution.maximumMinutes([[2, 2, 0], [0, 2, 2], [1, 0, 2]]) == -1\nassert solution.maximumMinutes([[1, 0, 0, 2, 0], [0, 0, 2, 1, 2], [1, 2, 2, 1, 0], [0, 1, 0, 2, 1], [2, 2, 2, 2, 2]]) == -1\nassert solution.maximumMinutes([[1, 0, 1, 2, 0], [1, 0, 1, 1, 1]]) == -1\nassert solution.maximumMinutes([[0, 2, 2, 1], [1, 1, 2, 2], [1, 0, 0, 1], [0, 1, 1, 0]]) == -1\nassert solution.maximumMinutes([[2, 1, 0, 1, 0], [2, 2, 2, 2, 1], [0, 1, 0, 1, 0], [2, 2, 2, 2, 2]]) == -1\nassert solution.maximumMinutes([[2, 0, 0, 2], [2, 2, 0, 1], [2, 0, 0, 1], [2, 1, 2, 2]]) == -1\nassert solution.maximumMinutes([[0, 1, 0, 2], [0, 0, 1, 1], [1, 2, 0, 0], [2, 2, 1, 0], [1, 1, 0, 1]]) == -1\nassert solution.maximumMinutes([[2, 2], [0, 1], [0, 2]]) == -1\nassert solution.maximumMinutes([[1, 0, 1], [0, 2, 0], [2, 0, 1], [2, 2, 1]]) == -1\nassert solution.maximumMinutes([[2, 2, 2, 1], [2, 1, 0, 1]]) == -1\nassert solution.maximumMinutes([[2, 0, 1, 1], [0, 1, 1, 1], [0, 0, 2, 1], [1, 1, 2, 1]]) == -1\nassert solution.maximumMinutes([[0, 0, 2], [1, 2, 0], [2, 0, 1], [1, 2, 2]]) == -1\nassert solution.maximumMinutes([[1, 1], [0, 0], [1, 0], [1, 1]]) == -1\nassert solution.maximumMinutes([[0, 2, 2], [1, 0, 2], [1, 1, 1], [2, 0, 1]]) == -1\nassert solution.maximumMinutes([[1, 1, 2, 2], [0, 1, 1, 2]]) == -1\nassert solution.maximumMinutes([[0, 0], [0, 2], [2, 1], [1, 1], [0, 0]]) == -1\nassert solution.maximumMinutes([[2, 2, 2, 2], [2, 2, 0, 2]]) == -1\nassert solution.maximumMinutes([[1, 2, 2, 2, 1], [0, 2, 0, 0, 2], [1, 1, 2, 1, 2]]) == -1\nassert solution.maximumMinutes([[1, 1, 0], [0, 2, 0], [0, 0, 1]]) == -1\nassert solution.maximumMinutes([[1, 1, 2], [2, 1, 2], [0, 1, 0]]) == -1\nassert solution.maximumMinutes([[0, 2, 0], [1, 0, 0], [0, 0, 2], [2, 0, 1]]) == -1\nassert solution.maximumMinutes([[0, 2, 1], [0, 2, 1], [1, 0, 1], [2, 1, 2], [1, 0, 2]]) == -1\nassert solution.maximumMinutes([[2, 2, 0], [1, 0, 2], [2, 0, 0], [2, 1, 0], [1, 2, 0]]) == -1\nassert solution.maximumMinutes([[1, 1, 2, 1, 2], [2, 1, 1, 0, 1], [0, 2, 2, 2, 1], [0, 2, 2, 1, 2], [1, 2, 2, 1, 2]]) == -1\nassert solution.maximumMinutes([[1, 0, 2, 0], [0, 1, 1, 2], [2, 1, 0, 0], [1, 2, 0, 0], [0, 2, 1, 1]]) == -1\nassert solution.maximumMinutes([[0, 2, 2, 1], [2, 2, 2, 0], [2, 2, 2, 0]]) == -1\nassert solution.maximumMinutes([[2, 1], [1, 1], [0, 0]]) == -1\nassert solution.maximumMinutes([[1, 0, 2], [2, 2, 2]]) == -1\nassert solution.maximumMinutes([[2, 2, 2, 1], [2, 2, 1, 1]]) == -1\nassert solution.maximumMinutes([[0, 2, 2], [0, 1, 2], [2, 1, 1]]) == -1\nassert solution.maximumMinutes([[0, 2, 2, 0, 0], [2, 2, 2, 0, 2], [0, 1, 1, 2, 1], [0, 1, 2, 2, 1], [1, 1, 0, 0, 1]]) == -1\nassert solution.maximumMinutes([[1, 0, 2], [0, 1, 1], [0, 2, 2]]) == -1\nassert solution.maximumMinutes([[2, 2], [0, 1]]) == -1\nassert solution.maximumMinutes([[2, 0], [1, 1], [0, 0], [1, 0]]) == -1\nassert solution.maximumMinutes([[2, 0], [0, 1], [0, 0]]) == -1\nassert solution.maximumMinutes([[2, 2], [0, 0], [0, 0], [1, 1], [1, 0]]) == -1\nassert solution.maximumMinutes([[0, 2], [0, 0], [0, 2], [1, 0]]) == -1\nassert solution.maximumMinutes([[2, 0, 1], [1, 2, 0], [1, 2, 0], [0, 1, 0], [0, 0, 2]]) == -1\nassert solution.maximumMinutes([[1, 0], [0, 0]]) == -1\nassert solution.maximumMinutes([[1, 1], [0, 2], [1, 1]]) == -1\nassert solution.maximumMinutes([[0, 0, 0], [2, 2, 1], [0, 2, 0]]) == -1\nassert solution.maximumMinutes([[0, 2], [0, 0]]) == 1000000000\nassert solution.maximumMinutes([[2, 2, 1, 0], [1, 1, 2, 2], [0, 1, 1, 0]]) == -1\nassert solution.maximumMinutes([[0, 2], [2, 0], [2, 1], [1, 2], [2, 2]]) == -1\nassert solution.maximumMinutes([[1, 1], [1, 0], [2, 2]]) == -1\nassert solution.maximumMinutes([[2, 1], [2, 2], [1, 2], [0, 2]]) == -1\nassert solution.maximumMinutes([[2, 1, 1, 1], [1, 1, 2, 2], [2, 2, 2, 1]]) == -1\nassert solution.maximumMinutes([[0, 1, 2, 2], [1, 0, 1, 2], [2, 2, 1, 1], [2, 2, 2, 1], [0, 1, 0, 2]]) == -1\nassert solution.maximumMinutes([[1, 1, 0], [0, 1, 2], [2, 1, 1], [0, 1, 2]]) == -1\nassert solution.maximumMinutes([[1, 2, 0, 1, 0], [2, 2, 2, 2, 2], [1, 2, 0, 0, 1], [0, 1, 0, 2, 1]]) == -1\nassert solution.maximumMinutes([[1, 2, 0], [1, 1, 0], [0, 1, 1], [2, 1, 0]]) == -1\nassert solution.maximumMinutes([[2, 2, 1, 1, 1], [0, 0, 0, 0, 2], [2, 2, 0, 2, 1], [0, 2, 0, 0, 0]]) == -1\nassert solution.maximumMinutes([[0, 1, 0, 1], [1, 0, 2, 1], [0, 2, 2, 1]]) == -1\nassert solution.maximumMinutes([[2, 2, 1, 1], [0, 1, 2, 1], [1, 1, 2, 1], [2, 1, 1, 1], [0, 2, 2, 1]]) == -1\nassert solution.maximumMinutes([[0, 0, 2, 1, 0], [2, 0, 0, 0, 0], [0, 1, 1, 0, 0], [0, 1, 2, 0, 1], [2, 0, 0, 2, 1]]) == -1\nassert solution.maximumMinutes([[1, 1], [1, 2], [2, 1], [2, 1]]) == -1\nassert solution.maximumMinutes([[0, 2, 2, 1, 2], [2, 0, 1, 2, 0]]) == -1\nassert solution.maximumMinutes([[0, 0, 2, 2], [1, 2, 2, 2], [1, 0, 0, 0]]) == -1\nassert solution.maximumMinutes([[0, 0, 1], [2, 0, 1], [2, 0, 1], [2, 2, 1]]) == -1\nassert solution.maximumMinutes([[2, 2, 0, 2, 2], [0, 1, 2, 0, 1], [2, 2, 1, 2, 1], [1, 0, 2, 0, 1]]) == -1\nassert solution.maximumMinutes([[2, 2], [0, 0]]) == 1000000000\nassert solution.maximumMinutes([[1, 2, 2, 0], [1, 0, 0, 2], [0, 0, 0, 1], [0, 2, 0, 0]]) == -1\nassert solution.maximumMinutes([[0, 2, 0, 0, 0], [2, 2, 0, 0, 1], [2, 1, 1, 2, 0]]) == -1\nassert solution.maximumMinutes([[0, 0, 0, 1, 0], [0, 1, 2, 2, 0]]) == -1\nassert solution.maximumMinutes([[0, 0, 1, 1], [1, 2, 0, 1]]) == -1\nassert solution.maximumMinutes([[2, 2, 0, 1, 1], [2, 1, 1, 2, 1], [0, 1, 1, 2, 2], [1, 1, 1, 2, 1]]) == -1\nassert solution.maximumMinutes([[1, 1], [0, 0], [1, 2], [1, 1]]) == -1",
  "inefficient_solution": "class Solution:\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\n        def spread(q: list) -> list:\n            new_q = []\n            for i, j in q:\n                for a, b in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                    x, y = i + a, j + b\n                    if (\n                        0 <= x < m\n                        and 0 <= y < n\n                        and not fire[x][y]\n                        and grid[x][y] == 0\n                    ):\n                        fire[x][y] = True\n                        new_q.append((x, y))\n            return new_q\n\n        def check(t: int) -> bool:\n            for i in range(m):\n                for j in range(n):\n                    fire[i][j] = False\n            tmp_q1 = []\n            for i, row in enumerate(grid):\n                for j, x in enumerate(row):\n                    if x == 1:\n                        fire[i][j] = True\n                        tmp_q1.append((i, j))\n            while t and tmp_q1:\n                tmp_q1 = spread(tmp_q1)\n                t -= 1\n            if fire[0][0]:\n                return False\n            tmp_q2 = [(0, 0)]\n            tmp_vis = [[False] * n for _ in range(m)]\n            tmp_vis[0][0] = True\n            while tmp_q2:\n                for _ in range(len(tmp_q2)):\n                    i, j = tmp_q2.pop(0)\n                    if fire[i][j]:\n                        continue\n                    for a, b in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                        x, y = i + a, j + b\n                        if (\n                            0 <= x < m\n                            and 0 <= y < n\n                            and not tmp_vis[x][y]\n                            and not fire[x][y]\n                            and grid[x][y] == 0\n                        ):\n                            if x == m - 1 and y == n - 1:\n                                return True\n                            tmp_vis[x][y] = True\n                            tmp_q2.append((x, y))\n                tmp_q1 = spread(tmp_q1)\n            return False\n\n        m, n = len(grid), len(grid[0])\n        l, r = -1, m * n\n        fire = [[False] * n for _ in range(m)]\n        for _ in range(m * n):\n            fire.append([False] * n)\n        for _ in range(m):\n            fire.append([False] * n)\n        dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        while l < r:\n            mid = (l + r + 1) >> 1\n            if check(mid):\n                l = mid\n            else:\n                r = mid - 1\n        return int(1e9) if l == m * n else l",
  "is_python": true
}