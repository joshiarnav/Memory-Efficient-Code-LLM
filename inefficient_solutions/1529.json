{
  "problem_idx": 1529,
  "task_name": "Minimum Suffix Flips",
  "markdown_description": "\nYou are given a **0-indexed** binary string `target` of length `n`. You have another binary string `s` of length `n` that is initially set to all zeros. You want to make `s` equal to `target`.\n\n\nIn one operation, you can pick an index `i` where `0 <= i < n` and flip all bits in the **inclusive** range `[i, n - 1]`. Flip means changing `'0'` to `'1'` and `'1'` to `'0'`.\n\n\nReturn *the minimum number of operations needed to make* `s` *equal to* `target`.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** target = \"10111\"\n**Output:** 3\n**Explanation:** Initially, s = \"00000\".\nChoose index i = 2: \"00000\" -> \"00111\"\nChoose index i = 0: \"00111\" -> \"11000\"\nChoose index i = 1: \"11000\" -> \"10111\"\nWe need at least 3 flip operations to form target.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** target = \"101\"\n**Output:** 3\n**Explanation:** Initially, s = \"000\".\nChoose index i = 0: \"000\" -> \"111\"\nChoose index i = 1: \"111\" -> \"100\"\nChoose index i = 2: \"100\" -> \"101\"\nWe need at least 3 flip operations to form target.\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** target = \"00000\"\n**Output:** 0\n**Explanation:** We do not need any operations since the initial s already equals target.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `n == target.length`\n* `1 <= n <= 105`\n* `target[i]` is either `'0'` or `'1'`.\n\n\n",
  "canonical_solution": "class Solution:\n    def minFlips(self, target: str) -> int:\n        ans = 0\n        for v in target:\n            if (ans & 1) ^ int(v):\n                ans += 1\n        return ans\n",
  "test_case_generator": "\nimport random\n\nclass Solution:\n    def minFlips(self, target: str) -> int:\n        ans = 0\n        for v in target:\n            if (ans & 1) ^ int(v):\n                ans += 1\n        return ans\n\n\ndef generate_test_case():\n    solution = Solution()\n    \n    # Generate random binary string\n    target = ''.join(random.choices(['0', '1'], k=random.randint(1, 10)))\n    \n    # Calculate the expected result using the provided Solution class\n    expected_result = solution.minFlips(target)\n\n    return target, expected_result\n\ndef test_generated_test_cases(num_tests):\n    test_case_generator_results = []\n    for i in range(num_tests):\n        target, expected_result = generate_test_case()\n        solution = Solution()\n        assert solution.minFlips(target) == expected_result\n        print(f\"assert solution.minFlips('{target}') == {expected_result}\")\n        test_case_generator_results.append(f\"assert solution.minFlips('{target}') == {expected_result}\")\n    return test_case_generator_results\n\nif __name__ == \"__main__\":\n    num_tests = 100  # You can change this to generate more test cases\n    test_case_generator_results = test_generated_test_cases(num_tests)\n",
  "test_case": "assert solution.minFlips('011') == 1\nassert solution.minFlips('11010000') == 4\nassert solution.minFlips('011') == 1\nassert solution.minFlips('110000101') == 5\nassert solution.minFlips('101') == 3\nassert solution.minFlips('00101') == 3\nassert solution.minFlips('001101110') == 4\nassert solution.minFlips('1010110001') == 7\nassert solution.minFlips('11') == 1\nassert solution.minFlips('001011') == 3\nassert solution.minFlips('110011') == 3\nassert solution.minFlips('01010101') == 7\nassert solution.minFlips('10101101') == 7\nassert solution.minFlips('1000100') == 4\nassert solution.minFlips('001000111') == 3\nassert solution.minFlips('10010') == 4\nassert solution.minFlips('1') == 1\nassert solution.minFlips('1') == 1\nassert solution.minFlips('11110111') == 3\nassert solution.minFlips('0110') == 2\nassert solution.minFlips('0') == 0\nassert solution.minFlips('0100000011') == 3\nassert solution.minFlips('01') == 1\nassert solution.minFlips('001101100') == 4\nassert solution.minFlips('01') == 1\nassert solution.minFlips('1100010') == 4\nassert solution.minFlips('110011101') == 5\nassert solution.minFlips('0100') == 2\nassert solution.minFlips('010') == 2\nassert solution.minFlips('0011101') == 3\nassert solution.minFlips('10111000') == 4\nassert solution.minFlips('00000') == 0\nassert solution.minFlips('010011') == 3\nassert solution.minFlips('11011001') == 5\nassert solution.minFlips('101010011') == 7\nassert solution.minFlips('0101000') == 4\nassert solution.minFlips('011000') == 2\nassert solution.minFlips('001011') == 3\nassert solution.minFlips('101110') == 4\nassert solution.minFlips('0110') == 2\nassert solution.minFlips('1') == 1\nassert solution.minFlips('0000') == 0\nassert solution.minFlips('0') == 0\nassert solution.minFlips('01') == 1\nassert solution.minFlips('1101') == 3\nassert solution.minFlips('001') == 1\nassert solution.minFlips('100011010') == 6\nassert solution.minFlips('0101001') == 5\nassert solution.minFlips('000101110') == 4\nassert solution.minFlips('0000111000') == 2\nassert solution.minFlips('1011') == 3\nassert solution.minFlips('1011100') == 4\nassert solution.minFlips('0010110000') == 4\nassert solution.minFlips('111011') == 3\nassert solution.minFlips('110') == 2\nassert solution.minFlips('1001') == 3\nassert solution.minFlips('1101000') == 4\nassert solution.minFlips('11010') == 4\nassert solution.minFlips('0000011101') == 3\nassert solution.minFlips('011111000') == 2\nassert solution.minFlips('00') == 0\nassert solution.minFlips('0100101101') == 7\nassert solution.minFlips('00100101') == 5\nassert solution.minFlips('10110110') == 6\nassert solution.minFlips('1101100010') == 6\nassert solution.minFlips('001101') == 3\nassert solution.minFlips('1') == 1\nassert solution.minFlips('1') == 1\nassert solution.minFlips('011111000') == 2\nassert solution.minFlips('0111') == 1\nassert solution.minFlips('000011') == 1\nassert solution.minFlips('11000010') == 4\nassert solution.minFlips('011110') == 2\nassert solution.minFlips('10011011') == 5\nassert solution.minFlips('1000') == 2\nassert solution.minFlips('0000') == 0\nassert solution.minFlips('1100100101') == 7\nassert solution.minFlips('101011111') == 5\nassert solution.minFlips('111111') == 1\nassert solution.minFlips('101') == 3\nassert solution.minFlips('010000') == 2\nassert solution.minFlips('11110010') == 4\nassert solution.minFlips('1110000') == 2\nassert solution.minFlips('010101') == 5\nassert solution.minFlips('1101011100') == 6\nassert solution.minFlips('0000011001') == 3\nassert solution.minFlips('1') == 1\nassert solution.minFlips('11010') == 4\nassert solution.minFlips('1111') == 1\nassert solution.minFlips('1') == 1\nassert solution.minFlips('0111011') == 3\nassert solution.minFlips('000') == 0\nassert solution.minFlips('01000') == 2\nassert solution.minFlips('110000100') == 4\nassert solution.minFlips('001101') == 3\nassert solution.minFlips('1') == 1\nassert solution.minFlips('110') == 2\nassert solution.minFlips('0000100001') == 3\nassert solution.minFlips('000001') == 1\nassert solution.minFlips('0010') == 2",
  "inefficient_solution": "class Solution:\n    def minFlips(self, target: str) -> int:\n        n = len(target)\n        s = ['0'] * n\n        ans = 0\n        for i in range(n):\n            for j in range(i, n):\n                if target[j] == '1':\n                    s[j] = '1'\n                else:\n                    s[j] = '0'\n            temp = [int(x) for x in s]\n            if temp != [int(x) for x in target]:\n                ans += 1\n                for j in range(i, n):\n                    s[j] = '1' if s[j] == '0' else '0'\n        return ans",
  "is_python": true
}