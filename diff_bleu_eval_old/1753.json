{
  "problem_idx": "1753",
  "description": "\nYou are playing a solitaire game with **three piles** of stones of sizes `a`\u200b\u200b\u200b\u200b\u200b\u200b, `b`,\u200b\u200b\u200b\u200b\u200b\u200b and `c`\u200b\u200b\u200b\u200b\u200b\u200b respectively. Each turn you choose two **different non-empty** piles, take one stone from each, and add `1` point to your score. The game stops when there are **fewer than two non-empty** piles (meaning there are no more available moves).\n\n\nGiven three integers `a`\u200b\u200b\u200b\u200b\u200b, `b`,\u200b\u200b\u200b\u200b\u200b and `c`\u200b\u200b\u200b\u200b\u200b, return *the* ***maximum*** ***score** you can get.*\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** a = 2, b = 4, c = 6\n**Output:** 6\n**Explanation:** The starting state is (2, 4, 6). One optimal set of moves is:\n- Take from 1st and 3rd piles, state is now (1, 4, 5)\n- Take from 1st and 3rd piles, state is now (0, 4, 4)\n- Take from 2nd and 3rd piles, state is now (0, 3, 3)\n- Take from 2nd and 3rd piles, state is now (0, 2, 2)\n- Take from 2nd and 3rd piles, state is now (0, 1, 1)\n- Take from 2nd and 3rd piles, state is now (0, 0, 0)\nThere are fewer than two non-empty piles, so the game ends. Total: 6 points.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** a = 4, b = 4, c = 6\n**Output:** 7\n**Explanation:** The starting state is (4, 4, 6). One optimal set of moves is:\n- Take from 1st and 2nd piles, state is now (3, 3, 6)\n- Take from 1st and 3rd piles, state is now (2, 3, 5)\n- Take from 1st and 3rd piles, state is now (1, 3, 4)\n- Take from 1st and 3rd piles, state is now (0, 3, 3)\n- Take from 2nd and 3rd piles, state is now (0, 2, 2)\n- Take from 2nd and 3rd piles, state is now (0, 1, 1)\n- Take from 2nd and 3rd piles, state is now (0, 0, 0)\nThere are fewer than two non-empty piles, so the game ends. Total: 7 points.\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** a = 1, b = 8, c = 8\n**Output:** 8\n**Explanation:** One optimal set of moves is to take from the 2nd and 3rd piles for 8 turns until they are empty.\nAfter that, there are fewer than two non-empty piles, so the game ends.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= a, b, c <= 105`\n\n\n",
  "inefficient_solution": "class Solution:\n    def maximumScore(self, a: int, b: int, c: int) -> int:\n        # Create a list to store all possible moves\n        moves = [(a, b, c)]\n\n        # Initialize a dictionary to store the results of each move\n        results = {}\n\n        # Initialize a set to store the visited moves\n        visited = set()\n\n        # Function to calculate the score for a given move\n        def calculate_score(a, b, c):\n            # Calculate the score by taking one stone from each pile\n            score = min(a, b, c) * 2\n            return score\n\n        # Function to apply the move and update the results\n        def apply_move(a, b, c):\n            # Check if the move has been visited before\n            if (a, b, c) in visited:\n                return\n\n            # Mark the move as visited\n            visited.add((a, b, c))\n\n            # Calculate the score for the move\n            score = calculate_score(a, b, c)\n\n            # Update the results dictionary\n            results[(a, b, c)] = score\n\n            # Generate new moves by applying the take one stone from each pile operation\n            new_moves = []\n            if a > 0:\n                new_moves.append((a - 1, b, c))\n            if b > 0:\n                new_moves.append((a, b - 1, c))\n            if c > 0:\n                new_moves.append((a, b, c - 1))\n\n            # Recursively apply the moves and update the results\n            for new_a, new_b, new_c in new_moves:\n                apply_move(new_a, new_b, new_c)\n\n        # Apply the initial move and update the results\n        apply_move(a, b, c)\n\n        # Find the maximum score\n        max_score = 0\n        for a, b, c in moves:\n            score = results.get((a, b, c), 0)\n            max_score = max(max_score, score)\n\n        # Return the maximum score\n        return max_score",
  "canonical_solution": "class Solution:\n    def maximumScore(self, a: int, b: int, c: int) -> int:\n        a, b, c = sorted([a, b, c])\n        if a + b < c:\n            return a + b\n        return (a + b + c) >> 1\n",
  "finetuned_model_solution": "class Solution:\n    def maximumScore(self, a: int, b: int, c: int) -> int:\n        return min(a, b, c) * 2",
  "raw_model_solution": "class Solution:\n    def maximumScore(self, a: int, b: int, c: int) -> int:\n        # Sort the piles in descending order\n        piles = sorted([a, b, c], reverse=True)\n\n        # Initialize the score and the number of turns\n        score = 0\n        turns = 0\n\n        # Iterate over the piles until there are fewer than two non-empty piles\n        while piles[0] > 0 and piles[1] > 0 and piles[2] > 0:\n            # Take one stone from each pile and increment the score and turns\n            score += 1\n            turns += 1\n\n            # Decrement the piles\n            piles[0] -= 1\n            piles[1] -= 1\n            piles[2] -= 1\n\n            # Sort the piles in descending order\n            piles.sort(reverse=True)\n\n        # Return the maximum score\n        return score",
  "finetuned_model_diff_bleu": 0.8659448988522563,
  "raw_model_diff_bleu": 0.7243696798564297,
  "is_python": true,
  "diff_bleu_delta": 0.1415752189958266
}