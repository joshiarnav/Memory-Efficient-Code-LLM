{
  "problem_idx": "2208",
  "description": "\nYou are given an array `nums` of positive integers. In one operation, you can choose **any** number from `nums` and reduce it to **exactly** half the number. (Note that you may choose this reduced number in future operations.)\n\n\nReturn *the **minimum** number of operations to reduce the sum of* `nums` *by **at least** half.*\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** nums = [5,19,8,1]\n**Output:** 3\n**Explanation:** The initial sum of nums is equal to 5 + 19 + 8 + 1 = 33.\nThe following is one of the ways to reduce the sum by at least half:\nPick the number 19 and reduce it to 9.5.\nPick the number 9.5 and reduce it to 4.75.\nPick the number 8 and reduce it to 4.\nThe final array is [5, 4.75, 4, 1] with a total sum of 5 + 4.75 + 4 + 1 = 14.75. \nThe sum of nums has been reduced by 33 - 14.75 = 18.25, which is at least half of the initial sum, 18.25 >= 33/2 = 16.5.\nOverall, 3 operations were used so we return 3.\nIt can be shown that we cannot reduce the sum by at least half in less than 3 operations.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** nums = [3,8,20]\n**Output:** 3\n**Explanation:** The initial sum of nums is equal to 3 + 8 + 20 = 31.\nThe following is one of the ways to reduce the sum by at least half:\nPick the number 20 and reduce it to 10.\nPick the number 10 and reduce it to 5.\nPick the number 3 and reduce it to 1.5.\nThe final array is [1.5, 8, 5] with a total sum of 1.5 + 8 + 5 = 14.5. \nThe sum of nums has been reduced by 31 - 14.5 = 16.5, which is at least half of the initial sum, 16.5 >= 31/2 = 15.5.\nOverall, 3 operations were used so we return 3.\nIt can be shown that we cannot reduce the sum by at least half in less than 3 operations.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= nums.length <= 105`\n* `1 <= nums[i] <= 107`\n\n\n",
  "inefficient_solution": "class Solution:\n    def halveArray(self, nums: List[int]) -> int:\n        s = sum(nums) / 2\n        vals = []\n        for v in nums:\n            vals.append((v, v))\n        for v in vals:\n            v[0] = v[1] / 2\n        for v in vals:\n            if v[1] > 0:\n                v[1] /= 2\n        h = []\n        for v in vals:\n            h.append(v)\n        ans = 0\n        while s > 0:\n            t = max(h, key=lambda x: x[0])\n            h.remove(t)\n            t = (t[0] / 2, t[1] / 2)\n            h.append(t)\n            s -= t[1]\n            ans += 1\n        return ans",
  "canonical_solution": "class Solution:\n    def halveArray(self, nums: List[int]) -> int:\n        s = sum(nums) / 2\n        h = []\n        for v in nums:\n            heappush(h, -v)\n        ans = 0\n        while s > 0:\n            t = -heappop(h) / 2\n            s -= t\n            heappush(h, -t)\n            ans += 1\n        return ans\n",
  "finetuned_model_solution": "class Solution:\n    def halveArray(self, nums: List[int]) -> int:\n        s, k = sum(nums) / 2, 0\n        for v in nums:\n            if v > 0:\n                v >>= 1\n                k += 1\n                s -= v\n        return k",
  "raw_model_solution": "import heapq\nfrom typing import List\n\nclass Solution:\n    def halveArray(self, nums: List[int]) -> int:\n        s = sum(nums)\n        pq = []\n        for num in nums:\n            heapq.heappush(pq, -num)  # Use negative numbers to simulate a max heap\n        ans = 0\n        while s > 0:\n            num = -heapq.heappop(pq)\n            s -= num\n            num /= 2\n            heapq.heappush(pq, -num)\n            ans += 1\n        return ans",
  "finetuned_model_diff_bleu": 0.6758845303054023,
  "raw_model_diff_bleu": 0.6494566435775078,
  "is_python": true,
  "diff_bleu_delta": 0.026427886727894534
}