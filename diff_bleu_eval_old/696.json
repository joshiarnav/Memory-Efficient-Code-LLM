{
  "problem_idx": "696",
  "description": "\nGiven a binary string `s`, return the number of non-empty substrings that have the same number of `0`'s and `1`'s, and all the `0`'s and all the `1`'s in these substrings are grouped consecutively.\n\n\nSubstrings that occur multiple times are counted the number of times they occur.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** s = \"00110011\"\n**Output:** 6\n**Explanation:** There are 6 substrings that have equal number of consecutive 1's and 0's: \"0011\", \"01\", \"1100\", \"10\", \"0011\", and \"01\".\nNotice that some of these substrings repeat and are counted the number of times they occur.\nAlso, \"00110011\" is not a valid substring because all the 0's (and 1's) are not grouped together.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** s = \"10101\"\n**Output:** 4\n**Explanation:** There are 4 substrings: \"10\", \"01\", \"10\", \"01\" that have equal number of consecutive 1's and 0's.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= s.length <= 105`\n* `s[i]` is either `'0'` or `'1'`.\n\n\n",
  "inefficient_solution": "class Solution:\n    def countBinarySubstrings(self, s: str) -> int:\n        i, n = 0, len(s)\n        t = []\n        while i < n:\n            cnt = 1\n            while i + 1 < n and s[i + 1] == s[i]:\n                cnt += 1\n                i += 1\n            temp = [s[i - cnt + 1:i + 1]] * cnt\n            t.extend(temp)\n            i += 1\n        t = [x for x in t if x != '']\n        ans = 0\n        for i in range(1, len(t)):\n            if len(t[i]) != len(t[i - 1]):\n                continue\n            ans += min(t[i - 1], t[i])\n        return ans",
  "canonical_solution": "class Solution:\n    def countBinarySubstrings(self, s: str) -> int:\n        i, n = 0, len(s)\n        t = []\n        while i < n:\n            cnt = 1\n            while i + 1 < n and s[i + 1] == s[i]:\n                cnt += 1\n                i += 1\n            t.append(cnt)\n            i += 1\n        ans = 0\n        for i in range(1, len(t)):\n            ans += min(t[i - 1], t[i])\n        return ans\n",
  "finetuned_model_solution": "class Solution:\n    def countBinarySubstrings(self, s: str) -> int:\n        i, n = 0, len(s)\n        t = []\n        while i < n:\n            cnt = 1\n            while i + 1 < n and s[i + 1] == s[i]:\n                cnt += 1\n                i += 1\n            t.append(cnt)\n            i += 1\n        ans = 0\n        i = 1\n        while i < len(t):\n            ans += min(t[i - 1], t[i])\n            i += 2\n        return ans",
  "raw_model_solution": "class Solution:\n    def countBinarySubstrings(self, s: str) -> int:\n        # Count consecutive occurrences of '0' and '1' in the string\n        groups = [(s[i-1], i) for i in range(1, len(s)+1) if s[i-1] != s[i-2]]\n        \n        # Initialize the count of substrings with equal number of '0's and '1's\n        count = 0\n        \n        # Iterate over the groups\n        for i in range(1, len(groups)):\n            # The number of substrings that can be formed using the current group\n            # and the previous group is min(len(group[i-1]), len(group[i]))\n            count += min(len(groups[i-1]), len(groups[i]))\n        \n        return count",
  "finetuned_model_diff_bleu": 0.6672109559003769,
  "raw_model_diff_bleu": 0.25557242347072134,
  "is_python": true,
  "diff_bleu_delta": 0.4116385324296556
}