{
  "problem_idx": "2518",
  "description": "\nYou are given an array `nums` consisting of **positive** integers and an integer `k`.\n\n\n**Partition** the array into two ordered **groups** such that each element is in exactly **one** group. A partition is called great if the **sum** of elements of each group is greater than or equal to `k`.\n\n\nReturn *the number of **distinct** great partitions*. Since the answer may be too large, return it **modulo** `109 + 7`.\n\n\nTwo partitions are considered distinct if some element `nums[i]` is in different groups in the two partitions.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** nums = [1,2,3,4], k = 4\n**Output:** 6\n**Explanation:** The great partitions are: ([1,2,3], [4]), ([1,3], [2,4]), ([1,4], [2,3]), ([2,3], [1,4]), ([2,4], [1,3]) and ([4], [1,2,3]).\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** nums = [3,3,3], k = 4\n**Output:** 0\n**Explanation:** There are no great partitions for this array.\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** nums = [6,6], k = 2\n**Output:** 2\n**Explanation:** We can either put nums[0] in the first partition or in the second partition.\nThe great partitions will be ([6], [6]) and ([6], [6]).\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= nums.length, k <= 1000`\n* `1 <= nums[i] <= 109`\n\n\n",
  "inefficient_solution": "class Solution:\n    def countPartitions(self, nums: List[int], k: int) -> int:\n        if sum(nums) < k * 2:\n            return 0\n        mod = 10**9 + 7\n        n = len(nums)\n        f = [[[0] * k for _ in range(n + 1)] for _ in range(n + 1)]\n        f[0][0][0] = 1\n        ans = 1\n        for i in range(1, n + 1):\n            f[i][i][0] = 1\n            for j in range(i):\n                for l in range(k):\n                    f[i][j+1][l] = f[i][j][l]\n                    if l >= nums[i-1]:\n                        f[i][j+1][l] = (f[i][j+1][l] + f[i-1][j][l - nums[i-1]]) % mod\n            for j in range(i + 1):\n                for l in range(k):\n                    if l >= nums[i-1]:\n                        f[i][j][l] = (f[i][j][l] + f[i-1][j-1][l - nums[i-1]]) % mod\n            ans = ans * 2 % mod\n        return (ans - sum([sum([sum(row) for row in col]) for col in f[-1]]) * 2 + mod) % mod",
  "canonical_solution": "class Solution:\n    def countPartitions(self, nums: List[int], k: int) -> int:\n        if sum(nums) < k * 2:\n            return 0\n        mod = 10**9 + 7\n        n = len(nums)\n        f = [[0] * k for _ in range(n + 1)]\n        f[0][0] = 1\n        ans = 1\n        for i in range(1, n + 1):\n            ans = ans * 2 % mod\n            for j in range(k):\n                f[i][j] = f[i - 1][j]\n                if j >= nums[i - 1]:\n                    f[i][j] = (f[i][j] + f[i - 1][j - nums[i - 1]]) % mod\n        return (ans - sum(f[-1]) * 2 + mod) % mod\n",
  "finetuned_model_solution": "class Solution:\n    def countPartitions(self, nums: List[int], k: int) -> int:\n        if s := sum(nums); s < k * 2:\n            return 0\n        mod, n = 10**9 + 7, len(nums)\n        f = [[0] * (s // 2 + 2) for _ in range(n + 2)]\n        f[0][0] = 1\n        ans = 1\n        for i, v in enumerate(nums, 1):\n            for j in range(i, 0, -1):\n                for l in range(f[i - 1][j - 1], f[i - 1][j] + 1):\n                    if l + v <= s // 2:\n                        f[i][j] = (f[i][j] + f[i - 1][l]) % mod\n            ans = ans * 2 % mod\n        return (ans - sum(f[-1]) * 2 + mod) % mod",
  "raw_model_solution": "class Solution:\n    def countPartitions(self, nums: List[int], k: int) -> int:\n        mod = 10**9 + 7\n        n = len(nums)\n        total_sum = sum(nums)\n        \n        if total_sum < k * 2:\n            return 0\n        \n        dp = [[0] * (k + 1) for _ in range(n + 1)]\n        dp[0][0] = 1\n        \n        # Initialize the first row and column of the dp table\n        for i in range(1, n + 1):\n            if nums[i - 1] < k:\n                dp[i][nums[i - 1]] = 1\n        \n        for i in range(1, n + 1):\n            for j in range(1, k + 1):\n                if j >= nums[i - 1]:\n                    dp[i][j] = (dp[i - 1][j] + dp[i - 1][j - nums[i - 1]]) % mod\n        \n        # Count the number of distinct great partitions\n        ans = 0\n        for i in range(k + 1):\n            ans = (ans + dp[n][i]) % mod\n        \n        return ans",
  "finetuned_model_diff_bleu": 0.6978110094927107,
  "raw_model_diff_bleu": 0.6910447195414621,
  "is_python": true,
  "diff_bleu_delta": 0.006766289951248616
}