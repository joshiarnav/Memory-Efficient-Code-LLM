{
  "problem_idx": "659",
  "description": "\nYou are given an integer array `nums` that is **sorted in non-decreasing order**.\n\n\nDetermine if it is possible to split `nums` into **one or more subsequences** such that **both** of the following conditions are true:\n\n\n* Each subsequence is a **consecutive increasing sequence** (i.e. each integer is **exactly one** more than the previous integer).\n* All subsequences have a length of `3` **or more**.\n\n\nReturn `true` *if you can split* `nums` *according to the above conditions, or* `false` *otherwise*.\n\n\nA **subsequence** of an array is a new array that is formed from the original array by deleting some (can be none) of the elements without disturbing the relative positions of the remaining elements. (i.e., `[1,3,5]` is a subsequence of `[1,2,3,4,5]` while `[1,3,2]` is not).\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** nums = [1,2,3,3,4,5]\n**Output:** true\n**Explanation:** nums can be split into the following subsequences:\n[**1**,**2**,**3**,3,4,5] --> 1, 2, 3\n[1,2,3,**3**,**4**,**5**] --> 3, 4, 5\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** nums = [1,2,3,3,4,4,5,5]\n**Output:** true\n**Explanation:** nums can be split into the following subsequences:\n[**1**,**2**,**3**,3,**4**,4,**5**,5] --> 1, 2, 3, 4, 5\n[1,2,3,**3**,4,**4**,5,**5**] --> 3, 4, 5\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** nums = [1,2,3,4,4,5]\n**Output:** false\n**Explanation:** It is impossible to split nums into consecutive increasing subsequences of length 3 or more.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= nums.length <= 104`\n* `-1000 <= nums[i] <= 1000`\n* `nums` is sorted in **non-decreasing** order.\n\n\n",
  "inefficient_solution": "class Solution:\n    def isPossible(self, nums: List[int]) -> bool:\n        d = defaultdict(list)\n        for v in nums:\n            tmp = []\n            for h in d[v - 1][:]:\n                if h > 2:\n                    heappush(tmp, h + 1)\n                else:\n                    break\n            for h in tmp:\n                heappush(d[v], h)\n            if not d[v - 1]:\n                heappush(d[v], 1)\n            else:\n                heappush(d[v], heappop(d[v - 1]) + 1)\n            if d[v - 1]:\n                heappush(d[v], heappop(d[v - 1]) + 1)\n            else:\n                heappush(d[v], 1)\n        return all(not v or v and v[0] > 2 for v in d.values())",
  "canonical_solution": "class Solution:\n    def isPossible(self, nums: List[int]) -> bool:\n        d = defaultdict(list)\n        for v in nums:\n            if h := d[v - 1]:\n                heappush(d[v], heappop(h) + 1)\n            else:\n                heappush(d[v], 1)\n        return all(not v or v and v[0] > 2 for v in d.values())\n",
  "finetuned_model_solution": "class Solution:\n    def isPossible(self, nums: List[int]) -> bool:\n        d = defaultdict(list)\n        for v in nums:\n            if d[v - 1] and d[v - 1][-1] - d[v - 1][0] + 1 < 3:\n                return False\n            d[v - 1].append(v)\n        return True",
  "raw_model_solution": "import heapq\n\nclass Solution:\n    def isPossible(self, nums: List[int]) -> bool:\n        d = {}\n        \n        for v in nums:\n            if v - 1 not in d:\n                heapq.heappush(d.get(v, []), 1)\n            else:\n                length = heapq.heappop(d[v - 1])\n                if length > 2:\n                    heapq.heappush(d.get(v, []), length + 1)\n                else:\n                    heapq.heappush(d.get(v, []), 1)\n        \n        return all(not v or v and v[0] > 2 for v in d.values())",
  "finetuned_model_diff_bleu": 0.6334358291570962,
  "raw_model_diff_bleu": 0.5064652617171176,
  "is_python": true,
  "diff_bleu_delta": 0.1269705674399786
}