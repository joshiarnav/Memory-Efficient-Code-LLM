{
  "problem_idx": "2760",
  "description": "\nYou are given a **0-indexed** integer array `nums` and an integer `threshold`.\n\n\nFind the length of the **longest subarray** of `nums` starting at index `l` and ending at index `r` `(0 <= l <= r < nums.length)` that satisfies the following conditions:\n\n\n* `nums[l] % 2 == 0`\n* For all indices `i` in the range `[l, r - 1]`, `nums[i] % 2 != nums[i + 1] % 2`\n* For all indices `i` in the range `[l, r]`, `nums[i] <= threshold`\n\n\nReturn *an integer denoting the length of the longest such subarray.*\n\n\n**Note:** A **subarray** is a contiguous non-empty sequence of elements within an array.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** nums = [3,2,5,4], threshold = 5\n**Output:** 3\n**Explanation:** In this example, we can select the subarray that starts at l = 1 and ends at r = 3 => [2,5,4]. This subarray satisfies the conditions.\nHence, the answer is the length of the subarray, 3. We can show that 3 is the maximum possible achievable length.\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** nums = [1,2], threshold = 2\n**Output:** 1\n**Explanation:** In this example, we can select the subarray that starts at l = 1 and ends at r = 1 => [2]. \nIt satisfies all the conditions and we can show that 1 is the maximum possible achievable length.\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** nums = [2,3,4,5], threshold = 4\n**Output:** 3\n**Explanation:** In this example, we can select the subarray that starts at l = 0 and ends at r = 2 => [2,3,4]. \nIt satisfies all the conditions.\nHence, the answer is the length of the subarray, 3. We can show that 3 is the maximum possible achievable length.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= nums.length <= 100`\n* `1 <= nums[i] <= 100`\n* `1 <= threshold <= 100`\n\n\n",
  "inefficient_solution": "class Solution:\n    def longestAlternatingSubarray(self, nums, threshold):\n        n = len(nums)\n        if n == 1:\n            return 1\n\n        max_len = 0\n        for i in range(n):\n            length = 1\n            flag = nums[i] % 2\n            for j in range(i + 1, n):\n                if nums[j] % 2 != flag and nums[j] <= threshold:\n                    length += 1\n                elif nums[j] % 2 == flag or nums[j] > threshold:\n                    break\n                else:\n                    flag = nums[j] % 2\n                    length += 1\n                max_len = max(max_len, length)\n\n        return max_len",
  "canonical_solution": "class Solution:\n    def longestAlternatingSubarray(self, nums: List[int], threshold: int) -> int:\n        ans, l, n = 0, 0, len(nums)\n        while l < n:\n            if nums[l] % 2 == 0 and nums[l] <= threshold:\n                r = l + 1\n                while r < n and nums[r] % 2 != nums[r - 1] % 2 and nums[r] <= threshold:\n                    r += 1\n                ans = max(ans, r - l)\n                l = r\n            else:\n                l += 1\n        return ans\n",
  "finetuned_model_solution": "class Solution:\n    def longestAlternatingSubarray(self, nums: List[int], threshold: int) -> int:\n        ans = 0\n        l = r = -2\n        for i, v in enumerate(nums):\n            if v % 2 == 0:\n                if l >= r:\n                    l = r = i\n                else:\n                    ans = max(ans, r - l + 1)\n                    l = i\n            elif v > threshold:\n                l = r = -2\n                break\n            else:\n                r = i\n        if l >= r:\n            return ans\n        ans = max(ans, r - l + 1)\n        l += 1\n        r += 1\n        for i in range(l, r):\n            if nums[i] % 2 == 0 or nums[i] > threshold:\n                l = r = -2\n                break\n            r = i + 1\n        return ans",
  "raw_model_solution": "class Solution:\n    def longestAlternatingSubarray(self, nums, threshold):\n        n = len(nums)\n        max_len = 0\n        left = 0\n        \n        # Handle the case where length is 1\n        for i in range(n):\n            if nums[i] % 2 == 0 and nums[i] <= threshold:\n                max_len = max(max_len, 1)\n        \n        for right in range(n):\n            # If current element is even and not within the threshold, move the left pointer to the right\n            while left <= right and (nums[right] % 2 == nums[left] % 2 or nums[right] > threshold):\n                if nums[left] % 2 == 0 and nums[left] <= threshold:\n                    max_len = max(max_len, right - left + 1)\n                left += 1\n            \n            # If the current element is even and within the threshold, update the maximum length\n            if nums[right] % 2 == 0 and nums[right] <= threshold:\n                max_len = max(max_len, right - left + 1)\n        \n        return max_len",
  "finetuned_model_diff_bleu": 0.6250313278162856,
  "raw_model_diff_bleu": 0.5314208831025132,
  "is_python": true,
  "diff_bleu_delta": 0.09361044471377233
}