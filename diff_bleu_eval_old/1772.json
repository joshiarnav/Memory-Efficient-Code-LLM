{
  "problem_idx": "1772",
  "description": "\nYou are given a string array `features` where `features[i]` is a single word that represents the name of a feature of the latest product you are working on. You have made a survey where users have reported which features they like. You are given a string array `responses`, where each `responses[i]` is a string containing space-separated words.\n\n\nThe **popularity** of a feature is the number of `responses[i]` that contain the feature. You want to sort the features in non-increasing order by their popularity. If two features have the same popularity, order them by their original index in `features`. Notice that one response could contain the same feature multiple times; this feature is only counted once in its popularity.\n\n\nReturn *the features in sorted order.*\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** features = [\"cooler\",\"lock\",\"touch\"], responses = [\"i like cooler cooler\",\"lock touch cool\",\"locker like touch\"]\n**Output:** [\"touch\",\"cooler\",\"lock\"]\n**Explanation:** appearances(\"cooler\") = 1, appearances(\"lock\") = 1, appearances(\"touch\") = 2. Since \"cooler\" and \"lock\" both had 1 appearance, \"cooler\" comes first because \"cooler\" came first in the features array.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** features = [\"a\",\"aa\",\"b\",\"c\"], responses = [\"a\",\"a aa\",\"a a a a a\",\"b a\"]\n**Output:** [\"a\",\"aa\",\"b\",\"c\"]\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= features.length <= 104`\n* `1 <= features[i].length <= 10`\n* `features` contains no duplicates.\n* `features[i]` consists of lowercase letters.\n* `1 <= responses.length <= 102`\n* `1 <= responses[i].length <= 103`\n* `responses[i]` consists of lowercase letters and spaces.\n* `responses[i]` contains no two consecutive spaces.\n* `responses[i]` has no leading or trailing spaces.\n\n\n",
  "inefficient_solution": "class Solution:\n    def sortFeatures(self, features: List[str], responses: List[str]) -> List[str]:\n        dict = {}\n        for i, feature in enumerate(features):\n            dict[feature] = []\n        for response in responses:\n            words = response.split()\n            for feature in features:\n                if feature in words:\n                    dict[feature].append(response)\n        cnt = {feature: len(set(response for response in responses for word in response.split() if word == feature)) for feature in features}\n        return sorted(features, key=lambda w: (-cnt[w], features.index(w)))",
  "canonical_solution": "class Solution:\n    def sortFeatures(self, features: List[str], responses: List[str]) -> List[str]:\n        cnt = Counter()\n        for s in responses:\n            for w in set(s.split()):\n                cnt[w] += 1\n        return sorted(features, key=lambda w: -cnt[w])\n",
  "finetuned_model_solution": "class Solution:\n    def sortFeatures(self, features: List[str], responses: List[str]) -> List[str]:\n        cnt = Counter()\n        for response in responses:\n            for feature in response.split():\n                cnt[feature] += 1\n        return sorted(features, key=lambda w: (-cnt[w], features.index(w)))",
  "raw_model_solution": "class Solution:\n    def sortFeatures(self, features: List[str], responses: List[str]) -> List[str]:\n        # Count the appearances of each feature in the responses\n        cnt = {}\n        for response in responses:\n            words = response.split()\n            for feature in features:\n                if feature in words:\n                    cnt[feature] = cnt.get(feature, 0) + 1\n        \n        # Sort the features based on their popularity and original index\n        return sorted(features, key=lambda w: (-cnt.get(w, 0), features.index(w)))",
  "finetuned_model_diff_bleu": 0.5573837281682785,
  "raw_model_diff_bleu": 0.6507367239470946,
  "is_python": true,
  "diff_bleu_delta": -0.09335299577881606
}