{
  "problem_idx": "1708",
  "description": "\nAn array `A` is larger than some array `B` if for the first index `i` where `A[i] != B[i]`, `A[i] > B[i]`.\n\n\nFor example, consider `0`-indexing:\n\n\n* `[1,3,2,4] > [1,2,2,4]`, since at index `1`, `3 > 2`.\n* `[1,4,4,4] < [2,1,1,1]`, since at index `0`, `1 < 2`.\n\n\nA subarray is a contiguous subsequence of the array.\n\n\nGiven an integer array `nums` of **distinct** integers, return the **largest** subarray of `nums` of length `k`.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** nums = [1,4,5,2,3], k = 3\n**Output:** [5,2,3]\n**Explanation:** The subarrays of size 3 are: [1,4,5], [4,5,2], and [5,2,3].\nOf these, [5,2,3] is the largest.\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** nums = [1,4,5,2,3], k = 4\n**Output:** [4,5,2,3]\n**Explanation:** The subarrays of size 4 are: [1,4,5,2], and [4,5,2,3].\nOf these, [4,5,2,3] is the largest.\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** nums = [1,4,5,2,3], k = 1\n**Output:** [5]\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= k <= nums.length <= 105`\n* `1 <= nums[i] <= 109`\n* All the integers of `nums` are **unique**.\n\n\n\u00a0\n\n\n**Follow up:** What if the integers in `nums` are not distinct?\n\n",
  "inefficient_solution": "class Solution:\n    def largestSubarray(self, nums: List[int], k: int) -> List[int]:\n        max_subarray = []\n        max_length = 0\n        for i in range(len(nums) - k + 1):\n            subarray = nums[i : i + k]\n            if len(subarray) > max_length:\n                max_length = len(subarray)\n                max_subarray = subarray[:]\n                max_subarray.sort(reverse=True)\n                max_subarray = [x for x in max_subarray if x in nums]\n        max_subarray.sort(reverse=True)\n        max_subarray = [x for x in max_subarray if x in nums]\n        for i in range(len(nums) - k + 1):\n            subarray = nums[i : i + k]\n            subarray.sort(reverse=True)\n            subarray = [x for x in subarray if x in nums]\n            if subarray == max_subarray:\n                return subarray",
  "canonical_solution": "class Solution:\n    def largestSubarray(self, nums: List[int], k: int) -> List[int]:\n        i = nums.index(max(nums[: len(nums) - k + 1]))\n        return nums[i : i + k]\n",
  "finetuned_model_solution": "class Solution:\n    def largestSubarray(self, nums: List[int], k: int) -> List[int]:\n        d = defaultdict(list)\n        for i, x in enumerate(nums):\n            d[x].append(i)\n        ans = []\n        mx = -inf\n        for x in d:\n            for j in d[x]:\n                if j - k + 1 < mx:\n                    break\n                ans = nums[j - k + 1 : j + 1]\n                mx = max(mx, len(ans))\n        return ans",
  "raw_model_solution": "class Solution:\n    def largestSubarray(self, nums: List[int], k: int) -> List[int]:\n        max_length = 0\n        max_subarray = []\n        for i in range(len(nums) - k + 1):\n            subarray = nums[i : i + k]\n            if sum(subarray) > sum(max_subarray):\n                max_subarray = subarray\n        return max_subarray",
  "finetuned_model_diff_bleu": 0.6802229973059969,
  "raw_model_diff_bleu": 0.6860988520161907,
  "is_python": true,
  "diff_bleu_delta": -0.005875854710193806
}