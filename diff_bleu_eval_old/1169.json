{
  "problem_idx": "1169",
  "description": "\nA transaction is possibly invalid if:\n\n\n* the amount exceeds `$1000`, or;\n* if it occurs within (and including) `60` minutes of another transaction with the **same name** in a **different city**.\n\n\nYou are given an array of strings `transaction` where `transactions[i]` consists of comma-separated values representing the name, time (in minutes), amount, and city of the transaction.\n\n\nReturn a list of `transactions` that are possibly invalid. You may return the answer in **any order**.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** transactions = [\"alice,20,800,mtv\",\"alice,50,100,beijing\"]\n**Output:** [\"alice,20,800,mtv\",\"alice,50,100,beijing\"]\n**Explanation:** The first transaction is invalid because the second transaction occurs within a difference of 60 minutes, have the same name and is in a different city. Similarly the second one is invalid too.\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** transactions = [\"alice,20,800,mtv\",\"alice,50,1200,mtv\"]\n**Output:** [\"alice,50,1200,mtv\"]\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** transactions = [\"alice,20,800,mtv\",\"bob,50,1200,mtv\"]\n**Output:** [\"bob,50,1200,mtv\"]\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `transactions.length <= 1000`\n* Each `transactions[i]` takes the form `\"{name},{time},{amount},{city}\"`\n* Each `{name}` and `{city}` consist of lowercase English letters, and have lengths between `1` and `10`.\n* Each `{time}` consist of digits, and represent an integer between `0` and `1000`.\n* Each `{amount}` consist of digits, and represent an integer between `0` and `2000`.\n\n\n",
  "inefficient_solution": "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        invalid = []\n        for transaction in transactions:\n            name, time, amount, city = transaction.split(\",\")\n            time, amount = int(time), int(amount)\n            for other_transaction in transactions:\n                other_name, other_time, other_amount, other_city = other_transaction.split(\",\")\n                other_time, other_amount = int(other_time), int(other_amount)\n                if other_name != name and (amount > 1000 or abs(time - other_time) <= 60 and city != other_city):\n                    invalid.append(transaction)\n        return invalid",
  "canonical_solution": "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        d = defaultdict(list)\n        idx = set()\n        for i, x in enumerate(transactions):\n            name, time, amount, city = x.split(\",\")\n            time, amount = int(time), int(amount)\n            d[name].append((time, city, i))\n            if amount > 1000:\n                idx.add(i)\n            for t, c, j in d[name]:\n                if c != city and abs(time - t) <= 60:\n                    idx.add(i)\n                    idx.add(j)\n        return [transactions[i] for i in idx]\n",
  "finetuned_model_solution": "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        d = defaultdict(list)\n        for i, x in enumerate(transactions):\n            n, t, a, c = x.split(\",\")\n            t, a = int(t), int(a)\n            d[n].append((t, a, i, c))\n        names = list(d.keys())\n        for i in range(len(names)):\n            for j in range(i + 1, len(names)):\n                name1, name2 = names[i], names[j]\n                for k in range(len(d[name1])):\n                    for l in range(len(d[name2])):\n                        if (\n                            d[name1][k][1] > 1000\n                            or abs(d[name1][k][0] - d[name2][l][0]) <= 60\n                            and d[name1][k][3]!= d[name2][l][3]\n                        ):\n                            invalid.append(transactions[d[name1][k][2]])\n                            break\n        return invalid",
  "raw_model_solution": "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        # Create a HashMap to store transactions that have been processed\n        processed = set()\n        \n        # Create a HashMap to store transactions that are invalid\n        invalid = set()\n        \n        for transaction in transactions:\n            name, time, amount, city = transaction.split(\",\")\n            time, amount = int(time), int(amount)\n            \n            # If the transaction has been processed, skip it\n            if (name, time) in processed:\n                continue\n            \n            # Add the transaction to the processed set\n            processed.add((name, time))\n            \n            # Check all transactions that have been processed\n            for other_transaction in transactions:\n                other_name, other_time, other_amount, other_city = other_transaction.split(\",\")\n                other_time, other_amount = int(other_time), int(other_amount)\n                \n                # If the transactions are the same, skip it\n                if name == other_name:\n                    continue\n                \n                # If the transaction is invalid, add it to the invalid set\n                if (amount > 1000 or abs(time - other_time) <= 60 and city != other_city):\n                    invalid.add(transaction)\n        \n        # Remove duplicate transactions from the result\n        return list(invalid)",
  "finetuned_model_diff_bleu": 0.4231515056887783,
  "raw_model_diff_bleu": 0.2738000685328797,
  "is_python": true,
  "diff_bleu_delta": 0.1493514371558986
}