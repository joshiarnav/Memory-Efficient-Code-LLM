{
  "problem_idx": "1955",
  "description": "\nA sequence is **special** if it consists of a **positive** number of `0`s, followed by a **positive** number of `1`s, then a **positive** number of `2`s.\n\n\n* For example, `[0,1,2]` and `[0,0,1,1,1,2]` are special.\n* In contrast, `[2,1,0]`, `[1]`, and `[0,1,2,0]` are not special.\n\n\nGiven an array `nums` (consisting of **only** integers `0`, `1`, and `2`), return *the **number of different subsequences** that are special*. Since the answer may be very large, **return it modulo** `109 + 7`.\n\n\nA **subsequence** of an array is a sequence that can be derived from the array by deleting some or no elements without changing the order of the remaining elements. Two subsequences are **different** if the **set of indices** chosen are different.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** nums = [0,1,2,2]\n**Output:** 3\n**Explanation:** The special subsequences are bolded [**0**,**1**,**2**,2], [**0**,**1**,2,**2**], and [**0**,**1**,**2**,**2**].\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** nums = [2,2,0,0]\n**Output:** 0\n**Explanation:** There are no special subsequences in [2,2,0,0].\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** nums = [0,1,2,0,1,2]\n**Output:** 7\n**Explanation:** The special subsequences are bolded:\n- [**0**,**1**,**2**,0,1,2]\n- [**0**,**1**,2,0,1,**2**]\n- [**0**,**1**,**2**,0,1,**2**]\n- [**0**,**1**,2,0,**1**,**2**]\n- [**0**,1,2,**0**,**1**,**2**]\n- [**0**,1,2,0,**1**,**2**]\n- [0,1,2,**0**,**1**,**2**]\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= nums.length <= 105`\n* `0 <= nums[i] <= 2`\n\n\n",
  "inefficient_solution": "class Solution:\n    def countSpecialSubsequences(self, nums: List[int]) -> int:\n        mod = 10**9 + 7\n        n = len(nums)\n        dp = [[[] for _ in range(3)] for _ in range(n)]\n        for i in range(n):\n            for j in range(3):\n                dp[i][j] = [0] * 10\n        for i in range(n):\n            dp[i][0][0] = 1 if nums[i] == 0 else 0\n        for i in range(1, n):\n            for j in range(3):\n                for k in range(len(dp[i-1][j])):\n                    dp[i][j][k] = 0\n            for j in range(3):\n                if nums[i] == 0:\n                    dp[i][0][0] = (2 * dp[i-1][0][0] + dp[i-1][0][0]) % mod\n                elif nums[i] == 1:\n                    dp[i][1][0] = (dp[i-1][0][0] + 2 * dp[i-1][1][0]) % mod\n                else:\n                    dp[i][2][0] = (dp[i-1][1][0] + 2 * dp[i-1][2][0]) % mod\n        ans = 0\n        for i in range(n):\n            for j in range(3):\n                ans = (ans + dp[n-1][j][0]) % mod\n        return ans",
  "canonical_solution": "class Solution:\n    def countSpecialSubsequences(self, nums: List[int]) -> int:\n        mod = 10**9 + 7\n        n = len(nums)\n        f = [0] * 3\n        f[0] = nums[0] == 0\n        for i in range(1, n):\n            if nums[i] == 0:\n                f[0] = (2 * f[0] + 1) % mod\n            elif nums[i] == 1:\n                f[1] = (f[0] + 2 * f[1]) % mod\n            else:\n                f[2] = (f[1] + 2 * f[2]) % mod\n        return f[2]\n",
  "finetuned_model_solution": "class Solution:\n    def countSpecialSubsequences(self, nums: List[int]) -> int:\n        mod = 10**9 + 7\n        f0, f1, f2 = 1, 0, 0\n        for x in nums:\n            if x == 0:\n                f0 = (2 * f0 + f0) % mod\n            elif x == 1:\n                f1 = (f0 + 2 * f1) % mod\n            else:\n                f2 = (f1 + 2 * f2) % mod\n        return f0 + f1 + f2",
  "raw_model_solution": "class Solution:\n    def countSpecialSubsequences(self, nums: List[int]) -> int:\n        mod = 10**9 + 7\n        n = len(nums)\n        dp = [[0, 0, 0] for _ in range(n + 1)]\n        \n        dp[0][0] = 1\n        for i in range(n):\n            if nums[i] == 0:\n                dp[i + 1][0] = (dp[i][0] * 2) % mod\n            elif nums[i] == 1:\n                dp[i + 1][1] = (dp[i][0] + dp[i][1] * 2) % mod\n            else:\n                dp[i + 1][2] = (dp[i][1] + dp[i][2] * 2) % mod\n        \n        return (dp[n][0] + dp[n][1]) % mod",
  "finetuned_model_diff_bleu": 0.7409175517036474,
  "raw_model_diff_bleu": 0.7621471253171286,
  "is_python": true,
  "diff_bleu_delta": -0.021229573613481212
}