{
  "problem_idx": "2410",
  "description": "\nYou are given a **0-indexed** integer array `players`, where `players[i]` represents the **ability** of the `ith` player. You are also given a **0-indexed** integer array `trainers`, where `trainers[j]` represents the **training capacity** of the `jth` trainer.\n\n\nThe `ith` player can **match** with the `jth` trainer if the player's ability is **less than or equal to** the trainer's training capacity. Additionally, the `ith` player can be matched with at most one trainer, and the `jth` trainer can be matched with at most one player.\n\n\nReturn *the **maximum** number of matchings between* `players` *and* `trainers` *that satisfy these conditions.*\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** players = [4,7,9], trainers = [8,2,5,8]\n**Output:** 2\n**Explanation:**\nOne of the ways we can form two matchings is as follows:\n- players[0] can be matched with trainers[0] since 4 <= 8.\n- players[1] can be matched with trainers[3] since 7 <= 8.\nIt can be proven that 2 is the maximum number of matchings that can be formed.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** players = [1,1,1], trainers = [10]\n**Output:** 1\n**Explanation:**\nThe trainer can be matched with any of the 3 players.\nEach player can only be matched with one trainer, so the maximum answer is 1.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= players.length, trainers.length <= 105`\n* `1 <= players[i], trainers[j] <= 109`\n\n\n",
  "inefficient_solution": "class Solution:\n    def matchPlayersAndTrainers(self, players: List[int], trainers: List[int]) -> int:\n        players = [i * 1000 for i in players]\n        trainers = [i * 1000 for i in trainers]\n        players.sort()\n        trainers.sort()\n        ans = j = 0\n        while j < len(trainers):\n            for p in players:\n                if p <= trainers[j]:\n                    ans += 1\n                    break\n            j += 1\n        return ans",
  "canonical_solution": "class Solution:\n    def matchPlayersAndTrainers(self, players: List[int], trainers: List[int]) -> int:\n        players.sort()\n        trainers.sort()\n        ans = j = 0\n        for p in players:\n            while j < len(trainers) and trainers[j] < p:\n                j += 1\n            if j < len(trainers):\n                ans += 1\n                j += 1\n        return ans\n",
  "finetuned_model_solution": "class Solution:\n    def matchPlayersAndTrainers(\n        self, players: List[int], trainers: List[int]\n    ) -> int:\n        i = j = 0\n        ans = 0\n        while i < len(players) and j < len(trainers):\n            if players[i] <= trainers[j]:\n                ans += 1\n                i, j = i + 1, j + 1\n            else:\n                j += 1\n        return ans",
  "raw_model_solution": "class Solution:\n    def matchPlayersAndTrainers(self, players: List[int], trainers: List[int]) -> int:\n        players.sort()\n        trainers.sort()\n        j = 0\n        ans = 0\n        for p in players:\n            while j < len(trainers) and p > trainers[j]:\n                j += 1\n            if j < len(trainers):\n                ans += 1\n                j += 1\n        return ans",
  "finetuned_model_diff_bleu": 0.3569049320361742,
  "raw_model_diff_bleu": 0.7420185761434382,
  "is_python": true,
  "diff_bleu_delta": -0.38511364410726406
}