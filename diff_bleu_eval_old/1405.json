{
  "problem_idx": "1405",
  "description": "\nA string `s` is called **happy** if it satisfies the following conditions:\n\n\n* `s` only contains the letters `'a'`, `'b'`, and `'c'`.\n* `s` does not contain any of `\"aaa\"`, `\"bbb\"`, or `\"ccc\"` as a substring.\n* `s` contains **at most** `a` occurrences of the letter `'a'`.\n* `s` contains **at most** `b` occurrences of the letter `'b'`.\n* `s` contains **at most** `c` occurrences of the letter `'c'`.\n\n\nGiven three integers `a`, `b`, and `c`, return *the **longest possible happy** string*. If there are multiple longest happy strings, return *any of them*. If there is no such string, return *the empty string* `\"\"`.\n\n\nA **substring** is a contiguous sequence of characters within a string.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** a = 1, b = 1, c = 7\n**Output:** \"ccaccbcc\"\n**Explanation:** \"ccbccacc\" would also be a correct answer.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** a = 7, b = 1, c = 0\n**Output:** \"aabaa\"\n**Explanation:** It is the only correct answer in this case.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `0 <= a, b, c <= 100`\n* `a + b + c > 0`\n\n\n",
  "inefficient_solution": "class Solution:\n    def longestDiverseString(self, a: int, b: int, c: int) -> str:\n        h = []\n        if a > 0:\n            h.append([a, 'a'])\n            h.append([a, 'a'])\n        if b > 0:\n            h.append([b, 'b'])\n            h.append([b, 'b'])\n        if c > 0:\n            h.append([c, 'c'])\n            h.append([c, 'c'])\n\n        ans = []\n        while len(h) > 0:\n            cur = h.pop()\n            if len(ans) >= 2 and ans[-1] == cur[1] and ans[-2] == cur[1]:\n                if len(h) == 0:\n                    break\n                nxt = h.pop()\n                h.append(nxt)\n                h.append(nxt)\n                ans.append(nxt[1])\n                nxt[0] += 1\n                h.append(nxt)\n                h.append(cur)\n            else:\n                ans.append(cur[1])\n                h.append(cur)\n\n        return ''.join(ans)",
  "canonical_solution": "class Solution:\n    def longestDiverseString(self, a: int, b: int, c: int) -> str:\n        h = []\n        if a > 0:\n            heappush(h, [-a, 'a'])\n        if b > 0:\n            heappush(h, [-b, 'b'])\n        if c > 0:\n            heappush(h, [-c, 'c'])\n\n        ans = []\n        while len(h) > 0:\n            cur = heappop(h)\n            if len(ans) >= 2 and ans[-1] == cur[1] and ans[-2] == cur[1]:\n                if len(h) == 0:\n                    break\n                nxt = heappop(h)\n                ans.append(nxt[1])\n                if -nxt[0] > 1:\n                    nxt[0] += 1\n                    heappush(h, nxt)\n                heappush(h, cur)\n            else:\n                ans.append(cur[1])\n                if -cur[0] > 1:\n                    cur[0] += 1\n                    heappush(h, cur)\n\n        return ''.join(ans)\n",
  "finetuned_model_solution": "class Solution:\n    def longestDiverseString(self, a: int, b: int, c: int) -> str:\n        h = heapify([(a, 'a'), (b, 'b'), (c, 'c')])\n        ans = []\n        while h[0][0] > 0:\n            _, c = heappop(h)\n            if len(ans) >= 2 and ans[-1] == c and ans[-2] == c:\n                if h:\n                    _, c = heappop(h)\n                    heappush(h, (c + 1, c))\n                else:\n                    break\n            ans.append(c)\n            heappush(h, (h[0][0] + 1, c))\n        return ''.join(ans)",
  "raw_model_solution": "class Solution:\n    def longestDiverseString(self, a: int, b: int, c: int) -> str:\n        chars = [['a', a], ['b', b], ['c', c]]\n        chars.sort(key=lambda x: x[1], reverse=True)\n        \n        ans = []\n        while len(chars) > 0:\n            cur = chars.pop()\n            if len(ans) >= 2 and ans[-1] == cur[0] and ans[-2] == cur[0]:\n                if len(chars) > 0:\n                    nxt = chars.pop()\n                    chars.append([nxt[0] + 1, nxt[0]])\n                    chars.append([nxt[0] + 1, nxt[0]])\n                    ans.append(nxt[0] + 1)\n                else:\n                    ans.append(cur[1])\n            else:\n                ans.extend([cur[0]] * (cur[1] - (len(ans) >= 2 and ans[-1] == cur[0] and ans[-2] == cur[0])))\n        \n        return ''.join(map(str, ans))",
  "finetuned_model_diff_bleu": 0.4643037121192905,
  "raw_model_diff_bleu": 0.3553399645716231,
  "is_python": true,
  "diff_bleu_delta": 0.10896374754766741
}