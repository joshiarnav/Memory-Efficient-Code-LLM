{
  "problem_idx": "976",
  "description": "\nGiven an integer array `nums`, return *the largest perimeter of a triangle with a non-zero area, formed from three of these lengths*. If it is impossible to form any triangle of a non-zero area, return `0`.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** nums = [2,1,2]\n**Output:** 5\n**Explanation:** You can form a triangle with three side lengths: 1, 2, and 2.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** nums = [1,2,1,10]\n**Output:** 0\n**Explanation:** \nYou cannot use the side lengths 1, 1, and 2 to form a triangle.\nYou cannot use the side lengths 1, 1, and 10 to form a triangle.\nYou cannot use the side lengths 1, 2, and 10 to form a triangle.\nAs we cannot use any three side lengths to form a triangle of non-zero area, we return 0.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `3 <= nums.length <= 104`\n* `1 <= nums[i] <= 106`\n\n\n",
  "inefficient_solution": "class Solution:\n    def largestPerimeter(self, nums: List[int]) -> int:\n        nums = nums[:]\n        nums.sort()\n        perimeter = 0\n        for _ in range(len(nums)):\n            nums = nums + nums\n        for i in range(len(nums) - 1, 1, -1):\n            if a := nums[i - 1] != 0:\n                if b := nums[i - 2] != 0:\n                    if c := nums[i] != 0:\n                        if (c := nums[i - 1] + nums[i - 2]) > nums[i]:\n                            perimeter = max(perimeter, c + nums[i])\n        return perimeter",
  "canonical_solution": "class Solution:\n    def largestPerimeter(self, nums: List[int]) -> int:\n        nums.sort()\n        for i in range(len(nums) - 1, 1, -1):\n            if (c := nums[i - 1] + nums[i - 2]) > nums[i]:\n                return c + nums[i]\n        return 0\n",
  "finetuned_model_solution": "class Solution:\n    def largestPerimeter(self, nums: List[int]) -> int:\n        nums.sort()\n        for i in range(len(nums) - 1, 1, -1):\n            if nums[i - 1] + nums[i - 2] > nums[i]:\n                return nums[i - 1] + nums[i - 2] + nums[i]\n        return 0",
  "raw_model_solution": "from typing import List\n\nclass Solution:\n    def largestPerimeter(self, nums: List[int]) -> int:\n        nums.sort(reverse=True)\n        for i in range(len(nums) - 2):\n            if nums[i] < nums[i + 1] + nums[i + 2]:\n                return nums[i] + nums[i + 1] + nums[i + 2]\n        return 0",
  "finetuned_model_diff_bleu": 0.6460090322915445,
  "raw_model_diff_bleu": 0.4295932873660184,
  "is_python": true,
  "diff_bleu_delta": 0.21641574492552612
}