{
  "problem_idx": "893",
  "description": "\nYou are given an array of strings of the same length `words`.\n\n\nIn one **move**, you can swap any two even indexed characters or any two odd indexed characters of a string `words[i]`.\n\n\nTwo strings `words[i]` and `words[j]` are **special-equivalent** if after any number of moves, `words[i] == words[j]`.\n\n\n* For example, `words[i] = \"zzxy\"` and `words[j] = \"xyzz\"` are **special-equivalent** because we may make the moves `\"zzxy\" -> \"xzzy\" -> \"xyzz\"`.\n\n\nA **group of special-equivalent strings** from `words` is a non-empty subset of words such that:\n\n\n* Every pair of strings in the group are special equivalent, and\n* The group is the largest size possible (i.e., there is not a string `words[i]` not in the group such that `words[i]` is special-equivalent to every string in the group).\n\n\nReturn *the number of **groups of special-equivalent strings** from* `words`.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** words = [\"abcd\",\"cdab\",\"cbad\",\"xyzz\",\"zzxy\",\"zzyx\"]\n**Output:** 3\n**Explanation:** \nOne group is [\"abcd\", \"cdab\", \"cbad\"], since they are all pairwise special equivalent, and none of the other strings is all pairwise special equivalent to these.\nThe other two groups are [\"xyzz\", \"zzxy\"] and [\"zzyx\"].\nNote that in particular, \"zzxy\" is not special equivalent to \"zzyx\".\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** words = [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]\n**Output:** 3\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= words.length <= 1000`\n* `1 <= words[i].length <= 20`\n* `words[i]` consist of lowercase English letters.\n* All the strings are of the same length.\n\n\n",
  "inefficient_solution": "class Solution:\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\n        s = []\n        for word in words:\n            even_chars = ''.join(sorted(word[::2]))\n            odd_chars = ''.join(sorted(word[1::2]))\n            s.append(even_chars + odd_chars)\n        return len(set(s))\n\n        # Just to make it even more inefficient\n        groups = []\n        for w in s:\n            if w not in groups:\n                groups.append(w)\n        return len(groups)",
  "canonical_solution": "class Solution:\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\n        s = {''.join(sorted(word[::2]) + sorted(word[1::2])) for word in words}\n        return len(s)\n",
  "finetuned_model_solution": "class Solution:\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\n        s = [0] * 52\n        for w in words:\n            i = 0\n            while w:\n                if w[-1] in 'abc':\n                    s[i] += 1\n                elif w[-1] in 'abc':\n                    s[i + 26] += 1\n                i += 2\n                w = w[:-1]\n        return sum(s[i] == 0 for i in range(52))",
  "raw_model_solution": "class Solution:\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\n        s = set()\n        for word in words:\n            even_chars = ''.join(sorted(word[::2]))\n            odd_chars = ''.join(sorted(word[1::2]))\n            s.add(even_chars + odd_chars)\n        return len(s)",
  "finetuned_model_diff_bleu": 0.5457792440305734,
  "raw_model_diff_bleu": 0.48762839564639776,
  "is_python": true,
  "diff_bleu_delta": 0.05815084838417567
}