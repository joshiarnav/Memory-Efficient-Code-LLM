{
  "problem_idx": "1223",
  "description": "\nA die simulator generates a random number from `1` to `6` for each roll. You introduced a constraint to the generator such that it cannot roll the number `i` more than `rollMax[i]` (**1-indexed**) consecutive times.\n\n\nGiven an array of integers `rollMax` and an integer `n`, return *the number of distinct sequences that can be obtained with exact* `n` *rolls*. Since the answer may be too large, return it **modulo** `109 + 7`.\n\n\nTwo sequences are considered different if at least one element differs from each other.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** n = 2, rollMax = [1,1,2,2,2,3]\n**Output:** 34\n**Explanation:** There will be 2 rolls of die, if there are no constraints on the die, there are 6 * 6 = 36 possible combinations. In this case, looking at rollMax array, the numbers 1 and 2 appear at most once consecutively, therefore sequences (1,1) and (2,2) cannot occur, so the final answer is 36-2 = 34.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** n = 2, rollMax = [1,1,1,1,1,1]\n**Output:** 30\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** n = 3, rollMax = [1,1,1,2,2,3]\n**Output:** 181\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= n <= 5000`\n* `rollMax.length == 6`\n* `1 <= rollMax[i] <= 15`\n\n\n",
  "inefficient_solution": "class Solution:\n    def dieSimulator(self, n: int, rollMax: List[int]) -> int:\n        MOD = 10**9 + 7\n        dp = [[[0]*16 for _ in range(6)] for _ in range(n+1)]\n\n        for i in range(6):\n            dp[1][i][1] = 1\n\n        for i in range(1, n):\n            for j in range(6):\n                for k in range(16):\n                    for m in range(1, 7):\n                        if m != j:\n                            dp[i+1][m][1] += dp[i][j][k]\n                        else:\n                            if k < rollMax[j]:\n                                dp[i+1][m][k+1] += dp[i][j][k]\n\n        ans = 0\n        for i in range(6):\n            for j in range(16):\n                ans += dp[n][i][j]\n\n        return ans % MOD",
  "canonical_solution": "class Solution:\n    def dieSimulator(self, n: int, rollMax: List[int]) -> int:\n        @cache\n        def dfs(i, j, x):\n            if i >= n:\n                return 1\n            ans = 0\n            for k in range(1, 7):\n                if k != j:\n                    ans += dfs(i + 1, k, 1)\n                elif x < rollMax[j - 1]:\n                    ans += dfs(i + 1, j, x + 1)\n            return ans % (10**9 + 7)\n\n        return dfs(0, 0, 0)\n",
  "finetuned_model_solution": "class Solution:\n    def dieSimulator(self, n: int, rollMax: List[int]) -> int:\n        def mul(a, b):\n            y = 1\n            while b:\n                if b & 1:\n                    y = y * a % MOD\n                a = a * a % MOD\n                b >>= 1\n            return y\n\n        f = [1] * (n + 1)\n        g = [1] * (n + 1)\n        for i in range(6):\n            for j in range(1, rollMax[i] + 1):\n                f[1] = mul(f[1], j)\n\n        for i in range(1, n + 1):\n            for j in range(6):\n                for k in range(1, rollMax[j] + 1):\n                    if j == 0 or k == 1:\n                        g[i] = mul(g[i], k)\n                    else:\n                        g[i] = mul(g[i], k)\n                        f[i] = (f[i] + mul(f[i - k], g[i - k])) % MOD\n        return (f[n] - 1 + MOD) % MOD",
  "raw_model_solution": "class Solution:\n    def dieSimulator(self, n: int, rollMax: List[int]) -> int:\n        MOD = 10**9 + 7\n        dp = [[0]*(17) for _ in range(6)]\n\n        for i in range(6):\n            dp[i][1] = 1\n\n        for _ in range(1, n):\n            new_dp = [[0]*(17) for _ in range(6)]\n            for j in range(6):\n                for k in range(1, 17):\n                    for m in range(1, 7):\n                        if m != j or k < 2:\n                            new_dp[m-1][1] += dp[j][k]\n                        else:\n                            if k < rollMax[j]:\n                                new_dp[j][k+1] += dp[j][k]\n                            else:\n                                new_dp[j][1] += dp[j][k]\n            dp = new_dp\n\n        ans = 0\n        for i in range(6):\n            for j in range(1, 17):\n                ans += dp[i][j]\n\n        return ans % MOD",
  "finetuned_model_diff_bleu": 0.4853364102273456,
  "raw_model_diff_bleu": 0.4848820039700028,
  "is_python": true,
  "diff_bleu_delta": 0.0004544062573427765
}