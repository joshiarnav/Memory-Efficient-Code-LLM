{
  "problem_idx": "1461",
  "description": "\nGiven a binary string `s` and an integer `k`, return `true` *if every binary code of length* `k` *is a substring of* `s`. Otherwise, return `false`.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** s = \"00110110\", k = 2\n**Output:** true\n**Explanation:** The binary codes of length 2 are \"00\", \"01\", \"10\" and \"11\". They can be all found as substrings at indices 0, 1, 3 and 2 respectively.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** s = \"0110\", k = 1\n**Output:** true\n**Explanation:** The binary codes of length 1 are \"0\" and \"1\", it is clear that both exist as a substring. \n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** s = \"0110\", k = 2\n**Output:** false\n**Explanation:** The binary code \"00\" is of length 2 and does not exist in the array.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= s.length <= 5 * 105`\n* `s[i]` is either `'0'` or `'1'`.\n* `1 <= k <= 20`\n\n\n",
  "inefficient_solution": "class Solution:\n    def hasAllCodes(self, s: str, k: int) -> bool:\n        codes = []\n        for i in range(len(s) - k + 1):\n            codes.append([int(c) for c in s[i : i + k]])\n        return len(set(tuple(code) for code in codes)) == 1 << k",
  "canonical_solution": "class Solution:\n    def hasAllCodes(self, s: str, k: int) -> bool:\n        ss = {s[i : i + k] for i in range(len(s) - k + 1)}\n        return len(ss) == 1 << k\n",
  "finetuned_model_solution": "class Solution:\n    def hasAllCodes(self, s: str, k: int) -> bool:\n        t = ord('1')\n        ans = set()\n        for i, c in enumerate(s):\n            if ord(c) == t:\n                ans.add(i - k + 1)\n        return len(ans) == 1 << k",
  "raw_model_solution": "class Solution:\n    def hasAllCodes(self, s: str, k: int) -> bool:\n        # Create a set to store unique binary codes of length k\n        codes = set()\n        \n        # Calculate the total number of unique binary codes of length k\n        total_codes = 1 << k\n        \n        # Iterate over the string s using a sliding window of size k\n        for i in range(len(s) - k + 1):\n            # Extract the binary code of length k from the string\n            code = int(s[i : i + k], 2)\n            \n            # Add the binary code to the set\n            codes.add(code)\n            \n            # If we have found all possible binary codes, return True\n            if len(codes) == total_codes:\n                return True\n        \n        # If we reach the end of the string and haven't found all possible binary codes, return False\n        return False",
  "finetuned_model_diff_bleu": 0.65165010420073,
  "raw_model_diff_bleu": 0.5397291498977168,
  "is_python": true,
  "diff_bleu_delta": 0.11192095430301319
}