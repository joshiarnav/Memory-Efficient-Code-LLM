{
  "problem_idx": "1439",
  "description": "\nYou are given an `m x n` matrix `mat` that has its rows sorted in non-decreasing order and an integer `k`.\n\n\nYou are allowed to choose **exactly one element** from each row to form an array.\n\n\nReturn *the* `kth` *smallest array sum among all possible arrays*.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** mat = [[1,3,11],[2,4,6]], k = 5\n**Output:** 7\n**Explanation:** Choosing one element from each row, the first k smallest sum are:\n[1,2], [1,4], [3,2], [3,4], [1,6]. Where the 5th sum is 7.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** mat = [[1,3,11],[2,4,6]], k = 9\n**Output:** 17\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** mat = [[1,10,10],[1,4,5],[2,3,6]], k = 7\n**Output:** 9\n**Explanation:** Choosing one element from each row, the first k smallest sum are:\n[1,1,2], [1,1,3], [1,4,2], [1,4,3], [1,1,6], [1,5,2], [1,5,3]. Where the 7th sum is 9.  \n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `m == mat.length`\n* `n == mat.length[i]`\n* `1 <= m, n <= 40`\n* `1 <= mat[i][j] <= 5000`\n* `1 <= k <= min(200, nm)`\n* `mat[i]` is a non-decreasing array.\n\n\n",
  "inefficient_solution": "class Solution:\n    def kthSmallest(self, mat: List[List[int]], k: int) -> int:\n        n = len(mat)\n        arr = [list(map(tuple, zip(*row))) for row in mat]\n        pre = [[(0, 0) for _ in range(n)] for _ in range(n)]\n        pre[0][0] = (mat[0][0], 0)\n        for i in range(n):\n            for j in range(n):\n                pre[i][j] = sorted((a + b, i, j) for i, a in enumerate(pre[i]) for j, b in enumerate(arr[i][j]) if a + b <= 5000)[:k]\n        return pre[-1][-1][0]",
  "canonical_solution": "class Solution:\n    def kthSmallest(self, mat: List[List[int]], k: int) -> int:\n        pre = [0]\n        for cur in mat:\n            pre = sorted(a + b for a in pre for b in cur[:k])[:k]\n        return pre[-1]\n",
  "finetuned_model_solution": "class Solution:\n    def kthSmallest(self, mat: List[List[int]], k: int) -> int:\n        def check(x):\n            co = 0\n            for i in range(n):\n                s = 0\n                for j in range(n):\n                    if arr[i][j] <= x:\n                        s += arr[i][j]\n                co += bisect_left(arr[i], x + 1)\n                if s >= x * co:\n                    break\n            return co >= k\n\n        n = len(mat)\n        arr = [sorted(row) for row in mat]\n        left, right = mat[0][0], mat[-1][-1]\n        while left < right:\n            mid = (left + right) >> 1\n            if check(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left",
  "raw_model_solution": "import heapq\nfrom typing import List\n\nclass Solution:\n    def kthSmallest(self, mat: List[List[int]], k: int) -> int:\n        n = len(mat[0])\n        pq = [(0, 0) * n]\n        heapq.heapify(pq)\n        vis = set((0,) * n)\n        \n        while pq:\n            s, idx = heapq.heappop(pq)\n            if idx == n - 1:\n                return s\n            for i in range(n):\n                if idx + i + 1 not in vis:\n                    vis.add(idx + i + 1)\n                    heapq.heappush(pq, (s + mat[i][idx + i + 1], idx + i + 1))\n            vis.remove(idx)",
  "finetuned_model_diff_bleu": 0.4757988653041865,
  "raw_model_diff_bleu": 0.4992786761541718,
  "is_python": true,
  "diff_bleu_delta": -0.023479810849985294
}