{
  "problem_idx": "2401",
  "description": "\nYou are given an array `nums` consisting of **positive** integers.\n\n\nWe call a subarray of `nums` **nice** if the bitwise **AND** of every pair of elements that are in **different** positions in the subarray is equal to `0`.\n\n\nReturn *the length of the **longest** nice subarray*.\n\n\nA **subarray** is a **contiguous** part of an array.\n\n\n**Note** that subarrays of length `1` are always considered nice.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** nums = [1,3,8,48,10]\n**Output:** 3\n**Explanation:** The longest nice subarray is [3,8,48]. This subarray satisfies the conditions:\n- 3 AND 8 = 0.\n- 3 AND 48 = 0.\n- 8 AND 48 = 0.\nIt can be proven that no longer nice subarray can be obtained, so we return 3.\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** nums = [3,1,5,11,13]\n**Output:** 1\n**Explanation:** The length of the longest nice subarray is 1. Any subarray of length 1 can be chosen.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= nums.length <= 105`\n* `1 <= nums[i] <= 109`\n\n\n",
  "inefficient_solution": "class Solution:\n    def longestNiceSubarray(self, nums):\n        ans = []\n        for x in nums:\n            new_ans = []\n            for i, old_ans in enumerate(ans):\n                if not (old_ans & x):\n                    new_ans.append(old_ans)\n            if not any(old_ans & x for old_ans in ans):\n                new_ans.append(x)\n            ans = new_ans\n            ans.append(x)\n        return len(max(ans, key=len))",
  "canonical_solution": "class Solution:\n    def longestNiceSubarray(self, nums: List[int]) -> int:\n        ans = j = mask = 0\n        for i, x in enumerate(nums):\n            while mask & x:\n                mask ^= nums[j]\n                j += 1\n            ans = max(ans, i - j + 1)\n            mask |= x\n        return ans\n",
  "finetuned_model_solution": "class Solution:\n    def longestNiceSubarray(self, nums: List[int]) -> int:\n        ans = cnt = 0\n        for x in nums:\n            if cnt and x & ans:\n                ans = 0\n            else:\n                cnt |= x\n                ans = max(ans, cnt)\n        return ans",
  "raw_model_solution": "class Solution:\n    def longestNiceSubarray(self, nums):\n        max_len = 0\n        mask = 0\n        for x in nums:\n            new_mask = mask | x\n            while new_mask & -new_mask != new_mask:\n                new_mask ^= mask & -mask\n            max_len = max(max_len, bin(new_mask).count('1'))\n            mask = new_mask\n        return max_len",
  "finetuned_model_diff_bleu": 0.6984038040936564,
  "raw_model_diff_bleu": 0.5256321776482306,
  "is_python": true,
  "diff_bleu_delta": 0.17277162644542587
}