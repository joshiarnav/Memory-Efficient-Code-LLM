{
  "problem_idx": "1183",
  "description": "\nConsider a matrix `M` with dimensions `width * height`, such that every cell has value `0`\u00a0or `1`, and any **square**\u00a0sub-matrix of `M` of size `sideLength * sideLength`\u00a0has at most `maxOnes`\u00a0ones.\n\n\nReturn the maximum possible number of ones that the matrix `M` can have.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** width = 3, height = 3, sideLength = 2, maxOnes = 1\n**Output:** 4\n**Explanation:**\nIn a 3*3 matrix, no 2*2 sub-matrix can have more than 1 one.\nThe best solution that has 4 ones is:\n[1,0,1]\n[0,0,0]\n[1,0,1]\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** width = 3, height = 3, sideLength = 2, maxOnes = 2\n**Output:** 6\n**Explanation:**\n[1,0,1]\n[1,0,1]\n[1,0,1]\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= width, height <= 100`\n* `1 <= sideLength <= width, height`\n* `0 <= maxOnes <= sideLength * sideLength`\n\n\n",
  "inefficient_solution": "class Solution:\n    def maximumNumberOfOnes(\n        self, width: int, height: int, sideLength: int, maxOnes: int\n    ) -> int:\n        x = sideLength\n        cnt = []\n        for i in range(width):\n            for j in range(height):\n                k = (i % x) * x + (j % x)\n                cnt.append(cnt[k] + 1 if k < len(cnt) else 1)\n        for i in range(len(cnt)):\n            for j in range(len(cnt) - 1):\n                if cnt[j] > cnt[j + 1]:\n                    cnt[j], cnt[j + 1] = cnt[j + 1], cnt[j]\n        return sum(cnt[:maxOnes])",
  "canonical_solution": "class Solution:\n    def maximumNumberOfOnes(\n        self, width: int, height: int, sideLength: int, maxOnes: int\n    ) -> int:\n        x = sideLength\n        cnt = [0] * (x * x)\n        for i in range(width):\n            for j in range(height):\n                k = (i % x) * x + (j % x)\n                cnt[k] += 1\n        cnt.sort(reverse=True)\n        return sum(cnt[:maxOnes])\n",
  "finetuned_model_solution": "class Solution:\n    def maximumNumberOfOnes(\n        self, width: int, height: int, sideLength: int, maxOnes: int\n    ) -> int:\n        x = sideLength\n        cnt = [0] * (x * x)\n        ans = 0\n        for i in range(width):\n            for j in range(height):\n                k = (i % x) * x + (j % x)\n                cnt[k] += 1\n                idx = (k + 1) % x * x + (i // x + 1) % x\n                cnt[idx] -= 1\n                ans += 1\n                while idx < len(cnt) and cnt[idx] < 0:\n                    idx -= 1\n                    ans -= 1\n        cnt.sort()\n        return ans + sum(cnt[:maxOnes - ans])",
  "raw_model_solution": "class Solution:\n    def maximumNumberOfOnes(\n        self, width: int, height: int, sideLength: int, maxOnes: int\n    ) -> int:\n        # Initialize the matrix with zeros\n        matrix = [[0] * width for _ in range(height)]\n        \n        # Initialize the count of ones\n        ones = 0\n        \n        # Iterate over the matrix in a row-major order\n        for i in range(width):\n            for j in range(height):\n                # Calculate the maximum possible number of ones in the current cell\n                ones_in_cell = min(maxOnes, (sideLength - 1) * ((i + j) // sideLength) + 1)\n                \n                # Update the count of ones\n                ones += ones_in_cell\n        \n        # Return the maximum possible number of ones\n        return ones",
  "finetuned_model_diff_bleu": 0.5606965054924061,
  "raw_model_diff_bleu": 0.5220151749133797,
  "is_python": true,
  "diff_bleu_delta": 0.03868133057902645
}