{
  "problem_idx": "1151",
  "description": "\nGiven a\u00a0binary array `data`, return\u00a0the minimum number of swaps required to group all `1`\u2019s present in the array together in **any place** in the array.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** data = [1,0,1,0,1]\n**Output:** 1\n**Explanation:** There are 3 ways to group all 1's together:\n[1,1,1,0,0] using 1 swap.\n[0,1,1,1,0] using 2 swaps.\n[0,0,1,1,1] using 1 swap.\nThe minimum is 1.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** data = [0,0,0,1,0]\n**Output:** 0\n**Explanation:** Since there is only one 1 in the array, no swaps are needed.\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** data = [1,0,1,0,1,0,0,1,1,0,1]\n**Output:** 3\n**Explanation:** One possible solution that uses 3 swaps is [0,0,0,0,0,1,1,1,1,1,1].\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= data.length <= 105`\n* `data[i]` is either `0` or `1`.\n\n\n",
  "inefficient_solution": "class Solution:\n    def minSwaps(self, data: List[int]) -> int:\n        all_ones = [1] * data.count(1)\n        all_zeros = [0] * len(data) - len(all_ones)\n        result = []\n        for i in range(len(data)):\n            temp = []\n            for j in range(len(data)):\n                if j < i:\n                    temp.append(data[j])\n                else:\n                    if j - i < len(all_ones):\n                        temp.append(all_ones[-(j - i)])\n                    else:\n                        temp.append(all_zeros[-(j - i) + len(all_ones)])\n            result.append(temp)\n        min_swaps = float('inf')\n        for arrangement in result:\n            swaps = 0\n            for i in range(len(arrangement)):\n                if arrangement[i] != 1:\n                    swaps += 1\n                    j = i\n                    while j < len(arrangement) and arrangement[j] != 1:\n                        j += 1\n                    if j == len(arrangement):\n                        break\n                    temp = arrangement[i:j+1]\n                    temp.sort()\n                    arrangement[i:j+1] = temp\n                    swaps += j - i\n            min_swaps = min(min_swaps, swaps)\n        return min_swaps",
  "canonical_solution": "class Solution:\n    def minSwaps(self, data: List[int]) -> int:\n        k = data.count(1)\n        t = sum(data[:k])\n        mx = t\n        for i in range(k, len(data)):\n            t += data[i]\n            t -= data[i - k]\n            mx = max(mx, t)\n        return k - mx\n",
  "finetuned_model_solution": "class Solution:\n    def minSwaps(self, data: List[int]) -> int:\n        cnt = data.count(1)\n        l = r = 0\n        ans = cnt - 1\n        while r < len(data):\n            if data[r]:\n                l, r = r, r + 1\n                ans += 1\n            else:\n                r += 1\n        return ans",
  "raw_model_solution": "class Solution:\n    def minSwaps(self, data: List[int]) -> int:\n        n = len(data)\n        ones = sum(data)\n        swaps = 0\n        start = 0\n        end = 0\n\n        while end < n:\n            while end < n and data[end] == 0:\n                end += 1\n\n            if end < n:\n                count = 0\n                while start <= end and count < ones:\n                    if data[start] == 1:\n                        count += 1\n                    start += 1\n\n                swaps += end - start + 1\n                start = end + 1\n\n        return swaps",
  "finetuned_model_diff_bleu": 0.8113196056458177,
  "raw_model_diff_bleu": 0.7077171529481574,
  "is_python": true,
  "diff_bleu_delta": 0.10360245269766033
}