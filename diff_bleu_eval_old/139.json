{
  "problem_idx": "139",
  "description": "\nGiven a string `s` and a dictionary of strings `wordDict`, return `true` if `s` can be segmented into a space-separated sequence of one or more dictionary words.\n\n\n**Note** that the same word in the dictionary may be reused multiple times in the segmentation.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** s = \"leetcode\", wordDict = [\"leet\",\"code\"]\n**Output:** true\n**Explanation:** Return true because \"leetcode\" can be segmented as \"leet code\".\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** s = \"applepenapple\", wordDict = [\"apple\",\"pen\"]\n**Output:** true\n**Explanation:** Return true because \"applepenapple\" can be segmented as \"apple pen apple\".\nNote that you are allowed to reuse a dictionary word.\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\n**Output:** false\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= s.length <= 300`\n* `1 <= wordDict.length <= 1000`\n* `1 <= wordDict[i].length <= 20`\n* `s` and `wordDict[i]` consist of only lowercase English letters.\n* All the strings of `wordDict` are **unique**.\n\n\n",
  "inefficient_solution": "class Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\n        words = set(wordDict)\n        n = len(s)\n        f = [True] * (n + 1) * (n + 1)\n        res = [False] * (n + 1) * (n + 1)\n        for i in range(1, n + 1):\n            for j in range(1, n + 1):\n                for k in range(i, n + 1):\n                    if f[j - 1] and s[j - 1:k] in words:\n                        res[i * (n + 1) + k] = True\n                f[j * (n + 1) + i] = True\n        return res[-1]",
  "canonical_solution": "class Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\n        words = set(wordDict)\n        n = len(s)\n        f = [True] + [False] * n\n        for i in range(1, n + 1):\n            f[i] = any(f[j] and s[j:i] in words for j in range(i))\n        return f[n]\n",
  "finetuned_model_solution": "class Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\n        words = set(wordDict)\n        n = len(s)\n        f = [True] + [False] * n\n        for i in range(n):\n            for w in words:\n                if s[i:] == w or i - len(w) >= 0 and f[i - len(w)] and s[i : i + len(w)] == w:\n                    f[i + 1] = True\n        return f[-1]",
  "raw_model_solution": "class Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\n        words = set(wordDict)\n        n = len(s)\n        dp = [False] * (n + 1)\n        dp[0] = True\n        \n        for i in range(1, n + 1):\n            for j in range(i):\n                if dp[j] and s[j:i] in words:\n                    dp[i] = True\n                    break\n        \n        return dp[-1]",
  "finetuned_model_diff_bleu": 0.6545545074152054,
  "raw_model_diff_bleu": 0.7973885003116346,
  "is_python": true,
  "diff_bleu_delta": -0.14283399289642917
}