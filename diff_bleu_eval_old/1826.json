{
  "problem_idx": "1826",
  "description": "\nAn experiment is being conducted in a lab. To ensure accuracy, there are **two** sensors collecting data simultaneously. You are given two arrays `sensor1` and `sensor2`, where `sensor1[i]` and `sensor2[i]` are the `ith` data points collected by the two sensors.\n\n\nHowever, this type of sensor has a chance of being defective, which causes **exactly one** data point to be dropped. After the data is dropped, all the data points to the **right** of the dropped data are **shifted** one place to the left, and the last data point is replaced with some **random value**. It is guaranteed that this random value will **not** be equal to the dropped value.\n\n\n* For example, if the correct data is `[1,2,**3**,4,5]` and `3` is dropped, the sensor could return `[1,2,4,5,**7**]` (the last position can be **any** value, not just `7`).\n\n\nWe know that there is a defect in **at most one** of the sensors. Return *the sensor number (*`1` *or* `2`*) with the defect. If there is **no defect** in either sensor or if it is **impossible** to determine the defective sensor, return* `-1`*.*\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** sensor1 = [2,3,4,5], sensor2 = [2,1,3,4]\n**Output:** 1\n**Explanation:** Sensor 2 has the correct values.\nThe second data point from sensor 2 is dropped, and the last value of sensor 1 is replaced by a 5.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** sensor1 = [2,2,2,2,2], sensor2 = [2,2,2,2,5]\n**Output:** -1\n**Explanation:** It is impossible to determine which sensor has a defect.\nDropping the last value for either sensor could produce the output for the other sensor.\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** sensor1 = [2,3,2,2,3,2], sensor2 = [2,3,2,3,2,7]\n**Output:** 2\n**Explanation:** Sensor 1 has the correct values.\nThe fourth data point from sensor 1 is dropped, and the last value of sensor 1 is replaced by a 7.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `sensor1.length == sensor2.length`\n* `1 <= sensor1.length <= 100`\n* `1 <= sensor1[i], sensor2[i] <= 100`\n\n\n",
  "inefficient_solution": "class Solution:\n    def badSensor(self, sensor1: List[int], sensor2: List[int]) -> int:\n        n = len(sensor1)\n        lists = [[sensor1, 1], [sensor2, 2]]\n        for i in range(n):\n            for j in range(n - i - 1):\n                new_sensor1 = sensor1[:i + j + 1] + sensor1[i + j + 2:] + [random.randint(1, 100)]\n                new_sensor2 = sensor2[:i + j + 1] + sensor2[i + j + 2:] + [random.randint(1, 100)]\n                if new_sensor1 == new_sensor2:\n                    return -1\n                if new_sensor1 == lists[0][0]:\n                    return lists[0][1]\n                if new_sensor2 == lists[1][0]:\n                    return lists[1][1]\n        return -1",
  "canonical_solution": "class Solution:\n    def badSensor(self, sensor1: List[int], sensor2: List[int]) -> int:\n        i, n = 0, len(sensor1)\n        while i < n - 1:\n            if sensor1[i] != sensor2[i]:\n                break\n            i += 1\n        while i < n - 1:\n            if sensor1[i + 1] != sensor2[i]:\n                return 1\n            if sensor1[i] != sensor2[i + 1]:\n                return 2\n            i += 1\n        return -1\n",
  "finetuned_model_solution": "class Solution:\n    def badSensor(self, sensor1: List[int], sensor2: List[int]) -> int:\n        n = len(sensor1)\n        for i in range(n):\n            a = sensor1[:i] + sensor1[i + 1:]\n            b = sensor2[:i] + sensor2[i + 1:]\n            if a == b:\n                return -1\n            if a in [sensor1, sensor2] or b in [sensor1, sensor2]:\n                return 1 if a == sensor1 else 2\n        return -1",
  "raw_model_solution": "class Solution:\n    def badSensor(self, sensor1: List[int], sensor2: List[int]) -> int:\n        n = len(sensor1)\n        for i in range(n):\n            if sensor1[i] == sensor2[i]:\n                continue\n            for j in range(i + 1, n):\n                if sensor1[i] == sensor2[j] and sensor1[j] == sensor2[i]:\n                    return 1 if sensor1[i] != sensor2[i] else -1\n        return -1 if sensor1 == sensor2 else 1",
  "finetuned_model_diff_bleu": 0.6198664245236625,
  "raw_model_diff_bleu": 0.7058971666615751,
  "is_python": true,
  "diff_bleu_delta": -0.08603074213791262
}