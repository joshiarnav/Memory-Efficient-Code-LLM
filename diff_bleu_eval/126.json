{
  "problem_idx": "126",
  "metrics": {
    "finetuned_model": {
      "bleu_score": 0.8899285220381372,
      "edit_similarity": 0.9185232336091661,
      "ast_similarity": 1.0,
      "diff_bleu": 0.3399088453745771
    },
    "raw_model": {
      "bleu_score": 0.28401496618314487,
      "edit_similarity": 0.39497422680412375,
      "ast_similarity": 0.0,
      "diff_bleu": 0.2559674816310139
    }
  },
  "deltas": {
    "bleu_delta": 0.6059135558549924,
    "edit_sim_delta": 0.5235490068050423,
    "ast_sim_delta": 1.0,
    "diff_bleu_delta": 0.0839413637435632
  },
  "solutions": {
    "inefficient": "class Solution:\n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\n        def dfs(cur, path):\n            if cur == beginWord:\n                ans.append(path[::-1])\n                return\n            for precursor in prev[cur]:\n                path.append(precursor)\n                dfs(precursor, path)\n                path.pop()\n            for i in range(len(path)):\n                for j in range(i+1, len(path)):\n                    path[i], path[j] = path[j], path[i]\n                    dfs(cur, path)\n                    path[i], path[j] = path[j], path[i]\n\n        ans = []\n        words = set(wordList)\n        if endWord not in words:\n            return ans\n        words.discard(beginWord)\n        dist = {beginWord: 0}\n        prev = defaultdict(set)\n        q = deque([beginWord])\n        found = False\n        step = 0\n        while q and not found:\n            step += 1\n            for _ in range(len(q)):\n                p = q.popleft()\n                s = list(p)\n                for i in range(len(s)):\n                    for j in range(26):\n                        s[i] = chr(ord('a') + j)\n                        t = ''.join(s)\n                        if dist.get(t, 0) == step:\n                            prev[t].add(p)\n                        if t not in words:\n                            continue\n                        prev[t].add(p)\n                        words.discard(t)\n                        q.append(t)\n                        dist[t] = step\n                        if endWord == t:\n                            found = True\n                    s[i] = p[i]\n            if q:\n                q.append(beginWord)\n        if found:\n            path = [endWord]\n            dfs(endWord, path)\n        return ans",
    "efficient": "class Solution:\n    def findLadders(\n        self, beginWord: str, endWord: str, wordList: List[str]\n    ) -> List[List[str]]:\n        def dfs(path, cur):\n            if cur == beginWord:\n                ans.append(path[::-1])\n                return\n            for precursor in prev[cur]:\n                path.append(precursor)\n                dfs(path, precursor)\n                path.pop()\n\n        ans = []\n        words = set(wordList)\n        if endWord not in words:\n            return ans\n        words.discard(beginWord)\n        dist = {beginWord: 0}\n        prev = defaultdict(set)\n        q = deque([beginWord])\n        found = False\n        step = 0\n        while q and not found:\n            step += 1\n            for i in range(len(q), 0, -1):\n                p = q.popleft()\n                s = list(p)\n                for i in range(len(s)):\n                    ch = s[i]\n                    for j in range(26):\n                        s[i] = chr(ord('a') + j)\n                        t = ''.join(s)\n                        if dist.get(t, 0) == step:\n                            prev[t].add(p)\n                        if t not in words:\n                            continue\n                        prev[t].add(p)\n                        words.discard(t)\n                        q.append(t)\n                        dist[t] = step\n                        if endWord == t:\n                            found = True\n                    s[i] = ch\n        if found:\n            path = [endWord]\n            dfs(path, endWord)\n        return ans\n",
    "finetuned": "class Solution:\n    def findLadders(\n        self, beginWord: str, endWord: str, wordList: List[str]\n    ) -> List[List[str]]:\n        def dfs(cur, path):\n            if cur == beginWord:\n                ans.append(path[::-1])\n                return\n            for precursor in prev[cur]:\n                path.append(precursor)\n                dfs(precursor, path)\n                path.pop()\n\n        ans = []\n        words = set(wordList)\n        if endWord not in words:\n            return ans\n        words.discard(beginWord)\n        dist = {beginWord: 0}\n        prev = defaultdict(set)\n        q = deque([beginWord])\n        found = False\n        step = 0\n        while q and not found:\n            step += 1\n            for _ in range(len(q)):\n                p = q.popleft()\n                s = list(p)\n                for i in range(len(s)):\n                    for j in range(26):\n                        s[i] = chr(ord('a') + j)\n                        t = ''.join(s)\n                        if dist.get(t, 0) == step:\n                            prev[t].add(p)\n                        if t not in words:\n                            continue\n                        prev[t].add(p)\n                        words.discard(t)\n                        q.append(t)\n                        dist[t] = step\n                        if endWord == t:\n                            found = True\n                    s[i] = p[i]\n            if q:\n                q.append(beginWord)\n        if found:\n            path = [endWord]\n            dfs(endWord, path)\n        return ans",
    "raw_model": "from collections import deque\nfrom typing import List\n\nclass Solution:\n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\n        wordSet = set(wordList)\n        if endWord not in wordSet:\n            return []\n        wordSet.discard(beginWord)\n        \n        # Build a graph using BFS\n        graph = {}\n        queue = deque([beginWord])\n        level = {beginWord: 0}\n        while queue:\n            word = queue.popleft()\n            level[word] += 1\n            for i inrupa(word):\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    next_word = word[:i] + c + word[i+1:]\n                    if next_word in wordSet:\n                        if next_word not in graph:\n                            graph[next_word] = []\n                        graph[next_word].append(word)\n                        wordSet.discard(next_word)\n                        queue.append(next_word)\n        \n        # If there's no path from beginWord to endWord\n        if endWord not in graph:\n            return []\n        \n        # Build the result using DFS\n        result = []\n        self.dfs(graph, endWord, [endWord], result)\n        return result\n\n    def dfs(self, graph, cur, path, result):\n        if cur == self.beginWord:\n            result.append(path[:])\n            return\n        for neighbor in graph[cur]:\n            path.append(neighbor)\n            self.dfs(graph, neighbor, path, result)\n            path.pop()\n\n    def inrupa(self, word):\n        return range(len(word))"
  },
  "is_python": true
}