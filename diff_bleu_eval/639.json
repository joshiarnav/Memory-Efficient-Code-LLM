{
  "problem_idx": "639",
  "metrics": {
    "finetuned_model": {
      "bleu_score": 0.5049454128297065,
      "edit_similarity": 0.819926873857404,
      "ast_similarity": 0.9655172413793104,
      "diff_bleu": 0.7132730063834124
    },
    "raw_model": {
      "bleu_score": 0.3426668609365106,
      "edit_similarity": 0.42961608775137117,
      "ast_similarity": 0.8125,
      "diff_bleu": 0.6916398471972977
    }
  },
  "deltas": {
    "bleu_delta": 0.1622785518931959,
    "edit_sim_delta": 0.39031078610603287,
    "ast_sim_delta": 0.1530172413793104,
    "diff_bleu_delta": 0.021633159186114748
  },
  "solutions": {
    "inefficient": "class Solution:\n    def numDecodings(self, s: str) -> int:\n        mod = int(1e9 + 7)\n        n = len(s)\n        dp = [0] * (n + 1)\n        dp_cnt = [0] * (n + 1)\n        for i in range(n):\n            dp[i + 1] = 0\n            dp_cnt[i + 1] = 0\n        for i in range(n):\n            for j in range(i, n):\n                if s[j] == \"*\":\n                    if i == j:\n                        dp_cnt[i + 1] += 9\n                    else:\n                        dp_cnt[i + 1] += 15\n                elif s[j] != \"0\":\n                    if i == j:\n                        dp_cnt[i + 1] += 1\n                    else:\n                        dp_cnt[i + 1] += 1\n                if i > 0:\n                    if s[i - 1] == \"*\" and s[j] == \"*\":\n                        dp_cnt[i + 1] = (dp_cnt[i + 1] + 15 * dp_cnt[i]) % mod\n                        if (j - i + 1) >= 2:\n                            dp[j - i + 2] = (dp_cnt[i] * 15) % mod\n                    elif s[i - 1] == \"*\":\n                        if s[j] > \"6\":\n                            dp_cnt[i + 1] = (dp_cnt[i + 1] + dp_cnt[i]) % mod\n                        else:\n                            dp_cnt[i + 1] = (dp_cnt[i + 1] + 2 * dp_cnt[i]) % mod\n                            dp[j - i + 2] = (dp_cnt[i] * 2) % mod\n                    elif s[j] == \"*\":\n                        if s[i - 1] == \"1\":\n                            dp_cnt[i + 1] = (dp_cnt[i + 1] + 9 * dp_cnt[i]) % mod\n                            dp[j - i + 2] = (dp_cnt[i] * 9) % mod\n                        elif s[i - 1] == \"2\":\n                            dp_cnt[i + 1] = (dp_cnt[i + 1] + 6 * dp_cnt[i]) % mod\n                            dp[j - i + 2] = (dp_cnt[i] * 6) % mod\n                    elif (\n                        s[i - 1] != \"0\"\n                        and (ord(s[i - 1]) - ord(\"0\")) * 10 + ord(s[j]) - ord(\"0\") <= 26\n                    ):\n                        dp_cnt[i + 1] = (dp_cnt[i + 1] + dp_cnt[i]) % mod\n                        dp[j - i + 2] = (dp_cnt[i]) % mod\n        return dp_cnt[n]",
    "efficient": "class Solution:\n    def numDecodings(self, s: str) -> int:\n        mod = int(1e9 + 7)\n        n = len(s)\n\n        # dp[i - 2], dp[i - 1], dp[i]\n        a, b, c = 0, 1, 0\n        for i in range(1, n + 1):\n            # 1 digit\n            if s[i - 1] == \"*\":\n                c = 9 * b % mod\n            elif s[i - 1] != \"0\":\n                c = b\n            else:\n                c = 0\n\n            # 2 digits\n            if i > 1:\n                if s[i - 2] == \"*\" and s[i - 1] == \"*\":\n                    c = (c + 15 * a) % mod\n                elif s[i - 2] == \"*\":\n                    if s[i - 1] > \"6\":\n                        c = (c + a) % mod\n                    else:\n                        c = (c + 2 * a) % mod\n                elif s[i - 1] == \"*\":\n                    if s[i - 2] == \"1\":\n                        c = (c + 9 * a) % mod\n                    elif s[i - 2] == \"2\":\n                        c = (c + 6 * a) % mod\n                elif (\n                    s[i - 2] != \"0\"\n                    and (ord(s[i - 2]) - ord(\"0\")) * 10 + ord(s[i - 1]) - ord(\"0\") <= 26\n                ):\n                    c = (c + a) % mod\n\n            a, b = b, c\n\n        return c\n",
    "finetuned": "class Solution:\n    def numDecodings(self, s: str) -> int:\n        mod = int(1e9 + 7)\n        n = len(s)\n        f, g = 0, 1\n        for i in range(n):\n            t = g\n            if s[i] == \"*\":\n                if i == 0:\n                    t += 9\n                else:\n                    t += 15\n            elif s[i]!= \"0\":\n                t += 1\n            if i > 0:\n                if s[i - 1] == \"*\":\n                    if s[i] > \"6\":\n                        g = (g + t) % mod\n                    else:\n                        g = (g + 2 * t) % mod\n                elif s[i] == \"*\":\n                    if s[i - 1] == \"1\":\n                        g = (g + 9 * t) % mod\n                    elif s[i - 1] == \"2\":\n                        g = (g + 6 * t) % mod\n                elif (\n                    s[i - 1]!= \"0\"\n                    and (ord(s[i - 1]) - ord(\"0\")) * 10 + ord(s[i]) - ord(\"0\") <= 26\n                ):\n                    g = (g + t) % mod\n        return g",
    "raw_model": "class Solution:\n    def numDecodings(self, s: str) -> int:\n        mod = int(1e9 + 7)\n        n = len(s)\n        \n        # Base case: If the string is empty, there's one way to decode it (i.e., no decoding).\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        dp[1] = 1 if s[0] != \"0\" else 0\n        \n        for i in range(2, n + 1):\n            # If the current character is not zero, we can either decode it separately or as part of a two-digit number.\n            if s[i - 1] != \"0\":\n                dp[i] = (dp[i] + dp[i - 1]) % mod\n                \n            # Check if the current character and the previous character form a valid two-digit number.\n            if s[i - 2:i] >= \"10\" and s[i - 2:i] <= \"26\":\n                dp[i] = (dp[i] + dp[i - 2]) % mod\n                \n            # If the current character is '*', we need to consider all possible two-digit numbers it can form.\n            if s[i - 1] == \"*\":\n                dp[i] = (dp[i] + 9 * dp[i - 1]) % mod\n                \n            # If the current character and the previous character form a valid two-digit number, we need to consider them together.\n            if s[i - 2:i] == \"**\":\n                dp[i] = (dp[i] + 15 * dp[i - 2]) % mod\n                \n        return dp[n]"
  },
  "is_python": true
}