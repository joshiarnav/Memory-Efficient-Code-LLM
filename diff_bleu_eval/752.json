{
  "problem_idx": "752",
  "metrics": {
    "finetuned_model": {
      "bleu_score": 0.3898989714001269,
      "edit_similarity": 0.5596958174904942,
      "ast_similarity": 0.8378378378378378,
      "diff_bleu": 0.18433971762964851
    },
    "raw_model": {
      "bleu_score": 0.8743598264784835,
      "edit_similarity": 0.7047685834502104,
      "ast_similarity": 0.9473684210526315,
      "diff_bleu": 0.12568205213131386
    }
  },
  "deltas": {
    "bleu_delta": -0.4844608550783566,
    "edit_sim_delta": -0.1450727659597162,
    "ast_sim_delta": -0.1095305832147937,
    "diff_bleu_delta": 0.05865766549833465
  },
  "solutions": {
    "inefficient": "class Solution:\n    def openLock(self, deadends: List[str], target: str) -> int:\n        def next(s):\n            res = []\n            for i in range(4):\n                c = s[i]\n                for d in range(10):\n                    s[i] = str(d)\n                    res.append(''.join(s))\n                    s[i] = c\n                s[i] = '0' if c == '9' else str(int(c) + 1)\n                res.append(''.join(s))\n                s[i] = '9' if c == '0' else str(int(c) - 1)\n                res.append(''.join(s))\n            return res\n\n        def extend(m1, m2, q):\n            for _ in range(len(q)):\n                p = q.popleft()\n                step = m1[p]\n                for t in next(p):\n                    if t in s or t in m1:\n                        continue\n                    if t in m2:\n                        return step + 1 + m2[t]\n                    m1[t] = step + 1\n                    q.append(t)\n            return -1\n\n        def bfs():\n            m1, m2 = {\"0000\": 0}, {target: 0}\n            q1, q2 = deque([('0000')]), deque([(target)])\n            while q1 and q2:\n                t = extend(m1, m2, q1) if len(q1) <= len(q2) else extend(m2, m1, q2)\n                if t != -1:\n                    return t\n            return -1\n\n        if target == '0000':\n            return 0\n        s = set(deadends)\n        if '0000' in s:\n            return -1\n        return bfs()",
    "efficient": "class Solution:\n    def openLock(self, deadends: List[str], target: str) -> int:\n        def next(s):\n            res = []\n            s = list(s)\n            for i in range(4):\n                c = s[i]\n                s[i] = '9' if c == '0' else str(int(c) - 1)\n                res.append(''.join(s))\n                s[i] = '0' if c == '9' else str(int(c) + 1)\n                res.append(''.join(s))\n                s[i] = c\n            return res\n\n        def extend(m1, m2, q):\n            for _ in range(len(q)):\n                p = q.popleft()\n                step = m1[p]\n                for t in next(p):\n                    if t in s or t in m1:\n                        continue\n                    if t in m2:\n                        return step + 1 + m2[t]\n                    m1[t] = step + 1\n                    q.append(t)\n            return -1\n\n        def bfs():\n            m1, m2 = {\"0000\": 0}, {target: 0}\n            q1, q2 = deque([('0000')]), deque([(target)])\n            while q1 and q2:\n                t = extend(m1, m2, q1) if len(q1) <= len(q2) else extend(m2, m1, q2)\n                if t != -1:\n                    return t\n            return -1\n\n        if target == '0000':\n            return 0\n        s = set(deadends)\n        if '0000' in s:\n            return -1\n        return bfs()\n",
    "finetuned": "class Solution:\n    def openLock(self, deadends: List[str], target: str) -> int:\n        def next(s):\n            for i in range(4):\n                c = s[i]\n                for d in range(10):\n                    s[i] = str(d) if c == '9' or d == 0 else str(int(c) + 1)\n                    if s in s1 or s in s2:\n                        s[i] = c\n                        break\n                    s2[s] = 1\n                    if s == t:\n                        return 1\n                s[i] = '0' if c == '1' else str(int(c) - 1)\n                if s in s1 or s in s2:\n                    s[i] = c\n                    break\n                s2[s] = 1\n                if s == t:\n                    return 1\n            return 0\n\n        s1 = set(deadends)\n        if '0000' in s1:\n            return -1\n        s2 = set()\n        t = target\n        ans = 0\n        q = deque([('0000', 0)])\n        while q:\n            p, step = q.popleft()\n            ans = step\n            for d in next(p):\n                if d == 1:\n                    return ans + 1\n                q.append((d, step + 1))\n        return -1",
    "raw_model": "from collections import deque\n\nclass Solution:\n    def openLock(self, deadends: List[str], target: str) -> int:\n        def next(s):\n            res = []\n            for i in range(4):\n                c = s[i]\n                for d in range(10):\n                    s[i] = str(d)\n                    res.append(''.join(s))\n                    s[i] = c\n                s[i] = '0' if c == '9' else str(int(c) + 1)\n                res.append(''.join(s))\n                s[i] = '9' if c == '0' else str(int(c) - 1)\n                res.append(''.join(s))\n            return res\n\n        def extend(m1, m2, q):\n            for _ in range(len(q)):\n                p = q.popleft()\n                step = m1[p]\n                for t in next(p):\n                    if t in s or t in m1:\n                        continue\n                    if t in m2:\n                        return step + 1 + m2[t]\n                    m1[t] = step + 1\n                    q.append(t)\n            return -1\n\n        def bfs():\n            s = set(deadends)\n            if '0000' in s:\n                return -1\n            s.add('0000')\n            m1, m2 = {\"0000\": 0}, {target: 0}\n            q1, q2 = deque([('0000')]), deque([(target)])\n            while q1 and q2:\n                t = extend(m1, m2, q1) if len(q1) <= len(q2) else extend(m2, m1, q2)\n                if t != -1:\n                    return t\n            return -1\n\n        return bfs()"
  },
  "is_python": true
}