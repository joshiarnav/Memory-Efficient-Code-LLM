{
    "problem_idx": "2962",
    "description": "\nYou are given an integer array `nums` and a **positive** integer `k`.\n\n\nReturn *the number of subarrays where the **maximum** element of* `nums` *appears **at least*** `k` *times in that subarray.*\n\n\nA **subarray** is a contiguous sequence of elements within an array.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** nums = [1,3,2,3,3], k = 2\n**Output:** 6\n**Explanation:** The subarrays that contain the element 3 at least 2 times are: [1,3,2,3], [1,3,2,3,3], [3,2,3], [3,2,3,3], [2,3,3] and [3,3].\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** nums = [1,4,2,1], k = 3\n**Output:** 0\n**Explanation:** No subarray contains the element 4 at least 3 times.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= nums.length <= 105`\n* `1 <= nums[i] <= 106`\n* `1 <= k <= 105`\n\n\n",
    "inefficient_solution": "class Solution:\n    def countSubarrays(self, nums: List[int], k: int) -> int:\n        mx = max(nums)\n        n = len(nums)\n        ans = 0\n        for i in range(n):\n            cnt = 0\n            subarray = []\n            for j in range(i, n):\n                subarray.append(nums[j])\n                if nums[j] == mx:\n                    cnt += 1\n                if cnt < k:\n                    subarray = []\n                    continue\n                ans += 1\n        return ans",
    "efficient_solution": "class Solution:\n    def countSubarrays(self, nums: List[int], k: int) -> int:\n        mx = max(nums)\n        n = len(nums)\n        ans = cnt = j = 0\n        for x in nums:\n            while j < n and cnt < k:\n                cnt += nums[j] == mx\n                j += 1\n            if cnt < k:\n                break\n            ans += n - j + 1\n            cnt -= x == mx\n        return ans\n",
    "text": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nYou are given an integer array `nums` and a **positive** integer `k`.\n\n\nReturn *the number of subarrays where the **maximum** element of* `nums` *appears **at least*** `k` *times in that subarray.*\n\n\nA **subarray** is a contiguous sequence of elements within an array.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** nums = [1,3,2,3,3], k = 2\n**Output:** 6\n**Explanation:** The subarrays that contain the element 3 at least 2 times are: [1,3,2,3], [1,3,2,3,3], [3,2,3], [3,2,3,3], [2,3,3] and [3,3].\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** nums = [1,4,2,1], k = 3\n**Output:** 0\n**Explanation:** No subarray contains the element 4 at least 3 times.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= nums.length <= 105`\n* `1 <= nums[i] <= 106`\n* `1 <= k <= 105`\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def countSubarrays(self, nums: List[int], k: int) -> int:\n        mx = max(nums)\n        n = len(nums)\n        ans = 0\n        for i in range(n):\n            cnt = 0\n            subarray = []\n            for j in range(i, n):\n                subarray.append(nums[j])\n                if nums[j] == mx:\n                    cnt += 1\n                if cnt < k:\n                    subarray = []\n                    continue\n                ans += 1\n        return ans\n\n### Efficient Solution:\nclass Solution:\n    def countSubarrays(self, nums: List[int], k: int) -> int:\n        mx = max(nums)\n        n = len(nums)\n        ans = cnt = j = 0\n        for x in nums:\n            while j < n and cnt < k:\n                cnt += nums[j] == mx\n                j += 1\n            if cnt < k:\n                break\n            ans += n - j + 1\n            cnt -= x == mx\n        return ans\n<|eot_id|>",
    "model_generation": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nYou are given an integer array `nums` and a **positive** integer `k`.\n\n\nReturn *the number of subarrays where the **maximum** element of* `nums` *appears **at least*** `k` *times in that subarray.*\n\n\nA **subarray** is a contiguous sequence of elements within an array.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** nums = [1,3,2,3,3], k = 2\n**Output:** 6\n**Explanation:** The subarrays that contain the element 3 at least 2 times are: [1,3,2,3], [1,3,2,3,3], [3,2,3], [3,2,3,3], [2,3,3] and [3,3].\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** nums = [1,4,2,1], k = 3\n**Output:** 0\n**Explanation:** No subarray contains the element 4 at least 3 times.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= nums.length <= 105`\n* `1 <= nums[i] <= 106`\n* `1 <= k <= 105`\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def countSubarrays(self, nums: List[int], k: int) -> int:\n        mx = max(nums)\n        n = len(nums)\n        ans = 0\n        for i in range(n):\n            cnt = 0\n            subarray = []\n            for j in range(i, n):\n                subarray.append(nums[j])\n                if nums[j] == mx:\n                    cnt += 1\n                if cnt < k:\n                    subarray = []\n                    continue\n                ans += 1\n        return ans\n\n### Efficient Solution:\nclass Solution:\n    def countSubarrays(self, nums: List[int], k: int) -> int:\n        mx = max(nums)\n        ans = j = -1\n        for i, v in enumerate(nums):\n            if v == mx:\n                ans += (j + 1 - i + 1) * (k - 1)\n            j = i\n        return ans\n",
    "model_solution": "class Solution:\n    def countSubarrays(self, nums: List[int], k: int) -> int:\n        mx = max(nums)\n        ans = j = -1\n        for i, v in enumerate(nums):\n            if v == mx:\n                ans += (j + 1 - i + 1) * (k - 1)\n            j = i\n        return ans"
}