{
    "problem_idx": "207",
    "description": "\nThere are a total of `numCourses` courses you have to take, labeled from `0` to `numCourses - 1`. You are given an array `prerequisites` where `prerequisites[i] = [ai, bi]` indicates that you **must** take course `bi` first if you want to take course `ai`.\n\n\n* For example, the pair `[0, 1]`, indicates that to take course `0` you have to first take course `1`.\n\n\nReturn `true` if you can finish all courses. Otherwise, return `false`.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** numCourses = 2, prerequisites = [[1,0]]\n**Output:** true\n**Explanation:** There are a total of 2 courses to take. \nTo take course 1 you should have finished course 0. So it is possible.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** numCourses = 2, prerequisites = [[1,0],[0,1]]\n**Output:** false\n**Explanation:** There are a total of 2 courses to take. \nTo take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= numCourses <= 2000`\n* `0 <= prerequisites.length <= 5000`\n* `prerequisites[i].length == 2`\n* `0 <= ai, bi < numCourses`\n* All the pairs prerequisites[i] are **unique**.\n\n\n",
    "inefficient_solution": "class Solution:\n    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\n        g = [[] for _ in range(numCourses)]\n        indeg = [0] * numCourses\n        for _ in range(len(prerequisites)):\n            a, b = prerequisites[_]\n            g[b] = list(set(g[b] + [a]))\n            indeg[a] += 1\n        cnt = 0\n        q = deque(i for i, x in enumerate(indeg) if x == 0)\n        while q:\n            i = q.popleft()\n            cnt += 1\n            for j in g[i]:\n                temp_g = g[j].copy()\n                g[j] = []\n                for k in temp_g:\n                    g[k].append(j)\n                    indeg[k] += 1\n                if indeg[j] == 0:\n                    q.append(j)\n        return cnt == numCourses",
    "efficient_solution": "class Solution:\n    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\n        g = defaultdict(list)\n        indeg = [0] * numCourses\n        for a, b in prerequisites:\n            g[b].append(a)\n            indeg[a] += 1\n        cnt = 0\n        q = deque(i for i, x in enumerate(indeg) if x == 0)\n        while q:\n            i = q.popleft()\n            cnt += 1\n            for j in g[i]:\n                indeg[j] -= 1\n                if indeg[j] == 0:\n                    q.append(j)\n        return cnt == numCourses\n",
    "text": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nThere are a total of `numCourses` courses you have to take, labeled from `0` to `numCourses - 1`. You are given an array `prerequisites` where `prerequisites[i] = [ai, bi]` indicates that you **must** take course `bi` first if you want to take course `ai`.\n\n\n* For example, the pair `[0, 1]`, indicates that to take course `0` you have to first take course `1`.\n\n\nReturn `true` if you can finish all courses. Otherwise, return `false`.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** numCourses = 2, prerequisites = [[1,0]]\n**Output:** true\n**Explanation:** There are a total of 2 courses to take. \nTo take course 1 you should have finished course 0. So it is possible.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** numCourses = 2, prerequisites = [[1,0],[0,1]]\n**Output:** false\n**Explanation:** There are a total of 2 courses to take. \nTo take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= numCourses <= 2000`\n* `0 <= prerequisites.length <= 5000`\n* `prerequisites[i].length == 2`\n* `0 <= ai, bi < numCourses`\n* All the pairs prerequisites[i] are **unique**.\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\n        g = [[] for _ in range(numCourses)]\n        indeg = [0] * numCourses\n        for _ in range(len(prerequisites)):\n            a, b = prerequisites[_]\n            g[b] = list(set(g[b] + [a]))\n            indeg[a] += 1\n        cnt = 0\n        q = deque(i for i, x in enumerate(indeg) if x == 0)\n        while q:\n            i = q.popleft()\n            cnt += 1\n            for j in g[i]:\n                temp_g = g[j].copy()\n                g[j] = []\n                for k in temp_g:\n                    g[k].append(j)\n                    indeg[k] += 1\n                if indeg[j] == 0:\n                    q.append(j)\n        return cnt == numCourses\n\n### Efficient Solution:\nclass Solution:\n    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\n        g = defaultdict(list)\n        indeg = [0] * numCourses\n        for a, b in prerequisites:\n            g[b].append(a)\n            indeg[a] += 1\n        cnt = 0\n        q = deque(i for i, x in enumerate(indeg) if x == 0)\n        while q:\n            i = q.popleft()\n            cnt += 1\n            for j in g[i]:\n                indeg[j] -= 1\n                if indeg[j] == 0:\n                    q.append(j)\n        return cnt == numCourses\n<|eot_id|>",
    "model_generation": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nThere are a total of `numCourses` courses you have to take, labeled from `0` to `numCourses - 1`. You are given an array `prerequisites` where `prerequisites[i] = [ai, bi]` indicates that you **must** take course `bi` first if you want to take course `ai`.\n\n\n* For example, the pair `[0, 1]`, indicates that to take course `0` you have to first take course `1`.\n\n\nReturn `true` if you can finish all courses. Otherwise, return `false`.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** numCourses = 2, prerequisites = [[1,0]]\n**Output:** true\n**Explanation:** There are a total of 2 courses to take. \nTo take course 1 you should have finished course 0. So it is possible.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** numCourses = 2, prerequisites = [[1,0],[0,1]]\n**Output:** false\n**Explanation:** There are a total of 2 courses to take. \nTo take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= numCourses <= 2000`\n* `0 <= prerequisites.length <= 5000`\n* `prerequisites[i].length == 2`\n* `0 <= ai, bi < numCourses`\n* All the pairs prerequisites[i] are **unique**.\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\n        g = [[] for _ in range(numCourses)]\n        indeg = [0] * numCourses\n        for _ in range(len(prerequisites)):\n            a, b = prerequisites[_]\n            g[b] = list(set(g[b] + [a]))\n            indeg[a] += 1\n        cnt = 0\n        q = deque(i for i, x in enumerate(indeg) if x == 0)\n        while q:\n            i = q.popleft()\n            cnt += 1\n            for j in g[i]:\n                temp_g = g[j].copy()\n                g[j] = []\n                for k in temp_g:\n                    g[k].append(j)\n                    indeg[k] += 1\n                if indeg[j] == 0:\n                    q.append(j)\n        return cnt == numCourses\n\n### Efficient Solution:\nclass Solution:\n    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\n        g = defaultdict(list)\n        indeg = [0] * numCourses\n        for a, b in prerequisites:\n            g[b].append(a)\n            indeg[a] += 1\n        cnt = 0\n        q = deque(i for i, x in enumerate(indeg) if x == 0)\n        while q:\n            i = q.popleft()\n            cnt += 1\n            for j in g[i]:\n                indeg[j] -= 1\n                if indeg[j] == 0:\n                    q.append(j)\n        return cnt == numCourses\n",
    "model_solution": "class Solution:\n    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\n        g = defaultdict(list)\n        indeg = [0] * numCourses\n        for a, b in prerequisites:\n            g[b].append(a)\n            indeg[a] += 1\n        cnt = 0\n        q = deque(i for i, x in enumerate(indeg) if x == 0)\n        while q:\n            i = q.popleft()\n            cnt += 1\n            for j in g[i]:\n                indeg[j] -= 1\n                if indeg[j] == 0:\n                    q.append(j)\n        return cnt == numCourses"
}