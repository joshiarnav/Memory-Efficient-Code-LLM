{
    "problem_idx": "124",
    "description": "\nA **path** in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence **at most once**. Note that the path does not need to pass through the root.\n\n\nThe **path sum** of a path is the sum of the node's values in the path.\n\n\nGiven the `root` of a binary tree, return *the maximum **path sum** of any **non-empty** path*.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0124.Binary%20Tree%20Maximum%20Path%20Sum/images/exx1.jpg)\n\n```\n\n**Input:** root = [1,2,3]\n**Output:** 6\n**Explanation:** The optimal path is 2 -> 1 -> 3 with a path sum of 2 + 1 + 3 = 6.\n\n```\n\n**Example 2:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0124.Binary%20Tree%20Maximum%20Path%20Sum/images/exx2.jpg)\n\n```\n\n**Input:** root = [-10,9,20,null,null,15,7]\n**Output:** 42\n**Explanation:** The optimal path is 15 -> 20 -> 7 with a path sum of 15 + 20 + 7 = 42.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* The number of nodes in the tree is in the range `[1, 3 * 104]`.\n* `-1000 <= Node.val <= 1000`\n\n\n",
    "inefficient_solution": "class Solution:\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\n        paths = []\n        def dfs(root: Optional[TreeNode]) -> None:\n            if root is None:\n                return\n            left = []\n            right = []\n            if root.left is not None:\n                left = dfs(root.left)\n            if root.right is not None:\n                right = dfs(root.right)\n            paths.append([root.val])\n            if left:\n                paths.append([root.val] + left)\n            if right:\n                paths.append([root.val] + right)\n            for p in paths:\n                if len(p) == 2:\n                    p[1] += p[0]\n                else:\n                    p[1] += p[0]\n                    p[2] += p[0]\n            return paths\n\n        dfs(root)\n        return max(p[1] for p in paths)",
    "efficient_solution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\n        def dfs(root: Optional[TreeNode]) -> int:\n            if root is None:\n                return 0\n            left = max(0, dfs(root.left))\n            right = max(0, dfs(root.right))\n            nonlocal ans\n            ans = max(ans, root.val + left + right)\n            return root.val + max(left, right)\n\n        ans = -inf\n        dfs(root)\n        return ans\n",
    "text": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nA **path** in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence **at most once**. Note that the path does not need to pass through the root.\n\n\nThe **path sum** of a path is the sum of the node's values in the path.\n\n\nGiven the `root` of a binary tree, return *the maximum **path sum** of any **non-empty** path*.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0124.Binary%20Tree%20Maximum%20Path%20Sum/images/exx1.jpg)\n\n```\n\n**Input:** root = [1,2,3]\n**Output:** 6\n**Explanation:** The optimal path is 2 -> 1 -> 3 with a path sum of 2 + 1 + 3 = 6.\n\n```\n\n**Example 2:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0124.Binary%20Tree%20Maximum%20Path%20Sum/images/exx2.jpg)\n\n```\n\n**Input:** root = [-10,9,20,null,null,15,7]\n**Output:** 42\n**Explanation:** The optimal path is 15 -> 20 -> 7 with a path sum of 15 + 20 + 7 = 42.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* The number of nodes in the tree is in the range `[1, 3 * 104]`.\n* `-1000 <= Node.val <= 1000`\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\n        paths = []\n        def dfs(root: Optional[TreeNode]) -> None:\n            if root is None:\n                return\n            left = []\n            right = []\n            if root.left is not None:\n                left = dfs(root.left)\n            if root.right is not None:\n                right = dfs(root.right)\n            paths.append([root.val])\n            if left:\n                paths.append([root.val] + left)\n            if right:\n                paths.append([root.val] + right)\n            for p in paths:\n                if len(p) == 2:\n                    p[1] += p[0]\n                else:\n                    p[1] += p[0]\n                    p[2] += p[0]\n            return paths\n\n        dfs(root)\n        return max(p[1] for p in paths)\n\n### Efficient Solution:\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\n        def dfs(root: Optional[TreeNode]) -> int:\n            if root is None:\n                return 0\n            left = max(0, dfs(root.left))\n            right = max(0, dfs(root.right))\n            nonlocal ans\n            ans = max(ans, root.val + left + right)\n            return root.val + max(left, right)\n\n        ans = -inf\n        dfs(root)\n        return ans\n<|eot_id|>",
    "model_generation": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nA **path** in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence **at most once**. Note that the path does not need to pass through the root.\n\n\nThe **path sum** of a path is the sum of the node's values in the path.\n\n\nGiven the `root` of a binary tree, return *the maximum **path sum** of any **non-empty** path*.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0124.Binary%20Tree%20Maximum%20Path%20Sum/images/exx1.jpg)\n\n```\n\n**Input:** root = [1,2,3]\n**Output:** 6\n**Explanation:** The optimal path is 2 -> 1 -> 3 with a path sum of 2 + 1 + 3 = 6.\n\n```\n\n**Example 2:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0124.Binary%20Tree%20Maximum%20Path%20Sum/images/exx2.jpg)\n\n```\n\n**Input:** root = [-10,9,20,null,null,15,7]\n**Output:** 42\n**Explanation:** The optimal path is 15 -> 20 -> 7 with a path sum of 15 + 20 + 7 = 42.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* The number of nodes in the tree is in the range `[1, 3 * 104]`.\n* `-1000 <= Node.val <= 1000`\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\n        paths = []\n        def dfs(root: Optional[TreeNode]) -> None:\n            if root is None:\n                return\n            left = []\n            right = []\n            if root.left is not None:\n                left = dfs(root.left)\n            if root.right is not None:\n                right = dfs(root.right)\n            paths.append([root.val])\n            if left:\n                paths.append([root.val] + left)\n            if right:\n                paths.append([root.val] + right)\n            for p in paths:\n                if len(p) == 2:\n                    p[1] += p[0]\n                else:\n                    p[1] += p[0]\n                    p[2] += p[0]\n            return paths\n\n        dfs(root)\n        return max(p[1] for p in paths)\n\n### Efficient Solution:\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\n        ans = 0\n        def dfs(root):\n            nonlocal ans\n            if root is None:\n                return 0\n            l = max(0, dfs(root.left))\n            r = max(0, dfs(root.right))\n            ans = max(ans, root.val + l + r)\n            return root.val + max(l, r)\n        dfs(root)\n        return ans\n",
    "model_solution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\n        ans = 0\n        def dfs(root):\n            nonlocal ans\n            if root is None:\n                return 0\n            l = max(0, dfs(root.left))\n            r = max(0, dfs(root.right))\n            ans = max(ans, root.val + l + r)\n            return root.val + max(l, r)\n        dfs(root)\n        return ans"
}