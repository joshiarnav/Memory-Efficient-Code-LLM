{
    "problem_idx": "1065",
    "description": "\nGiven a string `text` and an array of strings `words`, return *an array of all index pairs* `[i, j]` *so that the substring* `text[i...j]` *is in `words`*.\n\n\nReturn the pairs `[i, j]` in sorted order (i.e., sort them by their first coordinate, and in case of ties sort them by their second coordinate).\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** text = \"thestoryofleetcodeandme\", words = [\"story\",\"fleet\",\"leetcode\"]\n**Output:** [[3,7],[9,13],[10,17]]\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** text = \"ababa\", words = [\"aba\",\"ab\"]\n**Output:** [[0,1],[0,2],[2,3],[2,4]]\n**Explanation:** Notice that matches can overlap, see \"aba\" is found in [0,2] and [2,4].\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= text.length <= 100`\n* `1 <= words.length <= 20`\n* `1 <= words[i].length <= 50`\n* `text` and `words[i]` consist of lowercase English letters.\n* All the strings of `words` are **unique**.\n\n\n",
    "inefficient_solution": "class Solution:\n    def indexPairs(self, text: str, words: List[str]) -> List[List[int]]:\n        n = len(text)\n        m = len(words)\n        freq_table = {}\n        for w in words:\n            freq_table[w] = 1\n        for i in range(m):\n            w = words[i]\n            for j in range(n):\n                substring = text[j:j+len(w)]\n                if substring in freq_table:\n                    freq_table[substring] += 1\n        ans = []\n        for i in range(n):\n            for j in range(i, n):\n                substring = text[i:j+1]\n                if substring in freq_table and freq_table[substring] > 1:\n                    ans.append([i, j])\n        return ans",
    "efficient_solution": "class Trie:\n    def __init__(self):\n        self.children = [None] * 26\n        self.is_end = False\n\n    def insert(self, word):\n        node = self\n        for c in word:\n            idx = ord(c) - ord('a')\n            if node.children[idx] is None:\n                node.children[idx] = Trie()\n            node = node.children[idx]\n        node.is_end = True\n\n\nclass Solution:\n    def indexPairs(self, text: str, words: List[str]) -> List[List[int]]:\n        trie = Trie()\n        for w in words:\n            trie.insert(w)\n        n = len(text)\n        ans = []\n        for i in range(n):\n            node = trie\n            for j in range(i, n):\n                idx = ord(text[j]) - ord('a')\n                if node.children[idx] is None:\n                    break\n                node = node.children[idx]\n                if node.is_end:\n                    ans.append([i, j])\n        return ans\n",
    "text": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nGiven a string `text` and an array of strings `words`, return *an array of all index pairs* `[i, j]` *so that the substring* `text[i...j]` *is in `words`*.\n\n\nReturn the pairs `[i, j]` in sorted order (i.e., sort them by their first coordinate, and in case of ties sort them by their second coordinate).\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** text = \"thestoryofleetcodeandme\", words = [\"story\",\"fleet\",\"leetcode\"]\n**Output:** [[3,7],[9,13],[10,17]]\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** text = \"ababa\", words = [\"aba\",\"ab\"]\n**Output:** [[0,1],[0,2],[2,3],[2,4]]\n**Explanation:** Notice that matches can overlap, see \"aba\" is found in [0,2] and [2,4].\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= text.length <= 100`\n* `1 <= words.length <= 20`\n* `1 <= words[i].length <= 50`\n* `text` and `words[i]` consist of lowercase English letters.\n* All the strings of `words` are **unique**.\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def indexPairs(self, text: str, words: List[str]) -> List[List[int]]:\n        n = len(text)\n        m = len(words)\n        freq_table = {}\n        for w in words:\n            freq_table[w] = 1\n        for i in range(m):\n            w = words[i]\n            for j in range(n):\n                substring = text[j:j+len(w)]\n                if substring in freq_table:\n                    freq_table[substring] += 1\n        ans = []\n        for i in range(n):\n            for j in range(i, n):\n                substring = text[i:j+1]\n                if substring in freq_table and freq_table[substring] > 1:\n                    ans.append([i, j])\n        return ans\n\n### Efficient Solution:\nclass Trie:\n    def __init__(self):\n        self.children = [None] * 26\n        self.is_end = False\n\n    def insert(self, word):\n        node = self\n        for c in word:\n            idx = ord(c) - ord('a')\n            if node.children[idx] is None:\n                node.children[idx] = Trie()\n            node = node.children[idx]\n        node.is_end = True\n\n\nclass Solution:\n    def indexPairs(self, text: str, words: List[str]) -> List[List[int]]:\n        trie = Trie()\n        for w in words:\n            trie.insert(w)\n        n = len(text)\n        ans = []\n        for i in range(n):\n            node = trie\n            for j in range(i, n):\n                idx = ord(text[j]) - ord('a')\n                if node.children[idx] is None:\n                    break\n                node = node.children[idx]\n                if node.is_end:\n                    ans.append([i, j])\n        return ans\n<|eot_id|>",
    "model_generation": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nGiven a string `text` and an array of strings `words`, return *an array of all index pairs* `[i, j]` *so that the substring* `text[i...j]` *is in `words`*.\n\n\nReturn the pairs `[i, j]` in sorted order (i.e., sort them by their first coordinate, and in case of ties sort them by their second coordinate).\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** text = \"thestoryofleetcodeandme\", words = [\"story\",\"fleet\",\"leetcode\"]\n**Output:** [[3,7],[9,13],[10,17]]\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** text = \"ababa\", words = [\"aba\",\"ab\"]\n**Output:** [[0,1],[0,2],[2,3],[2,4]]\n**Explanation:** Notice that matches can overlap, see \"aba\" is found in [0,2] and [2,4].\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= text.length <= 100`\n* `1 <= words.length <= 20`\n* `1 <= words[i].length <= 50`\n* `text` and `words[i]` consist of lowercase English letters.\n* All the strings of `words` are **unique**.\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def indexPairs(self, text: str, words: List[str]) -> List[List[int]]:\n        n = len(text)\n        m = len(words)\n        freq_table = {}\n        for w in words:\n            freq_table[w] = 1\n        for i in range(m):\n            w = words[i]\n            for j in range(n):\n                substring = text[j:j+len(w)]\n                if substring in freq_table:\n                    freq_table[substring] += 1\n        ans = []\n        for i in range(n):\n            for j in range(i, n):\n                substring = text[i:j+1]\n                if substring in freq_table and freq_table[substring] > 1:\n                    ans.append([i, j])\n        return ans\n\n### Efficient Solution:\nclass Solution:\n    def indexPairs(self, text: str, words: List[str]) -> List[List[int]]:\n        def f(k: str) -> List[int]:\n            pos = [i for i in range(n) if s[i : i + len(k)] == k]\n            return pos\n\n        s = text + '$'\n        n = len(s)\n        trie = Trie()\n        for w in words:\n            trie.insert(w)\n        ans = []\n        for i, c in enumerate(s):\n            if c == '$':\n                break\n            p = trie.search_prefix(c)\n            if p:\n                ans.extend([j for j in range(i, n) if s[j : j + len(p)] == p])\n        return ans\n\n\nclass Trie:\n    def __init__(self):\n        self.children = [None] * 26\n        self.v = 0\n\n    @staticmethod\n    def index(c: str) -> int:\n        return ord(c) - ord('a')\n\n    def insert(self, k: str) -> None:\n        node = self\n        for c in k:\n            idx = Trie.index(c)\n            if not node.children[idx]:\n                node.children[idx] = Trie()\n            node = node.children[idx]\n            node.v += 1\n\n    def search_prefix(self, k: str) -> str:\n        node = self\n        ans = ''\n        for c in k:\n            idx = Trie.index(c)\n            if not node.children[idx]:\n                break\n            ans += c\n            node = node.children[idx]\n        return ans\n",
    "model_solution": "class Solution:\n    def indexPairs(self, text: str, words: List[str]) -> List[List[int]]:\n        def f(k: str) -> List[int]:\n            pos = [i for i in range(n) if s[i : i + len(k)] == k]\n            return pos\n\n        s = text + '$'\n        n = len(s)\n        trie = Trie()\n        for w in words:\n            trie.insert(w)\n        ans = []\n        for i, c in enumerate(s):\n            if c == '$':\n                break\n            p = trie.search_prefix(c)\n            if p:\n                ans.extend([j for j in range(i, n) if s[j : j + len(p)] == p])\n        return ans\n\n\nclass Trie:\n    def __init__(self):\n        self.children = [None] * 26\n        self.v = 0\n\n    @staticmethod\n    def index(c: str) -> int:\n        return ord(c) - ord('a')\n\n    def insert(self, k: str) -> None:\n        node = self\n        for c in k:\n            idx = Trie.index(c)\n            if not node.children[idx]:\n                node.children[idx] = Trie()\n            node = node.children[idx]\n            node.v += 1\n\n    def search_prefix(self, k: str) -> str:\n        node = self\n        ans = ''\n        for c in k:\n            idx = Trie.index(c)\n            if not node.children[idx]:\n                break\n            ans += c\n            node = node.children[idx]\n        return ans"
}