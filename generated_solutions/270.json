{
    "problem_idx": "270",
    "description": "\nGiven the `root` of a binary search tree and a `target` value, return *the value in the BST that is closest to the* `target`. If there are multiple answers, print the smallest.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0200-0299/0270.Closest%20Binary%20Search%20Tree%20Value/images/closest1-1-tree.jpg)\n\n```\n\n**Input:** root = [4,2,5,1,3], target = 3.714286\n**Output:** 4\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** root = [1], target = 4.428571\n**Output:** 1\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* The number of nodes in the tree is in the range `[1, 104]`.\n* `0 <= Node.val <= 109`\n* `-109 <= target <= 109`\n\n\n",
    "inefficient_solution": "",
    "efficient_solution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def closestValue(self, root: Optional[TreeNode], target: float) -> int:\n        ans, mi = root.val, inf\n        while root:\n            t = abs(root.val - target)\n            if t < mi or (t == mi and root.val < ans):\n                mi = t\n                ans = root.val\n            if root.val > target:\n                root = root.left\n            else:\n                root = root.right\n        return ans\n",
    "text": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nGiven the `root` of a binary search tree and a `target` value, return *the value in the BST that is closest to the* `target`. If there are multiple answers, print the smallest.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0200-0299/0270.Closest%20Binary%20Search%20Tree%20Value/images/closest1-1-tree.jpg)\n\n```\n\n**Input:** root = [4,2,5,1,3], target = 3.714286\n**Output:** 4\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** root = [1], target = 4.428571\n**Output:** 1\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* The number of nodes in the tree is in the range `[1, 104]`.\n* `0 <= Node.val <= 109`\n* `-109 <= target <= 109`\n\n\n\n\n### Inefficient Solution:\n\n\n### Efficient Solution:\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def closestValue(self, root: Optional[TreeNode], target: float) -> int:\n        ans, mi = root.val, inf\n        while root:\n            t = abs(root.val - target)\n            if t < mi or (t == mi and root.val < ans):\n                mi = t\n                ans = root.val\n            if root.val > target:\n                root = root.left\n            else:\n                root = root.right\n        return ans\n<|eot_id|>",
    "model_generation": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nGiven the `root` of a binary search tree and a `target` value, return *the value in the BST that is closest to the* `target`. If there are multiple answers, print the smallest.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0200-0299/0270.Closest%20Binary%20Search%20Tree%20Value/images/closest1-1-tree.jpg)\n\n```\n\n**Input:** root = [4,2,5,1,3], target = 3.714286\n**Output:** 4\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** root = [1], target = 4.428571\n**Output:** 1\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* The number of nodes in the tree is in the range `[1, 104]`.\n* `0 <= Node.val <= 109`\n* `-109 <= target <= 109`\n\n\n\n\n### Inefficient Solution:\n\n\n### Efficient Solution:\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def closestValue(self, root: Optional[TreeNode], target: float) -> int:\n        ans = root.val\n        mn = abs(root.val - target)\n        node = root\n        while node:\n            if abs(node.val - target) < mn:\n                mn = abs(node.val - target)\n                ans = node.val\n            elif target < node.val:\n                node = node.left\n            else:\n                node = node.right\n        return ans\n",
    "model_solution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def closestValue(self, root: Optional[TreeNode], target: float) -> int:\n        ans = root.val\n        mn = abs(root.val - target)\n        node = root\n        while node:\n            if abs(node.val - target) < mn:\n                mn = abs(node.val - target)\n                ans = node.val\n            elif target < node.val:\n                node = node.left\n            else:\n                node = node.right\n        return ans"
}