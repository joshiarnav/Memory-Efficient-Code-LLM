{
    "problem_idx": "978",
    "description": "\nGiven an integer array `arr`, return *the length of a maximum size turbulent subarray of* `arr`.\n\n\nA subarray is **turbulent** if the comparison sign flips between each adjacent pair of elements in the subarray.\n\n\nMore formally, a subarray `[arr[i], arr[i + 1], ..., arr[j]]` of `arr` is said to be turbulent if and only if:\n\n\n* For `i <= k < j`:\n\t+ `arr[k] > arr[k + 1]` when `k` is odd, and\n\t+ `arr[k] < arr[k + 1]` when `k` is even.\n* Or, for `i <= k < j`:\n\t+ `arr[k] > arr[k + 1]` when `k` is even, and\n\t+ `arr[k] < arr[k + 1]` when `k` is odd.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** arr = [9,4,2,10,7,8,8,1,9]\n**Output:** 5\n**Explanation:** arr[1] > arr[2] < arr[3] > arr[4] < arr[5]\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** arr = [4,8,12,16]\n**Output:** 2\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** arr = [100]\n**Output:** 1\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= arr.length <= 4 * 104`\n* `0 <= arr[i] <= 109`\n\n\n",
    "inefficient_solution": "class Solution:\n    def maxTurbulenceSize(self, arr: List[int]) -> int:\n        ans = []\n        for i in range(len(arr)):\n            for j in range(i + 1, len(arr) + 1):\n                subarray = arr[i:j]\n                turbulent = True\n                for k in range(len(subarray) - 1):\n                    if subarray[k] > subarray[k + 1]:\n                        if k % 2 == 0:\n                            turbulent = False\n                            break\n                    elif subarray[k] < subarray[k + 1]:\n                        if k % 2 == 1:\n                            turbulent = False\n                            break\n                if turbulent:\n                    ans.append(len(subarray))\n        return max(ans)",
    "efficient_solution": "class Solution:\n    def maxTurbulenceSize(self, arr: List[int]) -> int:\n        ans = f = g = 1\n        for a, b in pairwise(arr):\n            ff = g + 1 if a < b else 1\n            gg = f + 1 if a > b else 1\n            f, g = ff, gg\n            ans = max(ans, f, g)\n        return ans\n",
    "text": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nGiven an integer array `arr`, return *the length of a maximum size turbulent subarray of* `arr`.\n\n\nA subarray is **turbulent** if the comparison sign flips between each adjacent pair of elements in the subarray.\n\n\nMore formally, a subarray `[arr[i], arr[i + 1], ..., arr[j]]` of `arr` is said to be turbulent if and only if:\n\n\n* For `i <= k < j`:\n\t+ `arr[k] > arr[k + 1]` when `k` is odd, and\n\t+ `arr[k] < arr[k + 1]` when `k` is even.\n* Or, for `i <= k < j`:\n\t+ `arr[k] > arr[k + 1]` when `k` is even, and\n\t+ `arr[k] < arr[k + 1]` when `k` is odd.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** arr = [9,4,2,10,7,8,8,1,9]\n**Output:** 5\n**Explanation:** arr[1] > arr[2] < arr[3] > arr[4] < arr[5]\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** arr = [4,8,12,16]\n**Output:** 2\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** arr = [100]\n**Output:** 1\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= arr.length <= 4 * 104`\n* `0 <= arr[i] <= 109`\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def maxTurbulenceSize(self, arr: List[int]) -> int:\n        ans = []\n        for i in range(len(arr)):\n            for j in range(i + 1, len(arr) + 1):\n                subarray = arr[i:j]\n                turbulent = True\n                for k in range(len(subarray) - 1):\n                    if subarray[k] > subarray[k + 1]:\n                        if k % 2 == 0:\n                            turbulent = False\n                            break\n                    elif subarray[k] < subarray[k + 1]:\n                        if k % 2 == 1:\n                            turbulent = False\n                            break\n                if turbulent:\n                    ans.append(len(subarray))\n        return max(ans)\n\n### Efficient Solution:\nclass Solution:\n    def maxTurbulenceSize(self, arr: List[int]) -> int:\n        ans = f = g = 1\n        for a, b in pairwise(arr):\n            ff = g + 1 if a < b else 1\n            gg = f + 1 if a > b else 1\n            f, g = ff, gg\n            ans = max(ans, f, g)\n        return ans\n<|eot_id|>",
    "model_generation": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nGiven an integer array `arr`, return *the length of a maximum size turbulent subarray of* `arr`.\n\n\nA subarray is **turbulent** if the comparison sign flips between each adjacent pair of elements in the subarray.\n\n\nMore formally, a subarray `[arr[i], arr[i + 1],..., arr[j]]` of `arr` is said to be turbulent if and only if:\n\n\n* For `i <= k < j`:\n\t+ `arr[k] > arr[k + 1]` when `k` is odd, and\n\t+ `arr[k] < arr[k + 1]` when `k` is even.\n* Or, for `i <= k < j`:\n\t+ `arr[k] > arr[k + 1]` when `k` is even, and\n\t+ `arr[k] < arr[k + 1]` when `k` is odd.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** arr = [9,4,2,10,7,8,8,1,9]\n**Output:** 5\n**Explanation:** arr[1] > arr[2] < arr[3] > arr[4] < arr[5]\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** arr = [4,8,12,16]\n**Output:** 2\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** arr = [100]\n**Output:** 1\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= arr.length <= 4 * 104`\n* `0 <= arr[i] <= 109`\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def maxTurbulenceSize(self, arr: List[int]) -> int:\n        ans = []\n        for i in range(len(arr)):\n            for j in range(i + 1, len(arr) + 1):\n                subarray = arr[i:j]\n                turbulent = True\n                for k in range(len(subarray) - 1):\n                    if subarray[k] > subarray[k + 1]:\n                        if k % 2 == 0:\n                            turbulent = False\n                            break\n                    elif subarray[k] < subarray[k + 1]:\n                        if k % 2 == 1:\n                            turbulent = False\n                            break\n                if turbulent:\n                    ans.append(len(subarray))\n        return max(ans)\n\n### Efficient Solution:\nclass Solution:\n    def maxTurbulenceSize(self, arr: List[int]) -> int:\n        ans, j = 1, 0\n        sign = None\n        while j < len(arr):\n            if sign is None:\n                if arr[j] > arr[j + 1]:\n                    sign = -1\n                elif arr[j] < arr[j + 1]:\n                    sign = 1\n                else:\n                    sign = None\n                    j += 1\n                    continue\n            if sign == -1 and arr[j] < arr[j + 1]:\n                sign = None\n            if sign == 1 and arr[j] > arr[j + 1]:\n                sign = None\n            ans = max(ans, j - i + 1)\n            j += 1\n        return ans\n",
    "model_solution": "class Solution:\n    def maxTurbulenceSize(self, arr: List[int]) -> int:\n        ans, j = 1, 0\n        sign = None\n        while j < len(arr):\n            if sign is None:\n                if arr[j] > arr[j + 1]:\n                    sign = -1\n                elif arr[j] < arr[j + 1]:\n                    sign = 1\n                else:\n                    sign = None\n                    j += 1\n                    continue\n            if sign == -1 and arr[j] < arr[j + 1]:\n                sign = None\n            if sign == 1 and arr[j] > arr[j + 1]:\n                sign = None\n            ans = max(ans, j - i + 1)\n            j += 1\n        return ans"
}