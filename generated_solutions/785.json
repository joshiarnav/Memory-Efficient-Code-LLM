{
    "problem_idx": "785",
    "description": "\nThere is an **undirected** graph with `n` nodes, where each node is numbered between `0` and `n - 1`. You are given a 2D array `graph`, where `graph[u]` is an array of nodes that node `u` is adjacent to. More formally, for each `v` in `graph[u]`, there is an undirected edge between node `u` and node `v`. The graph has the following properties:\n\n\n* There are no self-edges (`graph[u]` does not contain `u`).\n* There are no parallel edges (`graph[u]` does not contain duplicate values).\n* If `v` is in `graph[u]`, then `u` is in `graph[v]` (the graph is undirected).\n* The graph may not be connected, meaning there may be two nodes `u` and `v` such that there is no path between them.\n\n\nA graph is **bipartite** if the nodes can be partitioned into two independent sets `A` and `B` such that **every** edge in the graph connects a node in set `A` and a node in set `B`.\n\n\nReturn `true` *if and only if it is **bipartite***.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0700-0799/0785.Is%20Graph%20Bipartite/images/bi2.jpg)\n\n```\n\n**Input:** graph = [[1,2,3],[0,2],[0,1,3],[0,2]]\n**Output:** false\n**Explanation:** There is no way to partition the nodes into two independent sets such that every edge connects a node in one and a node in the other.\n```\n\n**Example 2:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0700-0799/0785.Is%20Graph%20Bipartite/images/bi1.jpg)\n\n```\n\n**Input:** graph = [[1,3],[0,2],[1,3],[0,2]]\n**Output:** true\n**Explanation:** We can partition the nodes into two sets: {0, 2} and {1, 3}.\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `graph.length == n`\n* `1 <= n <= 100`\n* `0 <= graph[u].length < n`\n* `0 <= graph[u][i] <= n - 1`\n* `graph[u]`\u00a0does not contain\u00a0`u`.\n* All the values of `graph[u]` are **unique**.\n* If `graph[u]` contains `v`, then `graph[v]` contains `u`.\n\n\n",
    "inefficient_solution": "class Solution:\n    def isBipartite(self, graph: List[List[int]]) -> bool:\n        color = [[0 for _ in range(101)] for _ in range(101)]\n        visited = [[False for _ in range(101)] for _ in range(101)]\n        n = len(graph)\n        \n        for i in range(n):\n            if not visited[i][0]:\n                self.dfs(i, 0, graph, color, visited)\n        \n        return True\n    \n    def dfs(self, u, c, graph, color, visited):\n        visited[u][c] = True\n        color[u] = c\n        for v in graph[u]:\n            if not visited[v][0]:\n                if not self.dfs(v, 1 - c, graph, color, visited):\n                    return False\n            elif color[v] == c:\n                return False\n        return True",
    "efficient_solution": "class Solution:\n    def isBipartite(self, graph: List[List[int]]) -> bool:\n        def dfs(u, c):\n            color[u] = c\n            for v in graph[u]:\n                if not color[v]:\n                    if not dfs(v, 3 - c):\n                        return False\n                elif color[v] == c:\n                    return False\n            return True\n\n        n = len(graph)\n        color = [0] * n\n        for i in range(n):\n            if not color[i] and not dfs(i, 1):\n                return False\n        return True\n",
    "text": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nThere is an **undirected** graph with `n` nodes, where each node is numbered between `0` and `n - 1`. You are given a 2D array `graph`, where `graph[u]` is an array of nodes that node `u` is adjacent to. More formally, for each `v` in `graph[u]`, there is an undirected edge between node `u` and node `v`. The graph has the following properties:\n\n\n* There are no self-edges (`graph[u]` does not contain `u`).\n* There are no parallel edges (`graph[u]` does not contain duplicate values).\n* If `v` is in `graph[u]`, then `u` is in `graph[v]` (the graph is undirected).\n* The graph may not be connected, meaning there may be two nodes `u` and `v` such that there is no path between them.\n\n\nA graph is **bipartite** if the nodes can be partitioned into two independent sets `A` and `B` such that **every** edge in the graph connects a node in set `A` and a node in set `B`.\n\n\nReturn `true` *if and only if it is **bipartite***.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0700-0799/0785.Is%20Graph%20Bipartite/images/bi2.jpg)\n\n```\n\n**Input:** graph = [[1,2,3],[0,2],[0,1,3],[0,2]]\n**Output:** false\n**Explanation:** There is no way to partition the nodes into two independent sets such that every edge connects a node in one and a node in the other.\n```\n\n**Example 2:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0700-0799/0785.Is%20Graph%20Bipartite/images/bi1.jpg)\n\n```\n\n**Input:** graph = [[1,3],[0,2],[1,3],[0,2]]\n**Output:** true\n**Explanation:** We can partition the nodes into two sets: {0, 2} and {1, 3}.\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `graph.length == n`\n* `1 <= n <= 100`\n* `0 <= graph[u].length < n`\n* `0 <= graph[u][i] <= n - 1`\n* `graph[u]`\u00a0does not contain\u00a0`u`.\n* All the values of `graph[u]` are **unique**.\n* If `graph[u]` contains `v`, then `graph[v]` contains `u`.\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def isBipartite(self, graph: List[List[int]]) -> bool:\n        color = [[0 for _ in range(101)] for _ in range(101)]\n        visited = [[False for _ in range(101)] for _ in range(101)]\n        n = len(graph)\n        \n        for i in range(n):\n            if not visited[i][0]:\n                self.dfs(i, 0, graph, color, visited)\n        \n        return True\n    \n    def dfs(self, u, c, graph, color, visited):\n        visited[u][c] = True\n        color[u] = c\n        for v in graph[u]:\n            if not visited[v][0]:\n                if not self.dfs(v, 1 - c, graph, color, visited):\n                    return False\n            elif color[v] == c:\n                return False\n        return True\n\n### Efficient Solution:\nclass Solution:\n    def isBipartite(self, graph: List[List[int]]) -> bool:\n        def dfs(u, c):\n            color[u] = c\n            for v in graph[u]:\n                if not color[v]:\n                    if not dfs(v, 3 - c):\n                        return False\n                elif color[v] == c:\n                    return False\n            return True\n\n        n = len(graph)\n        color = [0] * n\n        for i in range(n):\n            if not color[i] and not dfs(i, 1):\n                return False\n        return True\n<|eot_id|>",
    "model_generation": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nThere is an **undirected** graph with `n` nodes, where each node is numbered between `0` and `n - 1`. You are given a 2D array `graph`, where `graph[u]` is an array of nodes that node `u` is adjacent to. More formally, for each `v` in `graph[u]`, there is an undirected edge between node `u` and node `v`. The graph has the following properties:\n\n\n* There are no self-edges (`graph[u]` does not contain `u`).\n* There are no parallel edges (`graph[u]` does not contain duplicate values).\n* If `v` is in `graph[u]`, then `u` is in `graph[v]` (the graph is undirected).\n* The graph may not be connected, meaning there may be two nodes `u` and `v` such that there is no path between them.\n\n\nA graph is **bipartite** if the nodes can be partitioned into two independent sets `A` and `B` such that **every** edge in the graph connects a node in set `A` and a node in set `B`.\n\n\nReturn `true` *if and only if it is **bipartite***.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0700-0799/0785.Is%20Graph%20Bipartite/images/bi2.jpg)\n\n```\n\n**Input:** graph = [[1,2,3],[0,2],[0,1,3],[0,2]]\n**Output:** false\n**Explanation:** There is no way to partition the nodes into two independent sets such that every edge connects a node in one and a node in the other.\n```\n\n**Example 2:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0700-0799/0785.Is%20Graph%20Bipartite/images/bi1.jpg)\n\n```\n\n**Input:** graph = [[1,3],[0,2],[1,3],[0,2]]\n**Output:** true\n**Explanation:** We can partition the nodes into two sets: {0, 2} and {1, 3}.\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `graph.length == n`\n* `1 <= n <= 100`\n* `0 <= graph[u].length < n`\n* `0 <= graph[u][i] <= n - 1`\n* `graph[u]`\u00a0does not contain\u00a0`u`.\n* All the values of `graph[u]` are **unique**.\n* If `graph[u]` contains `v`, then `graph[v]` contains `u`.\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def isBipartite(self, graph: List[List[int]]) -> bool:\n        color = [[0 for _ in range(101)] for _ in range(101)]\n        visited = [[False for _ in range(101)] for _ in range(101)]\n        n = len(graph)\n        \n        for i in range(n):\n            if not visited[i][0]:\n                self.dfs(i, 0, graph, color, visited)\n        \n        return True\n    \n    def dfs(self, u, c, graph, color, visited):\n        visited[u][c] = True\n        color[u] = c\n        for v in graph[u]:\n            if not visited[v][0]:\n                if not self.dfs(v, 1 - c, graph, color, visited):\n                    return False\n            elif color[v] == c:\n                return False\n        return True\n\n### Efficient Solution:\nclass Solution:\n    def isBipartite(self, graph: List[List[int]]) -> bool:\n        color = [0] * len(graph)\n        for i, row in enumerate(graph):\n            if color[i] == 0:\n                if not self.dfs(i, 0, graph, color):\n                    return False\n        return True\n\n    def dfs(self, u: int, c: int, graph: List[List[int]], color: List[int]) -> bool:\n        for v in graph[u]:\n            if color[v] == 0:\n                if not self.dfs(v, 1 - c, graph, color):\n                    return False\n            elif color[v] == c:\n                return False\n        color[u] = c\n        return True\n",
    "model_solution": "class Solution:\n    def isBipartite(self, graph: List[List[int]]) -> bool:\n        color = [0] * len(graph)\n        for i, row in enumerate(graph):\n            if color[i] == 0:\n                if not self.dfs(i, 0, graph, color):\n                    return False\n        return True\n\n    def dfs(self, u: int, c: int, graph: List[List[int]], color: List[int]) -> bool:\n        for v in graph[u]:\n            if color[v] == 0:\n                if not self.dfs(v, 1 - c, graph, color):\n                    return False\n            elif color[v] == c:\n                return False\n        color[u] = c\n        return True"
}