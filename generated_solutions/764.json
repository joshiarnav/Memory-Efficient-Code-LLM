{
    "problem_idx": "764",
    "description": "\nYou are given an integer `n`. You have an `n x n` binary grid `grid` with all values initially `1`'s except for some indices given in the array `mines`. The `ith` element of the array `mines` is defined as `mines[i] = [xi, yi]` where `grid[xi][yi] == 0`.\n\n\nReturn *the order of the largest **axis-aligned** plus sign of* 1*'s contained in* `grid`. If there is none, return `0`.\n\n\nAn **axis-aligned plus sign** of `1`'s of order `k` has some center `grid[r][c] == 1` along with four arms of length `k - 1` going up, down, left, and right, and made of `1`'s. Note that there could be `0`'s or `1`'s beyond the arms of the plus sign, only the relevant area of the plus sign is checked for `1`'s.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0700-0799/0764.Largest%20Plus%20Sign/images/plus1-grid.jpg)\n\n```\n\n**Input:** n = 5, mines = [[4,2]]\n**Output:** 2\n**Explanation:** In the above grid, the largest plus sign can only be of order 2. One of them is shown.\n\n```\n\n**Example 2:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0700-0799/0764.Largest%20Plus%20Sign/images/plus2-grid.jpg)\n\n```\n\n**Input:** n = 1, mines = [[0,0]]\n**Output:** 0\n**Explanation:** There is no plus sign, so return 0.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= n <= 500`\n* `1 <= mines.length <= 5000`\n* `0 <= xi, yi < n`\n* All the pairs `(xi, yi)` are **unique**.\n\n\n",
    "inefficient_solution": "class Solution:\n    def orderOfLargestPlusSign(self, n: int, mines: List[List[int]]) -> int:\n        dp = [[n for _ in range(n)] for _ in range(n)]\n        for i in range(n):\n            for j in range(n):\n                dp[i][j] = 0\n        for x, y in mines:\n            dp[x][y] = -1\n        for i in range(n):\n            left = right = up = down = 0\n            for j in range(n):\n                left = left + 1 if dp[i][j] != -1 else 0\n                right = right + 1 if dp[i][n - 1 - j] != -1 else 0\n                up = up + 1 if dp[n - 1 - j][i] != -1 else 0\n                down = down + 1 if dp[j][i] != -1 else 0\n                dp[i][j] = min(dp[i][j], left)\n                dp[i][n - 1 - j] = min(dp[i][n - 1 - j], right)\n                dp[n - 1 - j][i] = min(dp[n - 1 - j][i], up)\n                dp[j][i] = min(dp[j][i], down)\n        max_order = 0\n        for i in range(n):\n            for j in range(n):\n                if dp[i][j] != -1:\n                    max_order = max(max_order, min(dp[i][j], min(dp[i][j] + 1, min(dp[i][j] + 2, min(dp[i][j] + 3, min(dp[i][j] + 4))))))\n        return max_order",
    "efficient_solution": "class Solution:\n    def orderOfLargestPlusSign(self, n: int, mines: List[List[int]]) -> int:\n        dp = [[n] * n for _ in range(n)]\n        for x, y in mines:\n            dp[x][y] = 0\n        for i in range(n):\n            left = right = up = down = 0\n            for j, k in zip(range(n), reversed(range(n))):\n                left = left + 1 if dp[i][j] else 0\n                right = right + 1 if dp[i][k] else 0\n                up = up + 1 if dp[j][i] else 0\n                down = down + 1 if dp[k][i] else 0\n                dp[i][j] = min(dp[i][j], left)\n                dp[i][k] = min(dp[i][k], right)\n                dp[j][i] = min(dp[j][i], up)\n                dp[k][i] = min(dp[k][i], down)\n        return max(max(v) for v in dp)\n",
    "text": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nYou are given an integer `n`. You have an `n x n` binary grid `grid` with all values initially `1`'s except for some indices given in the array `mines`. The `ith` element of the array `mines` is defined as `mines[i] = [xi, yi]` where `grid[xi][yi] == 0`.\n\n\nReturn *the order of the largest **axis-aligned** plus sign of* 1*'s contained in* `grid`. If there is none, return `0`.\n\n\nAn **axis-aligned plus sign** of `1`'s of order `k` has some center `grid[r][c] == 1` along with four arms of length `k - 1` going up, down, left, and right, and made of `1`'s. Note that there could be `0`'s or `1`'s beyond the arms of the plus sign, only the relevant area of the plus sign is checked for `1`'s.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0700-0799/0764.Largest%20Plus%20Sign/images/plus1-grid.jpg)\n\n```\n\n**Input:** n = 5, mines = [[4,2]]\n**Output:** 2\n**Explanation:** In the above grid, the largest plus sign can only be of order 2. One of them is shown.\n\n```\n\n**Example 2:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0700-0799/0764.Largest%20Plus%20Sign/images/plus2-grid.jpg)\n\n```\n\n**Input:** n = 1, mines = [[0,0]]\n**Output:** 0\n**Explanation:** There is no plus sign, so return 0.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= n <= 500`\n* `1 <= mines.length <= 5000`\n* `0 <= xi, yi < n`\n* All the pairs `(xi, yi)` are **unique**.\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def orderOfLargestPlusSign(self, n: int, mines: List[List[int]]) -> int:\n        dp = [[n for _ in range(n)] for _ in range(n)]\n        for i in range(n):\n            for j in range(n):\n                dp[i][j] = 0\n        for x, y in mines:\n            dp[x][y] = -1\n        for i in range(n):\n            left = right = up = down = 0\n            for j in range(n):\n                left = left + 1 if dp[i][j] != -1 else 0\n                right = right + 1 if dp[i][n - 1 - j] != -1 else 0\n                up = up + 1 if dp[n - 1 - j][i] != -1 else 0\n                down = down + 1 if dp[j][i] != -1 else 0\n                dp[i][j] = min(dp[i][j], left)\n                dp[i][n - 1 - j] = min(dp[i][n - 1 - j], right)\n                dp[n - 1 - j][i] = min(dp[n - 1 - j][i], up)\n                dp[j][i] = min(dp[j][i], down)\n        max_order = 0\n        for i in range(n):\n            for j in range(n):\n                if dp[i][j] != -1:\n                    max_order = max(max_order, min(dp[i][j], min(dp[i][j] + 1, min(dp[i][j] + 2, min(dp[i][j] + 3, min(dp[i][j] + 4))))))\n        return max_order\n\n### Efficient Solution:\nclass Solution:\n    def orderOfLargestPlusSign(self, n: int, mines: List[List[int]]) -> int:\n        dp = [[n] * n for _ in range(n)]\n        for x, y in mines:\n            dp[x][y] = 0\n        for i in range(n):\n            left = right = up = down = 0\n            for j, k in zip(range(n), reversed(range(n))):\n                left = left + 1 if dp[i][j] else 0\n                right = right + 1 if dp[i][k] else 0\n                up = up + 1 if dp[j][i] else 0\n                down = down + 1 if dp[k][i] else 0\n                dp[i][j] = min(dp[i][j], left)\n                dp[i][k] = min(dp[i][k], right)\n                dp[j][i] = min(dp[j][i], up)\n                dp[k][i] = min(dp[k][i], down)\n        return max(max(v) for v in dp)\n<|eot_id|>",
    "model_generation": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nYou are given an integer `n`. You have an `n x n` binary grid `grid` with all values initially `1`'s except for some indices given in the array `mines`. The `ith` element of the array `mines` is defined as `mines[i] = [xi, yi]` where `grid[xi][yi] == 0`.\n\n\nReturn *the order of the largest **axis-aligned** plus sign of* 1*'s contained in* `grid`. If there is none, return `0`.\n\n\nAn **axis-aligned plus sign** of `1`'s of order `k` has some center `grid[r][c] == 1` along with four arms of length `k - 1` going up, down, left, and right, and made of `1`'s. Note that there could be `0`'s or `1`'s beyond the arms of the plus sign, only the relevant area of the plus sign is checked for `1`'s.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0700-0799/0764.Largest%20Plus%20Sign/images/plus1-grid.jpg)\n\n```\n\n**Input:** n = 5, mines = [[4,2]]\n**Output:** 2\n**Explanation:** In the above grid, the largest plus sign can only be of order 2. One of them is shown.\n\n```\n\n**Example 2:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0700-0799/0764.Largest%20Plus%20Sign/images/plus2-grid.jpg)\n\n```\n\n**Input:** n = 1, mines = [[0,0]]\n**Output:** 0\n**Explanation:** There is no plus sign, so return 0.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= n <= 500`\n* `1 <= mines.length <= 5000`\n* `0 <= xi, yi < n`\n* All the pairs `(xi, yi)` are **unique**.\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def orderOfLargestPlusSign(self, n: int, mines: List[List[int]]) -> int:\n        dp = [[n for _ in range(n)] for _ in range(n)]\n        for i in range(n):\n            for j in range(n):\n                dp[i][j] = 0\n        for x, y in mines:\n            dp[x][y] = -1\n        for i in range(n):\n            left = right = up = down = 0\n            for j in range(n):\n                left = left + 1 if dp[i][j]!= -1 else 0\n                right = right + 1 if dp[i][n - 1 - j]!= -1 else 0\n                up = up + 1 if dp[n - 1 - j][i]!= -1 else 0\n                down = down + 1 if dp[j][i]!= -1 else 0\n                dp[i][j] = min(dp[i][j], left)\n                dp[i][n - 1 - j] = min(dp[i][n - 1 - j], right)\n                dp[n - 1 - j][i] = min(dp[n - 1 - j][i], up)\n                dp[j][i] = min(dp[j][i], down)\n        max_order = 0\n        for i in range(n):\n            for j in range(n):\n                if dp[i][j]!= -1:\n                    max_order = max(max_order, min(dp[i][j], min(dp[i][j] + 1, min(dp[i][j] + 2, min(dp[i][j] + 3, min(dp[i][j] + 4))))))\n        return max_order\n\n### Efficient Solution:\nclass Solution:\n    def orderOfLargestPlusSign(self, n: int, mines: List[List[int]]) -> int:\n        dp = [[n for _ in range(n)] for _ in range(n)]\n        for x, y in mines:\n            dp[x][y] = 0\n        for i in range(n):\n            left = right = up = down = 0\n            for j in range(n):\n                left = max(left, dp[i][j])\n                right = max(right, dp[i][n - 1 - j])\n                up = max(up, dp[n - 1 - j][i])\n                down = max(down, dp[j][i])\n                dp[i][j] = max(dp[i][j], left + 1)\n                dp[i][n - 1 - j] = max(dp[i][n - 1 - j], right + 1)\n                dp[n - 1 - j][i] = max(dp[n - 1 - j][i], up + 1)\n                dp[j][i] = max(dp[j][i], down + 1)\n        return max(dp[k][k] for k in range(n))\n",
    "model_solution": "class Solution:\n    def orderOfLargestPlusSign(self, n: int, mines: List[List[int]]) -> int:\n        dp = [[n for _ in range(n)] for _ in range(n)]\n        for x, y in mines:\n            dp[x][y] = 0\n        for i in range(n):\n            left = right = up = down = 0\n            for j in range(n):\n                left = max(left, dp[i][j])\n                right = max(right, dp[i][n - 1 - j])\n                up = max(up, dp[n - 1 - j][i])\n                down = max(down, dp[j][i])\n                dp[i][j] = max(dp[i][j], left + 1)\n                dp[i][n - 1 - j] = max(dp[i][n - 1 - j], right + 1)\n                dp[n - 1 - j][i] = max(dp[n - 1 - j][i], up + 1)\n                dp[j][i] = max(dp[j][i], down + 1)\n        return max(dp[k][k] for k in range(n))"
}