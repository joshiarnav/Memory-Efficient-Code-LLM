{
    "problem_idx": "567",
    "description": "\nGiven two strings `s1` and `s2`, return `true` *if* `s2` *contains a permutation of* `s1`*, or* `false` *otherwise*.\n\n\nIn other words, return `true` if one of `s1`'s permutations is the substring of `s2`.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** s1 = \"ab\", s2 = \"eidbaooo\"\n**Output:** true\n**Explanation:** s2 contains one permutation of s1 (\"ba\").\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** s1 = \"ab\", s2 = \"eidboaoo\"\n**Output:** false\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= s1.length, s2.length <= 104`\n* `s1` and `s2` consist of lowercase English letters.\n\n\n",
    "inefficient_solution": "class Solution:\n    def checkInclusion(self, s1: str, s2: str) -> bool:\n        n, m = len(s1), len(s2)\n        if n > m:\n            return False\n        s1_set = set(s1)\n        s2_list = [None] * m\n        for i in range(m):\n            if s2[i] in s1_set:\n                s2_list[i] = {'s1': s1_set, 's2': set(s2[i])}\n        for i in range(m - n + 1):\n            window = [None] * n\n            for j in range(n):\n                window[j] = {'s2': set(s2[i + j])}\n            for s2_str in s2_list[i:i + n]:\n                for key, value in s2_str.items():\n                    for j in range(n):\n                        window[j][key] = value\n            if self.is_perm(window, s1_set):\n                return True\n        return False\n\n    def is_perm(self, window, s1_set):\n        for i in range(len(window)):\n            for key, value in window[i].items():\n                if key == 's1':\n                    if value != s1_set:\n                        return False\n                else:\n                    if len(value) != 1 or list(value)[0] not in s1_set:\n                        return False\n        return True",
    "efficient_solution": "class Solution:\n    def checkInclusion(self, s1: str, s2: str) -> bool:\n        n, m = len(s1), len(s2)\n        if n > m:\n            return False\n        cnt = Counter()\n        for a, b in zip(s1, s2):\n            cnt[a] -= 1\n            cnt[b] += 1\n        diff = sum(x != 0 for x in cnt.values())\n        if diff == 0:\n            return True\n        for i in range(n, m):\n            a, b = s2[i - n], s2[i]\n\n            if cnt[b] == 0:\n                diff += 1\n            cnt[b] += 1\n            if cnt[b] == 0:\n                diff -= 1\n\n            if cnt[a] == 0:\n                diff += 1\n            cnt[a] -= 1\n            if cnt[a] == 0:\n                diff -= 1\n\n            if diff == 0:\n                return True\n        return False\n",
    "text": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nGiven two strings `s1` and `s2`, return `true` *if* `s2` *contains a permutation of* `s1`*, or* `false` *otherwise*.\n\n\nIn other words, return `true` if one of `s1`'s permutations is the substring of `s2`.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** s1 = \"ab\", s2 = \"eidbaooo\"\n**Output:** true\n**Explanation:** s2 contains one permutation of s1 (\"ba\").\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** s1 = \"ab\", s2 = \"eidboaoo\"\n**Output:** false\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= s1.length, s2.length <= 104`\n* `s1` and `s2` consist of lowercase English letters.\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def checkInclusion(self, s1: str, s2: str) -> bool:\n        n, m = len(s1), len(s2)\n        if n > m:\n            return False\n        s1_set = set(s1)\n        s2_list = [None] * m\n        for i in range(m):\n            if s2[i] in s1_set:\n                s2_list[i] = {'s1': s1_set, 's2': set(s2[i])}\n        for i in range(m - n + 1):\n            window = [None] * n\n            for j in range(n):\n                window[j] = {'s2': set(s2[i + j])}\n            for s2_str in s2_list[i:i + n]:\n                for key, value in s2_str.items():\n                    for j in range(n):\n                        window[j][key] = value\n            if self.is_perm(window, s1_set):\n                return True\n        return False\n\n    def is_perm(self, window, s1_set):\n        for i in range(len(window)):\n            for key, value in window[i].items():\n                if key == 's1':\n                    if value != s1_set:\n                        return False\n                else:\n                    if len(value) != 1 or list(value)[0] not in s1_set:\n                        return False\n        return True\n\n### Efficient Solution:\nclass Solution:\n    def checkInclusion(self, s1: str, s2: str) -> bool:\n        n, m = len(s1), len(s2)\n        if n > m:\n            return False\n        cnt = Counter()\n        for a, b in zip(s1, s2):\n            cnt[a] -= 1\n            cnt[b] += 1\n        diff = sum(x != 0 for x in cnt.values())\n        if diff == 0:\n            return True\n        for i in range(n, m):\n            a, b = s2[i - n], s2[i]\n\n            if cnt[b] == 0:\n                diff += 1\n            cnt[b] += 1\n            if cnt[b] == 0:\n                diff -= 1\n\n            if cnt[a] == 0:\n                diff += 1\n            cnt[a] -= 1\n            if cnt[a] == 0:\n                diff -= 1\n\n            if diff == 0:\n                return True\n        return False\n<|eot_id|>",
    "model_generation": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nGiven two strings `s1` and `s2`, return `true` *if* `s2` *contains a permutation of* `s1`*, or* `false` *otherwise*.\n\n\nIn other words, return `true` if one of `s1`'s permutations is the substring of `s2`.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** s1 = \"ab\", s2 = \"eidbaooo\"\n**Output:** true\n**Explanation:** s2 contains one permutation of s1 (\"ba\").\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** s1 = \"ab\", s2 = \"eidboaoo\"\n**Output:** false\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= s1.length, s2.length <= 104`\n* `s1` and `s2` consist of lowercase English letters.\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def checkInclusion(self, s1: str, s2: str) -> bool:\n        n, m = len(s1), len(s2)\n        if n > m:\n            return False\n        s1_set = set(s1)\n        s2_list = [None] * m\n        for i in range(m):\n            if s2[i] in s1_set:\n                s2_list[i] = {'s1': s1_set,'s2': set(s2[i])}\n        for i in range(m - n + 1):\n            window = [None] * n\n            for j in range(n):\n                window[j] = {'s2': set(s2[i + j])}\n            for s2_str in s2_list[i:i + n]:\n                for key, value in s2_str.items():\n                    for j in range(n):\n                        window[j][key] = value\n            if self.is_perm(window, s1_set):\n                return True\n        return False\n\n    def is_perm(self, window, s1_set):\n        for i in range(len(window)):\n            for key, value in window[i].items():\n                if key =='s1':\n                    if value!= s1_set:\n                        return False\n                else:\n                    if len(value)!= 1 or list(value)[0] not in s1_set:\n                        return False\n        return True\n\n### Efficient Solution:\nclass Solution:\n    def checkInclusion(self, s1: str, s2: str) -> bool:\n        n, m = len(s1), len(s2)\n        if n > m:\n            return False\n        cnt1 = Counter(s1)\n        cnt2 = Counter(s2[: n - 1])\n        for i in range(n - 1, m):\n            cnt2[list(cnt2.keys())[i - n + 1]] -= 1\n            cnt2[list(cnt2.keys())[i - n + 1]] = max(0, cnt2[list(cnt2.keys())[i - n + 1]])\n            cnt2[list(cnt2.keys())[i]] = cnt2.get(list(cnt2.keys())[i], 0) + 1\n            if cnt2 == cnt1:\n                return True\n        return False\n",
    "model_solution": "class Solution:\n    def checkInclusion(self, s1: str, s2: str) -> bool:\n        n, m = len(s1), len(s2)\n        if n > m:\n            return False\n        cnt1 = Counter(s1)\n        cnt2 = Counter(s2[: n - 1])\n        for i in range(n - 1, m):\n            cnt2[list(cnt2.keys())[i - n + 1]] -= 1\n            cnt2[list(cnt2.keys())[i - n + 1]] = max(0, cnt2[list(cnt2.keys())[i - n + 1]])\n            cnt2[list(cnt2.keys())[i]] = cnt2.get(list(cnt2.keys())[i], 0) + 1\n            if cnt2 == cnt1:\n                return True\n        return False"
}