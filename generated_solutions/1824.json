{
    "problem_idx": "1824",
    "description": "\nThere is a **3 lane road** of length `n` that consists of `n + 1` **points** labeled from `0` to `n`. A frog **starts** at point `0` in the **second** laneand wants to jump to point `n`. However, there could be obstacles along the way.\n\n\nYou are given an array `obstacles` of length `n + 1` where each `obstacles[i]` (**ranging from 0 to 3**) describes an obstacle on the lane `obstacles[i]` at point `i`. If `obstacles[i] == 0`, there are no obstacles at point `i`. There will be **at most one** obstacle in the 3 lanes at each point.\n\n\n* For example, if `obstacles[2] == 1`, then there is an obstacle on lane 1 at point 2.\n\n\nThe frog can only travel from point `i` to point `i + 1` on the same lane if there is not an obstacle on the lane at point `i + 1`. To avoid obstacles, the frog can also perform a **side jump** to jump to **another** lane (even if they are not adjacent) at the **same** point if there is no obstacle on the new lane.\n\n\n* For example, the frog can jump from lane 3 at point 3 to lane 1 at point 3.\n\n\nReturn *the **minimum number of side jumps** the frog needs to reach **any lane** at point n starting from lane `2` at point 0.*\n\n\n**Note:** There will be no obstacles on points `0` and `n`.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1800-1899/1824.Minimum%20Sideway%20Jumps/images/ic234-q3-ex1.png)\n\n```\n\n**Input:** obstacles = [0,1,2,3,0]\n**Output:** 2 \n**Explanation:** The optimal solution is shown by the arrows above. There are 2 side jumps (red arrows).\nNote that the frog can jump over obstacles only when making side jumps (as shown at point 2).\n\n```\n\n**Example 2:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1800-1899/1824.Minimum%20Sideway%20Jumps/images/ic234-q3-ex2.png)\n\n```\n\n**Input:** obstacles = [0,1,1,3,3,0]\n**Output:** 0\n**Explanation:** There are no obstacles on lane 2. No side jumps are required.\n\n```\n\n**Example 3:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1800-1899/1824.Minimum%20Sideway%20Jumps/images/ic234-q3-ex3.png)\n\n```\n\n**Input:** obstacles = [0,2,1,0,3,0]\n**Output:** 2\n**Explanation:** The optimal solution is shown by the arrows above. There are 2 side jumps.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `obstacles.length == n + 1`\n* `1 <= n <= 5 * 105`\n* `0 <= obstacles[i] <= 3`\n* `obstacles[0] == obstacles[n] == 0`\n\n\n",
    "inefficient_solution": "class Solution:\n    def minSideJumps(self, obstacles: List[int]) -> int:\n        n = len(obstacles)\n        dp = [[float('inf')] * 4 for _ in range(n + 1)]\n        dp[0][2] = 0\n        for i in range(n):\n            for j in range(4):\n                dp[i + 1][j] = min(dp[i + 1])\n                if obstacles[i] == j + 1:\n                    dp[i + 1][j] = float('inf')\n                elif j not in (obstacles[i], obstacles[i] - 1, obstacles[i] + 1):\n                    dp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + 1)\n        return min(dp[n])",
    "efficient_solution": "class Solution:\n    def minSideJumps(self, obstacles: List[int]) -> int:\n        f = [1, 0, 1]\n        for v in obstacles[1:]:\n            for j in range(3):\n                if v == j + 1:\n                    f[j] = inf\n                    break\n            x = min(f) + 1\n            for j in range(3):\n                if v != j + 1:\n                    f[j] = min(f[j], x)\n        return min(f)\n",
    "text": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nThere is a **3 lane road** of length `n` that consists of `n + 1` **points** labeled from `0` to `n`. A frog **starts** at point `0` in the **second** laneand wants to jump to point `n`. However, there could be obstacles along the way.\n\n\nYou are given an array `obstacles` of length `n + 1` where each `obstacles[i]` (**ranging from 0 to 3**) describes an obstacle on the lane `obstacles[i]` at point `i`. If `obstacles[i] == 0`, there are no obstacles at point `i`. There will be **at most one** obstacle in the 3 lanes at each point.\n\n\n* For example, if `obstacles[2] == 1`, then there is an obstacle on lane 1 at point 2.\n\n\nThe frog can only travel from point `i` to point `i + 1` on the same lane if there is not an obstacle on the lane at point `i + 1`. To avoid obstacles, the frog can also perform a **side jump** to jump to **another** lane (even if they are not adjacent) at the **same** point if there is no obstacle on the new lane.\n\n\n* For example, the frog can jump from lane 3 at point 3 to lane 1 at point 3.\n\n\nReturn *the **minimum number of side jumps** the frog needs to reach **any lane** at point n starting from lane `2` at point 0.*\n\n\n**Note:** There will be no obstacles on points `0` and `n`.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1800-1899/1824.Minimum%20Sideway%20Jumps/images/ic234-q3-ex1.png)\n\n```\n\n**Input:** obstacles = [0,1,2,3,0]\n**Output:** 2 \n**Explanation:** The optimal solution is shown by the arrows above. There are 2 side jumps (red arrows).\nNote that the frog can jump over obstacles only when making side jumps (as shown at point 2).\n\n```\n\n**Example 2:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1800-1899/1824.Minimum%20Sideway%20Jumps/images/ic234-q3-ex2.png)\n\n```\n\n**Input:** obstacles = [0,1,1,3,3,0]\n**Output:** 0\n**Explanation:** There are no obstacles on lane 2. No side jumps are required.\n\n```\n\n**Example 3:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1800-1899/1824.Minimum%20Sideway%20Jumps/images/ic234-q3-ex3.png)\n\n```\n\n**Input:** obstacles = [0,2,1,0,3,0]\n**Output:** 2\n**Explanation:** The optimal solution is shown by the arrows above. There are 2 side jumps.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `obstacles.length == n + 1`\n* `1 <= n <= 5 * 105`\n* `0 <= obstacles[i] <= 3`\n* `obstacles[0] == obstacles[n] == 0`\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def minSideJumps(self, obstacles: List[int]) -> int:\n        n = len(obstacles)\n        dp = [[float('inf')] * 4 for _ in range(n + 1)]\n        dp[0][2] = 0\n        for i in range(n):\n            for j in range(4):\n                dp[i + 1][j] = min(dp[i + 1])\n                if obstacles[i] == j + 1:\n                    dp[i + 1][j] = float('inf')\n                elif j not in (obstacles[i], obstacles[i] - 1, obstacles[i] + 1):\n                    dp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + 1)\n        return min(dp[n])\n\n### Efficient Solution:\nclass Solution:\n    def minSideJumps(self, obstacles: List[int]) -> int:\n        f = [1, 0, 1]\n        for v in obstacles[1:]:\n            for j in range(3):\n                if v == j + 1:\n                    f[j] = inf\n                    break\n            x = min(f) + 1\n            for j in range(3):\n                if v != j + 1:\n                    f[j] = min(f[j], x)\n        return min(f)\n<|eot_id|>",
    "model_generation": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nThere is a **3 lane road** of length `n` that consists of `n + 1` **points** labeled from `0` to `n`. A frog **starts** at point `0` in the **second** laneand wants to jump to point `n`. However, there could be obstacles along the way.\n\n\nYou are given an array `obstacles` of length `n + 1` where each `obstacles[i]` (**ranging from 0 to 3**) describes an obstacle on the lane `obstacles[i]` at point `i`. If `obstacles[i] == 0`, there are no obstacles at point `i`. There will be **at most one** obstacle in the 3 lanes at each point.\n\n\n* For example, if `obstacles[2] == 1`, then there is an obstacle on lane 1 at point 2.\n\n\nThe frog can only travel from point `i` to point `i + 1` on the same lane if there is not an obstacle on the lane at point `i + 1`. To avoid obstacles, the frog can also perform a **side jump** to jump to **another** lane (even if they are not adjacent) at the **same** point if there is no obstacle on the new lane.\n\n\n* For example, the frog can jump from lane 3 at point 3 to lane 1 at point 3.\n\n\nReturn *the **minimum number of side jumps** the frog needs to reach **any lane** at point n starting from lane `2` at point 0.*\n\n\n**Note:** There will be no obstacles on points `0` and `n`.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1800-1899/1824.Minimum%20Sideway%20Jumps/images/ic234-q3-ex1.png)\n\n```\n\n**Input:** obstacles = [0,1,2,3,0]\n**Output:** 2 \n**Explanation:** The optimal solution is shown by the arrows above. There are 2 side jumps (red arrows).\nNote that the frog can jump over obstacles only when making side jumps (as shown at point 2).\n\n```\n\n**Example 2:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1800-1899/1824.Minimum%20Sideway%20Jumps/images/ic234-q3-ex2.png)\n\n```\n\n**Input:** obstacles = [0,1,1,3,3,0]\n**Output:** 0\n**Explanation:** There are no obstacles on lane 2. No side jumps are required.\n\n```\n\n**Example 3:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1800-1899/1824.Minimum%20Sideway%20Jumps/images/ic234-q3-ex3.png)\n\n```\n\n**Input:** obstacles = [0,2,1,0,3,0]\n**Output:** 2\n**Explanation:** The optimal solution is shown by the arrows above. There are 2 side jumps.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `obstacles.length == n + 1`\n* `1 <= n <= 5 * 105`\n* `0 <= obstacles[i] <= 3`\n* `obstacles[0] == obstacles[n] == 0`\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def minSideJumps(self, obstacles: List[int]) -> int:\n        n = len(obstacles)\n        dp = [[float('inf')] * 4 for _ in range(n + 1)]\n        dp[0][2] = 0\n        for i in range(n):\n            for j in range(4):\n                dp[i + 1][j] = min(dp[i + 1])\n                if obstacles[i] == j + 1:\n                    dp[i + 1][j] = float('inf')\n                elif j not in (obstacles[i], obstacles[i] - 1, obstacles[i] + 1):\n                    dp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + 1)\n        return min(dp[n])\n\n### Efficient Solution:\nclass Solution:\n    def minSideJumps(self, obstacles: List[int]) -> int:\n        n = len(obstacles)\n        f = [[inf] * 4 for _ in range(n + 1)]\n        f[0][2] = 0\n        for i, x in enumerate(obstacles, 1):\n            f[i] = [min(f[i - 1]) if x == 0 else inf] * 4\n            if x!= 1:\n                f[i][0] = f[i - 1][0]\n            if x!= 2:\n                f[i][1] = f[i - 1][1]\n            if x!= 3:\n                f[i][2] = f[i - 1][2]\n        return f[-1][2]\n",
    "model_solution": "class Solution:\n    def minSideJumps(self, obstacles: List[int]) -> int:\n        n = len(obstacles)\n        f = [[inf] * 4 for _ in range(n + 1)]\n        f[0][2] = 0\n        for i, x in enumerate(obstacles, 1):\n            f[i] = [min(f[i - 1]) if x == 0 else inf] * 4\n            if x!= 1:\n                f[i][0] = f[i - 1][0]\n            if x!= 2:\n                f[i][1] = f[i - 1][1]\n            if x!= 3:\n                f[i][2] = f[i - 1][2]\n        return f[-1][2]"
}