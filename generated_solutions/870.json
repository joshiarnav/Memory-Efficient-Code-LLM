{
    "problem_idx": "870",
    "description": "\nYou are given two integer arrays `nums1` and `nums2` both of the same length. The **advantage** of `nums1` with respect to `nums2` is the number of indices `i` for which `nums1[i] > nums2[i]`.\n\n\nReturn *any permutation of* `nums1` *that maximizes its **advantage** with respect to* `nums2`.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n**Input:** nums1 = [2,7,11,15], nums2 = [1,10,4,11]\n**Output:** [2,11,7,15]\n\n```\n**Example 2:**\n\n\n\n```\n**Input:** nums1 = [12,24,8,32], nums2 = [13,25,32,11]\n**Output:** [24,32,8,12]\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= nums1.length <= 105`\n* `nums2.length == nums1.length`\n* `0 <= nums1[i], nums2[i] <= 109`\n\n\n",
    "inefficient_solution": "class Solution:\n    def advantageCount(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        # Create a list of tuples where each tuple contains a number from nums2 and its index\n        num2_info = [(nums2[i], i) for i in range(len(nums2))]\n        \n        # Create a list of tuples where each tuple contains a number from nums1 and its index\n        num1_info = [(nums1[i], i) for i in range(len(nums1))]\n        \n        # Create a copy of the nums2 list and sort it\n        sorted_nums2 = sorted(nums2)\n        \n        # Create a copy of the nums1 list and sort it in descending order\n        sorted_nums1 = sorted(nums1, reverse=True)\n        \n        # Create a list to store the result\n        result = [0] * len(nums2)\n        \n        # Iterate over the sorted nums1 list\n        for v in sorted_nums1:\n            # Find the index of the smallest number in nums2 that is greater than v\n            idx = self.binary_search(sorted_nums2, v)\n            # If such an index is found, assign v to the corresponding index in the result list\n            if idx != -1:\n                result[num2_info[idx][1]] = v\n                # Remove the element at the found index from the sorted nums2 list\n                sorted_nums2.pop(idx)\n            # If no such index is found, assign v to the smallest number in nums2 that is greater than v\n            else:\n                result[num2_info[0][1]] = v\n                # Remove the smallest number from the sorted nums2 list\n                sorted_nums2.pop(0)\n        \n        return result\n    \n    def binary_search(self, arr, target):\n        left, right = 0, len(arr) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if arr[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        if left < len(arr):\n            return left\n        return -1",
    "efficient_solution": "class Solution:\n    def advantageCount(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        nums1.sort()\n        t = sorted((v, i) for i, v in enumerate(nums2))\n        n = len(nums2)\n        ans = [0] * n\n        i, j = 0, n - 1\n        for v in nums1:\n            if v <= t[i][0]:\n                ans[t[j][1]] = v\n                j -= 1\n            else:\n                ans[t[i][1]] = v\n                i += 1\n        return ans\n",
    "text": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nYou are given two integer arrays `nums1` and `nums2` both of the same length. The **advantage** of `nums1` with respect to `nums2` is the number of indices `i` for which `nums1[i] > nums2[i]`.\n\n\nReturn *any permutation of* `nums1` *that maximizes its **advantage** with respect to* `nums2`.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n**Input:** nums1 = [2,7,11,15], nums2 = [1,10,4,11]\n**Output:** [2,11,7,15]\n\n```\n**Example 2:**\n\n\n\n```\n**Input:** nums1 = [12,24,8,32], nums2 = [13,25,32,11]\n**Output:** [24,32,8,12]\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= nums1.length <= 105`\n* `nums2.length == nums1.length`\n* `0 <= nums1[i], nums2[i] <= 109`\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def advantageCount(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        # Create a list of tuples where each tuple contains a number from nums2 and its index\n        num2_info = [(nums2[i], i) for i in range(len(nums2))]\n        \n        # Create a list of tuples where each tuple contains a number from nums1 and its index\n        num1_info = [(nums1[i], i) for i in range(len(nums1))]\n        \n        # Create a copy of the nums2 list and sort it\n        sorted_nums2 = sorted(nums2)\n        \n        # Create a copy of the nums1 list and sort it in descending order\n        sorted_nums1 = sorted(nums1, reverse=True)\n        \n        # Create a list to store the result\n        result = [0] * len(nums2)\n        \n        # Iterate over the sorted nums1 list\n        for v in sorted_nums1:\n            # Find the index of the smallest number in nums2 that is greater than v\n            idx = self.binary_search(sorted_nums2, v)\n            # If such an index is found, assign v to the corresponding index in the result list\n            if idx != -1:\n                result[num2_info[idx][1]] = v\n                # Remove the element at the found index from the sorted nums2 list\n                sorted_nums2.pop(idx)\n            # If no such index is found, assign v to the smallest number in nums2 that is greater than v\n            else:\n                result[num2_info[0][1]] = v\n                # Remove the smallest number from the sorted nums2 list\n                sorted_nums2.pop(0)\n        \n        return result\n    \n    def binary_search(self, arr, target):\n        left, right = 0, len(arr) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if arr[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        if left < len(arr):\n            return left\n        return -1\n\n### Efficient Solution:\nclass Solution:\n    def advantageCount(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        nums1.sort()\n        t = sorted((v, i) for i, v in enumerate(nums2))\n        n = len(nums2)\n        ans = [0] * n\n        i, j = 0, n - 1\n        for v in nums1:\n            if v <= t[i][0]:\n                ans[t[j][1]] = v\n                j -= 1\n            else:\n                ans[t[i][1]] = v\n                i += 1\n        return ans\n<|eot_id|>",
    "model_generation": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nYou are given two integer arrays `nums1` and `nums2` both of the same length. The **advantage** of `nums1` with respect to `nums2` is the number of indices `i` for which `nums1[i] > nums2[i]`.\n\n\nReturn *any permutation of* `nums1` *that maximizes its **advantage** with respect to* `nums2`.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n**Input:** nums1 = [2,7,11,15], nums2 = [1,10,4,11]\n**Output:** [2,11,7,15]\n\n```\n**Example 2:**\n\n\n\n```\n**Input:** nums1 = [12,24,8,32], nums2 = [13,25,32,11]\n**Output:** [24,32,8,12]\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= nums1.length <= 105`\n* `nums2.length == nums1.length`\n* `0 <= nums1[i], nums2[i] <= 109`\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def advantageCount(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        # Create a list of tuples where each tuple contains a number from nums2 and its index\n        num2_info = [(nums2[i], i) for i in range(len(nums2))]\n        \n        # Create a list of tuples where each tuple contains a number from nums1 and its index\n        num1_info = [(nums1[i], i) for i in range(len(nums1))]\n        \n        # Create a copy of the nums2 list and sort it\n        sorted_nums2 = sorted(nums2)\n        \n        # Create a copy of the nums1 list and sort it in descending order\n        sorted_nums1 = sorted(nums1, reverse=True)\n        \n        # Create a list to store the result\n        result = [0] * len(nums2)\n        \n        # Iterate over the sorted nums1 list\n        for v in sorted_nums1:\n            # Find the index of the smallest number in nums2 that is greater than v\n            idx = self.binary_search(sorted_nums2, v)\n            # If such an index is found, assign v to the corresponding index in the result list\n            if idx!= -1:\n                result[num2_info[idx][1]] = v\n                # Remove the element at the found index from the sorted nums2 list\n                sorted_nums2.pop(idx)\n            # If no such index is found, assign v to the smallest number in nums2 that is greater than v\n            else:\n                result[num2_info[0][1]] = v\n                # Remove the smallest number from the sorted nums2 list\n                sorted_nums2.pop(0)\n        \n        return result\n    \n    def binary_search(self, arr, target):\n        left, right = 0, len(arr) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if arr[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        if left < len(arr):\n            return left\n        return -1\n\n### Efficient Solution:\nclass Solution:\n    def advantageCount(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        nums1.sort()\n        nums2.sort()\n        m, n = len(nums1), len(nums2)\n        ans = [0] * n\n        i = j = 0\n        while j < n:\n            if nums1[i] <= nums2[j]:\n                j += 1\n                if j < n:\n                    ans[nums2[j - 1]] = nums1[m - 1]\n                    m -= 1\n                else:\n                    break\n            else:\n                ans[nums2[j]] = nums1[i]\n                i += 1\n                j += 1\n        if i < m:\n            ans[nums2[n - 1]] = nums1[i:]\n        return ans\n",
    "model_solution": "class Solution:\n    def advantageCount(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        nums1.sort()\n        nums2.sort()\n        m, n = len(nums1), len(nums2)\n        ans = [0] * n\n        i = j = 0\n        while j < n:\n            if nums1[i] <= nums2[j]:\n                j += 1\n                if j < n:\n                    ans[nums2[j - 1]] = nums1[m - 1]\n                    m -= 1\n                else:\n                    break\n            else:\n                ans[nums2[j]] = nums1[i]\n                i += 1\n                j += 1\n        if i < m:\n            ans[nums2[n - 1]] = nums1[i:]\n        return ans"
}