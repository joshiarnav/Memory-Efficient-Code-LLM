{
    "problem_idx": "687",
    "description": "\nGiven the `root` of a binary tree, return *the length of the longest path, where each node in the path has the same value*. This path may or may not pass through the root.\n\n\n**The length of the path** between two nodes is represented by the number of edges between them.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0600-0699/0687.Longest%20Univalue%20Path/images/ex1.jpg)\n\n```\n\n**Input:** root = [5,4,5,1,1,null,5]\n**Output:** 2\n**Explanation:** The shown image shows that the longest path of the same value (i.e. 5).\n\n```\n\n**Example 2:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0600-0699/0687.Longest%20Univalue%20Path/images/ex2.jpg)\n\n```\n\n**Input:** root = [1,4,5,4,4,null,5]\n**Output:** 2\n**Explanation:** The shown image shows that the longest path of the same value (i.e. 4).\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* The number of nodes in the tree is in the range `[0, 104]`.\n* `-1000 <= Node.val <= 1000`\n* The depth of the tree will not exceed `1000`.\n\n\n",
    "inefficient_solution": "class Solution:\n    def longestUnivaluePath(self, root: TreeNode) -> int:\n        def dfs(root):\n            if root is None:\n                return\n            left = []\n            right = []\n            if root.left:\n                left_val = root.val\n                left_dfs = dfs(root.left)\n                left = [left_val] + left_dfs\n            if root.right:\n                right_val = root.val\n                right_dfs = dfs(root.right)\n                right = [right_val] + right_dfs\n            left_len = len(left)\n            right_len = len(right)\n            left = left_len * [root.val]\n            right = right_len * [root.val]\n            if root.left and root.left.val == root.val:\n                left = left + [root.val]\n            if root.right and root.right.val == root.val:\n                right = right + [root.val]\n            nonlocal ans\n            ans = max(ans, len(left), len(right))\n            return max(left, right)\n\n        ans = 0\n        dfs(root)\n        return ans",
    "efficient_solution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestUnivaluePath(self, root: TreeNode) -> int:\n        def dfs(root):\n            if root is None:\n                return 0\n            left, right = dfs(root.left), dfs(root.right)\n            left = left + 1 if root.left and root.left.val == root.val else 0\n            right = right + 1 if root.right and root.right.val == root.val else 0\n            nonlocal ans\n            ans = max(ans, left + right)\n            return max(left, right)\n\n        ans = 0\n        dfs(root)\n        return ans\n",
    "text": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nGiven the `root` of a binary tree, return *the length of the longest path, where each node in the path has the same value*. This path may or may not pass through the root.\n\n\n**The length of the path** between two nodes is represented by the number of edges between them.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0600-0699/0687.Longest%20Univalue%20Path/images/ex1.jpg)\n\n```\n\n**Input:** root = [5,4,5,1,1,null,5]\n**Output:** 2\n**Explanation:** The shown image shows that the longest path of the same value (i.e. 5).\n\n```\n\n**Example 2:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0600-0699/0687.Longest%20Univalue%20Path/images/ex2.jpg)\n\n```\n\n**Input:** root = [1,4,5,4,4,null,5]\n**Output:** 2\n**Explanation:** The shown image shows that the longest path of the same value (i.e. 4).\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* The number of nodes in the tree is in the range `[0, 104]`.\n* `-1000 <= Node.val <= 1000`\n* The depth of the tree will not exceed `1000`.\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def longestUnivaluePath(self, root: TreeNode) -> int:\n        def dfs(root):\n            if root is None:\n                return\n            left = []\n            right = []\n            if root.left:\n                left_val = root.val\n                left_dfs = dfs(root.left)\n                left = [left_val] + left_dfs\n            if root.right:\n                right_val = root.val\n                right_dfs = dfs(root.right)\n                right = [right_val] + right_dfs\n            left_len = len(left)\n            right_len = len(right)\n            left = left_len * [root.val]\n            right = right_len * [root.val]\n            if root.left and root.left.val == root.val:\n                left = left + [root.val]\n            if root.right and root.right.val == root.val:\n                right = right + [root.val]\n            nonlocal ans\n            ans = max(ans, len(left), len(right))\n            return max(left, right)\n\n        ans = 0\n        dfs(root)\n        return ans\n\n### Efficient Solution:\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestUnivaluePath(self, root: TreeNode) -> int:\n        def dfs(root):\n            if root is None:\n                return 0\n            left, right = dfs(root.left), dfs(root.right)\n            left = left + 1 if root.left and root.left.val == root.val else 0\n            right = right + 1 if root.right and root.right.val == root.val else 0\n            nonlocal ans\n            ans = max(ans, left + right)\n            return max(left, right)\n\n        ans = 0\n        dfs(root)\n        return ans\n<|eot_id|>",
    "model_generation": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nGiven the `root` of a binary tree, return *the length of the longest path, where each node in the path has the same value*. This path may or may not pass through the root.\n\n\n**The length of the path** between two nodes is represented by the number of edges between them.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0600-0699/0687.Longest%20Univalue%20Path/images/ex1.jpg)\n\n```\n\n**Input:** root = [5,4,5,1,1,null,5]\n**Output:** 2\n**Explanation:** The shown image shows that the longest path of the same value (i.e. 5).\n\n```\n\n**Example 2:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0600-0699/0687.Longest%20Univalue%20Path/images/ex2.jpg)\n\n```\n\n**Input:** root = [1,4,5,4,4,null,5]\n**Output:** 2\n**Explanation:** The shown image shows that the longest path of the same value (i.e. 4).\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* The number of nodes in the tree is in the range `[0, 104]`.\n* `-1000 <= Node.val <= 1000`\n* The depth of the tree will not exceed `1000`.\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def longestUnivaluePath(self, root: TreeNode) -> int:\n        def dfs(root):\n            if root is None:\n                return\n            left = []\n            right = []\n            if root.left:\n                left_val = root.val\n                left_dfs = dfs(root.left)\n                left = [left_val] + left_dfs\n            if root.right:\n                right_val = root.val\n                right_dfs = dfs(root.right)\n                right = [right_val] + right_dfs\n            left_len = len(left)\n            right_len = len(right)\n            left = left_len * [root.val]\n            right = right_len * [root.val]\n            if root.left and root.left.val == root.val:\n                left = left + [root.val]\n            if root.right and root.right.val == root.val:\n                right = right + [root.val]\n            nonlocal ans\n            ans = max(ans, len(left), len(right))\n            return max(left, right)\n\n        ans = 0\n        dfs(root)\n        return ans\n\n### Efficient Solution:\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestUnivaluePath(self, root: TreeNode) -> int:\n        def dfs(root):\n            if root is None:\n                return 0\n            l, r = dfs(root.left), dfs(root.right)\n            nonlocal ans\n            if root.left and root.left.val == root.val:\n                l += 1\n            else:\n                l = 0\n            if root.right and root.right.val == root.val:\n                r += 1\n            else:\n                r = 0\n            ans = max(ans, l + r)\n            return max(l, r)\n\n        ans = 0\n        dfs(root)\n        return ans\n",
    "model_solution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestUnivaluePath(self, root: TreeNode) -> int:\n        def dfs(root):\n            if root is None:\n                return 0\n            l, r = dfs(root.left), dfs(root.right)\n            nonlocal ans\n            if root.left and root.left.val == root.val:\n                l += 1\n            else:\n                l = 0\n            if root.right and root.right.val == root.val:\n                r += 1\n            else:\n                r = 0\n            ans = max(ans, l + r)\n            return max(l, r)\n\n        ans = 0\n        dfs(root)\n        return ans"
}