{
    "problem_idx": "666",
    "description": "\nIf the depth of a tree is smaller than `5`, then this tree can be represented by an array of three-digit integers. For each integer in this array:\n\n\n* The hundreds digit represents the depth `d` of this node where `1 <= d <= 4`.\n* The tens digit represents the position `p` of this node in the level it belongs to where `1 <= p <= 8`. The position is the same as that in a full binary tree.\n* The units digit represents the value `v` of this node where `0 <= v <= 9`.\n\n\nGiven an array of **ascending** three-digit integers `nums` representing a binary tree with a depth smaller than `5`, return *the sum of all paths from the root towards the leaves*.\n\n\nIt is **guaranteed** that the given array represents a valid connected binary tree.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0600-0699/0666.Path%20Sum%20IV/images/pathsum4-1-tree.jpg)\n\n```\n\n**Input:** nums = [113,215,221]\n**Output:** 12\n**Explanation:** The tree that the list represents is shown.\nThe path sum is (3 + 5) + (3 + 1) = 12.\n\n```\n\n**Example 2:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0600-0699/0666.Path%20Sum%20IV/images/pathsum4-2-tree.jpg)\n\n```\n\n**Input:** nums = [113,221]\n**Output:** 4\n**Explanation:** The tree that the list represents is shown. \nThe path sum is (3 + 1) = 4.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= nums.length <= 15`\n* `110 <= nums[i] <= 489`\n* `nums` represents a valid binary tree with depth less than `5`.\n\n\n",
    "inefficient_solution": "class Solution:\n    def pathSum(self, nums: List[int]) -> int:\n        mem = {}\n        mem[11] = {}\n        for num in nums:\n            mem[11][num % 10] = num % 10\n\n        def dfs(node, t, visited):\n            if node not in mem:\n                return\n            if node in visited:\n                return\n            visited.add(node)\n            t += mem[node]\n            d, p = divmod(node, 10)\n            l = (d + 1) * 10 + (p * 2) - 1\n            r = l + 1\n            ans = t\n            if l not in mem and r not in mem:\n                ans += t\n            if l in mem:\n                ans += dfs(l, t, visited)\n            if r in mem:\n                ans += dfs(r, t, visited)\n            return ans\n\n        ans = 0\n        for i in range(2, 15):\n            mem[i] = {}\n            for num in nums:\n                d, p = divmod(num, 10)\n                if d == i and p <= 8:\n                    mem[i][p] = num % 10\n        visited = set()\n        for i in range(2, 15):\n            ans += dfs(i, 0, visited)\n        return ans",
    "efficient_solution": "class Solution:\n    def pathSum(self, nums: List[int]) -> int:\n        def dfs(node, t):\n            if node not in mp:\n                return\n            t += mp[node]\n            d, p = divmod(node, 10)\n            l = (d + 1) * 10 + (p * 2) - 1\n            r = l + 1\n            nonlocal ans\n            if l not in mp and r not in mp:\n                ans += t\n                return\n            dfs(l, t)\n            dfs(r, t)\n\n        ans = 0\n        mp = {num // 10: num % 10 for num in nums}\n        dfs(11, 0)\n        return ans\n",
    "text": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nIf the depth of a tree is smaller than `5`, then this tree can be represented by an array of three-digit integers. For each integer in this array:\n\n\n* The hundreds digit represents the depth `d` of this node where `1 <= d <= 4`.\n* The tens digit represents the position `p` of this node in the level it belongs to where `1 <= p <= 8`. The position is the same as that in a full binary tree.\n* The units digit represents the value `v` of this node where `0 <= v <= 9`.\n\n\nGiven an array of **ascending** three-digit integers `nums` representing a binary tree with a depth smaller than `5`, return *the sum of all paths from the root towards the leaves*.\n\n\nIt is **guaranteed** that the given array represents a valid connected binary tree.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0600-0699/0666.Path%20Sum%20IV/images/pathsum4-1-tree.jpg)\n\n```\n\n**Input:** nums = [113,215,221]\n**Output:** 12\n**Explanation:** The tree that the list represents is shown.\nThe path sum is (3 + 5) + (3 + 1) = 12.\n\n```\n\n**Example 2:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0600-0699/0666.Path%20Sum%20IV/images/pathsum4-2-tree.jpg)\n\n```\n\n**Input:** nums = [113,221]\n**Output:** 4\n**Explanation:** The tree that the list represents is shown. \nThe path sum is (3 + 1) = 4.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= nums.length <= 15`\n* `110 <= nums[i] <= 489`\n* `nums` represents a valid binary tree with depth less than `5`.\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def pathSum(self, nums: List[int]) -> int:\n        mem = {}\n        mem[11] = {}\n        for num in nums:\n            mem[11][num % 10] = num % 10\n\n        def dfs(node, t, visited):\n            if node not in mem:\n                return\n            if node in visited:\n                return\n            visited.add(node)\n            t += mem[node]\n            d, p = divmod(node, 10)\n            l = (d + 1) * 10 + (p * 2) - 1\n            r = l + 1\n            ans = t\n            if l not in mem and r not in mem:\n                ans += t\n            if l in mem:\n                ans += dfs(l, t, visited)\n            if r in mem:\n                ans += dfs(r, t, visited)\n            return ans\n\n        ans = 0\n        for i in range(2, 15):\n            mem[i] = {}\n            for num in nums:\n                d, p = divmod(num, 10)\n                if d == i and p <= 8:\n                    mem[i][p] = num % 10\n        visited = set()\n        for i in range(2, 15):\n            ans += dfs(i, 0, visited)\n        return ans\n\n### Efficient Solution:\nclass Solution:\n    def pathSum(self, nums: List[int]) -> int:\n        def dfs(node, t):\n            if node not in mp:\n                return\n            t += mp[node]\n            d, p = divmod(node, 10)\n            l = (d + 1) * 10 + (p * 2) - 1\n            r = l + 1\n            nonlocal ans\n            if l not in mp and r not in mp:\n                ans += t\n                return\n            dfs(l, t)\n            dfs(r, t)\n\n        ans = 0\n        mp = {num // 10: num % 10 for num in nums}\n        dfs(11, 0)\n        return ans\n<|eot_id|>",
    "model_generation": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nIf the depth of a tree is smaller than `5`, then this tree can be represented by an array of three-digit integers. For each integer in this array:\n\n\n* The hundreds digit represents the depth `d` of this node where `1 <= d <= 4`.\n* The tens digit represents the position `p` of this node in the level it belongs to where `1 <= p <= 8`. The position is the same as that in a full binary tree.\n* The units digit represents the value `v` of this node where `0 <= v <= 9`.\n\n\nGiven an array of **ascending** three-digit integers `nums` representing a binary tree with a depth smaller than `5`, return *the sum of all paths from the root towards the leaves*.\n\n\nIt is **guaranteed** that the given array represents a valid connected binary tree.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0600-0699/0666.Path%20Sum%20IV/images/pathsum4-1-tree.jpg)\n\n```\n\n**Input:** nums = [113,215,221]\n**Output:** 12\n**Explanation:** The tree that the list represents is shown.\nThe path sum is (3 + 5) + (3 + 1) = 12.\n\n```\n\n**Example 2:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0600-0699/0666.Path%20Sum%20IV/images/pathsum4-2-tree.jpg)\n\n```\n\n**Input:** nums = [113,221]\n**Output:** 4\n**Explanation:** The tree that the list represents is shown. \nThe path sum is (3 + 1) = 4.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= nums.length <= 15`\n* `110 <= nums[i] <= 489`\n* `nums` represents a valid binary tree with depth less than `5`.\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def pathSum(self, nums: List[int]) -> int:\n        mem = {}\n        mem[11] = {}\n        for num in nums:\n            mem[11][num % 10] = num % 10\n\n        def dfs(node, t, visited):\n            if node not in mem:\n                return\n            if node in visited:\n                return\n            visited.add(node)\n            t += mem[node]\n            d, p = divmod(node, 10)\n            l = (d + 1) * 10 + (p * 2) - 1\n            r = l + 1\n            ans = t\n            if l not in mem and r not in mem:\n                ans += t\n            if l in mem:\n                ans += dfs(l, t, visited)\n            if r in mem:\n                ans += dfs(r, t, visited)\n            return ans\n\n        ans = 0\n        for i in range(2, 15):\n            mem[i] = {}\n            for num in nums:\n                d, p = divmod(num, 10)\n                if d == i and p <= 8:\n                    mem[i][p] = num % 10\n        visited = set()\n        for i in range(2, 15):\n            ans += dfs(i, 0, visited)\n        return ans\n\n### Efficient Solution:\nclass Solution:\n    def pathSum(self, nums: List[int]) -> int:\n        mem = defaultdict(int)\n        mem[11] = nums[0] % 10\n        for num in nums[1:]:\n            d, p, v = num // 100, (num // 10) % 10, num % 10\n            mem[d * 10 + p] = v\n        def dfs(node, t):\n            if node not in mem:\n                return\n            t += mem[node]\n            d, p = divmod(node, 10)\n            l = (d + 1) * 10 + (p * 2) - 1\n            r = l + 1\n            ans = t\n            if l in mem:\n                ans += dfs(l, t)\n            if r in mem:\n                ans += dfs(r, t)\n            return ans\n\n        return dfs(11, 0)\n",
    "model_solution": "class Solution:\n    def pathSum(self, nums: List[int]) -> int:\n        mem = defaultdict(int)\n        mem[11] = nums[0] % 10\n        for num in nums[1:]:\n            d, p, v = num // 100, (num // 10) % 10, num % 10\n            mem[d * 10 + p] = v\n        def dfs(node, t):\n            if node not in mem:\n                return\n            t += mem[node]\n            d, p = divmod(node, 10)\n            l = (d + 1) * 10 + (p * 2) - 1\n            r = l + 1\n            ans = t\n            if l in mem:\n                ans += dfs(l, t)\n            if r in mem:\n                ans += dfs(r, t)\n            return ans\n\n        return dfs(11, 0)"
}