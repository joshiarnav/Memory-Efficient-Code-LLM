{
    "problem_idx": "501",
    "description": "\nGiven the `root` of a binary search tree (BST) with duplicates, return *all the [mode(s)](https://en.wikipedia.org/wiki/Mode_(statistics)) (i.e., the most frequently occurred element) in it*.\n\n\nIf the tree has more than one mode, return them in **any order**.\n\n\nAssume a BST is defined as follows:\n\n\n* The left subtree of a node contains only nodes with keys **less than or equal to** the node's key.\n* The right subtree of a node contains only nodes with keys **greater than or equal to** the node's key.\n* Both the left and right subtrees must also be binary search trees.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0500-0599/0501.Find%20Mode%20in%20Binary%20Search%20Tree/images/mode-tree.jpg)\n\n```\n\n**Input:** root = [1,null,2,2]\n**Output:** [2]\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** root = [0]\n**Output:** [0]\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* The number of nodes in the tree is in the range `[1, 104]`.\n* `-105 <= Node.val <= 105`\n\n\n\u00a0\n\n\n**Follow up:** Could you do that without using any extra space? (Assume that the implicit stack space incurred due to recursion does not count).\n\n",
    "inefficient_solution": "",
    "efficient_solution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def findMode(self, root: TreeNode) -> List[int]:\n        def dfs(root):\n            if root is None:\n                return\n            nonlocal mx, prev, ans, cnt\n            dfs(root.left)\n            cnt = cnt + 1 if prev == root.val else 1\n            if cnt > mx:\n                ans = [root.val]\n                mx = cnt\n            elif cnt == mx:\n                ans.append(root.val)\n            prev = root.val\n            dfs(root.right)\n\n        prev = None\n        mx = cnt = 0\n        ans = []\n        dfs(root)\n        return ans\n",
    "text": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nGiven the `root` of a binary search tree (BST) with duplicates, return *all the [mode(s)](https://en.wikipedia.org/wiki/Mode_(statistics)) (i.e., the most frequently occurred element) in it*.\n\n\nIf the tree has more than one mode, return them in **any order**.\n\n\nAssume a BST is defined as follows:\n\n\n* The left subtree of a node contains only nodes with keys **less than or equal to** the node's key.\n* The right subtree of a node contains only nodes with keys **greater than or equal to** the node's key.\n* Both the left and right subtrees must also be binary search trees.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0500-0599/0501.Find%20Mode%20in%20Binary%20Search%20Tree/images/mode-tree.jpg)\n\n```\n\n**Input:** root = [1,null,2,2]\n**Output:** [2]\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** root = [0]\n**Output:** [0]\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* The number of nodes in the tree is in the range `[1, 104]`.\n* `-105 <= Node.val <= 105`\n\n\n\u00a0\n\n\n**Follow up:** Could you do that without using any extra space? (Assume that the implicit stack space incurred due to recursion does not count).\n\n\n\n### Inefficient Solution:\n\n\n### Efficient Solution:\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def findMode(self, root: TreeNode) -> List[int]:\n        def dfs(root):\n            if root is None:\n                return\n            nonlocal mx, prev, ans, cnt\n            dfs(root.left)\n            cnt = cnt + 1 if prev == root.val else 1\n            if cnt > mx:\n                ans = [root.val]\n                mx = cnt\n            elif cnt == mx:\n                ans.append(root.val)\n            prev = root.val\n            dfs(root.right)\n\n        prev = None\n        mx = cnt = 0\n        ans = []\n        dfs(root)\n        return ans\n<|eot_id|>",
    "model_generation": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nGiven the `root` of a binary search tree (BST) with duplicates, return *all the [mode(s)](https://en.wikipedia.org/wiki/Mode_(statistics)) (i.e., the most frequently occurred element) in it*.\n\n\nIf the tree has more than one mode, return them in **any order**.\n\n\nAssume a BST is defined as follows:\n\n\n* The left subtree of a node contains only nodes with keys **less than or equal to** the node's key.\n* The right subtree of a node contains only nodes with keys **greater than or equal to** the node's key.\n* Both the left and right subtrees must also be binary search trees.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0500-0599/0501.Find%20Mode%20in%20Binary%20Search%20Tree/images/mode-tree.jpg)\n\n```\n\n**Input:** root = [1,null,2,2]\n**Output:** [2]\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** root = [0]\n**Output:** [0]\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* The number of nodes in the tree is in the range `[1, 104]`.\n* `-105 <= Node.val <= 105`\n\n\n\u00a0\n\n\n**Follow up:** Could you do that without using any extra space? (Assume that the implicit stack space incurred due to recursion does not count).\n\n\n\n### Inefficient Solution:\n\n\n### Efficient Solution:\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def findMode(self, root: Optional[TreeNode]) -> List[int]:\n        cnt = Counter()\n        def dfs(root):\n            if root is None:\n                return\n            dfs(root.left)\n            cnt[root.val] += 1\n            dfs(root.right)\n\n        def dfs2(root):\n            if root is None:\n                return\n            nonlocal mx\n            if cnt[root.val] == mx:\n                ans.append(root.val)\n            dfs2(root.left)\n            dfs2(root.right)\n\n        mx = 0\n        dfs(root)\n        for v in cnt.values():\n            mx = max(mx, v)\n        ans = []\n        dfs2(root)\n        return ans\n",
    "model_solution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def findMode(self, root: Optional[TreeNode]) -> List[int]:\n        cnt = Counter()\n        def dfs(root):\n            if root is None:\n                return\n            dfs(root.left)\n            cnt[root.val] += 1\n            dfs(root.right)\n\n        def dfs2(root):\n            if root is None:\n                return\n            nonlocal mx\n            if cnt[root.val] == mx:\n                ans.append(root.val)\n            dfs2(root.left)\n            dfs2(root.right)\n\n        mx = 0\n        dfs(root)\n        for v in cnt.values():\n            mx = max(mx, v)\n        ans = []\n        dfs2(root)\n        return ans"
}