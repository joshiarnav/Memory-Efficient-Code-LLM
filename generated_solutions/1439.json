{
    "problem_idx": "1439",
    "description": "\nYou are given an `m x n` matrix `mat` that has its rows sorted in non-decreasing order and an integer `k`.\n\n\nYou are allowed to choose **exactly one element** from each row to form an array.\n\n\nReturn *the* `kth` *smallest array sum among all possible arrays*.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** mat = [[1,3,11],[2,4,6]], k = 5\n**Output:** 7\n**Explanation:** Choosing one element from each row, the first k smallest sum are:\n[1,2], [1,4], [3,2], [3,4], [1,6]. Where the 5th sum is 7.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** mat = [[1,3,11],[2,4,6]], k = 9\n**Output:** 17\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** mat = [[1,10,10],[1,4,5],[2,3,6]], k = 7\n**Output:** 9\n**Explanation:** Choosing one element from each row, the first k smallest sum are:\n[1,1,2], [1,1,3], [1,4,2], [1,4,3], [1,1,6], [1,5,2], [1,5,3]. Where the 7th sum is 9.  \n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `m == mat.length`\n* `n == mat.length[i]`\n* `1 <= m, n <= 40`\n* `1 <= mat[i][j] <= 5000`\n* `1 <= k <= min(200, nm)`\n* `mat[i]` is a non-decreasing array.\n\n\n",
    "inefficient_solution": "class Solution:\n    def kthSmallest(self, mat: List[List[int]], k: int) -> int:\n        n = len(mat)\n        arr = [list(map(tuple, zip(*row))) for row in mat]\n        pre = [[(0, 0) for _ in range(n)] for _ in range(n)]\n        pre[0][0] = (mat[0][0], 0)\n        for i in range(n):\n            for j in range(n):\n                pre[i][j] = sorted((a + b, i, j) for i, a in enumerate(pre[i]) for j, b in enumerate(arr[i][j]) if a + b <= 5000)[:k]\n        return pre[-1][-1][0]",
    "efficient_solution": "class Solution:\n    def kthSmallest(self, mat: List[List[int]], k: int) -> int:\n        pre = [0]\n        for cur in mat:\n            pre = sorted(a + b for a in pre for b in cur[:k])[:k]\n        return pre[-1]\n",
    "text": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nYou are given an `m x n` matrix `mat` that has its rows sorted in non-decreasing order and an integer `k`.\n\n\nYou are allowed to choose **exactly one element** from each row to form an array.\n\n\nReturn *the* `kth` *smallest array sum among all possible arrays*.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** mat = [[1,3,11],[2,4,6]], k = 5\n**Output:** 7\n**Explanation:** Choosing one element from each row, the first k smallest sum are:\n[1,2], [1,4], [3,2], [3,4], [1,6]. Where the 5th sum is 7.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** mat = [[1,3,11],[2,4,6]], k = 9\n**Output:** 17\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** mat = [[1,10,10],[1,4,5],[2,3,6]], k = 7\n**Output:** 9\n**Explanation:** Choosing one element from each row, the first k smallest sum are:\n[1,1,2], [1,1,3], [1,4,2], [1,4,3], [1,1,6], [1,5,2], [1,5,3]. Where the 7th sum is 9.  \n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `m == mat.length`\n* `n == mat.length[i]`\n* `1 <= m, n <= 40`\n* `1 <= mat[i][j] <= 5000`\n* `1 <= k <= min(200, nm)`\n* `mat[i]` is a non-decreasing array.\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def kthSmallest(self, mat: List[List[int]], k: int) -> int:\n        n = len(mat)\n        arr = [list(map(tuple, zip(*row))) for row in mat]\n        pre = [[(0, 0) for _ in range(n)] for _ in range(n)]\n        pre[0][0] = (mat[0][0], 0)\n        for i in range(n):\n            for j in range(n):\n                pre[i][j] = sorted((a + b, i, j) for i, a in enumerate(pre[i]) for j, b in enumerate(arr[i][j]) if a + b <= 5000)[:k]\n        return pre[-1][-1][0]\n\n### Efficient Solution:\nclass Solution:\n    def kthSmallest(self, mat: List[List[int]], k: int) -> int:\n        pre = [0]\n        for cur in mat:\n            pre = sorted(a + b for a in pre for b in cur[:k])[:k]\n        return pre[-1]\n<|eot_id|>",
    "model_generation": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nYou are given an `m x n` matrix `mat` that has its rows sorted in non-decreasing order and an integer `k`.\n\n\nYou are allowed to choose **exactly one element** from each row to form an array.\n\n\nReturn *the* `kth` *smallest array sum among all possible arrays*.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** mat = [[1,3,11],[2,4,6]], k = 5\n**Output:** 7\n**Explanation:** Choosing one element from each row, the first k smallest sum are:\n[1,2], [1,4], [3,2], [3,4], [1,6]. Where the 5th sum is 7.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** mat = [[1,3,11],[2,4,6]], k = 9\n**Output:** 17\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** mat = [[1,10,10],[1,4,5],[2,3,6]], k = 7\n**Output:** 9\n**Explanation:** Choosing one element from each row, the first k smallest sum are:\n[1,1,2], [1,1,3], [1,4,2], [1,4,3], [1,1,6], [1,5,2], [1,5,3]. Where the 7th sum is 9.  \n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `m == mat.length`\n* `n == mat.length[i]`\n* `1 <= m, n <= 40`\n* `1 <= mat[i][j] <= 5000`\n* `1 <= k <= min(200, nm)`\n* `mat[i]` is a non-decreasing array.\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def kthSmallest(self, mat: List[List[int]], k: int) -> int:\n        n = len(mat)\n        arr = [list(map(tuple, zip(*row))) for row in mat]\n        pre = [[(0, 0) for _ in range(n)] for _ in range(n)]\n        pre[0][0] = (mat[0][0], 0)\n        for i in range(n):\n            for j in range(n):\n                pre[i][j] = sorted((a + b, i, j) for i, a in enumerate(pre[i]) for j, b in enumerate(arr[i][j]) if a + b <= 5000)[:k]\n        return pre[-1][-1][0]\n\n### Efficient Solution:\nclass Solution:\n    def kthSmallest(self, mat: List[List[int]], k: int) -> int:\n        def check(x):\n            co = 0\n            for i in range(n):\n                s = 0\n                for j in range(n):\n                    if arr[i][j] <= x:\n                        s += arr[i][j]\n                co += bisect_left(arr[i], x + 1)\n                if s >= x * co:\n                    break\n            return co >= k\n\n        n = len(mat)\n        arr = [sorted(row) for row in mat]\n        left, right = mat[0][0], mat[-1][-1]\n        while left < right:\n            mid = (left + right) >> 1\n            if check(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left\n",
    "model_solution": "class Solution:\n    def kthSmallest(self, mat: List[List[int]], k: int) -> int:\n        def check(x):\n            co = 0\n            for i in range(n):\n                s = 0\n                for j in range(n):\n                    if arr[i][j] <= x:\n                        s += arr[i][j]\n                co += bisect_left(arr[i], x + 1)\n                if s >= x * co:\n                    break\n            return co >= k\n\n        n = len(mat)\n        arr = [sorted(row) for row in mat]\n        left, right = mat[0][0], mat[-1][-1]\n        while left < right:\n            mid = (left + right) >> 1\n            if check(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left"
}