{
    "problem_idx": "144",
    "description": "\nGiven the `root` of a binary tree, return *the preorder traversal of its nodes' values*.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0144.Binary%20Tree%20Preorder%20Traversal/images/inorder_1.jpg)\n\n```\n\n**Input:** root = [1,null,2,3]\n**Output:** [1,2,3]\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** root = []\n**Output:** []\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** root = [1]\n**Output:** [1]\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* The number of nodes in the tree is in the range `[0, 100]`.\n* `-100 <= Node.val <= 100`\n\n\n\u00a0\n\n\n**Follow up:** Recursive solution is trivial, could you do it iteratively?\n\n\n",
    "inefficient_solution": "class Solution:\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        if not root:\n            return []\n        \n        nodes = [root]\n        visited = set()\n        ans = []\n        i = 0\n        while i < len(nodes):\n            node = nodes[i]\n            if node not in visited:\n                visited.add(node)\n                ans.append(node.val)\n                if node.left:\n                    nodes.append(node.left)\n                if node.right:\n                    nodes.append(node.right)\n            i += 1\n        return ans",
    "efficient_solution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        ans = []\n        while root:\n            if root.left is None:\n                ans.append(root.val)\n                root = root.right\n            else:\n                prev = root.left\n                while prev.right and prev.right != root:\n                    prev = prev.right\n                if prev.right is None:\n                    ans.append(root.val)\n                    prev.right = root\n                    root = root.left\n                else:\n                    prev.right = None\n                    root = root.right\n        return ans\n",
    "text": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nGiven the `root` of a binary tree, return *the preorder traversal of its nodes' values*.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0144.Binary%20Tree%20Preorder%20Traversal/images/inorder_1.jpg)\n\n```\n\n**Input:** root = [1,null,2,3]\n**Output:** [1,2,3]\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** root = []\n**Output:** []\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** root = [1]\n**Output:** [1]\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* The number of nodes in the tree is in the range `[0, 100]`.\n* `-100 <= Node.val <= 100`\n\n\n\u00a0\n\n\n**Follow up:** Recursive solution is trivial, could you do it iteratively?\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        if not root:\n            return []\n        \n        nodes = [root]\n        visited = set()\n        ans = []\n        i = 0\n        while i < len(nodes):\n            node = nodes[i]\n            if node not in visited:\n                visited.add(node)\n                ans.append(node.val)\n                if node.left:\n                    nodes.append(node.left)\n                if node.right:\n                    nodes.append(node.right)\n            i += 1\n        return ans\n\n### Efficient Solution:\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        ans = []\n        while root:\n            if root.left is None:\n                ans.append(root.val)\n                root = root.right\n            else:\n                prev = root.left\n                while prev.right and prev.right != root:\n                    prev = prev.right\n                if prev.right is None:\n                    ans.append(root.val)\n                    prev.right = root\n                    root = root.left\n                else:\n                    prev.right = None\n                    root = root.right\n        return ans\n<|eot_id|>",
    "model_generation": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nGiven the `root` of a binary tree, return *the preorder traversal of its nodes' values*.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0100-0199/0144.Binary%20Tree%20Preorder%20Traversal/images/inorder_1.jpg)\n\n```\n\n**Input:** root = [1,null,2,3]\n**Output:** [1,2,3]\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** root = []\n**Output:** []\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** root = [1]\n**Output:** [1]\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* The number of nodes in the tree is in the range `[0, 100]`.\n* `-100 <= Node.val <= 100`\n\n\n\u00a0\n\n\n**Follow up:** Recursive solution is trivial, could you do it iteratively?\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        if not root:\n            return []\n        \n        nodes = [root]\n        visited = set()\n        ans = []\n        i = 0\n        while i < len(nodes):\n            node = nodes[i]\n            if node not in visited:\n                visited.add(node)\n                ans.append(node.val)\n                if node.left:\n                    nodes.append(node.left)\n                if node.right:\n                    nodes.append(node.right)\n            i += 1\n        return ans\n\n### Efficient Solution:\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        def dfs(root):\n            if root:\n                ans.append(root.val)\n                dfs(root.left)\n                dfs(root.right)\n\n        ans = []\n        dfs(root)\n        return ans\n",
    "model_solution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        def dfs(root):\n            if root:\n                ans.append(root.val)\n                dfs(root.left)\n                dfs(root.right)\n\n        ans = []\n        dfs(root)\n        return ans"
}