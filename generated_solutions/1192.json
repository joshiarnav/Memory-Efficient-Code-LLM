{
    "problem_idx": "1192",
    "description": "\nThere are `n` servers numbered from `0` to `n - 1` connected by undirected server-to-server `connections` forming a network where `connections[i] = [ai, bi]` represents a connection between servers `ai` and `bi`. Any server can reach other servers directly or indirectly through the network.\n\n\nA *critical connection* is a connection that, if removed, will make some servers unable to reach some other server.\n\n\nReturn all critical connections in the network in any order.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1100-1199/1192.Critical%20Connections%20in%20a%20Network/images/1537_ex1_2.png)\n\n```\n\n**Input:** n = 4, connections = [[0,1],[1,2],[2,0],[1,3]]\n**Output:** [[1,3]]\n**Explanation:** [[3,1]] is also accepted.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** n = 2, connections = [[0,1]]\n**Output:** [[0,1]]\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `2 <= n <= 105`\n* `n - 1 <= connections.length <= 105`\n* `0 <= ai, bi <= n - 1`\n* `ai != bi`\n* There are no repeated connections.\n\n\n",
    "inefficient_solution": "class Solution:\n    def criticalConnections(\n        self, n: int, connections: List[List[int]]\n    ) -> List[List[int]]:\n        def tarjan(a: int, fa: int):\n            nonlocal now\n            now += 1\n            dfn = [0] * n\n            dfn[a] = low = [0] * n\n            low[a] = now\n            for b in g[a]:\n                if b == fa:\n                    continue\n                g_copy = g.copy()\n                g_copy[a].remove(b)\n                g_copy[b].remove(a)\n                dfn_copy = dfn.copy()\n                tarjan(b, a)\n                if dfn_copy[b] > low[a]:\n                    ans.append([a, b])\n                else:\n                    low[a] = min(low[a], low[b])\n\n        g = [[] for _ in range(n)]\n        for a, b in connections:\n            g[a].append(b)\n            g[b].append(a)\n\n        ans = []\n        now = 0\n        tarjan(0, -1)\n        return ans",
    "efficient_solution": "class Solution:\n    def criticalConnections(\n        self, n: int, connections: List[List[int]]\n    ) -> List[List[int]]:\n        def tarjan(a: int, fa: int):\n            nonlocal now\n            now += 1\n            dfn[a] = low[a] = now\n            for b in g[a]:\n                if b == fa:\n                    continue\n                if not dfn[b]:\n                    tarjan(b, a)\n                    low[a] = min(low[a], low[b])\n                    if low[b] > dfn[a]:\n                        ans.append([a, b])\n                else:\n                    low[a] = min(low[a], dfn[b])\n\n        g = [[] for _ in range(n)]\n        for a, b in connections:\n            g[a].append(b)\n            g[b].append(a)\n\n        dfn = [0] * n\n        low = [0] * n\n        now = 0\n        ans = []\n        tarjan(0, -1)\n        return ans\n",
    "text": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nThere are `n` servers numbered from `0` to `n - 1` connected by undirected server-to-server `connections` forming a network where `connections[i] = [ai, bi]` represents a connection between servers `ai` and `bi`. Any server can reach other servers directly or indirectly through the network.\n\n\nA *critical connection* is a connection that, if removed, will make some servers unable to reach some other server.\n\n\nReturn all critical connections in the network in any order.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1100-1199/1192.Critical%20Connections%20in%20a%20Network/images/1537_ex1_2.png)\n\n```\n\n**Input:** n = 4, connections = [[0,1],[1,2],[2,0],[1,3]]\n**Output:** [[1,3]]\n**Explanation:** [[3,1]] is also accepted.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** n = 2, connections = [[0,1]]\n**Output:** [[0,1]]\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `2 <= n <= 105`\n* `n - 1 <= connections.length <= 105`\n* `0 <= ai, bi <= n - 1`\n* `ai != bi`\n* There are no repeated connections.\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def criticalConnections(\n        self, n: int, connections: List[List[int]]\n    ) -> List[List[int]]:\n        def tarjan(a: int, fa: int):\n            nonlocal now\n            now += 1\n            dfn = [0] * n\n            dfn[a] = low = [0] * n\n            low[a] = now\n            for b in g[a]:\n                if b == fa:\n                    continue\n                g_copy = g.copy()\n                g_copy[a].remove(b)\n                g_copy[b].remove(a)\n                dfn_copy = dfn.copy()\n                tarjan(b, a)\n                if dfn_copy[b] > low[a]:\n                    ans.append([a, b])\n                else:\n                    low[a] = min(low[a], low[b])\n\n        g = [[] for _ in range(n)]\n        for a, b in connections:\n            g[a].append(b)\n            g[b].append(a)\n\n        ans = []\n        now = 0\n        tarjan(0, -1)\n        return ans\n\n### Efficient Solution:\nclass Solution:\n    def criticalConnections(\n        self, n: int, connections: List[List[int]]\n    ) -> List[List[int]]:\n        def tarjan(a: int, fa: int):\n            nonlocal now\n            now += 1\n            dfn[a] = low[a] = now\n            for b in g[a]:\n                if b == fa:\n                    continue\n                if not dfn[b]:\n                    tarjan(b, a)\n                    low[a] = min(low[a], low[b])\n                    if low[b] > dfn[a]:\n                        ans.append([a, b])\n                else:\n                    low[a] = min(low[a], dfn[b])\n\n        g = [[] for _ in range(n)]\n        for a, b in connections:\n            g[a].append(b)\n            g[b].append(a)\n\n        dfn = [0] * n\n        low = [0] * n\n        now = 0\n        ans = []\n        tarjan(0, -1)\n        return ans\n<|eot_id|>",
    "model_generation": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nThere are `n` servers numbered from `0` to `n - 1` connected by undirected server-to-server `connections` forming a network where `connections[i] = [ai, bi]` represents a connection between servers `ai` and `bi`. Any server can reach other servers directly or indirectly through the network.\n\n\nA *critical connection* is a connection that, if removed, will make some servers unable to reach some other server.\n\n\nReturn all critical connections in the network in any order.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1100-1199/1192.Critical%20Connections%20in%20a%20Network/images/1537_ex1_2.png)\n\n```\n\n**Input:** n = 4, connections = [[0,1],[1,2],[2,0],[1,3]]\n**Output:** [[1,3]]\n**Explanation:** [[3,1]] is also accepted.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** n = 2, connections = [[0,1]]\n**Output:** [[0,1]]\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `2 <= n <= 105`\n* `n - 1 <= connections.length <= 105`\n* `0 <= ai, bi <= n - 1`\n* `ai!= bi`\n* There are no repeated connections.\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def criticalConnections(\n        self, n: int, connections: List[List[int]]\n    ) -> List[List[int]]:\n        def tarjan(a: int, fa: int):\n            nonlocal now\n            now += 1\n            dfn = [0] * n\n            dfn[a] = low = [0] * n\n            low[a] = now\n            for b in g[a]:\n                if b == fa:\n                    continue\n                g_copy = g.copy()\n                g_copy[a].remove(b)\n                g_copy[b].remove(a)\n                dfn_copy = dfn.copy()\n                tarjan(b, a)\n                if dfn_copy[b] > low[a]:\n                    ans.append([a, b])\n                else:\n                    low[a] = min(low[a], low[b])\n\n        g = [[] for _ in range(n)]\n        for a, b in connections:\n            g[a].append(b)\n            g[b].append(a)\n\n        ans = []\n        now = 0\n        tarjan(0, -1)\n        return ans\n\n### Efficient Solution:\nclass Solution:\n    def criticalConnections(\n        self, n: int, connections: List[List[int]]\n    ) -> List[List[int]]:\n        def tarjan(a: int, fa: int):\n            nonlocal now\n            now += 1\n            dfn[a] = low[a] = now\n            for b in g[a]:\n                if b == fa:\n                    continue\n                tarjan(b, a)\n                low[a] = min(low[a], low[b])\n                if low[b] > dfn[a]:\n                    ans.append([a, b])\n\n        g = defaultdict(list)\n        for a, b in connections:\n            g[a].append(b)\n            g[b].append(a)\n        dfn = [0] * n\n        low = [0] * n\n        ans = []\n        now = 0\n        tarjan(0, -1)\n        return ans\n",
    "model_solution": "class Solution:\n    def criticalConnections(\n        self, n: int, connections: List[List[int]]\n    ) -> List[List[int]]:\n        def tarjan(a: int, fa: int):\n            nonlocal now\n            now += 1\n            dfn[a] = low[a] = now\n            for b in g[a]:\n                if b == fa:\n                    continue\n                tarjan(b, a)\n                low[a] = min(low[a], low[b])\n                if low[b] > dfn[a]:\n                    ans.append([a, b])\n\n        g = defaultdict(list)\n        for a, b in connections:\n            g[a].append(b)\n            g[b].append(a)\n        dfn = [0] * n\n        low = [0] * n\n        ans = []\n        now = 0\n        tarjan(0, -1)\n        return ans"
}