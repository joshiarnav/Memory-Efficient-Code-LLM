{
    "problem_idx": "971",
    "description": "\nYou are given the `root` of a binary tree with `n` nodes, where each node is uniquely assigned a value from `1` to `n`. You are also given a sequence of `n` values `voyage`, which is the **desired** [**pre-order traversal**](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order) of the binary tree.\n\n\nAny node in the binary tree can be **flipped** by swapping its left and right subtrees. For example, flipping node 1 will have the following effect:\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0900-0999/0971.Flip%20Binary%20Tree%20To%20Match%20Preorder%20Traversal/images/fliptree.jpg)\nFlip the **smallest** number of nodes so that the **pre-order traversal** of the tree **matches** `voyage`.\n\n\nReturn *a list of the values of all **flipped** nodes. You may return the answer in **any order**. If it is **impossible** to flip the nodes in the tree to make the pre-order traversal match* `voyage`*, return the list* `[-1]`.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0900-0999/0971.Flip%20Binary%20Tree%20To%20Match%20Preorder%20Traversal/images/1219-01.png)\n\n```\n\n**Input:** root = [1,2], voyage = [2,1]\n**Output:** [-1]\n**Explanation:** It is impossible to flip the nodes such that the pre-order traversal matches voyage.\n\n```\n\n**Example 2:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0900-0999/0971.Flip%20Binary%20Tree%20To%20Match%20Preorder%20Traversal/images/1219-02.png)\n\n```\n\n**Input:** root = [1,2,3], voyage = [1,3,2]\n**Output:** [1]\n**Explanation:** Flipping node 1 swaps nodes 2 and 3, so the pre-order traversal matches voyage.\n```\n\n**Example 3:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0900-0999/0971.Flip%20Binary%20Tree%20To%20Match%20Preorder%20Traversal/images/1219-02.png)\n\n```\n\n**Input:** root = [1,2,3], voyage = [1,2,3]\n**Output:** []\n**Explanation:** The tree's pre-order traversal already matches voyage, so no nodes need to be flipped.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* The number of nodes in the tree is `n`.\n* `n == voyage.length`\n* `1 <= n <= 100`\n* `1 <= Node.val, voyage[i] <= n`\n* All the values in the tree are **unique**.\n* All the values in `voyage` are **unique**.\n\n\n",
    "inefficient_solution": "class Solution:\n    def flipMatchVoyage(self, root: Optional[TreeNode], voyage: List[int]) -> List[int]:\n        self.ans = []\n        self.i = 0\n        self.ok = True\n        self.voyage = voyage\n        self.dfs(root)\n        return self.ans if self.ok else [-1]\n\n    def dfs(self, root):\n        if root is None:\n            return\n        self.dfs(root.left)\n        if root.val != self.voyage[self.i]:\n            self.ok = False\n            return\n        self.i += 1\n        if root.right is not None and root.right.val != self.voyage[self.i]:\n            self.ans.append(root.val)\n            self.i += 1\n        self.dfs(root.right)\n        self.dfs(root.left)",
    "efficient_solution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def flipMatchVoyage(self, root: Optional[TreeNode], voyage: List[int]) -> List[int]:\n        def dfs(root):\n            nonlocal i, ok\n            if root is None or not ok:\n                return\n            if root.val != voyage[i]:\n                ok = False\n                return\n            i += 1\n            if root.left is None or root.left.val == voyage[i]:\n                dfs(root.left)\n                dfs(root.right)\n            else:\n                ans.append(root.val)\n                dfs(root.right)\n                dfs(root.left)\n\n        ans = []\n        i = 0\n        ok = True\n        dfs(root)\n        return ans if ok else [-1]\n",
    "text": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nYou are given the `root` of a binary tree with `n` nodes, where each node is uniquely assigned a value from `1` to `n`. You are also given a sequence of `n` values `voyage`, which is the **desired** [**pre-order traversal**](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order) of the binary tree.\n\n\nAny node in the binary tree can be **flipped** by swapping its left and right subtrees. For example, flipping node 1 will have the following effect:\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0900-0999/0971.Flip%20Binary%20Tree%20To%20Match%20Preorder%20Traversal/images/fliptree.jpg)\nFlip the **smallest** number of nodes so that the **pre-order traversal** of the tree **matches** `voyage`.\n\n\nReturn *a list of the values of all **flipped** nodes. You may return the answer in **any order**. If it is **impossible** to flip the nodes in the tree to make the pre-order traversal match* `voyage`*, return the list* `[-1]`.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0900-0999/0971.Flip%20Binary%20Tree%20To%20Match%20Preorder%20Traversal/images/1219-01.png)\n\n```\n\n**Input:** root = [1,2], voyage = [2,1]\n**Output:** [-1]\n**Explanation:** It is impossible to flip the nodes such that the pre-order traversal matches voyage.\n\n```\n\n**Example 2:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0900-0999/0971.Flip%20Binary%20Tree%20To%20Match%20Preorder%20Traversal/images/1219-02.png)\n\n```\n\n**Input:** root = [1,2,3], voyage = [1,3,2]\n**Output:** [1]\n**Explanation:** Flipping node 1 swaps nodes 2 and 3, so the pre-order traversal matches voyage.\n```\n\n**Example 3:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0900-0999/0971.Flip%20Binary%20Tree%20To%20Match%20Preorder%20Traversal/images/1219-02.png)\n\n```\n\n**Input:** root = [1,2,3], voyage = [1,2,3]\n**Output:** []\n**Explanation:** The tree's pre-order traversal already matches voyage, so no nodes need to be flipped.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* The number of nodes in the tree is `n`.\n* `n == voyage.length`\n* `1 <= n <= 100`\n* `1 <= Node.val, voyage[i] <= n`\n* All the values in the tree are **unique**.\n* All the values in `voyage` are **unique**.\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def flipMatchVoyage(self, root: Optional[TreeNode], voyage: List[int]) -> List[int]:\n        self.ans = []\n        self.i = 0\n        self.ok = True\n        self.voyage = voyage\n        self.dfs(root)\n        return self.ans if self.ok else [-1]\n\n    def dfs(self, root):\n        if root is None:\n            return\n        self.dfs(root.left)\n        if root.val != self.voyage[self.i]:\n            self.ok = False\n            return\n        self.i += 1\n        if root.right is not None and root.right.val != self.voyage[self.i]:\n            self.ans.append(root.val)\n            self.i += 1\n        self.dfs(root.right)\n        self.dfs(root.left)\n\n### Efficient Solution:\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def flipMatchVoyage(self, root: Optional[TreeNode], voyage: List[int]) -> List[int]:\n        def dfs(root):\n            nonlocal i, ok\n            if root is None or not ok:\n                return\n            if root.val != voyage[i]:\n                ok = False\n                return\n            i += 1\n            if root.left is None or root.left.val == voyage[i]:\n                dfs(root.left)\n                dfs(root.right)\n            else:\n                ans.append(root.val)\n                dfs(root.right)\n                dfs(root.left)\n\n        ans = []\n        i = 0\n        ok = True\n        dfs(root)\n        return ans if ok else [-1]\n<|eot_id|>",
    "model_generation": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nYou are given the `root` of a binary tree with `n` nodes, where each node is uniquely assigned a value from `1` to `n`. You are also given a sequence of `n` values `voyage`, which is the **desired** [**pre-order traversal**](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order) of the binary tree.\n\n\nAny node in the binary tree can be **flipped** by swapping its left and right subtrees. For example, flipping node 1 will have the following effect:\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0900-0999/0971.Flip%20Binary%20Tree%20To%20Match%20Preorder%20Traversal/images/fliptree.jpg)\nFlip the **smallest** number of nodes so that the **pre-order traversal** of the tree **matches** `voyage`.\n\n\nReturn *a list of the values of all **flipped** nodes. You may return the answer in **any order**. If it is **impossible** to flip the nodes in the tree to make the pre-order traversal match* `voyage`*, return the list* `[-1]`.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0900-0999/0971.Flip%20Binary%20Tree%20To%20Match%20Preorder%20Traversal/images/1219-01.png)\n\n```\n\n**Input:** root = [1,2], voyage = [2,1]\n**Output:** [-1]\n**Explanation:** It is impossible to flip the nodes such that the pre-order traversal matches voyage.\n\n```\n\n**Example 2:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0900-0999/0971.Flip%20Binary%20Tree%20To%20Match%20Preorder%20Traversal/images/1219-02.png)\n\n```\n\n**Input:** root = [1,2,3], voyage = [1,3,2]\n**Output:** [1]\n**Explanation:** Flipping node 1 swaps nodes 2 and 3, so the pre-order traversal matches voyage.\n```\n\n**Example 3:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0900-0999/0971.Flip%20Binary%20Tree%20To%20Match%20Preorder%20Traversal/images/1219-02.png)\n\n```\n\n**Input:** root = [1,2,3], voyage = [1,2,3]\n**Output:** []\n**Explanation:** The tree's pre-order traversal already matches voyage, so no nodes need to be flipped.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* The number of nodes in the tree is `n`.\n* `n == voyage.length`\n* `1 <= n <= 100`\n* `1 <= Node.val, voyage[i] <= n`\n* All the values in the tree are **unique**.\n* All the values in `voyage` are **unique**.\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def flipMatchVoyage(self, root: Optional[TreeNode], voyage: List[int]) -> List[int]:\n        self.ans = []\n        self.i = 0\n        self.ok = True\n        self.voyage = voyage\n        self.dfs(root)\n        return self.ans if self.ok else [-1]\n\n    def dfs(self, root):\n        if root is None:\n            return\n        self.dfs(root.left)\n        if root.val!= self.voyage[self.i]:\n            self.ok = False\n            return\n        self.i += 1\n        if root.right is not None and root.right.val!= self.voyage[self.i]:\n            self.ans.append(root.val)\n            self.i += 1\n        self.dfs(root.right)\n        self.dfs(root.left)\n\n### Efficient Solution:\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def flipMatchVoyage(self, root: Optional[TreeNode], voyage: List[int]) -> List[int]:\n        self.ans = []\n        self.i = 0\n        self.ok = True\n        self.voyage = voyage\n        self.dfs(root)\n        return self.ans if self.ok else [-1]\n\n    def dfs(self, root):\n        if root is None:\n            return\n        if root.left and root.left.val!= self.voyage[self.i]:\n            self.ok = False\n            return\n        if root.val!= self.voyage[self.i]:\n            self.ok = False\n            return\n        self.i += 1\n        if root.right and root.right.val!= self.voyage[self.i]:\n            self.ans.append(root.val)\n            self.i += 1\n        if root.left:\n            self.dfs(root.left)\n        if root.right:\n            self.dfs(root.right)\n        if root.right and root.left:\n            self.ans.append(root.val)\n            self.i += 1\n",
    "model_solution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def flipMatchVoyage(self, root: Optional[TreeNode], voyage: List[int]) -> List[int]:\n        self.ans = []\n        self.i = 0\n        self.ok = True\n        self.voyage = voyage\n        self.dfs(root)\n        return self.ans if self.ok else [-1]\n\n    def dfs(self, root):\n        if root is None:\n            return\n        if root.left and root.left.val!= self.voyage[self.i]:\n            self.ok = False\n            return\n        if root.val!= self.voyage[self.i]:\n            self.ok = False\n            return\n        self.i += 1\n        if root.right and root.right.val!= self.voyage[self.i]:\n            self.ans.append(root.val)\n            self.i += 1\n        if root.left:\n            self.dfs(root.left)\n        if root.right:\n            self.dfs(root.right)\n        if root.right and root.left:\n            self.ans.append(root.val)\n            self.i += 1"
}