{
    "problem_idx": "1203",
    "description": "\nThere are\u00a0`n`\u00a0items each\u00a0belonging to zero or one of\u00a0`m`\u00a0groups where `group[i]`\u00a0is the group that the `i`-th item belongs to and it's equal to `-1`\u00a0if the `i`-th item belongs to no group. The items and the groups are zero indexed. A group can have no item belonging to it.\n\n\nReturn a sorted list of the items such that:\n\n\n* The items that belong to the same group are next to each other in the sorted list.\n* There are some\u00a0relations\u00a0between these items where\u00a0`beforeItems[i]`\u00a0is a list containing all the items that should come before the\u00a0`i`-th item in the sorted array (to the left of the\u00a0`i`-th item).\n\n\nReturn any solution if there is more than one solution and return an **empty list**\u00a0if there is no solution.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n**![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1200-1299/1203.Sort%20Items%20by%20Groups%20Respecting%20Dependencies/images/1359_ex1.png)**\n\n\n\n```\n\n**Input:** n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3,6],[],[],[]]\n**Output:** [6,3,4,1,5,2,0,7]\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3],[],[4],[]]\n**Output:** []\n**Explanation:**\u00a0This is the same as example 1 except that 4 needs to be before 6 in the sorted list.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= m <= n <= 3 * 104`\n* `group.length == beforeItems.length == n`\n* `-1 <= group[i] <= m - 1`\n* `0 <= beforeItems[i].length <= n - 1`\n* `0 <= beforeItems[i][j] <= n - 1`\n* `i != beforeItems[i][j]`\n* `beforeItems[i]`does not contain\u00a0duplicates elements.\n\n\n",
    "inefficient_solution": "class Solution:\n    def sortItems(\n        self, n: int, m: int, group: List[int], beforeItems: List[List[int]]\n    ) -> List[int]:\n        idx = m\n        group_items = [[] for _ in range(n + m)]\n        for i, g in enumerate(group):\n            if g == -1:\n                group[i] = idx\n                idx += 1\n            group_items[group[i]].append(i)\n\n        item_degree = [0] * n\n        group_degree = [0] * (n + m)\n        item_graph = [[] for _ in range(n)]\n        group_graph = [[] for _ in range(n + m)]\n        for i, gi in enumerate(group):\n            for j in beforeItems[i]:\n                gj = group[j]\n                if gi == gj:\n                    item_degree[i] += 1\n                    item_graph[j].append(i)\n                else:\n                    group_degree[gi] += 1\n                    group_graph[gj].append(gi)\n\n        group_order = self.topo_sort(group_degree, group_graph, range(n + m), n + m)\n        if not group_order:\n            return []\n        ans = []\n        for gi in group_order:\n            items = group_items[gi]\n            item_order = self.topo_sort(item_degree, item_graph, items, n)\n            if len(items) != len(item_order):\n                return []\n            ans.extend(item_order)\n        return ans\n\n    def topo_sort(self, degree, graph, items, max_item):\n        q = deque(i for _, i in enumerate(items) if degree[i] == 0)\n        res = []\n        while q:\n            i = q.popleft()\n            res.append(i)\n            for j in graph[i]:\n                degree[j] -= 1\n                if degree[j] >= 0:\n                    q.append(j)\n        return res if len(res) == len(items) else []\n\n    def check_topo_sort(self, degree, graph, items):\n        count = 0\n        for i in range(len(degree)):\n            if degree[i] == 0:\n                count += 1\n        if count == 0:\n            return False\n        res = []\n        q = deque(i for i in range(len(degree)) if degree[i] == 0)\n        while q:\n            i = q.popleft()\n            res.append(i)\n            for j in graph[i]:\n                degree[j] -= 1\n                if degree[j] >= 0:\n                    q.append(j)\n        return len(res) == len(items)\n\n    def dfs(self, degree, graph, items, max_item):\n        for i in range(len(degree)):\n            if degree[i] == 0:\n                self.dfs_util(degree, graph, items, max_item, i)\n\n    def dfs_util(self, degree, graph, items, max_item, i):\n        res = []\n        q = deque(i)\n        while q:\n            i = q.popleft()\n            res.append(i)\n            for j in graph[i]:\n                degree[j] -= 1\n                if degree[j] >= 0:\n                    q.append(j)\n        if len(res) != len(items):\n            return False\n        return True",
    "efficient_solution": "class Solution:\n    def sortItems(\n        self, n: int, m: int, group: List[int], beforeItems: List[List[int]]\n    ) -> List[int]:\n        def topo_sort(degree, graph, items):\n            q = deque(i for _, i in enumerate(items) if degree[i] == 0)\n            res = []\n            while q:\n                i = q.popleft()\n                res.append(i)\n                for j in graph[i]:\n                    degree[j] -= 1\n                    if degree[j] == 0:\n                        q.append(j)\n            return res if len(res) == len(items) else []\n\n        idx = m\n        group_items = [[] for _ in range(n + m)]\n        for i, g in enumerate(group):\n            if g == -1:\n                group[i] = idx\n                idx += 1\n            group_items[group[i]].append(i)\n\n        item_degree = [0] * n\n        group_degree = [0] * (n + m)\n        item_graph = [[] for _ in range(n)]\n        group_graph = [[] for _ in range(n + m)]\n        for i, gi in enumerate(group):\n            for j in beforeItems[i]:\n                gj = group[j]\n                if gi == gj:\n                    item_degree[i] += 1\n                    item_graph[j].append(i)\n                else:\n                    group_degree[gi] += 1\n                    group_graph[gj].append(gi)\n\n        group_order = topo_sort(group_degree, group_graph, range(n + m))\n        if not group_order:\n            return []\n        ans = []\n        for gi in group_order:\n            items = group_items[gi]\n            item_order = topo_sort(item_degree, item_graph, items)\n            if len(items) != len(item_order):\n                return []\n            ans.extend(item_order)\n        return ans\n",
    "text": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nThere are\u00a0`n`\u00a0items each\u00a0belonging to zero or one of\u00a0`m`\u00a0groups where `group[i]`\u00a0is the group that the `i`-th item belongs to and it's equal to `-1`\u00a0if the `i`-th item belongs to no group. The items and the groups are zero indexed. A group can have no item belonging to it.\n\n\nReturn a sorted list of the items such that:\n\n\n* The items that belong to the same group are next to each other in the sorted list.\n* There are some\u00a0relations\u00a0between these items where\u00a0`beforeItems[i]`\u00a0is a list containing all the items that should come before the\u00a0`i`-th item in the sorted array (to the left of the\u00a0`i`-th item).\n\n\nReturn any solution if there is more than one solution and return an **empty list**\u00a0if there is no solution.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n**![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1200-1299/1203.Sort%20Items%20by%20Groups%20Respecting%20Dependencies/images/1359_ex1.png)**\n\n\n\n```\n\n**Input:** n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3,6],[],[],[]]\n**Output:** [6,3,4,1,5,2,0,7]\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3],[],[4],[]]\n**Output:** []\n**Explanation:**\u00a0This is the same as example 1 except that 4 needs to be before 6 in the sorted list.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= m <= n <= 3 * 104`\n* `group.length == beforeItems.length == n`\n* `-1 <= group[i] <= m - 1`\n* `0 <= beforeItems[i].length <= n - 1`\n* `0 <= beforeItems[i][j] <= n - 1`\n* `i != beforeItems[i][j]`\n* `beforeItems[i]`does not contain\u00a0duplicates elements.\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def sortItems(\n        self, n: int, m: int, group: List[int], beforeItems: List[List[int]]\n    ) -> List[int]:\n        idx = m\n        group_items = [[] for _ in range(n + m)]\n        for i, g in enumerate(group):\n            if g == -1:\n                group[i] = idx\n                idx += 1\n            group_items[group[i]].append(i)\n\n        item_degree = [0] * n\n        group_degree = [0] * (n + m)\n        item_graph = [[] for _ in range(n)]\n        group_graph = [[] for _ in range(n + m)]\n        for i, gi in enumerate(group):\n            for j in beforeItems[i]:\n                gj = group[j]\n                if gi == gj:\n                    item_degree[i] += 1\n                    item_graph[j].append(i)\n                else:\n                    group_degree[gi] += 1\n                    group_graph[gj].append(gi)\n\n        group_order = self.topo_sort(group_degree, group_graph, range(n + m), n + m)\n        if not group_order:\n            return []\n        ans = []\n        for gi in group_order:\n            items = group_items[gi]\n            item_order = self.topo_sort(item_degree, item_graph, items, n)\n            if len(items) != len(item_order):\n                return []\n            ans.extend(item_order)\n        return ans\n\n    def topo_sort(self, degree, graph, items, max_item):\n        q = deque(i for _, i in enumerate(items) if degree[i] == 0)\n        res = []\n        while q:\n            i = q.popleft()\n            res.append(i)\n            for j in graph[i]:\n                degree[j] -= 1\n                if degree[j] >= 0:\n                    q.append(j)\n        return res if len(res) == len(items) else []\n\n    def check_topo_sort(self, degree, graph, items):\n        count = 0\n        for i in range(len(degree)):\n            if degree[i] == 0:\n                count += 1\n        if count == 0:\n            return False\n        res = []\n        q = deque(i for i in range(len(degree)) if degree[i] == 0)\n        while q:\n            i = q.popleft()\n            res.append(i)\n            for j in graph[i]:\n                degree[j] -= 1\n                if degree[j] >= 0:\n                    q.append(j)\n        return len(res) == len(items)\n\n    def dfs(self, degree, graph, items, max_item):\n        for i in range(len(degree)):\n            if degree[i] == 0:\n                self.dfs_util(degree, graph, items, max_item, i)\n\n    def dfs_util(self, degree, graph, items, max_item, i):\n        res = []\n        q = deque(i)\n        while q:\n            i = q.popleft()\n            res.append(i)\n            for j in graph[i]:\n                degree[j] -= 1\n                if degree[j] >= 0:\n                    q.append(j)\n        if len(res) != len(items):\n            return False\n        return True\n\n### Efficient Solution:\nclass Solution:\n    def sortItems(\n        self, n: int, m: int, group: List[int], beforeItems: List[List[int]]\n    ) -> List[int]:\n        def topo_sort(degree, graph, items):\n            q = deque(i for _, i in enumerate(items) if degree[i] == 0)\n            res = []\n            while q:\n                i = q.popleft()\n                res.append(i)\n                for j in graph[i]:\n                    degree[j] -= 1\n                    if degree[j] == 0:\n                        q.append(j)\n            return res if len(res) == len(items) else []\n\n        idx = m\n        group_items = [[] for _ in range(n + m)]\n        for i, g in enumerate(group):\n            if g == -1:\n                group[i] = idx\n                idx += 1\n            group_items[group[i]].append(i)\n\n        item_degree = [0] * n\n        group_degree = [0] * (n + m)\n        item_graph = [[] for _ in range(n)]\n        group_graph = [[] for _ in range(n + m)]\n        for i, gi in enumerate(group):\n            for j in beforeItems[i]:\n                gj = group[j]\n                if gi == gj:\n                    item_degree[i] += 1\n                    item_graph[j].append(i)\n                else:\n                    group_degree[gi] += 1\n                    group_graph[gj].append(gi)\n\n        group_order = topo_sort(group_degree, group_graph, range(n + m))\n        if not group_order:\n            return []\n        ans = []\n        for gi in group_order:\n            items = group_items[gi]\n            item_order = topo_sort(item_degree, item_graph, items)\n            if len(items) != len(item_order):\n                return []\n            ans.extend(item_order)\n        return ans\n<|eot_id|>",
    "model_generation": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nThere are\u00a0`n`\u00a0items each\u00a0belonging to zero or one of\u00a0`m`\u00a0groups where `group[i]`\u00a0is the group that the `i`-th item belongs to and it's equal to `-1`\u00a0if the `i`-th item belongs to no group. The items and the groups are zero indexed. A group can have no item belonging to it.\n\n\nReturn a sorted list of the items such that:\n\n\n* The items that belong to the same group are next to each other in the sorted list.\n* There are some\u00a0relations\u00a0between these items where\u00a0`beforeItems[i]`\u00a0is a list containing all the items that should come before the\u00a0`i`-th item in the sorted array (to the left of the\u00a0`i`-th item).\n\n\nReturn any solution if there is more than one solution and return an **empty list**\u00a0if there is no solution.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n**![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1200-1299/1203.Sort%20Items%20by%20Groups%20Respecting%20Dependencies/images/1359_ex1.png)**\n\n\n\n```\n\n**Input:** n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3,6],[],[],[]]\n**Output:** [6,3,4,1,5,2,0,7]\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3],[],[4],[]]\n**Output:** []\n**Explanation:**\u00a0This is the same as example 1 except that 4 needs to be before 6 in the sorted list.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= m <= n <= 3 * 104`\n* `group.length == beforeItems.length == n`\n* `-1 <= group[i] <= m - 1`\n* `0 <= beforeItems[i].length <= n - 1`\n* `0 <= beforeItems[i][j] <= n - 1`\n* `i!= beforeItems[i][j]`\n* `beforeItems[i]`does not contain\u00a0duplicates elements.\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def sortItems(\n        self, n: int, m: int, group: List[int], beforeItems: List[List[int]]\n    ) -> List[int]:\n        idx = m\n        group_items = [[] for _ in range(n + m)]\n        for i, g in enumerate(group):\n            if g == -1:\n                group[i] = idx\n                idx += 1\n            group_items[group[i]].append(i)\n\n        item_degree = [0] * n\n        group_degree = [0] * (n + m)\n        item_graph = [[] for _ in range(n)]\n        group_graph = [[] for _ in range(n + m)]\n        for i, gi in enumerate(group):\n            for j in beforeItems[i]:\n                gj = group[j]\n                if gi == gj:\n                    item_degree[i] += 1\n                    item_graph[j].append(i)\n                else:\n                    group_degree[gi] += 1\n                    group_graph[gj].append(gi)\n\n        group_order = self.topo_sort(group_degree, group_graph, range(n + m), n + m)\n        if not group_order:\n            return []\n        ans = []\n        for gi in group_order:\n            items = group_items[gi]\n            item_order = self.topo_sort(item_degree, item_graph, items, n)\n            if len(items)!= len(item_order):\n                return []\n            ans.extend(item_order)\n        return ans\n\n    def topo_sort(self, degree, graph, items, max_item):\n        q = deque(i for _, i in enumerate(items) if degree[i] == 0)\n        res = []\n        while q:\n            i = q.popleft()\n            res.append(i)\n            for j in graph[i]:\n                degree[j] -= 1\n                if degree[j] >= 0:\n                    q.append(j)\n        return res if len(res) == len(items) else []\n\n    def check_topo_sort(self, degree, graph, items):\n        count = 0\n        for i in range(len(degree)):\n            if degree[i] == 0:\n                count += 1\n        if count == 0:\n            return False\n        res = []\n        q = deque(i for i in range(len(degree)) if degree[i] == 0)\n        while q:\n            i = q.popleft()\n            res.append(i)\n            for j in graph[i]:\n                degree[j] -= 1\n                if degree[j] >= 0:\n                    q.append(j)\n        return len(res) == len(items)\n\n    def dfs(self, degree, graph, items, max_item):\n        for i in range(len(degree)):\n            if degree[i] == 0:\n                self.dfs_util(degree, graph, items, max_item, i)\n\n    def dfs_util(self, degree, graph, items, max_item, i):\n        res = []\n        q = deque(i)\n        while q:\n            i = q.popleft()\n            res.append(i)\n            for j in graph[i]:\n                degree[j] -= 1\n                if degree[j] >= 0:\n                    q.append(j)\n        if len(res)!= len(items):\n            return False\n        return True\n\n### Efficient Solution:\nclass Solution:\n    def sortItems(\n        self, n: int, m: int, group: List[int], beforeItems: List[List[int]]\n    ) -> List[int]:\n        idx = m\n        group_items = [[] for _ in range(n + m)]\n        for i, g in enumerate(group):\n            if g == -1:\n                group[i] = idx\n                idx += 1\n            group_items[group[i]].append(i)\n\n        @cache\n        def dfs(i):\n            ans = 0\n            for j in beforeItems[i]:\n                ans = max(ans, dfs(group[j]))\n            degree[group[i]] -= 1\n            return ans + 1\n\n        deg = [0] * (n + m)\n        for i, gi in enumerate(group):\n            for j in beforeItems[i]:\n                gj = group[j]\n                if gi == gj:\n                    deg[i] += 1\n                else:\n                    deg[gi] += 1\n        for i in range(m, n + m):\n            deg[i] += 1\n        for i in range(m, n + m):\n            if deg[i] == 0:\n                idx = i\n        order = []\n        while idx < n + m:\n            order.append(idx)\n            idx = dfs(idx)\n\n        if len(order)!= n:\n            return []\n        ans = []\n        for i in range(len(order)):\n            if order[i] < m:\n                for j in group_items[order[i]]:\n                    ans.append(j)\n        return ans\n",
    "model_solution": "class Solution:\n    def sortItems(\n        self, n: int, m: int, group: List[int], beforeItems: List[List[int]]\n    ) -> List[int]:\n        idx = m\n        group_items = [[] for _ in range(n + m)]\n        for i, g in enumerate(group):\n            if g == -1:\n                group[i] = idx\n                idx += 1\n            group_items[group[i]].append(i)\n\n        @cache\n        def dfs(i):\n            ans = 0\n            for j in beforeItems[i]:\n                ans = max(ans, dfs(group[j]))\n            degree[group[i]] -= 1\n            return ans + 1\n\n        deg = [0] * (n + m)\n        for i, gi in enumerate(group):\n            for j in beforeItems[i]:\n                gj = group[j]\n                if gi == gj:\n                    deg[i] += 1\n                else:\n                    deg[gi] += 1\n        for i in range(m, n + m):\n            deg[i] += 1\n        for i in range(m, n + m):\n            if deg[i] == 0:\n                idx = i\n        order = []\n        while idx < n + m:\n            order.append(idx)\n            idx = dfs(idx)\n\n        if len(order)!= n:\n            return []\n        ans = []\n        for i in range(len(order)):\n            if order[i] < m:\n                for j in group_items[order[i]]:\n                    ans.append(j)\n        return ans"
}