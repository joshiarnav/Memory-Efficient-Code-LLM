{
    "problem_idx": "861",
    "description": "\nYou are given an `m x n` binary matrix `grid`.\n\n\nA **move** consists of choosing any row or column and toggling each value in that row or column (i.e., changing all `0`'s to `1`'s, and all `1`'s to `0`'s).\n\n\nEvery row of the matrix is interpreted as a binary number, and the **score** of the matrix is the sum of these numbers.\n\n\nReturn *the highest possible **score** after making any number of **moves** (including zero moves)*.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0800-0899/0861.Score%20After%20Flipping%20Matrix/images/lc-toogle1.jpg)\n\n```\n\n**Input:** grid = [[0,0,1,1],[1,0,1,0],[1,1,0,0]]\n**Output:** 39\n**Explanation:** 0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** grid = [[0]]\n**Output:** 1\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `m == grid.length`\n* `n == grid[i].length`\n* `1 <= m, n <= 20`\n* `grid[i][j]` is either `0` or `1`.\n\n\n",
    "inefficient_solution": "class Solution:\n    def matrixScore(self, grid):\n        m, n = len(grid), len(grid[0])\n        rows, cols = [[] for _ in range(m)], [[] for _ in range(n)]\n        for i in range(m):\n            for j in range(n):\n                rows[i].append(grid[i][j])\n                cols[j].append(grid[i][j])\n        for i in range(m):\n            if rows[i][0] == 0:\n                for j in range(n):\n                    rows[i][j] ^= 1\n        for j in range(n):\n            if cols[j][0] == 0:\n                for i in range(m):\n                    cols[j][i] ^= 1\n        ans = 0\n        for j in range(n):\n            cnt = sum(rows[i][j] for i in range(m))\n            ans += max(cnt, m - cnt) * (1 << (n - j - 1))\n        for i in range(m):\n            for j in range(n):\n                rows[i][j] = None\n                cols[j][i] = None\n        return ans",
    "efficient_solution": "class Solution:\n    def matrixScore(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        for i in range(m):\n            if grid[i][0] == 0:\n                for j in range(n):\n                    grid[i][j] ^= 1\n        ans = 0\n        for j in range(n):\n            cnt = sum(grid[i][j] for i in range(m))\n            ans += max(cnt, m - cnt) * (1 << (n - j - 1))\n        return ans\n",
    "text": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nYou are given an `m x n` binary matrix `grid`.\n\n\nA **move** consists of choosing any row or column and toggling each value in that row or column (i.e., changing all `0`'s to `1`'s, and all `1`'s to `0`'s).\n\n\nEvery row of the matrix is interpreted as a binary number, and the **score** of the matrix is the sum of these numbers.\n\n\nReturn *the highest possible **score** after making any number of **moves** (including zero moves)*.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0800-0899/0861.Score%20After%20Flipping%20Matrix/images/lc-toogle1.jpg)\n\n```\n\n**Input:** grid = [[0,0,1,1],[1,0,1,0],[1,1,0,0]]\n**Output:** 39\n**Explanation:** 0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** grid = [[0]]\n**Output:** 1\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `m == grid.length`\n* `n == grid[i].length`\n* `1 <= m, n <= 20`\n* `grid[i][j]` is either `0` or `1`.\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def matrixScore(self, grid):\n        m, n = len(grid), len(grid[0])\n        rows, cols = [[] for _ in range(m)], [[] for _ in range(n)]\n        for i in range(m):\n            for j in range(n):\n                rows[i].append(grid[i][j])\n                cols[j].append(grid[i][j])\n        for i in range(m):\n            if rows[i][0] == 0:\n                for j in range(n):\n                    rows[i][j] ^= 1\n        for j in range(n):\n            if cols[j][0] == 0:\n                for i in range(m):\n                    cols[j][i] ^= 1\n        ans = 0\n        for j in range(n):\n            cnt = sum(rows[i][j] for i in range(m))\n            ans += max(cnt, m - cnt) * (1 << (n - j - 1))\n        for i in range(m):\n            for j in range(n):\n                rows[i][j] = None\n                cols[j][i] = None\n        return ans\n\n### Efficient Solution:\nclass Solution:\n    def matrixScore(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        for i in range(m):\n            if grid[i][0] == 0:\n                for j in range(n):\n                    grid[i][j] ^= 1\n        ans = 0\n        for j in range(n):\n            cnt = sum(grid[i][j] for i in range(m))\n            ans += max(cnt, m - cnt) * (1 << (n - j - 1))\n        return ans\n<|eot_id|>",
    "model_generation": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nYou are given an `m x n` binary matrix `grid`.\n\n\nA **move** consists of choosing any row or column and toggling each value in that row or column (i.e., changing all `0`'s to `1`'s, and all `1`'s to `0`'s).\n\n\nEvery row of the matrix is interpreted as a binary number, and the **score** of the matrix is the sum of these numbers.\n\n\nReturn *the highest possible **score** after making any number of **moves** (including zero moves)*.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0800-0899/0861.Score%20After%20Flipping%20Matrix/images/lc-toogle1.jpg)\n\n```\n\n**Input:** grid = [[0,0,1,1],[1,0,1,0],[1,1,0,0]]\n**Output:** 39\n**Explanation:** 0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** grid = [[0]]\n**Output:** 1\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `m == grid.length`\n* `n == grid[i].length`\n* `1 <= m, n <= 20`\n* `grid[i][j]` is either `0` or `1`.\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def matrixScore(self, grid):\n        m, n = len(grid), len(grid[0])\n        rows, cols = [[] for _ in range(m)], [[] for _ in range(n)]\n        for i in range(m):\n            for j in range(n):\n                rows[i].append(grid[i][j])\n                cols[j].append(grid[i][j])\n        for i in range(m):\n            if rows[i][0] == 0:\n                for j in range(n):\n                    rows[i][j] ^= 1\n        for j in range(n):\n            if cols[j][0] == 0:\n                for i in range(m):\n                    cols[j][i] ^= 1\n        ans = 0\n        for j in range(n):\n            cnt = sum(rows[i][j] for i in range(m))\n            ans += max(cnt, m - cnt) * (1 << (n - j - 1))\n        for i in range(m):\n            for j in range(n):\n                rows[i][j] = None\n                cols[j][i] = None\n        return ans\n\n### Efficient Solution:\nclass Solution:\n    def matrixScore(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        for i in range(m):\n            if grid[i][0] == 0:\n                grid[i] = [x ^ 1 for x in grid[i]]\n        for i in range(n):\n            if grid[0][i] == 0:\n                grid = [row[:i] + row[i + 1 :] for row in grid]\n                grid = [row[::-1] for row in grid]\n        ans = 0\n        for i, row in enumerate(grid):\n            cnt = sum(row)\n            ans += cnt * (1 << (n - i - 1))\n        return ans\n",
    "model_solution": "class Solution:\n    def matrixScore(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        for i in range(m):\n            if grid[i][0] == 0:\n                grid[i] = [x ^ 1 for x in grid[i]]\n        for i in range(n):\n            if grid[0][i] == 0:\n                grid = [row[:i] + row[i + 1 :] for row in grid]\n                grid = [row[::-1] for row in grid]\n        ans = 0\n        for i, row in enumerate(grid):\n            cnt = sum(row)\n            ans += cnt * (1 << (n - i - 1))\n        return ans"
}