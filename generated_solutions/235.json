{
    "problem_idx": "235",
    "description": "\nGiven a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST.\n\n\nAccording to the [definition of LCA on Wikipedia](https://en.wikipedia.org/wiki/Lowest_common_ancestor): \u201cThe lowest common ancestor is defined between two nodes `p` and `q` as the lowest node in `T` that has both `p` and `q` as descendants (where we allow **a node to be a descendant of itself**).\u201d\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0200-0299/0235.Lowest%20Common%20Ancestor%20of%20a%20Binary%20Search%20Tree/images/binarysearchtree_improved.png)\n\n```\n\n**Input:** root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8\n**Output:** 6\n**Explanation:** The LCA of nodes 2 and 8 is 6.\n\n```\n\n**Example 2:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0200-0299/0235.Lowest%20Common%20Ancestor%20of%20a%20Binary%20Search%20Tree/images/binarysearchtree_improved.png)\n\n```\n\n**Input:** root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4\n**Output:** 2\n**Explanation:** The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** root = [2,1], p = 2, q = 1\n**Output:** 2\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* The number of nodes in the tree is in the range `[2, 105]`.\n* `-109 <= Node.val <= 109`\n* All `Node.val` are **unique**.\n* `p != q`\n* `p` and `q` will exist in the BST.\n\n\n",
    "inefficient_solution": "class Solution:\n    def lowestCommonAncestor(\n        self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode'\n    ) -> 'TreeNode':\n        self.check = False\n        self.result = None\n\n        def helper(root, p, q):\n            if root is None:\n                return False\n            left = helper(root.left, p, q)\n            right = helper(root.right, p, q)\n            if left and right:\n                return True\n            if (root == p or root == q) and not self.check:\n                self.check = True\n                self.result = root\n                return True\n            if left or right:\n                return True\n            return False\n\n        helper(root, p, q)\n        return self.result",
    "efficient_solution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\n\nclass Solution:\n    def lowestCommonAncestor(\n        self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode'\n    ) -> 'TreeNode':\n        while 1:\n            if root.val < min(p.val, q.val):\n                root = root.right\n            elif root.val > max(p.val, q.val):\n                root = root.left\n            else:\n                return root\n",
    "text": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nGiven a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST.\n\n\nAccording to the [definition of LCA on Wikipedia](https://en.wikipedia.org/wiki/Lowest_common_ancestor): \u201cThe lowest common ancestor is defined between two nodes `p` and `q` as the lowest node in `T` that has both `p` and `q` as descendants (where we allow **a node to be a descendant of itself**).\u201d\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0200-0299/0235.Lowest%20Common%20Ancestor%20of%20a%20Binary%20Search%20Tree/images/binarysearchtree_improved.png)\n\n```\n\n**Input:** root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8\n**Output:** 6\n**Explanation:** The LCA of nodes 2 and 8 is 6.\n\n```\n\n**Example 2:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0200-0299/0235.Lowest%20Common%20Ancestor%20of%20a%20Binary%20Search%20Tree/images/binarysearchtree_improved.png)\n\n```\n\n**Input:** root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4\n**Output:** 2\n**Explanation:** The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** root = [2,1], p = 2, q = 1\n**Output:** 2\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* The number of nodes in the tree is in the range `[2, 105]`.\n* `-109 <= Node.val <= 109`\n* All `Node.val` are **unique**.\n* `p != q`\n* `p` and `q` will exist in the BST.\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def lowestCommonAncestor(\n        self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode'\n    ) -> 'TreeNode':\n        self.check = False\n        self.result = None\n\n        def helper(root, p, q):\n            if root is None:\n                return False\n            left = helper(root.left, p, q)\n            right = helper(root.right, p, q)\n            if left and right:\n                return True\n            if (root == p or root == q) and not self.check:\n                self.check = True\n                self.result = root\n                return True\n            if left or right:\n                return True\n            return False\n\n        helper(root, p, q)\n        return self.result\n\n### Efficient Solution:\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\n\nclass Solution:\n    def lowestCommonAncestor(\n        self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode'\n    ) -> 'TreeNode':\n        while 1:\n            if root.val < min(p.val, q.val):\n                root = root.right\n            elif root.val > max(p.val, q.val):\n                root = root.left\n            else:\n                return root\n<|eot_id|>",
    "model_generation": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nGiven a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST.\n\n\nAccording to the [definition of LCA on Wikipedia](https://en.wikipedia.org/wiki/Lowest_common_ancestor): \u201cThe lowest common ancestor is defined between two nodes `p` and `q` as the lowest node in `T` that has both `p` and `q` as descendants (where we allow **a node to be a descendant of itself**).\u201d\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0200-0299/0235.Lowest%20Common%20Ancestor%20of%20a%20Binary%20Search%20Tree/images/binarysearchtree_improved.png)\n\n```\n\n**Input:** root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8\n**Output:** 6\n**Explanation:** The LCA of nodes 2 and 8 is 6.\n\n```\n\n**Example 2:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0200-0299/0235.Lowest%20Common%20Ancestor%20of%20a%20Binary%20Search%20Tree/images/binarysearchtree_improved.png)\n\n```\n\n**Input:** root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4\n**Output:** 2\n**Explanation:** The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** root = [2,1], p = 2, q = 1\n**Output:** 2\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* The number of nodes in the tree is in the range `[2, 105]`.\n* `-109 <= Node.val <= 109`\n* All `Node.val` are **unique**.\n* `p!= q`\n* `p` and `q` will exist in the BST.\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def lowestCommonAncestor(\n        self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode'\n    ) -> 'TreeNode':\n        self.check = False\n        self.result = None\n\n        def helper(root, p, q):\n            if root is None:\n                return False\n            left = helper(root.left, p, q)\n            right = helper(root.right, p, q)\n            if left and right:\n                return True\n            if (root == p or root == q) and not self.check:\n                self.check = True\n                self.result = root\n                return True\n            if left or right:\n                return True\n            return False\n\n        helper(root, p, q)\n        return self.result\n\n### Efficient Solution:\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\n\nclass Solution:\n    def lowestCommonAncestor(\n        self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode'\n    ) -> 'TreeNode':\n        def dfs(root, p, q):\n            if root is None:\n                return False\n            l = dfs(root.left, p, q)\n            r = dfs(root.right, p, q)\n            nonlocal ans\n            if l and r:\n                ans = root\n            if (root == p or root == q) ^ (l ^ r):\n                ans = root\n            return l or r\n\n        ans = None\n        dfs(root, p, q)\n        return ans\n",
    "model_solution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\n\nclass Solution:\n    def lowestCommonAncestor(\n        self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode'\n    ) -> 'TreeNode':\n        def dfs(root, p, q):\n            if root is None:\n                return False\n            l = dfs(root.left, p, q)\n            r = dfs(root.right, p, q)\n            nonlocal ans\n            if l and r:\n                ans = root\n            if (root == p or root == q) ^ (l ^ r):\n                ans = root\n            return l or r\n\n        ans = None\n        dfs(root, p, q)\n        return ans"
}