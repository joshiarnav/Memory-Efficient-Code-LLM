{
    "problem_idx": "1081",
    "description": "\nGiven a string `s`, return *the* *lexicographically smallest* *subsequence* *of* `s` *that contains all the distinct characters of* `s` *exactly once*.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** s = \"bcabc\"\n**Output:** \"abc\"\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** s = \"cbacdcbc\"\n**Output:** \"acdb\"\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= s.length <= 1000`\n* `s` consists of lowercase English letters.\n\n\n\u00a0\n\n\n**Note:** This question is the same as 316: <https://leetcode.com/problems/remove-duplicate-letters/>\n",
    "inefficient_solution": "class Solution:\n    def smallestSubsequence(self, s: str) -> str:\n        last = {c: i for i, c in enumerate(s)}\n        stk = []\n        vis = set()\n        counts = {}\n        for c in s:\n            counts[c] = counts.get(c, 0) + 1\n        for i, c in enumerate(s):\n            if c in vis:\n                counts[c] -= 1\n                continue\n            while stk and stk[-1] > c and last[stk[-1]] > i:\n                stk.pop()\n                vis.remove(stk[-1])\n                counts[stk[-1]] += 1\n            stk.append(c)\n            stk.append(c)  # duplicate\n            vis.add(c)\n            vis.add(c)     # duplicate\n        return \"\".join(stk)",
    "efficient_solution": "class Solution:\n    def smallestSubsequence(self, s: str) -> str:\n        last = {c: i for i, c in enumerate(s)}\n        stk = []\n        vis = set()\n        for i, c in enumerate(s):\n            if c in vis:\n                continue\n            while stk and stk[-1] > c and last[stk[-1]] > i:\n                vis.remove(stk.pop())\n            stk.append(c)\n            vis.add(c)\n        return \"\".join(stk)\n",
    "text": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nGiven a string `s`, return *the* *lexicographically smallest* *subsequence* *of* `s` *that contains all the distinct characters of* `s` *exactly once*.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** s = \"bcabc\"\n**Output:** \"abc\"\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** s = \"cbacdcbc\"\n**Output:** \"acdb\"\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= s.length <= 1000`\n* `s` consists of lowercase English letters.\n\n\n\u00a0\n\n\n**Note:** This question is the same as 316: <https://leetcode.com/problems/remove-duplicate-letters/>\n\n\n### Inefficient Solution:\nclass Solution:\n    def smallestSubsequence(self, s: str) -> str:\n        last = {c: i for i, c in enumerate(s)}\n        stk = []\n        vis = set()\n        counts = {}\n        for c in s:\n            counts[c] = counts.get(c, 0) + 1\n        for i, c in enumerate(s):\n            if c in vis:\n                counts[c] -= 1\n                continue\n            while stk and stk[-1] > c and last[stk[-1]] > i:\n                stk.pop()\n                vis.remove(stk[-1])\n                counts[stk[-1]] += 1\n            stk.append(c)\n            stk.append(c)  # duplicate\n            vis.add(c)\n            vis.add(c)     # duplicate\n        return \"\".join(stk)\n\n### Efficient Solution:\nclass Solution:\n    def smallestSubsequence(self, s: str) -> str:\n        last = {c: i for i, c in enumerate(s)}\n        stk = []\n        vis = set()\n        for i, c in enumerate(s):\n            if c in vis:\n                continue\n            while stk and stk[-1] > c and last[stk[-1]] > i:\n                vis.remove(stk.pop())\n            stk.append(c)\n            vis.add(c)\n        return \"\".join(stk)\n<|eot_id|>",
    "model_generation": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nGiven a string `s`, return *the* *lexicographically smallest* *subsequence* *of* `s` *that contains all the distinct characters of* `s` *exactly once*.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** s = \"bcabc\"\n**Output:** \"abc\"\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** s = \"cbacdcbc\"\n**Output:** \"acdb\"\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= s.length <= 1000`\n* `s` consists of lowercase English letters.\n\n\n\u00a0\n\n\n**Note:** This question is the same as 316: <https://leetcode.com/problems/remove-duplicate-letters/>\n\n\n### Inefficient Solution:\nclass Solution:\n    def smallestSubsequence(self, s: str) -> str:\n        last = {c: i for i, c in enumerate(s)}\n        stk = []\n        vis = set()\n        counts = {}\n        for c in s:\n            counts[c] = counts.get(c, 0) + 1\n        for i, c in enumerate(s):\n            if c in vis:\n                counts[c] -= 1\n                continue\n            while stk and stk[-1] > c and last[stk[-1]] > i:\n                stk.pop()\n                vis.remove(stk[-1])\n                counts[stk[-1]] += 1\n            stk.append(c)\n            stk.append(c)  # duplicate\n            vis.add(c)\n            vis.add(c)     # duplicate\n        return \"\".join(stk)\n\n### Efficient Solution:\nclass Solution:\n    def smallestSubsequence(self, s: str) -> str:\n        last = {c: i for i, c in enumerate(s)}\n        stk = []\n        vis = set()\n        for i, c in enumerate(s):\n            if c in vis:\n                continue\n            while stk and stk[-1] > c and last[stk[-1]] > i:\n                stk.pop()\n                vis.remove(stk[-1])\n            stk.append(c)\n            vis.add(c)\n        return \"\".join(stk)\n",
    "model_solution": "class Solution:\n    def smallestSubsequence(self, s: str) -> str:\n        last = {c: i for i, c in enumerate(s)}\n        stk = []\n        vis = set()\n        for i, c in enumerate(s):\n            if c in vis:\n                continue\n            while stk and stk[-1] > c and last[stk[-1]] > i:\n                stk.pop()\n                vis.remove(stk[-1])\n            stk.append(c)\n            vis.add(c)\n        return \"\".join(stk)"
}