{
    "problem_idx": "2320",
    "description": "\nThere is a street with `n * 2` **plots**, where there are `n` plots on each side of the street. The plots on each side are numbered from `1` to `n`. On each plot, a house can be placed.\n\n\nReturn *the number of ways houses can be placed such that no two houses are adjacent to each other on the same side of the street*. Since the answer may be very large, return it **modulo** `109 + 7`.\n\n\nNote that if a house is placed on the `ith` plot on one side of the street, a house can also be placed on the `ith` plot on the other side of the street.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** n = 1\n**Output:** 4\n**Explanation:** \nPossible arrangements:\n1. All plots are empty.\n2. A house is placed on one side of the street.\n3. A house is placed on the other side of the street.\n4. Two houses are placed, one on each side of the street.\n\n```\n\n**Example 2:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2300-2399/2320.Count%20Number%20of%20Ways%20to%20Place%20Houses/images/arrangements.png)\n\n```\n\n**Input:** n = 2\n**Output:** 9\n**Explanation:** The 9 possible arrangements are shown in the diagram above.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= n <= 104`\n\n\n",
    "inefficient_solution": "class Solution:\n    def countHousePlacements(self, n: int) -> int:\n        mod = 10**9 + 7\n        f = [1] * (n * 10**6)  # Excessive memory allocation\n        g = [1] * (n * 10**6)\n        for i in range(1, n):\n            f[i] = g[i - 1]\n            g[i] = (f[i - 1] + g[i - 1]) % mod\n        v = f[n-1] + g[n-1]\n        return v * v % mod",
    "efficient_solution": "class Solution:\n    def countHousePlacements(self, n: int) -> int:\n        mod = 10**9 + 7\n        f = [1] * n\n        g = [1] * n\n        for i in range(1, n):\n            f[i] = g[i - 1]\n            g[i] = (f[i - 1] + g[i - 1]) % mod\n        v = f[-1] + g[-1]\n        return v * v % mod\n",
    "text": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nThere is a street with `n * 2` **plots**, where there are `n` plots on each side of the street. The plots on each side are numbered from `1` to `n`. On each plot, a house can be placed.\n\n\nReturn *the number of ways houses can be placed such that no two houses are adjacent to each other on the same side of the street*. Since the answer may be very large, return it **modulo** `109 + 7`.\n\n\nNote that if a house is placed on the `ith` plot on one side of the street, a house can also be placed on the `ith` plot on the other side of the street.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** n = 1\n**Output:** 4\n**Explanation:** \nPossible arrangements:\n1. All plots are empty.\n2. A house is placed on one side of the street.\n3. A house is placed on the other side of the street.\n4. Two houses are placed, one on each side of the street.\n\n```\n\n**Example 2:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2300-2399/2320.Count%20Number%20of%20Ways%20to%20Place%20Houses/images/arrangements.png)\n\n```\n\n**Input:** n = 2\n**Output:** 9\n**Explanation:** The 9 possible arrangements are shown in the diagram above.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= n <= 104`\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def countHousePlacements(self, n: int) -> int:\n        mod = 10**9 + 7\n        f = [1] * (n * 10**6)  # Excessive memory allocation\n        g = [1] * (n * 10**6)\n        for i in range(1, n):\n            f[i] = g[i - 1]\n            g[i] = (f[i - 1] + g[i - 1]) % mod\n        v = f[n-1] + g[n-1]\n        return v * v % mod\n\n### Efficient Solution:\nclass Solution:\n    def countHousePlacements(self, n: int) -> int:\n        mod = 10**9 + 7\n        f = [1] * n\n        g = [1] * n\n        for i in range(1, n):\n            f[i] = g[i - 1]\n            g[i] = (f[i - 1] + g[i - 1]) % mod\n        v = f[-1] + g[-1]\n        return v * v % mod\n<|eot_id|>",
    "model_generation": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nThere is a street with `n * 2` **plots**, where there are `n` plots on each side of the street. The plots on each side are numbered from `1` to `n`. On each plot, a house can be placed.\n\n\nReturn *the number of ways houses can be placed such that no two houses are adjacent to each other on the same side of the street*. Since the answer may be very large, return it **modulo** `109 + 7`.\n\n\nNote that if a house is placed on the `ith` plot on one side of the street, a house can also be placed on the `ith` plot on the other side of the street.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** n = 1\n**Output:** 4\n**Explanation:** \nPossible arrangements:\n1. All plots are empty.\n2. A house is placed on one side of the street.\n3. A house is placed on the other side of the street.\n4. Two houses are placed, one on each side of the street.\n\n```\n\n**Example 2:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2300-2399/2320.Count%20Number%20of%20Ways%20to%20Place%20Houses/images/arrangements.png)\n\n```\n\n**Input:** n = 2\n**Output:** 9\n**Explanation:** The 9 possible arrangements are shown in the diagram above.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= n <= 104`\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def countHousePlacements(self, n: int) -> int:\n        mod = 10**9 + 7\n        f = [1] * (n * 10**6)  # Excessive memory allocation\n        g = [1] * (n * 10**6)\n        for i in range(1, n):\n            f[i] = g[i - 1]\n            g[i] = (f[i - 1] + g[i - 1]) % mod\n        v = f[n-1] + g[n-1]\n        return v * v % mod\n\n### Efficient Solution:\nclass Solution:\n    def countHousePlacements(self, n: int) -> int:\n        mod = 10**9 + 7\n        f = [1] * (n + 1)\n        g = [1] * (n + 1)\n        for i in range(1, n + 1):\n            f[i] = g[i - 1]\n            g[i] = (f[i - 1] + g[i - 1]) % mod\n        v = f[n] + g[n]\n        return v * v % mod\n",
    "model_solution": "class Solution:\n    def countHousePlacements(self, n: int) -> int:\n        mod = 10**9 + 7\n        f = [1] * (n + 1)\n        g = [1] * (n + 1)\n        for i in range(1, n + 1):\n            f[i] = g[i - 1]\n            g[i] = (f[i - 1] + g[i - 1]) % mod\n        v = f[n] + g[n]\n        return v * v % mod"
}