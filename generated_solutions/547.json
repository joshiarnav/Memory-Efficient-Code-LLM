{
    "problem_idx": "547",
    "description": "\nThere are `n` cities. Some of them are connected, while some are not. If city `a` is connected directly with city `b`, and city `b` is connected directly with city `c`, then city `a` is connected indirectly with city `c`.\n\n\nA **province** is a group of directly or indirectly connected cities and no other cities outside of the group.\n\n\nYou are given an `n x n` matrix `isConnected` where `isConnected[i][j] = 1` if the `ith` city and the `jth` city are directly connected, and `isConnected[i][j] = 0` otherwise.\n\n\nReturn *the total number of **provinces***.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0500-0599/0547.Number%20of%20Provinces/images/graph1.jpg)\n\n```\n\n**Input:** isConnected = [[1,1,0],[1,1,0],[0,0,1]]\n**Output:** 2\n\n```\n\n**Example 2:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0500-0599/0547.Number%20of%20Provinces/images/graph2.jpg)\n\n```\n\n**Input:** isConnected = [[1,0,0],[0,1,0],[0,0,1]]\n**Output:** 3\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= n <= 200`\n* `n == isConnected.length`\n* `n == isConnected[i].length`\n* `isConnected[i][j]` is `1` or `0`.\n* `isConnected[i][i] == 1`\n* `isConnected[i][j] == isConnected[j][i]`\n\n\n",
    "inefficient_solution": "class Solution:\n    def findCircleNum(self, isConnected: List[List[int]]) -> int:\n        def dfs_helper(i: int):\n            global visited\n            visited[i] = True\n            cities[i] = True\n            for j in range(len(isConnected)):\n                if visited[j] == False and isConnected[i][j] == 1:\n                    dfs_helper(j)\n                elif visited[j] == False and cities[j] == True:\n                    cities[j] = False\n            return\n\n        n = len(isConnected)\n        visited = [False] * n\n        cities = [True] * n\n        ans = 0\n        for i in range(n):\n            if visited[i] == False:\n                visited = [False] * n\n                dfs_helper(i)\n                cities = [True] * n\n                ans += 1\n        return ans",
    "efficient_solution": "class Solution:\n    def findCircleNum(self, isConnected: List[List[int]]) -> int:\n        def dfs(i: int):\n            vis[i] = True\n            for j, x in enumerate(isConnected[i]):\n                if not vis[j] and x:\n                    dfs(j)\n\n        n = len(isConnected)\n        vis = [False] * n\n        ans = 0\n        for i in range(n):\n            if not vis[i]:\n                dfs(i)\n                ans += 1\n        return ans\n",
    "text": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nThere are `n` cities. Some of them are connected, while some are not. If city `a` is connected directly with city `b`, and city `b` is connected directly with city `c`, then city `a` is connected indirectly with city `c`.\n\n\nA **province** is a group of directly or indirectly connected cities and no other cities outside of the group.\n\n\nYou are given an `n x n` matrix `isConnected` where `isConnected[i][j] = 1` if the `ith` city and the `jth` city are directly connected, and `isConnected[i][j] = 0` otherwise.\n\n\nReturn *the total number of **provinces***.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0500-0599/0547.Number%20of%20Provinces/images/graph1.jpg)\n\n```\n\n**Input:** isConnected = [[1,1,0],[1,1,0],[0,0,1]]\n**Output:** 2\n\n```\n\n**Example 2:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0500-0599/0547.Number%20of%20Provinces/images/graph2.jpg)\n\n```\n\n**Input:** isConnected = [[1,0,0],[0,1,0],[0,0,1]]\n**Output:** 3\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= n <= 200`\n* `n == isConnected.length`\n* `n == isConnected[i].length`\n* `isConnected[i][j]` is `1` or `0`.\n* `isConnected[i][i] == 1`\n* `isConnected[i][j] == isConnected[j][i]`\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def findCircleNum(self, isConnected: List[List[int]]) -> int:\n        def dfs_helper(i: int):\n            global visited\n            visited[i] = True\n            cities[i] = True\n            for j in range(len(isConnected)):\n                if visited[j] == False and isConnected[i][j] == 1:\n                    dfs_helper(j)\n                elif visited[j] == False and cities[j] == True:\n                    cities[j] = False\n            return\n\n        n = len(isConnected)\n        visited = [False] * n\n        cities = [True] * n\n        ans = 0\n        for i in range(n):\n            if visited[i] == False:\n                visited = [False] * n\n                dfs_helper(i)\n                cities = [True] * n\n                ans += 1\n        return ans\n\n### Efficient Solution:\nclass Solution:\n    def findCircleNum(self, isConnected: List[List[int]]) -> int:\n        def dfs(i: int):\n            vis[i] = True\n            for j, x in enumerate(isConnected[i]):\n                if not vis[j] and x:\n                    dfs(j)\n\n        n = len(isConnected)\n        vis = [False] * n\n        ans = 0\n        for i in range(n):\n            if not vis[i]:\n                dfs(i)\n                ans += 1\n        return ans\n<|eot_id|>",
    "model_generation": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nThere are `n` cities. Some of them are connected, while some are not. If city `a` is connected directly with city `b`, and city `b` is connected directly with city `c`, then city `a` is connected indirectly with city `c`.\n\n\nA **province** is a group of directly or indirectly connected cities and no other cities outside of the group.\n\n\nYou are given an `n x n` matrix `isConnected` where `isConnected[i][j] = 1` if the `ith` city and the `jth` city are directly connected, and `isConnected[i][j] = 0` otherwise.\n\n\nReturn *the total number of **provinces***.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0500-0599/0547.Number%20of%20Provinces/images/graph1.jpg)\n\n```\n\n**Input:** isConnected = [[1,1,0],[1,1,0],[0,0,1]]\n**Output:** 2\n\n```\n\n**Example 2:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0500-0599/0547.Number%20of%20Provinces/images/graph2.jpg)\n\n```\n\n**Input:** isConnected = [[1,0,0],[0,1,0],[0,0,1]]\n**Output:** 3\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= n <= 200`\n* `n == isConnected.length`\n* `n == isConnected[i].length`\n* `isConnected[i][j]` is `1` or `0`.\n* `isConnected[i][i] == 1`\n* `isConnected[i][j] == isConnected[j][i]`\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def findCircleNum(self, isConnected: List[List[int]]) -> int:\n        def dfs_helper(i: int):\n            global visited\n            visited[i] = True\n            cities[i] = True\n            for j in range(len(isConnected)):\n                if visited[j] == False and isConnected[i][j] == 1:\n                    dfs_helper(j)\n                elif visited[j] == False and cities[j] == True:\n                    cities[j] = False\n            return\n\n        n = len(isConnected)\n        visited = [False] * n\n        cities = [True] * n\n        ans = 0\n        for i in range(n):\n            if visited[i] == False:\n                visited = [False] * n\n                dfs_helper(i)\n                cities = [True] * n\n                ans += 1\n        return ans\n\n### Efficient Solution:\nclass Solution:\n    def findCircleNum(self, isConnected: List[List[int]]) -> int:\n        def dfs(i: int):\n            for j in range(n):\n                if g[i][j] and not vis[j]:\n                    vis[j] = True\n                    dfs(j)\n\n        n = len(isConnected)\n        g = isConnected\n        vis = [False] * n\n        ans = 0\n        for i in range(n):\n            if not vis[i]:\n                vis[i] = True\n                ans += 1\n                dfs(i)\n        return ans\n",
    "model_solution": "class Solution:\n    def findCircleNum(self, isConnected: List[List[int]]) -> int:\n        def dfs(i: int):\n            for j in range(n):\n                if g[i][j] and not vis[j]:\n                    vis[j] = True\n                    dfs(j)\n\n        n = len(isConnected)\n        g = isConnected\n        vis = [False] * n\n        ans = 0\n        for i in range(n):\n            if not vis[i]:\n                vis[i] = True\n                ans += 1\n                dfs(i)\n        return ans"
}