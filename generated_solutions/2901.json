{
    "problem_idx": "2901",
    "description": "\nYou are given an integer `n`, a **0-indexed** string array `words`, and a **0-indexed** array `groups`, both arrays having length `n`.\n\n\nThe **hamming distance** between two strings of equal length is the number of positions at which the corresponding characters are **different**.\n\n\nYou need to select the **longest** **subsequence** from an array of indices `[0, 1, ..., n - 1]`, such that for the subsequence denoted as `[i0, i1, ..., ik - 1]` having length `k`, the following holds:\n\n\n* For **adjacent** indices in the subsequence, their corresponding groups are **unequal**, i.e., `groups[ij] != groups[ij + 1]`, for each `j` where `0 < j + 1 < k`.\n* `words[ij]` and `words[ij + 1]` are **equal** in length, and the **hamming distance** between them is `1`, where `0 < j + 1 < k`, for all indices in the subsequence.\n\n\nReturn *a string array containing the words corresponding to the indices **(in order)** in the selected subsequence*. If there are multiple answers, return *any of them*.\n\n\nA **subsequence** of an array is a new array that is formed from the original array by deleting some (possibly none) of the elements without disturbing the relative positions of the remaining elements.\n\n\n**Note:** strings in `words` may be **unequal** in length.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** n = 3, words = [\"bab\",\"dab\",\"cab\"], groups = [1,2,2]\n**Output:** [\"bab\",\"cab\"]\n**Explanation:** A subsequence that can be selected is [0,2].\n- groups[0] != groups[2]\n- words[0].length == words[2].length, and the hamming distance between them is 1.\nSo, a valid answer is [words[0],words[2]] = [\"bab\",\"cab\"].\nAnother subsequence that can be selected is [0,1].\n- groups[0] != groups[1]\n- words[0].length == words[1].length, and the hamming distance between them is 1.\nSo, another valid answer is [words[0],words[1]] = [\"bab\",\"dab\"].\nIt can be shown that the length of the longest subsequence of indices that satisfies the conditions is 2.  \n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** n = 4, words = [\"a\",\"b\",\"c\",\"d\"], groups = [1,2,3,4]\n**Output:** [\"a\",\"b\",\"c\",\"d\"]\n**Explanation:** We can select the subsequence [0,1,2,3].\nIt satisfies both conditions.\nHence, the answer is [words[0],words[1],words[2],words[3]] = [\"a\",\"b\",\"c\",\"d\"].\nIt has the longest length among all subsequences of indices that satisfy the conditions.\nHence, it is the only answer.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= n == words.length == groups.length <= 1000`\n* `1 <= words[i].length <= 10`\n* `1 <= groups[i] <= n`\n* `words` consists of **distinct** strings.\n* `words[i]` consists of lowercase English letters.\n\n\n",
    "inefficient_solution": "class Solution:\n    def getWordsInLongestSubsequence(\n        self, n: int, words: List[str], groups: List[int]\n    ) -> List[str]:\n        def check(s: str, t: str) -> bool:\n            return len(s) == len(t) and sum(a != b for a, b in zip(s, t)) == 1\n\n        f = [0] * (n * n)\n        g = [-1] * (n * n)\n        mx = 0\n        for i in range(n):\n            for j in range(n):\n                for k in range(n):\n                    if groups[i] != groups[k] and f[j * n + i] < f[k * n + j] + 1 and check(words[i], words[k]):\n                        f[j * n + i] = f[k * n + j] + 1\n                        g[j * n + i] = k * n + j\n                        mx = max(mx, f[j * n + i])\n        ans = []\n        for i in range(n * n):\n            if f[i] == mx:\n                j = i\n                while j >= 0:\n                    ans.append(words[j % n])\n                    j = g[j]\n                break\n        return ans[::-1]",
    "efficient_solution": "class Solution:\n    def getWordsInLongestSubsequence(\n        self, n: int, words: List[str], groups: List[int]\n    ) -> List[str]:\n        def check(s: str, t: str) -> bool:\n            return len(s) == len(t) and sum(a != b for a, b in zip(s, t)) == 1\n\n        f = [1] * n\n        g = [-1] * n\n        mx = 1\n        for i, x in enumerate(groups):\n            for j, y in enumerate(groups[:i]):\n                if x != y and f[i] < f[j] + 1 and check(words[i], words[j]):\n                    f[i] = f[j] + 1\n                    g[i] = j\n                    mx = max(mx, f[i])\n        ans = []\n        for i in range(n):\n            if f[i] == mx:\n                j = i\n                while j >= 0:\n                    ans.append(words[j])\n                    j = g[j]\n                break\n        return ans[::-1]\n",
    "text": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nYou are given an integer `n`, a **0-indexed** string array `words`, and a **0-indexed** array `groups`, both arrays having length `n`.\n\n\nThe **hamming distance** between two strings of equal length is the number of positions at which the corresponding characters are **different**.\n\n\nYou need to select the **longest** **subsequence** from an array of indices `[0, 1, ..., n - 1]`, such that for the subsequence denoted as `[i0, i1, ..., ik - 1]` having length `k`, the following holds:\n\n\n* For **adjacent** indices in the subsequence, their corresponding groups are **unequal**, i.e., `groups[ij] != groups[ij + 1]`, for each `j` where `0 < j + 1 < k`.\n* `words[ij]` and `words[ij + 1]` are **equal** in length, and the **hamming distance** between them is `1`, where `0 < j + 1 < k`, for all indices in the subsequence.\n\n\nReturn *a string array containing the words corresponding to the indices **(in order)** in the selected subsequence*. If there are multiple answers, return *any of them*.\n\n\nA **subsequence** of an array is a new array that is formed from the original array by deleting some (possibly none) of the elements without disturbing the relative positions of the remaining elements.\n\n\n**Note:** strings in `words` may be **unequal** in length.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** n = 3, words = [\"bab\",\"dab\",\"cab\"], groups = [1,2,2]\n**Output:** [\"bab\",\"cab\"]\n**Explanation:** A subsequence that can be selected is [0,2].\n- groups[0] != groups[2]\n- words[0].length == words[2].length, and the hamming distance between them is 1.\nSo, a valid answer is [words[0],words[2]] = [\"bab\",\"cab\"].\nAnother subsequence that can be selected is [0,1].\n- groups[0] != groups[1]\n- words[0].length == words[1].length, and the hamming distance between them is 1.\nSo, another valid answer is [words[0],words[1]] = [\"bab\",\"dab\"].\nIt can be shown that the length of the longest subsequence of indices that satisfies the conditions is 2.  \n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** n = 4, words = [\"a\",\"b\",\"c\",\"d\"], groups = [1,2,3,4]\n**Output:** [\"a\",\"b\",\"c\",\"d\"]\n**Explanation:** We can select the subsequence [0,1,2,3].\nIt satisfies both conditions.\nHence, the answer is [words[0],words[1],words[2],words[3]] = [\"a\",\"b\",\"c\",\"d\"].\nIt has the longest length among all subsequences of indices that satisfy the conditions.\nHence, it is the only answer.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= n == words.length == groups.length <= 1000`\n* `1 <= words[i].length <= 10`\n* `1 <= groups[i] <= n`\n* `words` consists of **distinct** strings.\n* `words[i]` consists of lowercase English letters.\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def getWordsInLongestSubsequence(\n        self, n: int, words: List[str], groups: List[int]\n    ) -> List[str]:\n        def check(s: str, t: str) -> bool:\n            return len(s) == len(t) and sum(a != b for a, b in zip(s, t)) == 1\n\n        f = [0] * (n * n)\n        g = [-1] * (n * n)\n        mx = 0\n        for i in range(n):\n            for j in range(n):\n                for k in range(n):\n                    if groups[i] != groups[k] and f[j * n + i] < f[k * n + j] + 1 and check(words[i], words[k]):\n                        f[j * n + i] = f[k * n + j] + 1\n                        g[j * n + i] = k * n + j\n                        mx = max(mx, f[j * n + i])\n        ans = []\n        for i in range(n * n):\n            if f[i] == mx:\n                j = i\n                while j >= 0:\n                    ans.append(words[j % n])\n                    j = g[j]\n                break\n        return ans[::-1]\n\n### Efficient Solution:\nclass Solution:\n    def getWordsInLongestSubsequence(\n        self, n: int, words: List[str], groups: List[int]\n    ) -> List[str]:\n        def check(s: str, t: str) -> bool:\n            return len(s) == len(t) and sum(a != b for a, b in zip(s, t)) == 1\n\n        f = [1] * n\n        g = [-1] * n\n        mx = 1\n        for i, x in enumerate(groups):\n            for j, y in enumerate(groups[:i]):\n                if x != y and f[i] < f[j] + 1 and check(words[i], words[j]):\n                    f[i] = f[j] + 1\n                    g[i] = j\n                    mx = max(mx, f[i])\n        ans = []\n        for i in range(n):\n            if f[i] == mx:\n                j = i\n                while j >= 0:\n                    ans.append(words[j])\n                    j = g[j]\n                break\n        return ans[::-1]\n<|eot_id|>",
    "model_generation": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nYou are given an integer `n`, a **0-indexed** string array `words`, and a **0-indexed** array `groups`, both arrays having length `n`.\n\n\nThe **hamming distance** between two strings of equal length is the number of positions at which the corresponding characters are **different**.\n\n\nYou need to select the **longest** **subsequence** from an array of indices `[0, 1,..., n - 1]`, such that for the subsequence denoted as `[i0, i1,..., ik - 1]` having length `k`, the following holds:\n\n\n* For **adjacent** indices in the subsequence, their corresponding groups are **unequal**, i.e., `groups[ij]!= groups[ij + 1]`, for each `j` where `0 < j + 1 < k`.\n* `words[ij]` and `words[ij + 1]` are **equal** in length, and the **hamming distance** between them is `1`, where `0 < j + 1 < k`, for all indices in the subsequence.\n\n\nReturn *a string array containing the words corresponding to the indices **(in order)** in the selected subsequence*. If there are multiple answers, return *any of them*.\n\n\nA **subsequence** of an array is a new array that is formed from the original array by deleting some (possibly none) of the elements without disturbing the relative positions of the remaining elements.\n\n\n**Note:** strings in `words` may be **unequal** in length.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** n = 3, words = [\"bab\",\"dab\",\"cab\"], groups = [1,2,2]\n**Output:** [\"bab\",\"cab\"]\n**Explanation:** A subsequence that can be selected is [0,2].\n- groups[0]!= groups[2]\n- words[0].length == words[2].length, and the hamming distance between them is 1.\nSo, a valid answer is [words[0],words[2]] = [\"bab\",\"cab\"].\nAnother subsequence that can be selected is [0,1].\n- groups[0]!= groups[1]\n- words[0].length == words[1].length, and the hamming distance between them is 1.\nSo, another valid answer is [words[0],words[1]] = [\"bab\",\"dab\"].\nIt can be shown that the length of the longest subsequence of indices that satisfies the conditions is 2.  \n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** n = 4, words = [\"a\",\"b\",\"c\",\"d\"], groups = [1,2,3,4]\n**Output:** [\"a\",\"b\",\"c\",\"d\"]\n**Explanation:** We can select the subsequence [0,1,2,3].\nIt satisfies both conditions.\nHence, the answer is [words[0],words[1],words[2],words[3]] = [\"a\",\"b\",\"c\",\"d\"].\nIt has the longest length among all subsequences of indices that satisfy the conditions.\nHence, it is the only answer.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= n == words.length == groups.length <= 1000`\n* `1 <= words[i].length <= 10`\n* `1 <= groups[i] <= n`\n* `words` consists of **distinct** strings.\n* `words[i]` consists of lowercase English letters.\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def getWordsInLongestSubsequence(\n        self, n: int, words: List[str], groups: List[int]\n    ) -> List[str]:\n        def check(s: str, t: str) -> bool:\n            return len(s) == len(t) and sum(a!= b for a, b in zip(s, t)) == 1\n\n        f = [0] * (n * n)\n        g = [-1] * (n * n)\n        mx = 0\n        for i in range(n):\n            for j in range(n):\n                for k in range(n):\n                    if groups[i]!= groups[k] and f[j * n + i] < f[k * n + j] + 1 and check(words[i], words[k]):\n                        f[j * n + i] = f[k * n + j] + 1\n                        g[j * n + i] = k * n + j\n                        mx = max(mx, f[j * n + i])\n        ans = []\n        for i in range(n * n):\n            if f[i] == mx:\n                j = i\n                while j >= 0:\n                    ans.append(words[j % n])\n                    j = g[j]\n                break\n        return ans[::-1]\n\n### Efficient Solution:\nclass Solution:\n    def getWordsInLongestSubsequence(\n        self, n: int, words: List[str], groups: List[int]\n    ) -> List[str]:\n        def check(s: str, t: str) -> bool:\n            return len(s) == len(t) and sum(a!= b for a, b in zip(s, t)) == 1\n\n        f = [0] * n\n        g = [-1] * n\n        mx = 0\n        for i in range(n):\n            for k in range(n):\n                if groups[i]!= groups[k] and f[i] < f[k] + 1 and check(words[i], words[k]):\n                    f[i] = f[k] + 1\n                    g[i] = k\n                    mx = max(mx, f[i])\n        ans = []\n        for i in range(n):\n            if f[i] == mx:\n                j = i\n                while j >= 0:\n                    ans.append(words[j])\n                    j = g[j]\n                break\n        return ans[::-1]\n",
    "model_solution": "class Solution:\n    def getWordsInLongestSubsequence(\n        self, n: int, words: List[str], groups: List[int]\n    ) -> List[str]:\n        def check(s: str, t: str) -> bool:\n            return len(s) == len(t) and sum(a!= b for a, b in zip(s, t)) == 1\n\n        f = [0] * n\n        g = [-1] * n\n        mx = 0\n        for i in range(n):\n            for k in range(n):\n                if groups[i]!= groups[k] and f[i] < f[k] + 1 and check(words[i], words[k]):\n                    f[i] = f[k] + 1\n                    g[i] = k\n                    mx = max(mx, f[i])\n        ans = []\n        for i in range(n):\n            if f[i] == mx:\n                j = i\n                while j >= 0:\n                    ans.append(words[j])\n                    j = g[j]\n                break\n        return ans[::-1]"
}