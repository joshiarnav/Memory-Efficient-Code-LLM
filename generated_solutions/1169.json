{
    "problem_idx": "1169",
    "description": "\nA transaction is possibly invalid if:\n\n\n* the amount exceeds `$1000`, or;\n* if it occurs within (and including) `60` minutes of another transaction with the **same name** in a **different city**.\n\n\nYou are given an array of strings `transaction` where `transactions[i]` consists of comma-separated values representing the name, time (in minutes), amount, and city of the transaction.\n\n\nReturn a list of `transactions` that are possibly invalid. You may return the answer in **any order**.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** transactions = [\"alice,20,800,mtv\",\"alice,50,100,beijing\"]\n**Output:** [\"alice,20,800,mtv\",\"alice,50,100,beijing\"]\n**Explanation:** The first transaction is invalid because the second transaction occurs within a difference of 60 minutes, have the same name and is in a different city. Similarly the second one is invalid too.\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** transactions = [\"alice,20,800,mtv\",\"alice,50,1200,mtv\"]\n**Output:** [\"alice,50,1200,mtv\"]\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** transactions = [\"alice,20,800,mtv\",\"bob,50,1200,mtv\"]\n**Output:** [\"bob,50,1200,mtv\"]\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `transactions.length <= 1000`\n* Each `transactions[i]` takes the form `\"{name},{time},{amount},{city}\"`\n* Each `{name}` and `{city}` consist of lowercase English letters, and have lengths between `1` and `10`.\n* Each `{time}` consist of digits, and represent an integer between `0` and `1000`.\n* Each `{amount}` consist of digits, and represent an integer between `0` and `2000`.\n\n\n",
    "inefficient_solution": "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        invalid = []\n        for transaction in transactions:\n            name, time, amount, city = transaction.split(\",\")\n            time, amount = int(time), int(amount)\n            for other_transaction in transactions:\n                other_name, other_time, other_amount, other_city = other_transaction.split(\",\")\n                other_time, other_amount = int(other_time), int(other_amount)\n                if other_name != name and (amount > 1000 or abs(time - other_time) <= 60 and city != other_city):\n                    invalid.append(transaction)\n        return invalid",
    "efficient_solution": "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        d = defaultdict(list)\n        idx = set()\n        for i, x in enumerate(transactions):\n            name, time, amount, city = x.split(\",\")\n            time, amount = int(time), int(amount)\n            d[name].append((time, city, i))\n            if amount > 1000:\n                idx.add(i)\n            for t, c, j in d[name]:\n                if c != city and abs(time - t) <= 60:\n                    idx.add(i)\n                    idx.add(j)\n        return [transactions[i] for i in idx]\n",
    "text": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nA transaction is possibly invalid if:\n\n\n* the amount exceeds `$1000`, or;\n* if it occurs within (and including) `60` minutes of another transaction with the **same name** in a **different city**.\n\n\nYou are given an array of strings `transaction` where `transactions[i]` consists of comma-separated values representing the name, time (in minutes), amount, and city of the transaction.\n\n\nReturn a list of `transactions` that are possibly invalid. You may return the answer in **any order**.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** transactions = [\"alice,20,800,mtv\",\"alice,50,100,beijing\"]\n**Output:** [\"alice,20,800,mtv\",\"alice,50,100,beijing\"]\n**Explanation:** The first transaction is invalid because the second transaction occurs within a difference of 60 minutes, have the same name and is in a different city. Similarly the second one is invalid too.\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** transactions = [\"alice,20,800,mtv\",\"alice,50,1200,mtv\"]\n**Output:** [\"alice,50,1200,mtv\"]\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** transactions = [\"alice,20,800,mtv\",\"bob,50,1200,mtv\"]\n**Output:** [\"bob,50,1200,mtv\"]\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `transactions.length <= 1000`\n* Each `transactions[i]` takes the form `\"{name},{time},{amount},{city}\"`\n* Each `{name}` and `{city}` consist of lowercase English letters, and have lengths between `1` and `10`.\n* Each `{time}` consist of digits, and represent an integer between `0` and `1000`.\n* Each `{amount}` consist of digits, and represent an integer between `0` and `2000`.\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        invalid = []\n        for transaction in transactions:\n            name, time, amount, city = transaction.split(\",\")\n            time, amount = int(time), int(amount)\n            for other_transaction in transactions:\n                other_name, other_time, other_amount, other_city = other_transaction.split(\",\")\n                other_time, other_amount = int(other_time), int(other_amount)\n                if other_name != name and (amount > 1000 or abs(time - other_time) <= 60 and city != other_city):\n                    invalid.append(transaction)\n        return invalid\n\n### Efficient Solution:\nclass Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        d = defaultdict(list)\n        idx = set()\n        for i, x in enumerate(transactions):\n            name, time, amount, city = x.split(\",\")\n            time, amount = int(time), int(amount)\n            d[name].append((time, city, i))\n            if amount > 1000:\n                idx.add(i)\n            for t, c, j in d[name]:\n                if c != city and abs(time - t) <= 60:\n                    idx.add(i)\n                    idx.add(j)\n        return [transactions[i] for i in idx]\n<|eot_id|>",
    "model_generation": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nA transaction is possibly invalid if:\n\n\n* the amount exceeds `$1000`, or;\n* if it occurs within (and including) `60` minutes of another transaction with the **same name** in a **different city**.\n\n\nYou are given an array of strings `transaction` where `transactions[i]` consists of comma-separated values representing the name, time (in minutes), amount, and city of the transaction.\n\n\nReturn a list of `transactions` that are possibly invalid. You may return the answer in **any order**.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** transactions = [\"alice,20,800,mtv\",\"alice,50,100,beijing\"]\n**Output:** [\"alice,20,800,mtv\",\"alice,50,100,beijing\"]\n**Explanation:** The first transaction is invalid because the second transaction occurs within a difference of 60 minutes, have the same name and is in a different city. Similarly the second one is invalid too.\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** transactions = [\"alice,20,800,mtv\",\"alice,50,1200,mtv\"]\n**Output:** [\"alice,50,1200,mtv\"]\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** transactions = [\"alice,20,800,mtv\",\"bob,50,1200,mtv\"]\n**Output:** [\"bob,50,1200,mtv\"]\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `transactions.length <= 1000`\n* Each `transactions[i]` takes the form `\"{name},{time},{amount},{city}\"`\n* Each `{name}` and `{city}` consist of lowercase English letters, and have lengths between `1` and `10`.\n* Each `{time}` consist of digits, and represent an integer between `0` and `1000`.\n* Each `{amount}` consist of digits, and represent an integer between `0` and `2000`.\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        invalid = []\n        for transaction in transactions:\n            name, time, amount, city = transaction.split(\",\")\n            time, amount = int(time), int(amount)\n            for other_transaction in transactions:\n                other_name, other_time, other_amount, other_city = other_transaction.split(\",\")\n                other_time, other_amount = int(other_time), int(other_amount)\n                if other_name!= name and (amount > 1000 or abs(time - other_time) <= 60 and city!= other_city):\n                    invalid.append(transaction)\n        return invalid\n\n### Efficient Solution:\nclass Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        d = defaultdict(list)\n        for i, x in enumerate(transactions):\n            n, t, a, c = x.split(\",\")\n            t, a = int(t), int(a)\n            d[n].append((t, a, i, c))\n        names = list(d.keys())\n        for i in range(len(names)):\n            for j in range(i + 1, len(names)):\n                name1, name2 = names[i], names[j]\n                for k in range(len(d[name1])):\n                    for l in range(len(d[name2])):\n                        if (\n                            d[name1][k][1] > 1000\n                            or abs(d[name1][k][0] - d[name2][l][0]) <= 60\n                            and d[name1][k][3]!= d[name2][l][3]\n                        ):\n                            invalid.append(transactions[d[name1][k][2]])\n                            break\n        return invalid\n",
    "model_solution": "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        d = defaultdict(list)\n        for i, x in enumerate(transactions):\n            n, t, a, c = x.split(\",\")\n            t, a = int(t), int(a)\n            d[n].append((t, a, i, c))\n        names = list(d.keys())\n        for i in range(len(names)):\n            for j in range(i + 1, len(names)):\n                name1, name2 = names[i], names[j]\n                for k in range(len(d[name1])):\n                    for l in range(len(d[name2])):\n                        if (\n                            d[name1][k][1] > 1000\n                            or abs(d[name1][k][0] - d[name2][l][0]) <= 60\n                            and d[name1][k][3]!= d[name2][l][3]\n                        ):\n                            invalid.append(transactions[d[name1][k][2]])\n                            break\n        return invalid"
}