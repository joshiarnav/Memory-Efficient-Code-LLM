{
    "problem_idx": "1183",
    "description": "\nConsider a matrix `M` with dimensions `width * height`, such that every cell has value `0`\u00a0or `1`, and any **square**\u00a0sub-matrix of `M` of size `sideLength * sideLength`\u00a0has at most `maxOnes`\u00a0ones.\n\n\nReturn the maximum possible number of ones that the matrix `M` can have.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** width = 3, height = 3, sideLength = 2, maxOnes = 1\n**Output:** 4\n**Explanation:**\nIn a 3*3 matrix, no 2*2 sub-matrix can have more than 1 one.\nThe best solution that has 4 ones is:\n[1,0,1]\n[0,0,0]\n[1,0,1]\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** width = 3, height = 3, sideLength = 2, maxOnes = 2\n**Output:** 6\n**Explanation:**\n[1,0,1]\n[1,0,1]\n[1,0,1]\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= width, height <= 100`\n* `1 <= sideLength <= width, height`\n* `0 <= maxOnes <= sideLength * sideLength`\n\n\n",
    "inefficient_solution": "class Solution:\n    def maximumNumberOfOnes(\n        self, width: int, height: int, sideLength: int, maxOnes: int\n    ) -> int:\n        x = sideLength\n        cnt = []\n        for i in range(width):\n            for j in range(height):\n                k = (i % x) * x + (j % x)\n                cnt.append(cnt[k] + 1 if k < len(cnt) else 1)\n        for i in range(len(cnt)):\n            for j in range(len(cnt) - 1):\n                if cnt[j] > cnt[j + 1]:\n                    cnt[j], cnt[j + 1] = cnt[j + 1], cnt[j]\n        return sum(cnt[:maxOnes])",
    "efficient_solution": "class Solution:\n    def maximumNumberOfOnes(\n        self, width: int, height: int, sideLength: int, maxOnes: int\n    ) -> int:\n        x = sideLength\n        cnt = [0] * (x * x)\n        for i in range(width):\n            for j in range(height):\n                k = (i % x) * x + (j % x)\n                cnt[k] += 1\n        cnt.sort(reverse=True)\n        return sum(cnt[:maxOnes])\n",
    "text": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nConsider a matrix `M` with dimensions `width * height`, such that every cell has value `0`\u00a0or `1`, and any **square**\u00a0sub-matrix of `M` of size `sideLength * sideLength`\u00a0has at most `maxOnes`\u00a0ones.\n\n\nReturn the maximum possible number of ones that the matrix `M` can have.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** width = 3, height = 3, sideLength = 2, maxOnes = 1\n**Output:** 4\n**Explanation:**\nIn a 3*3 matrix, no 2*2 sub-matrix can have more than 1 one.\nThe best solution that has 4 ones is:\n[1,0,1]\n[0,0,0]\n[1,0,1]\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** width = 3, height = 3, sideLength = 2, maxOnes = 2\n**Output:** 6\n**Explanation:**\n[1,0,1]\n[1,0,1]\n[1,0,1]\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= width, height <= 100`\n* `1 <= sideLength <= width, height`\n* `0 <= maxOnes <= sideLength * sideLength`\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def maximumNumberOfOnes(\n        self, width: int, height: int, sideLength: int, maxOnes: int\n    ) -> int:\n        x = sideLength\n        cnt = []\n        for i in range(width):\n            for j in range(height):\n                k = (i % x) * x + (j % x)\n                cnt.append(cnt[k] + 1 if k < len(cnt) else 1)\n        for i in range(len(cnt)):\n            for j in range(len(cnt) - 1):\n                if cnt[j] > cnt[j + 1]:\n                    cnt[j], cnt[j + 1] = cnt[j + 1], cnt[j]\n        return sum(cnt[:maxOnes])\n\n### Efficient Solution:\nclass Solution:\n    def maximumNumberOfOnes(\n        self, width: int, height: int, sideLength: int, maxOnes: int\n    ) -> int:\n        x = sideLength\n        cnt = [0] * (x * x)\n        for i in range(width):\n            for j in range(height):\n                k = (i % x) * x + (j % x)\n                cnt[k] += 1\n        cnt.sort(reverse=True)\n        return sum(cnt[:maxOnes])\n<|eot_id|>",
    "model_generation": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nConsider a matrix `M` with dimensions `width * height`, such that every cell has value `0`\u00a0or `1`, and any **square**\u00a0sub-matrix of `M` of size `sideLength * sideLength`\u00a0has at most `maxOnes`\u00a0ones.\n\n\nReturn the maximum possible number of ones that the matrix `M` can have.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** width = 3, height = 3, sideLength = 2, maxOnes = 1\n**Output:** 4\n**Explanation:**\nIn a 3*3 matrix, no 2*2 sub-matrix can have more than 1 one.\nThe best solution that has 4 ones is:\n[1,0,1]\n[0,0,0]\n[1,0,1]\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** width = 3, height = 3, sideLength = 2, maxOnes = 2\n**Output:** 6\n**Explanation:**\n[1,0,1]\n[1,0,1]\n[1,0,1]\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= width, height <= 100`\n* `1 <= sideLength <= width, height`\n* `0 <= maxOnes <= sideLength * sideLength`\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def maximumNumberOfOnes(\n        self, width: int, height: int, sideLength: int, maxOnes: int\n    ) -> int:\n        x = sideLength\n        cnt = []\n        for i in range(width):\n            for j in range(height):\n                k = (i % x) * x + (j % x)\n                cnt.append(cnt[k] + 1 if k < len(cnt) else 1)\n        for i in range(len(cnt)):\n            for j in range(len(cnt) - 1):\n                if cnt[j] > cnt[j + 1]:\n                    cnt[j], cnt[j + 1] = cnt[j + 1], cnt[j]\n        return sum(cnt[:maxOnes])\n\n### Efficient Solution:\nclass Solution:\n    def maximumNumberOfOnes(\n        self, width: int, height: int, sideLength: int, maxOnes: int\n    ) -> int:\n        x = sideLength\n        cnt = [0] * (x * x)\n        ans = 0\n        for i in range(width):\n            for j in range(height):\n                k = (i % x) * x + (j % x)\n                cnt[k] += 1\n                idx = (k + 1) % x * x + (i // x + 1) % x\n                cnt[idx] -= 1\n                ans += 1\n                while idx < len(cnt) and cnt[idx] < 0:\n                    idx -= 1\n                    ans -= 1\n        cnt.sort()\n        return ans + sum(cnt[:maxOnes - ans])\n",
    "model_solution": "class Solution:\n    def maximumNumberOfOnes(\n        self, width: int, height: int, sideLength: int, maxOnes: int\n    ) -> int:\n        x = sideLength\n        cnt = [0] * (x * x)\n        ans = 0\n        for i in range(width):\n            for j in range(height):\n                k = (i % x) * x + (j % x)\n                cnt[k] += 1\n                idx = (k + 1) % x * x + (i // x + 1) % x\n                cnt[idx] -= 1\n                ans += 1\n                while idx < len(cnt) and cnt[idx] < 0:\n                    idx -= 1\n                    ans -= 1\n        cnt.sort()\n        return ans + sum(cnt[:maxOnes - ans])"
}