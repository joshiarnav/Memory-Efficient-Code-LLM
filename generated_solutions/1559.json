{
    "problem_idx": "1559",
    "description": "\nGiven a 2D array of characters `grid` of size `m x n`, you need to find if there exists any cycle consisting of the **same value** in `grid`.\n\n\nA cycle is a path of **length 4 or more** in the grid that starts and ends at the same cell. From a given cell, you can move to one of the cells adjacent to it - in one of the four directions (up, down, left, or right), if it has the **same value** of the current cell.\n\n\nAlso, you cannot move to the cell that you visited in your last move. For example, the cycle `(1, 1) -> (1, 2) -> (1, 1)` is invalid because from `(1, 2)` we visited `(1, 1)` which was the last visited cell.\n\n\nReturn `true` if any cycle of the same value exists in `grid`, otherwise, return `false`.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n**![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1500-1599/1559.Detect%20Cycles%20in%202D%20Grid/images/1.png)**\n\n\n\n```\n\n**Input:** grid = [[\"a\",\"a\",\"a\",\"a\"],[\"a\",\"b\",\"b\",\"a\"],[\"a\",\"b\",\"b\",\"a\"],[\"a\",\"a\",\"a\",\"a\"]]\n**Output:** true\n**Explanation:** There are two valid cycles shown in different colors in the image below:\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1500-1599/1559.Detect%20Cycles%20in%202D%20Grid/images/11.png)\n\n```\n\n**Example 2:**\n\n\n**![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1500-1599/1559.Detect%20Cycles%20in%202D%20Grid/images/22.png)**\n\n\n\n```\n\n**Input:** grid = [[\"c\",\"c\",\"c\",\"a\"],[\"c\",\"d\",\"c\",\"c\"],[\"c\",\"c\",\"e\",\"c\"],[\"f\",\"c\",\"c\",\"c\"]]\n**Output:** true\n**Explanation:** There is only one valid cycle highlighted in the image below:\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1500-1599/1559.Detect%20Cycles%20in%202D%20Grid/images/2.png)\n\n```\n\n**Example 3:**\n\n\n**![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1500-1599/1559.Detect%20Cycles%20in%202D%20Grid/images/3.png)**\n\n\n\n```\n\n**Input:** grid = [[\"a\",\"b\",\"b\"],[\"b\",\"z\",\"b\"],[\"b\",\"b\",\"a\"]]\n**Output:** false\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `m == grid.length`\n* `n == grid[i].length`\n* `1 <= m, n <= 500`\n* `grid` consists only of lowercase English letters.\n\n\n",
    "inefficient_solution": "class Solution:\n    def containsCycle(self, grid):\n        m, n = len(grid), len(grid[0])\n        chars = [[[] for _ in range(n)] for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                chars[i][j] = [grid[i][j]]\n                if i > 0 and grid[i][j] == grid[i-1][j]:\n                    chars[i][j].append(grid[i-1][j])\n                if j > 0 and grid[i][j] == grid[i][j-1]:\n                    chars[i][j].append(grid[i][j-1])\n        for i in range(m):\n            for j in range(n):\n                if len(chars[i][j]) > 2:\n                    for a, b in [[0, 1], [1, 0]]:\n                        x, y = i + a, j + b\n                        if x < m and y < n:\n                            curr = [(i, j)]\n                            while (x, y) != (i, j):\n                                if grid[x][y] == grid[i][j]:\n                                    curr.append((x, y))\n                                    if (x, y) in curr[:-3]:\n                                        return True\n                                    if x > 0 and grid[x][y] == grid[x-1][y]:\n                                        curr.append((x-1, y))\n                                    if y > 0 and grid[x][y] == grid[x][y-1]:\n                                        curr.append((x, y-1))\n                                    if x < m-1 and grid[x][y] == grid[x+1][y]:\n                                        curr.append((x+1, y))\n                                    if y < n-1 and grid[x][y] == grid[x][y+1]:\n                                        curr.append((x, y+1))\n                                else:\n                                    break\n                                x, y = curr[-1]\n                            else:\n                                return True\n        return False",
    "efficient_solution": "class Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        def find(x):\n            if p[x] != x:\n                p[x] = find(p[x])\n            return p[x]\n\n        m, n = len(grid), len(grid[0])\n        p = list(range(m * n))\n        for i in range(m):\n            for j in range(n):\n                for a, b in [[0, 1], [1, 0]]:\n                    x, y = i + a, j + b\n                    if x < m and y < n and grid[x][y] == grid[i][j]:\n                        if find(x * n + y) == find(i * n + j):\n                            return True\n                        p[find(x * n + y)] = find(i * n + j)\n        return False\n",
    "text": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nGiven a 2D array of characters `grid` of size `m x n`, you need to find if there exists any cycle consisting of the **same value** in `grid`.\n\n\nA cycle is a path of **length 4 or more** in the grid that starts and ends at the same cell. From a given cell, you can move to one of the cells adjacent to it - in one of the four directions (up, down, left, or right), if it has the **same value** of the current cell.\n\n\nAlso, you cannot move to the cell that you visited in your last move. For example, the cycle `(1, 1) -> (1, 2) -> (1, 1)` is invalid because from `(1, 2)` we visited `(1, 1)` which was the last visited cell.\n\n\nReturn `true` if any cycle of the same value exists in `grid`, otherwise, return `false`.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n**![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1500-1599/1559.Detect%20Cycles%20in%202D%20Grid/images/1.png)**\n\n\n\n```\n\n**Input:** grid = [[\"a\",\"a\",\"a\",\"a\"],[\"a\",\"b\",\"b\",\"a\"],[\"a\",\"b\",\"b\",\"a\"],[\"a\",\"a\",\"a\",\"a\"]]\n**Output:** true\n**Explanation:** There are two valid cycles shown in different colors in the image below:\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1500-1599/1559.Detect%20Cycles%20in%202D%20Grid/images/11.png)\n\n```\n\n**Example 2:**\n\n\n**![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1500-1599/1559.Detect%20Cycles%20in%202D%20Grid/images/22.png)**\n\n\n\n```\n\n**Input:** grid = [[\"c\",\"c\",\"c\",\"a\"],[\"c\",\"d\",\"c\",\"c\"],[\"c\",\"c\",\"e\",\"c\"],[\"f\",\"c\",\"c\",\"c\"]]\n**Output:** true\n**Explanation:** There is only one valid cycle highlighted in the image below:\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1500-1599/1559.Detect%20Cycles%20in%202D%20Grid/images/2.png)\n\n```\n\n**Example 3:**\n\n\n**![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1500-1599/1559.Detect%20Cycles%20in%202D%20Grid/images/3.png)**\n\n\n\n```\n\n**Input:** grid = [[\"a\",\"b\",\"b\"],[\"b\",\"z\",\"b\"],[\"b\",\"b\",\"a\"]]\n**Output:** false\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `m == grid.length`\n* `n == grid[i].length`\n* `1 <= m, n <= 500`\n* `grid` consists only of lowercase English letters.\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def containsCycle(self, grid):\n        m, n = len(grid), len(grid[0])\n        chars = [[[] for _ in range(n)] for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                chars[i][j] = [grid[i][j]]\n                if i > 0 and grid[i][j] == grid[i-1][j]:\n                    chars[i][j].append(grid[i-1][j])\n                if j > 0 and grid[i][j] == grid[i][j-1]:\n                    chars[i][j].append(grid[i][j-1])\n        for i in range(m):\n            for j in range(n):\n                if len(chars[i][j]) > 2:\n                    for a, b in [[0, 1], [1, 0]]:\n                        x, y = i + a, j + b\n                        if x < m and y < n:\n                            curr = [(i, j)]\n                            while (x, y) != (i, j):\n                                if grid[x][y] == grid[i][j]:\n                                    curr.append((x, y))\n                                    if (x, y) in curr[:-3]:\n                                        return True\n                                    if x > 0 and grid[x][y] == grid[x-1][y]:\n                                        curr.append((x-1, y))\n                                    if y > 0 and grid[x][y] == grid[x][y-1]:\n                                        curr.append((x, y-1))\n                                    if x < m-1 and grid[x][y] == grid[x+1][y]:\n                                        curr.append((x+1, y))\n                                    if y < n-1 and grid[x][y] == grid[x][y+1]:\n                                        curr.append((x, y+1))\n                                else:\n                                    break\n                                x, y = curr[-1]\n                            else:\n                                return True\n        return False\n\n### Efficient Solution:\nclass Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        def find(x):\n            if p[x] != x:\n                p[x] = find(p[x])\n            return p[x]\n\n        m, n = len(grid), len(grid[0])\n        p = list(range(m * n))\n        for i in range(m):\n            for j in range(n):\n                for a, b in [[0, 1], [1, 0]]:\n                    x, y = i + a, j + b\n                    if x < m and y < n and grid[x][y] == grid[i][j]:\n                        if find(x * n + y) == find(i * n + j):\n                            return True\n                        p[find(x * n + y)] = find(i * n + j)\n        return False\n<|eot_id|>",
    "model_generation": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nGiven a 2D array of characters `grid` of size `m x n`, you need to find if there exists any cycle consisting of the **same value** in `grid`.\n\n\nA cycle is a path of **length 4 or more** in the grid that starts and ends at the same cell. From a given cell, you can move to one of the cells adjacent to it - in one of the four directions (up, down, left, or right), if it has the **same value** of the current cell.\n\n\nAlso, you cannot move to the cell that you visited in your last move. For example, the cycle `(1, 1) -> (1, 2) -> (1, 1)` is invalid because from `(1, 2)` we visited `(1, 1)` which was the last visited cell.\n\n\nReturn `true` if any cycle of the same value exists in `grid`, otherwise, return `false`.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n**![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1500-1599/1559.Detect%20Cycles%20in%202D%20Grid/images/1.png)**\n\n\n\n```\n\n**Input:** grid = [[\"a\",\"a\",\"a\",\"a\"],[\"a\",\"b\",\"b\",\"a\"],[\"a\",\"b\",\"b\",\"a\"],[\"a\",\"a\",\"a\",\"a\"]]\n**Output:** true\n**Explanation:** There are two valid cycles shown in different colors in the image below:\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1500-1599/1559.Detect%20Cycles%20in%202D%20Grid/images/11.png)\n\n```\n\n**Example 2:**\n\n\n**![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1500-1599/1559.Detect%20Cycles%20in%202D%20Grid/images/22.png)**\n\n\n\n```\n\n**Input:** grid = [[\"c\",\"c\",\"c\",\"a\"],[\"c\",\"d\",\"c\",\"c\"],[\"c\",\"c\",\"e\",\"c\"],[\"f\",\"c\",\"c\",\"c\"]]\n**Output:** true\n**Explanation:** There is only one valid cycle highlighted in the image below:\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1500-1599/1559.Detect%20Cycles%20in%202D%20Grid/images/2.png)\n\n```\n\n**Example 3:**\n\n\n**![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1500-1599/1559.Detect%20Cycles%20in%202D%20Grid/images/3.png)**\n\n\n\n```\n\n**Input:** grid = [[\"a\",\"b\",\"b\"],[\"b\",\"z\",\"b\"],[\"b\",\"b\",\"a\"]]\n**Output:** false\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `m == grid.length`\n* `n == grid[i].length`\n* `1 <= m, n <= 500`\n* `grid` consists only of lowercase English letters.\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def containsCycle(self, grid):\n        m, n = len(grid), len(grid[0])\n        chars = [[[] for _ in range(n)] for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                chars[i][j] = [grid[i][j]]\n                if i > 0 and grid[i][j] == grid[i-1][j]:\n                    chars[i][j].append(grid[i-1][j])\n                if j > 0 and grid[i][j] == grid[i][j-1]:\n                    chars[i][j].append(grid[i][j-1])\n        for i in range(m):\n            for j in range(n):\n                if len(chars[i][j]) > 2:\n                    for a, b in [[0, 1], [1, 0]]:\n                        x, y = i + a, j + b\n                        if x < m and y < n:\n                            curr = [(i, j)]\n                            while (x, y)!= (i, j):\n                                if grid[x][y] == grid[i][j]:\n                                    curr.append((x, y))\n                                    if (x, y) in curr[:-3]:\n                                        return True\n                                    if x > 0 and grid[x][y] == grid[x-1][y]:\n                                        curr.append((x-1, y))\n                                    if y > 0 and grid[x][y] == grid[x][y-1]:\n                                        curr.append((x, y-1))\n                                    if x < m-1 and grid[x][y] == grid[x+1][y]:\n                                        curr.append((x+1, y))\n                                    if y < n-1 and grid[x][y] == grid[x][y+1]:\n                                        curr.append((x, y+1))\n                                else:\n                                    break\n                                x, y = curr[-1]\n                            else:\n                                return True\n        return False\n\n### Efficient Solution:\nclass Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        def dfs(i: int, j: int, c: str) -> bool:\n            if i < 0 or i >= m or j < 0 or j >= n or grid[i][j]!= c:\n                return False\n            vis[i][j] = True\n            for a, b in [[0, 1], [1, 0], [0, -1], [-1, 0]]:\n                x, y = i + a, j + b\n                if vis[x][y] and (x, y)!= (i, j):\n                    return True\n                if not vis[x][y] and dfs(x, y, c):\n                    return True\n            return False\n\n        m, n = len(grid), len(grid[0])\n        vis = [[False] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if vis[i][j]:\n                    continue\n                if dfs(i, j, grid[i][j]):\n                    return True\n        return False\n",
    "model_solution": "class Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        def dfs(i: int, j: int, c: str) -> bool:\n            if i < 0 or i >= m or j < 0 or j >= n or grid[i][j]!= c:\n                return False\n            vis[i][j] = True\n            for a, b in [[0, 1], [1, 0], [0, -1], [-1, 0]]:\n                x, y = i + a, j + b\n                if vis[x][y] and (x, y)!= (i, j):\n                    return True\n                if not vis[x][y] and dfs(x, y, c):\n                    return True\n            return False\n\n        m, n = len(grid), len(grid[0])\n        vis = [[False] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if vis[i][j]:\n                    continue\n                if dfs(i, j, grid[i][j]):\n                    return True\n        return False"
}