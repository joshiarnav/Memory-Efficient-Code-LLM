{
    "problem_idx": "2577",
    "description": "\nYou are given a `m x n` matrix `grid` consisting of **non-negative** integers where `grid[row][col]` represents the **minimum** time required to be able to visit the cell `(row, col)`, which means you can visit the cell `(row, col)` only when the time you visit it is greater than or equal to `grid[row][col]`.\n\n\nYou are standing in the **top-left** cell of the matrix in the `0th` second, and you must move to **any** adjacent cell in the four directions: up, down, left, and right. Each move you make takes 1 second.\n\n\nReturn *the **minimum** time required in which you can visit the bottom-right cell of the matrix*. If you cannot visit the bottom-right cell, then return `-1`.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2500-2599/2577.Minimum%20Time%20to%20Visit%20a%20Cell%20In%20a%20Grid/images/yetgriddrawio-8.png)\n\n\n\n```\n\n**Input:** grid = [[0,1,3,2],[5,1,2,5],[4,3,8,6]]\n**Output:** 7\n**Explanation:** One of the paths that we can take is the following:\n- at t = 0, we are on the cell (0,0).\n- at t = 1, we move to the cell (0,1). It is possible because grid[0][1] <= 1.\n- at t = 2, we move to the cell (1,1). It is possible because grid[1][1] <= 2.\n- at t = 3, we move to the cell (1,2). It is possible because grid[1][2] <= 3.\n- at t = 4, we move to the cell (1,1). It is possible because grid[1][1] <= 4.\n- at t = 5, we move to the cell (1,2). It is possible because grid[1][2] <= 5.\n- at t = 6, we move to the cell (1,3). It is possible because grid[1][3] <= 6.\n- at t = 7, we move to the cell (2,3). It is possible because grid[2][3] <= 7.\nThe final time is 7. It can be shown that it is the minimum time possible.\n\n```\n\n**Example 2:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2500-2599/2577.Minimum%20Time%20to%20Visit%20a%20Cell%20In%20a%20Grid/images/yetgriddrawio-9.png)\n\n\n\n```\n\n**Input:** grid = [[0,2,4],[3,2,1],[1,0,4]]\n**Output:** -1\n**Explanation:** There is no path from the top left to the bottom-right cell.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `m == grid.length`\n* `n == grid[i].length`\n* `2 <= m, n <= 1000`\n* `4 <= m * n <= 105`\n* `0 <= grid[i][j] <= 105`\n* `grid[0][0] == 0`\n\n\n\u00a0\n\n\n.spoilerbutton {display:block; border:dashed; padding: 0px 0px; margin:10px 0px; font-size:150%; font-weight: bold; color:#000000; background-color:cyan; outline:0; \n}\n.spoiler {overflow:hidden;}\n.spoiler > div {-webkit-transition: all 0s ease;-moz-transition: margin 0s ease;-o-transition: all 0s ease;transition: margin 0s ease;}\n.spoilerbutton[value=\"Show Message\"] + .spoiler > div {margin-top:-500%;}\n.spoilerbutton[value=\"Hide Message\"] + .spoiler {padding:5px;}\n\n",
    "inefficient_solution": "class Solution:\n    def minimumTime(self, grid: List[List[int]]) -> int:\n        if grid[0][1] > 1 and grid[1][0] > 1:\n            return -1\n        m, n = len(grid), len(grid[0])\n        dist = [[[inf] * 5000 for _ in range(n)] for _ in range(m)]\n        dist[0][0] = 0\n        q = [(0, 0, 0, 0)]\n        dirs = [-1, 0, 1, 0, -1]\n        while q:\n            t, i, j, idx = q.pop(0)\n            if i == m - 1 and j == n - 1:\n                return t\n            for a, b in pairwise(dirs):\n                x, y = i + a, j + b\n                if 0 <= x < m and 0 <= y < n:\n                    nt = t + 1\n                    if nt < grid[x][y]:\n                        nt = grid[x][y] + (grid[x][y] - nt) % 2\n                    if nt < dist[x][y][idx]:\n                        dist[x][y][idx] = nt\n                        q.append((nt, x, y, idx))\n                    if idx < 4999:\n                        q.append((nt, x, y, idx + 1))",
    "efficient_solution": "class Solution:\n    def minimumTime(self, grid: List[List[int]]) -> int:\n        if grid[0][1] > 1 and grid[1][0] > 1:\n            return -1\n        m, n = len(grid), len(grid[0])\n        dist = [[inf] * n for _ in range(m)]\n        dist[0][0] = 0\n        q = [(0, 0, 0)]\n        dirs = (-1, 0, 1, 0, -1)\n        while 1:\n            t, i, j = heappop(q)\n            if i == m - 1 and j == n - 1:\n                return t\n            for a, b in pairwise(dirs):\n                x, y = i + a, j + b\n                if 0 <= x < m and 0 <= y < n:\n                    nt = t + 1\n                    if nt < grid[x][y]:\n                        nt = grid[x][y] + (grid[x][y] - nt) % 2\n                    if nt < dist[x][y]:\n                        dist[x][y] = nt\n                        heappush(q, (nt, x, y))\n",
    "text": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nYou are given a `m x n` matrix `grid` consisting of **non-negative** integers where `grid[row][col]` represents the **minimum** time required to be able to visit the cell `(row, col)`, which means you can visit the cell `(row, col)` only when the time you visit it is greater than or equal to `grid[row][col]`.\n\n\nYou are standing in the **top-left** cell of the matrix in the `0th` second, and you must move to **any** adjacent cell in the four directions: up, down, left, and right. Each move you make takes 1 second.\n\n\nReturn *the **minimum** time required in which you can visit the bottom-right cell of the matrix*. If you cannot visit the bottom-right cell, then return `-1`.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2500-2599/2577.Minimum%20Time%20to%20Visit%20a%20Cell%20In%20a%20Grid/images/yetgriddrawio-8.png)\n\n\n\n```\n\n**Input:** grid = [[0,1,3,2],[5,1,2,5],[4,3,8,6]]\n**Output:** 7\n**Explanation:** One of the paths that we can take is the following:\n- at t = 0, we are on the cell (0,0).\n- at t = 1, we move to the cell (0,1). It is possible because grid[0][1] <= 1.\n- at t = 2, we move to the cell (1,1). It is possible because grid[1][1] <= 2.\n- at t = 3, we move to the cell (1,2). It is possible because grid[1][2] <= 3.\n- at t = 4, we move to the cell (1,1). It is possible because grid[1][1] <= 4.\n- at t = 5, we move to the cell (1,2). It is possible because grid[1][2] <= 5.\n- at t = 6, we move to the cell (1,3). It is possible because grid[1][3] <= 6.\n- at t = 7, we move to the cell (2,3). It is possible because grid[2][3] <= 7.\nThe final time is 7. It can be shown that it is the minimum time possible.\n\n```\n\n**Example 2:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2500-2599/2577.Minimum%20Time%20to%20Visit%20a%20Cell%20In%20a%20Grid/images/yetgriddrawio-9.png)\n\n\n\n```\n\n**Input:** grid = [[0,2,4],[3,2,1],[1,0,4]]\n**Output:** -1\n**Explanation:** There is no path from the top left to the bottom-right cell.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `m == grid.length`\n* `n == grid[i].length`\n* `2 <= m, n <= 1000`\n* `4 <= m * n <= 105`\n* `0 <= grid[i][j] <= 105`\n* `grid[0][0] == 0`\n\n\n\u00a0\n\n\n.spoilerbutton {display:block; border:dashed; padding: 0px 0px; margin:10px 0px; font-size:150%; font-weight: bold; color:#000000; background-color:cyan; outline:0; \n}\n.spoiler {overflow:hidden;}\n.spoiler > div {-webkit-transition: all 0s ease;-moz-transition: margin 0s ease;-o-transition: all 0s ease;transition: margin 0s ease;}\n.spoilerbutton[value=\"Show Message\"] + .spoiler > div {margin-top:-500%;}\n.spoilerbutton[value=\"Hide Message\"] + .spoiler {padding:5px;}\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def minimumTime(self, grid: List[List[int]]) -> int:\n        if grid[0][1] > 1 and grid[1][0] > 1:\n            return -1\n        m, n = len(grid), len(grid[0])\n        dist = [[[inf] * 5000 for _ in range(n)] for _ in range(m)]\n        dist[0][0] = 0\n        q = [(0, 0, 0, 0)]\n        dirs = [-1, 0, 1, 0, -1]\n        while q:\n            t, i, j, idx = q.pop(0)\n            if i == m - 1 and j == n - 1:\n                return t\n            for a, b in pairwise(dirs):\n                x, y = i + a, j + b\n                if 0 <= x < m and 0 <= y < n:\n                    nt = t + 1\n                    if nt < grid[x][y]:\n                        nt = grid[x][y] + (grid[x][y] - nt) % 2\n                    if nt < dist[x][y][idx]:\n                        dist[x][y][idx] = nt\n                        q.append((nt, x, y, idx))\n                    if idx < 4999:\n                        q.append((nt, x, y, idx + 1))\n\n### Efficient Solution:\nclass Solution:\n    def minimumTime(self, grid: List[List[int]]) -> int:\n        if grid[0][1] > 1 and grid[1][0] > 1:\n            return -1\n        m, n = len(grid), len(grid[0])\n        dist = [[inf] * n for _ in range(m)]\n        dist[0][0] = 0\n        q = [(0, 0, 0)]\n        dirs = (-1, 0, 1, 0, -1)\n        while 1:\n            t, i, j = heappop(q)\n            if i == m - 1 and j == n - 1:\n                return t\n            for a, b in pairwise(dirs):\n                x, y = i + a, j + b\n                if 0 <= x < m and 0 <= y < n:\n                    nt = t + 1\n                    if nt < grid[x][y]:\n                        nt = grid[x][y] + (grid[x][y] - nt) % 2\n                    if nt < dist[x][y]:\n                        dist[x][y] = nt\n                        heappush(q, (nt, x, y))\n<|eot_id|>",
    "model_generation": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nYou are given a `m x n` matrix `grid` consisting of **non-negative** integers where `grid[row][col]` represents the **minimum** time required to be able to visit the cell `(row, col)`, which means you can visit the cell `(row, col)` only when the time you visit it is greater than or equal to `grid[row][col]`.\n\n\nYou are standing in the **top-left** cell of the matrix in the `0th` second, and you must move to **any** adjacent cell in the four directions: up, down, left, and right. Each move you make takes 1 second.\n\n\nReturn *the **minimum** time required in which you can visit the bottom-right cell of the matrix*. If you cannot visit the bottom-right cell, then return `-1`.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2500-2599/2577.Minimum%20Time%20to%20Visit%20a%20Cell%20In%20a%20Grid/images/yetgriddrawio-8.png)\n\n\n\n```\n\n**Input:** grid = [[0,1,3,2],[5,1,2,5],[4,3,8,6]]\n**Output:** 7\n**Explanation:** One of the paths that we can take is the following:\n- at t = 0, we are on the cell (0,0).\n- at t = 1, we move to the cell (0,1). It is possible because grid[0][1] <= 1.\n- at t = 2, we move to the cell (1,1). It is possible because grid[1][1] <= 2.\n- at t = 3, we move to the cell (1,2). It is possible because grid[1][2] <= 3.\n- at t = 4, we move to the cell (1,1). It is possible because grid[1][1] <= 4.\n- at t = 5, we move to the cell (1,2). It is possible because grid[1][2] <= 5.\n- at t = 6, we move to the cell (1,3). It is possible because grid[1][3] <= 6.\n- at t = 7, we move to the cell (2,3). It is possible because grid[2][3] <= 7.\nThe final time is 7. It can be shown that it is the minimum time possible.\n\n```\n\n**Example 2:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2500-2599/2577.Minimum%20Time%20to%20Visit%20a%20Cell%20In%20a%20Grid/images/yetgriddrawio-9.png)\n\n\n\n```\n\n**Input:** grid = [[0,2,4],[3,2,1],[1,0,4]]\n**Output:** -1\n**Explanation:** There is no path from the top left to the bottom-right cell.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `m == grid.length`\n* `n == grid[i].length`\n* `2 <= m, n <= 1000`\n* `4 <= m * n <= 105`\n* `0 <= grid[i][j] <= 105`\n* `grid[0][0] == 0`\n\n\n\u00a0\n\n\n.spoilerbutton {display:block; border:dashed; padding: 0px 0px; margin:10px 0px; font-size:150%; font-weight: bold; color:#000000; background-color:cyan; outline:0; \n}\n.spoiler {overflow:hidden;}\n.spoiler > div {-webkit-transition: all 0s ease;-moz-transition: margin 0s ease;-o-transition: all 0s ease;transition: margin 0s ease;}\n.spoilerbutton[value=\"Show Message\"] +.spoiler > div {margin-top:-500%;}\n.spoilerbutton[value=\"Hide Message\"] +.spoiler {padding:5px;}\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def minimumTime(self, grid: List[List[int]]) -> int:\n        if grid[0][1] > 1 and grid[1][0] > 1:\n            return -1\n        m, n = len(grid), len(grid[0])\n        dist = [[[inf] * 5000 for _ in range(n)] for _ in range(m)]\n        dist[0][0] = 0\n        q = [(0, 0, 0, 0)]\n        dirs = [-1, 0, 1, 0, -1]\n        while q:\n            t, i, j, idx = q.pop(0)\n            if i == m - 1 and j == n - 1:\n                return t\n            for a, b in pairwise(dirs):\n                x, y = i + a, j + b\n                if 0 <= x < m and 0 <= y < n:\n                    nt = t + 1\n                    if nt < grid[x][y]:\n                        nt = grid[x][y] + (grid[x][y] - nt) % 2\n                    if nt < dist[x][y][idx]:\n                        dist[x][y][idx] = nt\n                        q.append((nt, x, y, idx))\n                    if idx < 4999:\n                        q.append((nt, x, y, idx + 1))\n\n### Efficient Solution:\nclass Solution:\n    def minimumTime(self, grid: List[List[int]]) -> int:\n        if grid[0][1] > 1 and grid[1][0] > 1:\n            return -1\n        m, n = len(grid), len(grid[0])\n        dist = [[[inf] * 2 for _ in range(n)] for _ in range(m)]\n        dist[0][0] = 0\n        q = deque([(0, 0, 0)])\n        dirs = (-1, 0, 1, 0, -1)\n        while q:\n            t, i, j = q.popleft()\n            if i == m - 1 and j == n - 1:\n                return t\n            for a, b in pairwise(dirs):\n                x, y = i + a, j + b\n                if 0 <= x < m and 0 <= y < n:\n                    nt = t + 1\n                    if nt < grid[x][y]:\n                        nt = grid[x][y] + (grid[x][y] - nt) % 2\n                    if nt < dist[x][y][t % 2]:\n                        dist[x][y][t % 2] = nt\n                        q.append((nt, x, y))\n",
    "model_solution": "class Solution:\n    def minimumTime(self, grid: List[List[int]]) -> int:\n        if grid[0][1] > 1 and grid[1][0] > 1:\n            return -1\n        m, n = len(grid), len(grid[0])\n        dist = [[[inf] * 2 for _ in range(n)] for _ in range(m)]\n        dist[0][0] = 0\n        q = deque([(0, 0, 0)])\n        dirs = (-1, 0, 1, 0, -1)\n        while q:\n            t, i, j = q.popleft()\n            if i == m - 1 and j == n - 1:\n                return t\n            for a, b in pairwise(dirs):\n                x, y = i + a, j + b\n                if 0 <= x < m and 0 <= y < n:\n                    nt = t + 1\n                    if nt < grid[x][y]:\n                        nt = grid[x][y] + (grid[x][y] - nt) % 2\n                    if nt < dist[x][y][t % 2]:\n                        dist[x][y][t % 2] = nt\n                        q.append((nt, x, y))"
}