{
    "problem_idx": "696",
    "description": "\nGiven a binary string `s`, return the number of non-empty substrings that have the same number of `0`'s and `1`'s, and all the `0`'s and all the `1`'s in these substrings are grouped consecutively.\n\n\nSubstrings that occur multiple times are counted the number of times they occur.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** s = \"00110011\"\n**Output:** 6\n**Explanation:** There are 6 substrings that have equal number of consecutive 1's and 0's: \"0011\", \"01\", \"1100\", \"10\", \"0011\", and \"01\".\nNotice that some of these substrings repeat and are counted the number of times they occur.\nAlso, \"00110011\" is not a valid substring because all the 0's (and 1's) are not grouped together.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** s = \"10101\"\n**Output:** 4\n**Explanation:** There are 4 substrings: \"10\", \"01\", \"10\", \"01\" that have equal number of consecutive 1's and 0's.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= s.length <= 105`\n* `s[i]` is either `'0'` or `'1'`.\n\n\n",
    "inefficient_solution": "class Solution:\n    def countBinarySubstrings(self, s: str) -> int:\n        i, n = 0, len(s)\n        t = []\n        while i < n:\n            cnt = 1\n            while i + 1 < n and s[i + 1] == s[i]:\n                cnt += 1\n                i += 1\n            temp = [s[i - cnt + 1:i + 1]] * cnt\n            t.extend(temp)\n            i += 1\n        t = [x for x in t if x != '']\n        ans = 0\n        for i in range(1, len(t)):\n            if len(t[i]) != len(t[i - 1]):\n                continue\n            ans += min(t[i - 1], t[i])\n        return ans",
    "efficient_solution": "class Solution:\n    def countBinarySubstrings(self, s: str) -> int:\n        i, n = 0, len(s)\n        t = []\n        while i < n:\n            cnt = 1\n            while i + 1 < n and s[i + 1] == s[i]:\n                cnt += 1\n                i += 1\n            t.append(cnt)\n            i += 1\n        ans = 0\n        for i in range(1, len(t)):\n            ans += min(t[i - 1], t[i])\n        return ans\n",
    "text": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nGiven a binary string `s`, return the number of non-empty substrings that have the same number of `0`'s and `1`'s, and all the `0`'s and all the `1`'s in these substrings are grouped consecutively.\n\n\nSubstrings that occur multiple times are counted the number of times they occur.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** s = \"00110011\"\n**Output:** 6\n**Explanation:** There are 6 substrings that have equal number of consecutive 1's and 0's: \"0011\", \"01\", \"1100\", \"10\", \"0011\", and \"01\".\nNotice that some of these substrings repeat and are counted the number of times they occur.\nAlso, \"00110011\" is not a valid substring because all the 0's (and 1's) are not grouped together.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** s = \"10101\"\n**Output:** 4\n**Explanation:** There are 4 substrings: \"10\", \"01\", \"10\", \"01\" that have equal number of consecutive 1's and 0's.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= s.length <= 105`\n* `s[i]` is either `'0'` or `'1'`.\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def countBinarySubstrings(self, s: str) -> int:\n        i, n = 0, len(s)\n        t = []\n        while i < n:\n            cnt = 1\n            while i + 1 < n and s[i + 1] == s[i]:\n                cnt += 1\n                i += 1\n            temp = [s[i - cnt + 1:i + 1]] * cnt\n            t.extend(temp)\n            i += 1\n        t = [x for x in t if x != '']\n        ans = 0\n        for i in range(1, len(t)):\n            if len(t[i]) != len(t[i - 1]):\n                continue\n            ans += min(t[i - 1], t[i])\n        return ans\n\n### Efficient Solution:\nclass Solution:\n    def countBinarySubstrings(self, s: str) -> int:\n        i, n = 0, len(s)\n        t = []\n        while i < n:\n            cnt = 1\n            while i + 1 < n and s[i + 1] == s[i]:\n                cnt += 1\n                i += 1\n            t.append(cnt)\n            i += 1\n        ans = 0\n        for i in range(1, len(t)):\n            ans += min(t[i - 1], t[i])\n        return ans\n<|eot_id|>",
    "model_generation": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nGiven a binary string `s`, return the number of non-empty substrings that have the same number of `0`'s and `1`'s, and all the `0`'s and all the `1`'s in these substrings are grouped consecutively.\n\n\nSubstrings that occur multiple times are counted the number of times they occur.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** s = \"00110011\"\n**Output:** 6\n**Explanation:** There are 6 substrings that have equal number of consecutive 1's and 0's: \"0011\", \"01\", \"1100\", \"10\", \"0011\", and \"01\".\nNotice that some of these substrings repeat and are counted the number of times they occur.\nAlso, \"00110011\" is not a valid substring because all the 0's (and 1's) are not grouped together.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** s = \"10101\"\n**Output:** 4\n**Explanation:** There are 4 substrings: \"10\", \"01\", \"10\", \"01\" that have equal number of consecutive 1's and 0's.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= s.length <= 105`\n* `s[i]` is either `'0'` or `'1'`.\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def countBinarySubstrings(self, s: str) -> int:\n        i, n = 0, len(s)\n        t = []\n        while i < n:\n            cnt = 1\n            while i + 1 < n and s[i + 1] == s[i]:\n                cnt += 1\n                i += 1\n            temp = [s[i - cnt + 1:i + 1]] * cnt\n            t.extend(temp)\n            i += 1\n        t = [x for x in t if x!= '']\n        ans = 0\n        for i in range(1, len(t)):\n            if len(t[i])!= len(t[i - 1]):\n                continue\n            ans += min(t[i - 1], t[i])\n        return ans\n\n### Efficient Solution:\nclass Solution:\n    def countBinarySubstrings(self, s: str) -> int:\n        i, n = 0, len(s)\n        t = []\n        while i < n:\n            cnt = 1\n            while i + 1 < n and s[i + 1] == s[i]:\n                cnt += 1\n                i += 1\n            t.append(cnt)\n            i += 1\n        ans = 0\n        i = 1\n        while i < len(t):\n            ans += min(t[i - 1], t[i])\n            i += 2\n        return ans\n",
    "model_solution": "class Solution:\n    def countBinarySubstrings(self, s: str) -> int:\n        i, n = 0, len(s)\n        t = []\n        while i < n:\n            cnt = 1\n            while i + 1 < n and s[i + 1] == s[i]:\n                cnt += 1\n                i += 1\n            t.append(cnt)\n            i += 1\n        ans = 0\n        i = 1\n        while i < len(t):\n            ans += min(t[i - 1], t[i])\n            i += 2\n        return ans"
}