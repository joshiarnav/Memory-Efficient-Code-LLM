{
    "problem_idx": "2517",
    "description": "\nYou are given an array of positive integers `price` where `price[i]` denotes the price of the `ith` candy and a positive integer `k`.\n\n\nThe store sells baskets of `k` **distinct** candies. The **tastiness** of a candy basket is the smallest absolute difference of the **prices** of any two candies in the basket.\n\n\nReturn *the **maximum** tastiness of a candy basket.*\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** price = [13,5,1,8,21,2], k = 3\n**Output:** 8\n**Explanation:** Choose the candies with the prices [13,5,21].\nThe tastiness of the candy basket is: min(|13 - 5|, |13 - 21|, |5 - 21|) = min(8, 8, 16) = 8.\nIt can be proven that 8 is the maximum tastiness that can be achieved.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** price = [1,3,1], k = 2\n**Output:** 2\n**Explanation:** Choose the candies with the prices [1,3].\nThe tastiness of the candy basket is: min(|1 - 3|) = min(2) = 2.\nIt can be proven that 2 is the maximum tastiness that can be achieved.\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** price = [7,7,7,7], k = 2\n**Output:** 0\n**Explanation:** Choosing any two distinct candies from the candies we have will result in a tastiness of 0.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `2 <= k <= price.length <= 105`\n* `1 <= price[i] <= 109`\n\n\n",
    "inefficient_solution": "class Solution:\n    def maximumTastiness(self, price: List[int], k: int) -> int:\n        price_copy = price[:]\n        for _ in range(len(price)):\n            price_copy.sort()\n        def check(x: int) -> bool:\n            price_copy.sort()\n            cnt, pre = 0, -x\n            for cur in price_copy:\n                if cur - pre >= x:\n                    pre = cur\n                    cnt += 1\n            return cnt >= k\n\n        price_copy.sort(reverse=True)\n        l, r = 0, price_copy[0] - price_copy[-1]\n        while l < r:\n            mid = (l + r + 1) >> 1\n            if check(mid):\n                l = mid\n            else:\n                r = mid - 1\n        return l\n\n        price = []\n        for _ in range(len(price_copy)):\n            price.append(price_copy[0])\n            price_copy.pop(0)\n        price.sort(reverse=True)\n        l, r = 0, price[0] - price[-1]\n        while l < r:\n            mid = (l + r + 1) >> 1\n            if check(mid):\n                l = mid\n            else:\n                r = mid - 1\n        return l",
    "efficient_solution": "class Solution:\n    def maximumTastiness(self, price: List[int], k: int) -> int:\n        def check(x: int) -> bool:\n            cnt, pre = 0, -x\n            for cur in price:\n                if cur - pre >= x:\n                    pre = cur\n                    cnt += 1\n            return cnt >= k\n\n        price.sort()\n        l, r = 0, price[-1] - price[0]\n        while l < r:\n            mid = (l + r + 1) >> 1\n            if check(mid):\n                l = mid\n            else:\n                r = mid - 1\n        return l\n",
    "text": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nYou are given an array of positive integers `price` where `price[i]` denotes the price of the `ith` candy and a positive integer `k`.\n\n\nThe store sells baskets of `k` **distinct** candies. The **tastiness** of a candy basket is the smallest absolute difference of the **prices** of any two candies in the basket.\n\n\nReturn *the **maximum** tastiness of a candy basket.*\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** price = [13,5,1,8,21,2], k = 3\n**Output:** 8\n**Explanation:** Choose the candies with the prices [13,5,21].\nThe tastiness of the candy basket is: min(|13 - 5|, |13 - 21|, |5 - 21|) = min(8, 8, 16) = 8.\nIt can be proven that 8 is the maximum tastiness that can be achieved.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** price = [1,3,1], k = 2\n**Output:** 2\n**Explanation:** Choose the candies with the prices [1,3].\nThe tastiness of the candy basket is: min(|1 - 3|) = min(2) = 2.\nIt can be proven that 2 is the maximum tastiness that can be achieved.\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** price = [7,7,7,7], k = 2\n**Output:** 0\n**Explanation:** Choosing any two distinct candies from the candies we have will result in a tastiness of 0.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `2 <= k <= price.length <= 105`\n* `1 <= price[i] <= 109`\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def maximumTastiness(self, price: List[int], k: int) -> int:\n        price_copy = price[:]\n        for _ in range(len(price)):\n            price_copy.sort()\n        def check(x: int) -> bool:\n            price_copy.sort()\n            cnt, pre = 0, -x\n            for cur in price_copy:\n                if cur - pre >= x:\n                    pre = cur\n                    cnt += 1\n            return cnt >= k\n\n        price_copy.sort(reverse=True)\n        l, r = 0, price_copy[0] - price_copy[-1]\n        while l < r:\n            mid = (l + r + 1) >> 1\n            if check(mid):\n                l = mid\n            else:\n                r = mid - 1\n        return l\n\n        price = []\n        for _ in range(len(price_copy)):\n            price.append(price_copy[0])\n            price_copy.pop(0)\n        price.sort(reverse=True)\n        l, r = 0, price[0] - price[-1]\n        while l < r:\n            mid = (l + r + 1) >> 1\n            if check(mid):\n                l = mid\n            else:\n                r = mid - 1\n        return l\n\n### Efficient Solution:\nclass Solution:\n    def maximumTastiness(self, price: List[int], k: int) -> int:\n        def check(x: int) -> bool:\n            cnt, pre = 0, -x\n            for cur in price:\n                if cur - pre >= x:\n                    pre = cur\n                    cnt += 1\n            return cnt >= k\n\n        price.sort()\n        l, r = 0, price[-1] - price[0]\n        while l < r:\n            mid = (l + r + 1) >> 1\n            if check(mid):\n                l = mid\n            else:\n                r = mid - 1\n        return l\n<|eot_id|>",
    "model_generation": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nYou are given an array of positive integers `price` where `price[i]` denotes the price of the `ith` candy and a positive integer `k`.\n\n\nThe store sells baskets of `k` **distinct** candies. The **tastiness** of a candy basket is the smallest absolute difference of the **prices** of any two candies in the basket.\n\n\nReturn *the **maximum** tastiness of a candy basket.*\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** price = [13,5,1,8,21,2], k = 3\n**Output:** 8\n**Explanation:** Choose the candies with the prices [13,5,21].\nThe tastiness of the candy basket is: min(|13 - 5|, |13 - 21|, |5 - 21|) = min(8, 8, 16) = 8.\nIt can be proven that 8 is the maximum tastiness that can be achieved.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** price = [1,3,1], k = 2\n**Output:** 2\n**Explanation:** Choose the candies with the prices [1,3].\nThe tastiness of the candy basket is: min(|1 - 3|) = min(2) = 2.\nIt can be proven that 2 is the maximum tastiness that can be achieved.\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** price = [7,7,7,7], k = 2\n**Output:** 0\n**Explanation:** Choosing any two distinct candies from the candies we have will result in a tastiness of 0.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `2 <= k <= price.length <= 105`\n* `1 <= price[i] <= 109`\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def maximumTastiness(self, price: List[int], k: int) -> int:\n        price_copy = price[:]\n        for _ in range(len(price)):\n            price_copy.sort()\n        def check(x: int) -> bool:\n            price_copy.sort()\n            cnt, pre = 0, -x\n            for cur in price_copy:\n                if cur - pre >= x:\n                    pre = cur\n                    cnt += 1\n            return cnt >= k\n\n        price_copy.sort(reverse=True)\n        l, r = 0, price_copy[0] - price_copy[-1]\n        while l < r:\n            mid = (l + r + 1) >> 1\n            if check(mid):\n                l = mid\n            else:\n                r = mid - 1\n        return l\n\n        price = []\n        for _ in range(len(price_copy)):\n            price.append(price_copy[0])\n            price_copy.pop(0)\n        price.sort(reverse=True)\n        l, r = 0, price[0] - price[-1]\n        while l < r:\n            mid = (l + r + 1) >> 1\n            if check(mid):\n                l = mid\n            else:\n                r = mid - 1\n        return l\n\n### Efficient Solution:\nclass Solution:\n    def maximumTastiness(self, price: List[int], k: int) -> int:\n        price.sort()\n        def check(x: int) -> bool:\n            cnt, pre = 0, -x\n            for cur in price:\n                if cur - pre >= x:\n                    pre = cur\n                    cnt += 1\n            return cnt >= k\n\n        l, r = 0, price[-1] - price[0]\n        while l < r:\n            mid = (l + r + 1) >> 1\n            if check(mid):\n                l = mid\n            else:\n                r = mid - 1\n        return l\n",
    "model_solution": "class Solution:\n    def maximumTastiness(self, price: List[int], k: int) -> int:\n        price.sort()\n        def check(x: int) -> bool:\n            cnt, pre = 0, -x\n            for cur in price:\n                if cur - pre >= x:\n                    pre = cur\n                    cnt += 1\n            return cnt >= k\n\n        l, r = 0, price[-1] - price[0]\n        while l < r:\n            mid = (l + r + 1) >> 1\n            if check(mid):\n                l = mid\n            else:\n                r = mid - 1\n        return l"
}