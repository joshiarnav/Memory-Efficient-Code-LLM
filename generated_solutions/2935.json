{
    "problem_idx": "2935",
    "description": "\nYou are given a **0-indexed** integer array `nums`. A pair of integers `x` and `y` is called a **strong** pair if it satisfies the condition:\n\n\n* `|x - y| <= min(x, y)`\n\n\nYou need to select two integers from `nums` such that they form a strong pair and their bitwise `XOR` is the **maximum** among all strong pairs in the array.\n\n\nReturn *the **maximum*** `XOR` *value out of all possible strong pairs in the array* `nums`.\n\n\n**Note** that you can pick the same integer twice to form a pair.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** nums = [1,2,3,4,5]\n**Output:** 7\n**Explanation:** There are 11 strong pairs in the array nums: (1, 1), (1, 2), (2, 2), (2, 3), (2, 4), (3, 3), (3, 4), (3, 5), (4, 4), (4, 5) and (5, 5).\nThe maximum XOR possible from these pairs is 3 XOR 4 = 7.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** nums = [10,100]\n**Output:** 0\n**Explanation:** There are 2 strong pairs in the array nums: (10, 10) and (100, 100).\nThe maximum XOR possible from these pairs is 10 XOR 10 = 0 since the pair (100, 100) also gives 100 XOR 100 = 0.\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** nums = [500,520,2500,3000]\n**Output:** 1020\n**Explanation:** There are 6 strong pairs in the array nums: (500, 500), (500, 520), (520, 520), (2500, 2500), (2500, 3000) and (3000, 3000).\nThe maximum XOR possible from these pairs is 500 XOR 520 = 1020 since the only other non-zero XOR value is 2500 XOR 3000 = 636.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= nums.length <= 5 * 104`\n* `1 <= nums[i] <= 220 - 1`\n\n\n",
    "inefficient_solution": "class Solution:\n    def maximumStrongPairXor(self, nums: List[int]) -> int:\n        nums.sort()\n        trie = []\n        for _ in range(len(nums)**2):\n            trie.append([None, None])\n        ans = i = 0\n        for y in nums:\n            self.insert(trie, y)\n            while y > nums[i] * 2:\n                self.remove(trie, nums[i])\n                i += 1\n            ans = max(ans, self.search(trie, y))\n        return ans\n\n    def insert(self, trie: List[List], x: int):\n        for i in range(20, -1, -1):\n            v = x >> i & 1\n            if trie[-len(nums) + i][v] is None:\n                trie[-len(nums) + i][v] = []\n            trie = trie[-len(nums) + i][v]\n            trie.append([])\n\n    def remove(self, trie: List[List], x: int):\n        for i in range(20, -1, -1):\n            v = x >> i & 1\n            trie[-len(nums) + i] = trie[-len(nums) + i][v]\n\n    def search(self, trie: List[List], x: int) -> int:\n        ans = 0\n        for i in range(20, -1, -1):\n            v = x >> i & 1\n            if trie[-len(nums) + i][v ^ 1]:\n                ans |= 1 << i\n                trie = trie[-len(nums) + i][v ^ 1]\n            else:\n                trie = trie[-len(nums) + i][v]\n        return ans",
    "efficient_solution": "class Trie:\n    __slots__ = (\"children\", \"cnt\")\n\n    def __init__(self):\n        self.children: List[Trie | None] = [None, None]\n        self.cnt = 0\n\n    def insert(self, x: int):\n        node = self\n        for i in range(20, -1, -1):\n            v = x >> i & 1\n            if node.children[v] is None:\n                node.children[v] = Trie()\n            node = node.children[v]\n            node.cnt += 1\n\n    def search(self, x: int) -> int:\n        node = self\n        ans = 0\n        for i in range(20, -1, -1):\n            v = x >> i & 1\n            if node.children[v ^ 1] and node.children[v ^ 1].cnt:\n                ans |= 1 << i\n                node = node.children[v ^ 1]\n            else:\n                node = node.children[v]\n        return ans\n\n    def remove(self, x: int):\n        node = self\n        for i in range(20, -1, -1):\n            v = x >> i & 1\n            node = node.children[v]\n            node.cnt -= 1\n\n\nclass Solution:\n    def maximumStrongPairXor(self, nums: List[int]) -> int:\n        nums.sort()\n        tree = Trie()\n        ans = i = 0\n        for y in nums:\n            tree.insert(y)\n            while y > nums[i] * 2:\n                tree.remove(nums[i])\n                i += 1\n            ans = max(ans, tree.search(y))\n        return ans\n",
    "text": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nYou are given a **0-indexed** integer array `nums`. A pair of integers `x` and `y` is called a **strong** pair if it satisfies the condition:\n\n\n* `|x - y| <= min(x, y)`\n\n\nYou need to select two integers from `nums` such that they form a strong pair and their bitwise `XOR` is the **maximum** among all strong pairs in the array.\n\n\nReturn *the **maximum*** `XOR` *value out of all possible strong pairs in the array* `nums`.\n\n\n**Note** that you can pick the same integer twice to form a pair.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** nums = [1,2,3,4,5]\n**Output:** 7\n**Explanation:** There are 11 strong pairs in the array nums: (1, 1), (1, 2), (2, 2), (2, 3), (2, 4), (3, 3), (3, 4), (3, 5), (4, 4), (4, 5) and (5, 5).\nThe maximum XOR possible from these pairs is 3 XOR 4 = 7.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** nums = [10,100]\n**Output:** 0\n**Explanation:** There are 2 strong pairs in the array nums: (10, 10) and (100, 100).\nThe maximum XOR possible from these pairs is 10 XOR 10 = 0 since the pair (100, 100) also gives 100 XOR 100 = 0.\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** nums = [500,520,2500,3000]\n**Output:** 1020\n**Explanation:** There are 6 strong pairs in the array nums: (500, 500), (500, 520), (520, 520), (2500, 2500), (2500, 3000) and (3000, 3000).\nThe maximum XOR possible from these pairs is 500 XOR 520 = 1020 since the only other non-zero XOR value is 2500 XOR 3000 = 636.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= nums.length <= 5 * 104`\n* `1 <= nums[i] <= 220 - 1`\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def maximumStrongPairXor(self, nums: List[int]) -> int:\n        nums.sort()\n        trie = []\n        for _ in range(len(nums)**2):\n            trie.append([None, None])\n        ans = i = 0\n        for y in nums:\n            self.insert(trie, y)\n            while y > nums[i] * 2:\n                self.remove(trie, nums[i])\n                i += 1\n            ans = max(ans, self.search(trie, y))\n        return ans\n\n    def insert(self, trie: List[List], x: int):\n        for i in range(20, -1, -1):\n            v = x >> i & 1\n            if trie[-len(nums) + i][v] is None:\n                trie[-len(nums) + i][v] = []\n            trie = trie[-len(nums) + i][v]\n            trie.append([])\n\n    def remove(self, trie: List[List], x: int):\n        for i in range(20, -1, -1):\n            v = x >> i & 1\n            trie[-len(nums) + i] = trie[-len(nums) + i][v]\n\n    def search(self, trie: List[List], x: int) -> int:\n        ans = 0\n        for i in range(20, -1, -1):\n            v = x >> i & 1\n            if trie[-len(nums) + i][v ^ 1]:\n                ans |= 1 << i\n                trie = trie[-len(nums) + i][v ^ 1]\n            else:\n                trie = trie[-len(nums) + i][v]\n        return ans\n\n### Efficient Solution:\nclass Trie:\n    __slots__ = (\"children\", \"cnt\")\n\n    def __init__(self):\n        self.children: List[Trie | None] = [None, None]\n        self.cnt = 0\n\n    def insert(self, x: int):\n        node = self\n        for i in range(20, -1, -1):\n            v = x >> i & 1\n            if node.children[v] is None:\n                node.children[v] = Trie()\n            node = node.children[v]\n            node.cnt += 1\n\n    def search(self, x: int) -> int:\n        node = self\n        ans = 0\n        for i in range(20, -1, -1):\n            v = x >> i & 1\n            if node.children[v ^ 1] and node.children[v ^ 1].cnt:\n                ans |= 1 << i\n                node = node.children[v ^ 1]\n            else:\n                node = node.children[v]\n        return ans\n\n    def remove(self, x: int):\n        node = self\n        for i in range(20, -1, -1):\n            v = x >> i & 1\n            node = node.children[v]\n            node.cnt -= 1\n\n\nclass Solution:\n    def maximumStrongPairXor(self, nums: List[int]) -> int:\n        nums.sort()\n        tree = Trie()\n        ans = i = 0\n        for y in nums:\n            tree.insert(y)\n            while y > nums[i] * 2:\n                tree.remove(nums[i])\n                i += 1\n            ans = max(ans, tree.search(y))\n        return ans\n<|eot_id|>",
    "model_generation": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nYou are given a **0-indexed** integer array `nums`. A pair of integers `x` and `y` is called a **strong** pair if it satisfies the condition:\n\n\n* `|x - y| <= min(x, y)`\n\n\nYou need to select two integers from `nums` such that they form a strong pair and their bitwise `XOR` is the **maximum** among all strong pairs in the array.\n\n\nReturn *the **maximum*** `XOR` *value out of all possible strong pairs in the array* `nums`.\n\n\n**Note** that you can pick the same integer twice to form a pair.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** nums = [1,2,3,4,5]\n**Output:** 7\n**Explanation:** There are 11 strong pairs in the array nums: (1, 1), (1, 2), (2, 2), (2, 3), (2, 4), (3, 3), (3, 4), (3, 5), (4, 4), (4, 5) and (5, 5).\nThe maximum XOR possible from these pairs is 3 XOR 4 = 7.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** nums = [10,100]\n**Output:** 0\n**Explanation:** There are 2 strong pairs in the array nums: (10, 10) and (100, 100).\nThe maximum XOR possible from these pairs is 10 XOR 10 = 0 since the pair (100, 100) also gives 100 XOR 100 = 0.\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** nums = [500,520,2500,3000]\n**Output:** 1020\n**Explanation:** There are 6 strong pairs in the array nums: (500, 500), (500, 520), (520, 520), (2500, 2500), (2500, 3000) and (3000, 3000).\nThe maximum XOR possible from these pairs is 500 XOR 520 = 1020 since the only other non-zero XOR value is 2500 XOR 3000 = 636.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= nums.length <= 5 * 104`\n* `1 <= nums[i] <= 220 - 1`\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def maximumStrongPairXor(self, nums: List[int]) -> int:\n        nums.sort()\n        trie = []\n        for _ in range(len(nums)**2):\n            trie.append([None, None])\n        ans = i = 0\n        for y in nums:\n            self.insert(trie, y)\n            while y > nums[i] * 2:\n                self.remove(trie, nums[i])\n                i += 1\n            ans = max(ans, self.search(trie, y))\n        return ans\n\n    def insert(self, trie: List[List], x: int):\n        for i in range(20, -1, -1):\n            v = x >> i & 1\n            if trie[-len(nums) + i][v] is None:\n                trie[-len(nums) + i][v] = []\n            trie = trie[-len(nums) + i][v]\n            trie.append([])\n\n    def remove(self, trie: List[List], x: int):\n        for i in range(20, -1, -1):\n            v = x >> i & 1\n            trie[-len(nums) + i] = trie[-len(nums) + i][v]\n\n    def search(self, trie: List[List], x: int) -> int:\n        ans = 0\n        for i in range(20, -1, -1):\n            v = x >> i & 1\n            if trie[-len(nums) + i][v ^ 1]:\n                ans |= 1 << i\n                trie = trie[-len(nums) + i][v ^ 1]\n            else:\n                trie = trie[-len(nums) + i][v]\n        return ans\n\n### Efficient Solution:\nclass Trie:\n    __slots__ = (\"children\",)\n\n    def __init__(self):\n        self.children = [None, None]\n\n    def insert(self, x: int):\n        node = self\n        for i in range(20, -1, -1):\n            v = x >> i & 1\n            if node.children[v] is None:\n                node.children[v] = Trie()\n            node = node.children[v]\n\n    def remove(self, x: int):\n        node = self\n        for i in range(20, -1, -1):\n            v = x >> i & 1\n            node = node.children[v]\n            node.children[v ^ 1] = None\n\n    def search(self, x: int) -> int:\n        ans = 0\n        node = self\n        for i in range(20, -1, -1):\n            v = x >> i & 1\n            if node.children[v ^ 1]:\n                ans |= 1 << i\n                node = node.children[v ^ 1]\n            else:\n                node = node.children[v]\n        return ans\n\n\nclass Solution:\n    def maximumStrongPairXor(self, nums: List[int]) -> int:\n        nums.sort()\n        trie = Trie()\n        ans = i = 0\n        for y in nums:\n            trie.insert(y)\n            while y > nums[i] * 2:\n                trie.remove(nums[i])\n                i += 1\n            ans = max(ans, trie.search(y))\n        return ans\n",
    "model_solution": "class Trie:\n    __slots__ = (\"children\",)\n\n    def __init__(self):\n        self.children = [None, None]\n\n    def insert(self, x: int):\n        node = self\n        for i in range(20, -1, -1):\n            v = x >> i & 1\n            if node.children[v] is None:\n                node.children[v] = Trie()\n            node = node.children[v]\n\n    def remove(self, x: int):\n        node = self\n        for i in range(20, -1, -1):\n            v = x >> i & 1\n            node = node.children[v]\n            node.children[v ^ 1] = None\n\n    def search(self, x: int) -> int:\n        ans = 0\n        node = self\n        for i in range(20, -1, -1):\n            v = x >> i & 1\n            if node.children[v ^ 1]:\n                ans |= 1 << i\n                node = node.children[v ^ 1]\n            else:\n                node = node.children[v]\n        return ans\n\n\nclass Solution:\n    def maximumStrongPairXor(self, nums: List[int]) -> int:\n        nums.sort()\n        trie = Trie()\n        ans = i = 0\n        for y in nums:\n            trie.insert(y)\n            while y > nums[i] * 2:\n                trie.remove(nums[i])\n                i += 1\n            ans = max(ans, trie.search(y))\n        return ans"
}