{
    "problem_idx": "35",
    "description": "\nGiven a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n\n\nYou must\u00a0write an algorithm with\u00a0`O(log n)` runtime complexity.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** nums = [1,3,5,6], target = 5\n**Output:** 2\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** nums = [1,3,5,6], target = 2\n**Output:** 1\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** nums = [1,3,5,6], target = 7\n**Output:** 4\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= nums.length <= 104`\n* `-104 <= nums[i] <= 104`\n* `nums` contains **distinct** values sorted in **ascending** order.\n* `-104 <= target <= 104`\n\n\n",
    "inefficient_solution": "class Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        def recursive_search(nums, left, right, target):\n            if left == right:\n                return left\n            mid = (left + right) >> 1\n            if nums[mid] >= target:\n                return recursive_search(nums, left, mid, target)\n            else:\n                return recursive_search(nums, mid + 1, right, target)\n        \n        return recursive_search(nums, 0, len(nums), target)",
    "efficient_solution": "class Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        left, right = 0, len(nums)\n        while left < right:\n            mid = (left + right) >> 1\n            if nums[mid] >= target:\n                right = mid\n            else:\n                left = mid + 1\n        return left\n",
    "text": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nGiven a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n\n\nYou must\u00a0write an algorithm with\u00a0`O(log n)` runtime complexity.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** nums = [1,3,5,6], target = 5\n**Output:** 2\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** nums = [1,3,5,6], target = 2\n**Output:** 1\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** nums = [1,3,5,6], target = 7\n**Output:** 4\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= nums.length <= 104`\n* `-104 <= nums[i] <= 104`\n* `nums` contains **distinct** values sorted in **ascending** order.\n* `-104 <= target <= 104`\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        def recursive_search(nums, left, right, target):\n            if left == right:\n                return left\n            mid = (left + right) >> 1\n            if nums[mid] >= target:\n                return recursive_search(nums, left, mid, target)\n            else:\n                return recursive_search(nums, mid + 1, right, target)\n        \n        return recursive_search(nums, 0, len(nums), target)\n\n### Efficient Solution:\nclass Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        left, right = 0, len(nums)\n        while left < right:\n            mid = (left + right) >> 1\n            if nums[mid] >= target:\n                right = mid\n            else:\n                left = mid + 1\n        return left\n<|eot_id|>",
    "model_generation": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nGiven a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n\n\nYou must\u00a0write an algorithm with\u00a0`O(log n)` runtime complexity.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** nums = [1,3,5,6], target = 5\n**Output:** 2\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** nums = [1,3,5,6], target = 2\n**Output:** 1\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** nums = [1,3,5,6], target = 7\n**Output:** 4\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= nums.length <= 104`\n* `-104 <= nums[i] <= 104`\n* `nums` contains **distinct** values sorted in **ascending** order.\n* `-104 <= target <= 104`\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        def recursive_search(nums, left, right, target):\n            if left == right:\n                return left\n            mid = (left + right) >> 1\n            if nums[mid] >= target:\n                return recursive_search(nums, left, mid, target)\n            else:\n                return recursive_search(nums, mid + 1, right, target)\n        \n        return recursive_search(nums, 0, len(nums), target)\n\n### Efficient Solution:\nclass Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        left, right = 0, len(nums)\n        while left < right:\n            mid = (left + right) >> 1\n            if nums[mid] >= target:\n                right = mid\n            else:\n                left = mid + 1\n        return left\n",
    "model_solution": "class Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        left, right = 0, len(nums)\n        while left < right:\n            mid = (left + right) >> 1\n            if nums[mid] >= target:\n                right = mid\n            else:\n                left = mid + 1\n        return left"
}