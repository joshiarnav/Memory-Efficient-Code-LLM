{
    "problem_idx": "350",
    "description": "\nGiven two integer arrays `nums1` and `nums2`, return *an array of their intersection*. Each element in the result must appear as many times as it shows in both arrays and you may return the result in **any order**.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** nums1 = [1,2,2,1], nums2 = [2,2]\n**Output:** [2,2]\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** nums1 = [4,9,5], nums2 = [9,4,9,8,4]\n**Output:** [4,9]\n**Explanation:** [9,4] is also accepted.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= nums1.length, nums2.length <= 1000`\n* `0 <= nums1[i], nums2[i] <= 1000`\n\n\n\u00a0\n\n\n**Follow up:**\n\n\n* What if the given array is already sorted? How would you optimize your algorithm?\n* What if `nums1`'s size is small compared to `nums2`'s size? Which algorithm is better?\n* What if elements of `nums2` are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?\n\n\n",
    "inefficient_solution": "from collections import Counter\nfrom typing import List\n\nclass Solution:\n    def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        counter = Counter(nums1)\n        res = []\n        for num in nums2:\n            if counter[num] > 0:\n                temp = []\n                for _ in range(counter[num]):\n                    temp.append(num)\n                res.extend(temp)\n                counter[num] = -1\n        return res",
    "efficient_solution": "class Solution:\n    def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        counter = Counter(nums1)\n        res = []\n        for num in nums2:\n            if counter[num] > 0:\n                res.append(num)\n                counter[num] -= 1\n        return res\n",
    "text": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nGiven two integer arrays `nums1` and `nums2`, return *an array of their intersection*. Each element in the result must appear as many times as it shows in both arrays and you may return the result in **any order**.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** nums1 = [1,2,2,1], nums2 = [2,2]\n**Output:** [2,2]\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** nums1 = [4,9,5], nums2 = [9,4,9,8,4]\n**Output:** [4,9]\n**Explanation:** [9,4] is also accepted.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= nums1.length, nums2.length <= 1000`\n* `0 <= nums1[i], nums2[i] <= 1000`\n\n\n\u00a0\n\n\n**Follow up:**\n\n\n* What if the given array is already sorted? How would you optimize your algorithm?\n* What if `nums1`'s size is small compared to `nums2`'s size? Which algorithm is better?\n* What if elements of `nums2` are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?\n\n\n\n\n### Inefficient Solution:\nfrom collections import Counter\nfrom typing import List\n\nclass Solution:\n    def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        counter = Counter(nums1)\n        res = []\n        for num in nums2:\n            if counter[num] > 0:\n                temp = []\n                for _ in range(counter[num]):\n                    temp.append(num)\n                res.extend(temp)\n                counter[num] = -1\n        return res\n\n### Efficient Solution:\nclass Solution:\n    def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        counter = Counter(nums1)\n        res = []\n        for num in nums2:\n            if counter[num] > 0:\n                res.append(num)\n                counter[num] -= 1\n        return res\n<|eot_id|>",
    "model_generation": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nGiven two integer arrays `nums1` and `nums2`, return *an array of their intersection*. Each element in the result must appear as many times as it shows in both arrays and you may return the result in **any order**.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** nums1 = [1,2,2,1], nums2 = [2,2]\n**Output:** [2,2]\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** nums1 = [4,9,5], nums2 = [9,4,9,8,4]\n**Output:** [4,9]\n**Explanation:** [9,4] is also accepted.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= nums1.length, nums2.length <= 1000`\n* `0 <= nums1[i], nums2[i] <= 1000`\n\n\n\u00a0\n\n\n**Follow up:**\n\n\n* What if the given array is already sorted? How would you optimize your algorithm?\n* What if `nums1`'s size is small compared to `nums2`'s size? Which algorithm is better?\n* What if elements of `nums2` are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?\n\n\n\n\n### Inefficient Solution:\nfrom collections import Counter\nfrom typing import List\n\nclass Solution:\n    def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        counter = Counter(nums1)\n        res = []\n        for num in nums2:\n            if counter[num] > 0:\n                temp = []\n                for _ in range(counter[num]):\n                    temp.append(num)\n                res.extend(temp)\n                counter[num] = -1\n        return res\n\n### Efficient Solution:\nclass Solution:\n    def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        cnt = Counter(nums1)\n        ans = []\n        for num in nums2:\n            while cnt[num] > 0:\n                ans.append(num)\n                cnt[num] -= 1\n        return ans\n",
    "model_solution": "class Solution:\n    def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        cnt = Counter(nums1)\n        ans = []\n        for num in nums2:\n            while cnt[num] > 0:\n                ans.append(num)\n                cnt[num] -= 1\n        return ans"
}