{
    "problem_idx": "1626",
    "description": "\nYou are the manager of a basketball team. For the upcoming tournament, you want to choose the team with the highest overall score. The score of the team is the **sum** of scores of all the players in the team.\n\n\nHowever, the basketball team is not allowed to have **conflicts**. A **conflict** exists if a younger player has a **strictly higher** score than an older player. A conflict does **not** occur between players of the same age.\n\n\nGiven two lists, `scores` and `ages`, where each `scores[i]` and `ages[i]` represents the score and age of the `ith` player, respectively, return *the highest overall score of all possible basketball teams*.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** scores = [1,3,5,10,15], ages = [1,2,3,4,5]\n**Output:** 34\n**Explanation:**\u00a0You can choose all the players.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** scores = [4,5,6,5], ages = [2,1,2,1]\n**Output:** 16\n**Explanation:**\u00a0It is best to choose the last 3 players. Notice that you are allowed to choose multiple people of the same age.\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** scores = [1,2,3,5], ages = [8,9,10,1]\n**Output:** 6\n**Explanation:**\u00a0It is best to choose the first 3 players. \n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= scores.length, ages.length <= 1000`\n* `scores.length == ages.length`\n* `1 <= scores[i] <= 106`\n* `1 <= ages[i] <= 1000`\n\n\n",
    "inefficient_solution": "class Solution:\n    def bestTeamScore(self, scores, ages):\n        n = len(scores)\n        res = 0\n        for i in range(n):\n            for j in range(i, n):\n                if scores[j] >= scores[i]:\n                    temp_sum = 0\n                    for k in range(i, j+1):\n                        temp_sum += scores[k]\n                    res = max(res, temp_sum)\n        return res",
    "efficient_solution": "class BinaryIndexedTree:\n    def __init__(self, n):\n        self.n = n\n        self.c = [0] * (n + 1)\n\n    def update(self, x, val):\n        while x <= self.n:\n            self.c[x] = max(self.c[x], val)\n            x += x & -x\n\n    def query(self, x):\n        s = 0\n        while x:\n            s = max(s, self.c[x])\n            x -= x & -x\n        return s\n\n\nclass Solution:\n    def bestTeamScore(self, scores: List[int], ages: List[int]) -> int:\n        m = max(ages)\n        tree = BinaryIndexedTree(m)\n        for score, age in sorted(zip(scores, ages)):\n            tree.update(age, score + tree.query(age))\n        return tree.query(m)\n",
    "text": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nYou are the manager of a basketball team. For the upcoming tournament, you want to choose the team with the highest overall score. The score of the team is the **sum** of scores of all the players in the team.\n\n\nHowever, the basketball team is not allowed to have **conflicts**. A **conflict** exists if a younger player has a **strictly higher** score than an older player. A conflict does **not** occur between players of the same age.\n\n\nGiven two lists, `scores` and `ages`, where each `scores[i]` and `ages[i]` represents the score and age of the `ith` player, respectively, return *the highest overall score of all possible basketball teams*.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** scores = [1,3,5,10,15], ages = [1,2,3,4,5]\n**Output:** 34\n**Explanation:**\u00a0You can choose all the players.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** scores = [4,5,6,5], ages = [2,1,2,1]\n**Output:** 16\n**Explanation:**\u00a0It is best to choose the last 3 players. Notice that you are allowed to choose multiple people of the same age.\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** scores = [1,2,3,5], ages = [8,9,10,1]\n**Output:** 6\n**Explanation:**\u00a0It is best to choose the first 3 players. \n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= scores.length, ages.length <= 1000`\n* `scores.length == ages.length`\n* `1 <= scores[i] <= 106`\n* `1 <= ages[i] <= 1000`\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def bestTeamScore(self, scores, ages):\n        n = len(scores)\n        res = 0\n        for i in range(n):\n            for j in range(i, n):\n                if scores[j] >= scores[i]:\n                    temp_sum = 0\n                    for k in range(i, j+1):\n                        temp_sum += scores[k]\n                    res = max(res, temp_sum)\n        return res\n\n### Efficient Solution:\nclass BinaryIndexedTree:\n    def __init__(self, n):\n        self.n = n\n        self.c = [0] * (n + 1)\n\n    def update(self, x, val):\n        while x <= self.n:\n            self.c[x] = max(self.c[x], val)\n            x += x & -x\n\n    def query(self, x):\n        s = 0\n        while x:\n            s = max(s, self.c[x])\n            x -= x & -x\n        return s\n\n\nclass Solution:\n    def bestTeamScore(self, scores: List[int], ages: List[int]) -> int:\n        m = max(ages)\n        tree = BinaryIndexedTree(m)\n        for score, age in sorted(zip(scores, ages)):\n            tree.update(age, score + tree.query(age))\n        return tree.query(m)\n<|eot_id|>",
    "model_generation": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nYou are the manager of a basketball team. For the upcoming tournament, you want to choose the team with the highest overall score. The score of the team is the **sum** of scores of all the players in the team.\n\n\nHowever, the basketball team is not allowed to have **conflicts**. A **conflict** exists if a younger player has a **strictly higher** score than an older player. A conflict does **not** occur between players of the same age.\n\n\nGiven two lists, `scores` and `ages`, where each `scores[i]` and `ages[i]` represents the score and age of the `ith` player, respectively, return *the highest overall score of all possible basketball teams*.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** scores = [1,3,5,10,15], ages = [1,2,3,4,5]\n**Output:** 34\n**Explanation:**\u00a0You can choose all the players.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** scores = [4,5,6,5], ages = [2,1,2,1]\n**Output:** 16\n**Explanation:**\u00a0It is best to choose the last 3 players. Notice that you are allowed to choose multiple people of the same age.\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** scores = [1,2,3,5], ages = [8,9,10,1]\n**Output:** 6\n**Explanation:**\u00a0It is best to choose the first 3 players. \n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= scores.length, ages.length <= 1000`\n* `scores.length == ages.length`\n* `1 <= scores[i] <= 106`\n* `1 <= ages[i] <= 1000`\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def bestTeamScore(self, scores, ages):\n        n = len(scores)\n        res = 0\n        for i in range(n):\n            for j in range(i, n):\n                if scores[j] >= scores[i]:\n                    temp_sum = 0\n                    for k in range(i, j+1):\n                        temp_sum += scores[k]\n                    res = max(res, temp_sum)\n        return res\n\n### Efficient Solution:\nclass Solution:\n    def bestTeamScore(self, scores: List[int], ages: List[int]) -> int:\n        nums = sorted(zip(scores, ages))\n        n = len(nums)\n        f = [0] * n\n        for i, (x, a) in enumerate(nums):\n            f[i] = x\n            for j in range(i):\n                if nums[j][1] <= a or nums[j][0] < x:\n                    f[i] = max(f[i], f[j] + x)\n        return max(f)\n",
    "model_solution": "class Solution:\n    def bestTeamScore(self, scores: List[int], ages: List[int]) -> int:\n        nums = sorted(zip(scores, ages))\n        n = len(nums)\n        f = [0] * n\n        for i, (x, a) in enumerate(nums):\n            f[i] = x\n            for j in range(i):\n                if nums[j][1] <= a or nums[j][0] < x:\n                    f[i] = max(f[i], f[j] + x)\n        return max(f)"
}