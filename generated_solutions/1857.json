{
    "problem_idx": "1857",
    "description": "\nThere is a **directed graph** of `n` colored nodes and `m` edges. The nodes are numbered from `0` to `n - 1`.\n\n\nYou are given a string `colors` where `colors[i]` is a lowercase English letter representing the **color** of the `ith` node in this graph (**0-indexed**). You are also given a 2D array `edges` where `edges[j] = [aj, bj]` indicates that there is a **directed edge** from node `aj` to node `bj`.\n\n\nA valid **path** in the graph is a sequence of nodes `x1 -> x2 -> x3 -> ... -> xk` such that there is a directed edge from `xi` to `xi+1` for every `1 <= i < k`. The **color value** of the path is the number of nodes that are colored the **most frequently** occurring color along that path.\n\n\nReturn *the **largest color value** of any valid path in the given graph, or* `-1` *if the graph contains a cycle*.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1800-1899/1857.Largest%20Color%20Value%20in%20a%20Directed%20Graph/images/leet1.png)\n\n\n\n```\n\n**Input:** colors = \"abaca\", edges = [[0,1],[0,2],[2,3],[3,4]]\n**Output:** 3\n**Explanation:** The path 0 -> 2 -> 3 -> 4 contains 3 nodes that are colored \"a\" (red in the above image).\n\n```\n\n**Example 2:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1800-1899/1857.Largest%20Color%20Value%20in%20a%20Directed%20Graph/images/leet2.png)\n\n\n\n```\n\n**Input:** colors = \"a\", edges = [[0,0]]\n**Output:** -1\n**Explanation:** There is a cycle from 0 to 0.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `n == colors.length`\n* `m == edges.length`\n* `1 <= n <= 105`\n* `0 <= m <= 105`\n* `colors` consists of lowercase English letters.\n* `0 <= aj, bj\u00a0< n`\n\n\n",
    "inefficient_solution": "class Solution:\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\n        n = len(colors)\n        indeg = [0] * (n * 2)\n        g = [[[] for _ in range(2)] for _ in range(n)]\n        for a, b in edges:\n            g[a][0].append((b, 1))\n            g[b][1].append((a, 0))\n            indeg[b] += 1\n        q = deque()\n        dp = [[[0] * 26 for _ in range(2)] for _ in range(n)]\n        for i, v in enumerate(indeg):\n            if v == 0:\n                q.append(i)\n                c = ord(colors[i]) - ord('a')\n                dp[i][0][c] = 1\n        cnt = 0\n        ans = 1\n        while q:\n            i = q.popleft()\n            cnt += 1\n            for j, v in g[i][0]:\n                indeg[j] -= 1\n                if indeg[j] == 0:\n                    q.append(j)\n                c = ord(colors[j]) - ord('a')\n                dp[j][0] = dp[j][1]\n                dp[j][1] = [[0] * 26 for _ in range(2)]\n                for k in range(26):\n                    if dp[i][v][k] > 0:\n                        for l in range(26):\n                            dp[j][1][l] = max(dp[j][1][l], dp[i][v][k] + (l == k))\n                            ans = max(ans, dp[j][1][l])\n        return -1 if cnt < n else ans",
    "efficient_solution": "class Solution:\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\n        n = len(colors)\n        indeg = [0] * n\n        g = defaultdict(list)\n        for a, b in edges:\n            g[a].append(b)\n            indeg[b] += 1\n        q = deque()\n        dp = [[0] * 26 for _ in range(n)]\n        for i, v in enumerate(indeg):\n            if v == 0:\n                q.append(i)\n                c = ord(colors[i]) - ord('a')\n                dp[i][c] += 1\n        cnt = 0\n        ans = 1\n        while q:\n            i = q.popleft()\n            cnt += 1\n            for j in g[i]:\n                indeg[j] -= 1\n                if indeg[j] == 0:\n                    q.append(j)\n                c = ord(colors[j]) - ord('a')\n                for k in range(26):\n                    dp[j][k] = max(dp[j][k], dp[i][k] + (c == k))\n                    ans = max(ans, dp[j][k])\n        return -1 if cnt < n else ans\n",
    "text": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nThere is a **directed graph** of `n` colored nodes and `m` edges. The nodes are numbered from `0` to `n - 1`.\n\n\nYou are given a string `colors` where `colors[i]` is a lowercase English letter representing the **color** of the `ith` node in this graph (**0-indexed**). You are also given a 2D array `edges` where `edges[j] = [aj, bj]` indicates that there is a **directed edge** from node `aj` to node `bj`.\n\n\nA valid **path** in the graph is a sequence of nodes `x1 -> x2 -> x3 -> ... -> xk` such that there is a directed edge from `xi` to `xi+1` for every `1 <= i < k`. The **color value** of the path is the number of nodes that are colored the **most frequently** occurring color along that path.\n\n\nReturn *the **largest color value** of any valid path in the given graph, or* `-1` *if the graph contains a cycle*.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1800-1899/1857.Largest%20Color%20Value%20in%20a%20Directed%20Graph/images/leet1.png)\n\n\n\n```\n\n**Input:** colors = \"abaca\", edges = [[0,1],[0,2],[2,3],[3,4]]\n**Output:** 3\n**Explanation:** The path 0 -> 2 -> 3 -> 4 contains 3 nodes that are colored \"a\" (red in the above image).\n\n```\n\n**Example 2:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1800-1899/1857.Largest%20Color%20Value%20in%20a%20Directed%20Graph/images/leet2.png)\n\n\n\n```\n\n**Input:** colors = \"a\", edges = [[0,0]]\n**Output:** -1\n**Explanation:** There is a cycle from 0 to 0.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `n == colors.length`\n* `m == edges.length`\n* `1 <= n <= 105`\n* `0 <= m <= 105`\n* `colors` consists of lowercase English letters.\n* `0 <= aj, bj\u00a0< n`\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\n        n = len(colors)\n        indeg = [0] * (n * 2)\n        g = [[[] for _ in range(2)] for _ in range(n)]\n        for a, b in edges:\n            g[a][0].append((b, 1))\n            g[b][1].append((a, 0))\n            indeg[b] += 1\n        q = deque()\n        dp = [[[0] * 26 for _ in range(2)] for _ in range(n)]\n        for i, v in enumerate(indeg):\n            if v == 0:\n                q.append(i)\n                c = ord(colors[i]) - ord('a')\n                dp[i][0][c] = 1\n        cnt = 0\n        ans = 1\n        while q:\n            i = q.popleft()\n            cnt += 1\n            for j, v in g[i][0]:\n                indeg[j] -= 1\n                if indeg[j] == 0:\n                    q.append(j)\n                c = ord(colors[j]) - ord('a')\n                dp[j][0] = dp[j][1]\n                dp[j][1] = [[0] * 26 for _ in range(2)]\n                for k in range(26):\n                    if dp[i][v][k] > 0:\n                        for l in range(26):\n                            dp[j][1][l] = max(dp[j][1][l], dp[i][v][k] + (l == k))\n                            ans = max(ans, dp[j][1][l])\n        return -1 if cnt < n else ans\n\n### Efficient Solution:\nclass Solution:\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\n        n = len(colors)\n        indeg = [0] * n\n        g = defaultdict(list)\n        for a, b in edges:\n            g[a].append(b)\n            indeg[b] += 1\n        q = deque()\n        dp = [[0] * 26 for _ in range(n)]\n        for i, v in enumerate(indeg):\n            if v == 0:\n                q.append(i)\n                c = ord(colors[i]) - ord('a')\n                dp[i][c] += 1\n        cnt = 0\n        ans = 1\n        while q:\n            i = q.popleft()\n            cnt += 1\n            for j in g[i]:\n                indeg[j] -= 1\n                if indeg[j] == 0:\n                    q.append(j)\n                c = ord(colors[j]) - ord('a')\n                for k in range(26):\n                    dp[j][k] = max(dp[j][k], dp[i][k] + (c == k))\n                    ans = max(ans, dp[j][k])\n        return -1 if cnt < n else ans\n<|eot_id|>",
    "model_generation": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nThere is a **directed graph** of `n` colored nodes and `m` edges. The nodes are numbered from `0` to `n - 1`.\n\n\nYou are given a string `colors` where `colors[i]` is a lowercase English letter representing the **color** of the `ith` node in this graph (**0-indexed**). You are also given a 2D array `edges` where `edges[j] = [aj, bj]` indicates that there is a **directed edge** from node `aj` to node `bj`.\n\n\nA valid **path** in the graph is a sequence of nodes `x1 -> x2 -> x3 ->... -> xk` such that there is a directed edge from `xi` to `xi+1` for every `1 <= i < k`. The **color value** of the path is the number of nodes that are colored the **most frequently** occurring color along that path.\n\n\nReturn *the **largest color value** of any valid path in the given graph, or* `-1` *if the graph contains a cycle*.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1800-1899/1857.Largest%20Color%20Value%20in%20a%20Directed%20Graph/images/leet1.png)\n\n\n\n```\n\n**Input:** colors = \"abaca\", edges = [[0,1],[0,2],[2,3],[3,4]]\n**Output:** 3\n**Explanation:** The path 0 -> 2 -> 3 -> 4 contains 3 nodes that are colored \"a\" (red in the above image).\n\n```\n\n**Example 2:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1800-1899/1857.Largest%20Color%20Value%20in%20a%20Directed%20Graph/images/leet2.png)\n\n\n\n```\n\n**Input:** colors = \"a\", edges = [[0,0]]\n**Output:** -1\n**Explanation:** There is a cycle from 0 to 0.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `n == colors.length`\n* `m == edges.length`\n* `1 <= n <= 105`\n* `0 <= m <= 105`\n* `colors` consists of lowercase English letters.\n* `0 <= aj, bj\u00a0< n`\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\n        n = len(colors)\n        indeg = [0] * (n * 2)\n        g = [[[] for _ in range(2)] for _ in range(n)]\n        for a, b in edges:\n            g[a][0].append((b, 1))\n            g[b][1].append((a, 0))\n            indeg[b] += 1\n        q = deque()\n        dp = [[[0] * 26 for _ in range(2)] for _ in range(n)]\n        for i, v in enumerate(indeg):\n            if v == 0:\n                q.append(i)\n                c = ord(colors[i]) - ord('a')\n                dp[i][0][c] = 1\n        cnt = 0\n        ans = 1\n        while q:\n            i = q.popleft()\n            cnt += 1\n            for j, v in g[i][0]:\n                indeg[j] -= 1\n                if indeg[j] == 0:\n                    q.append(j)\n                c = ord(colors[j]) - ord('a')\n                dp[j][0] = dp[j][1]\n                dp[j][1] = [[0] * 26 for _ in range(2)]\n                for k in range(26):\n                    if dp[i][v][k] > 0:\n                        for l in range(26):\n                            dp[j][1][l] = max(dp[j][1][l], dp[i][v][k] + (l == k))\n                            ans = max(ans, dp[j][1][l])\n        return -1 if cnt < n else ans\n\n### Efficient Solution:\nclass Solution:\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\n        n = len(colors)\n        indeg = [0] * n\n        g = defaultdict(list)\n        for a, b in edges:\n            g[a].append(b)\n            indeg[b] += 1\n        q = deque()\n        dp = [[[0] * 26 for _ in range(2)] for _ in range(n)]\n        for i, v in enumerate(indeg):\n            if v == 0:\n                q.append(i)\n                c = ord(colors[i]) - ord('a')\n                dp[i][0][c] = 1\n        cnt = 0\n        ans = 1\n        while q:\n            i = q.popleft()\n            cnt += 1\n            for j in g[i]:\n                indeg[j] -= 1\n                if indeg[j] == 0:\n                    q.append(j)\n                c = ord(colors[j]) - ord('a')\n                dp[j][0] = dp[j][1]\n                dp[j][1] = max(\n                    dp[j][1], dp[i][0], key=lambda x: x[max(x.keys())]\n                )\n                ans = max(ans, dp[j][1][c])\n        return -1 if cnt < n else ans\n",
    "model_solution": "class Solution:\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\n        n = len(colors)\n        indeg = [0] * n\n        g = defaultdict(list)\n        for a, b in edges:\n            g[a].append(b)\n            indeg[b] += 1\n        q = deque()\n        dp = [[[0] * 26 for _ in range(2)] for _ in range(n)]\n        for i, v in enumerate(indeg):\n            if v == 0:\n                q.append(i)\n                c = ord(colors[i]) - ord('a')\n                dp[i][0][c] = 1\n        cnt = 0\n        ans = 1\n        while q:\n            i = q.popleft()\n            cnt += 1\n            for j in g[i]:\n                indeg[j] -= 1\n                if indeg[j] == 0:\n                    q.append(j)\n                c = ord(colors[j]) - ord('a')\n                dp[j][0] = dp[j][1]\n                dp[j][1] = max(\n                    dp[j][1], dp[i][0], key=lambda x: x[max(x.keys())]\n                )\n                ans = max(ans, dp[j][1][c])\n        return -1 if cnt < n else ans"
}