{
    "problem_idx": "809",
    "description": "\nSometimes people repeat letters to represent extra feeling. For example:\n\n\n* `\"hello\" -> \"heeellooo\"`\n* `\"hi\" -> \"hiiii\"`\n\n\nIn these strings like `\"heeellooo\"`, we have groups of adjacent letters that are all the same: `\"h\"`, `\"eee\"`, `\"ll\"`, `\"ooo\"`.\n\n\nYou are given a string `s` and an array of query strings `words`. A query word is **stretchy** if it can be made to be equal to `s` by any number of applications of the following extension operation: choose a group consisting of characters `c`, and add some number of characters `c` to the group so that the size of the group is **three or more**.\n\n\n* For example, starting with `\"hello\"`, we could do an extension on the group `\"o\"` to get `\"hellooo\"`, but we cannot get `\"helloo\"` since the group `\"oo\"` has a size less than three. Also, we could do another extension like `\"ll\" -> \"lllll\"` to get `\"helllllooo\"`. If `s = \"helllllooo\"`, then the query word `\"hello\"` would be **stretchy** because of these two extension operations: `query = \"hello\" -> \"hellooo\" -> \"helllllooo\" = s`.\n\n\nReturn *the number of query strings that are **stretchy***.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** s = \"heeellooo\", words = [\"hello\", \"hi\", \"helo\"]\n**Output:** 1\n**Explanation:** \nWe can extend \"e\" and \"o\" in the word \"hello\" to get \"heeellooo\".\nWe can't extend \"helo\" to get \"heeellooo\" because the group \"ll\" is not size 3 or more.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** s = \"zzzzzyyyyy\", words = [\"zzyy\",\"zy\",\"zyy\"]\n**Output:** 3\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= s.length, words.length <= 100`\n* `1 <= words[i].length <= 100`\n* `s` and `words[i]` consist of lowercase letters.\n\n\n",
    "inefficient_solution": "class Solution:\n    def expressiveWords(self, s: str, words: List[str]) -> int:\n        def check(s, t):\n            m, n = len(s), len(t)\n            if n > m:\n                return False\n            i = j = 0\n            while i < m and j < n:\n                if s[i] != t[j]:\n                    return False\n                k = i\n                while k < m and s[k] == s[i]:\n                    k += 1\n                c1 = k - i\n                i, k = k, j\n                while k < n and t[k] == t[j]:\n                    k += 1\n                c2 = k - j\n                j = k\n                if c1 < c2 or (c1 < 3 and c1 != c2):\n                    return False\n            return (i == m or all(s[i] == s[i+1] and s[i] != s[i+2] for i in range(i, m))) and (j == n or all(t[j] == t[j+1] and t[j] != t[j+2] for j in range(j, n)))\n\n        return sum(check(s, t) for t in words)",
    "efficient_solution": "class Solution:\n    def expressiveWords(self, s: str, words: List[str]) -> int:\n        def check(s, t):\n            m, n = len(s), len(t)\n            if n > m:\n                return False\n            i = j = 0\n            while i < m and j < n:\n                if s[i] != t[j]:\n                    return False\n                k = i\n                while k < m and s[k] == s[i]:\n                    k += 1\n                c1 = k - i\n                i, k = k, j\n                while k < n and t[k] == t[j]:\n                    k += 1\n                c2 = k - j\n                j = k\n                if c1 < c2 or (c1 < 3 and c1 != c2):\n                    return False\n            return i == m and j == n\n\n        return sum(check(s, t) for t in words)\n",
    "text": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nSometimes people repeat letters to represent extra feeling. For example:\n\n\n* `\"hello\" -> \"heeellooo\"`\n* `\"hi\" -> \"hiiii\"`\n\n\nIn these strings like `\"heeellooo\"`, we have groups of adjacent letters that are all the same: `\"h\"`, `\"eee\"`, `\"ll\"`, `\"ooo\"`.\n\n\nYou are given a string `s` and an array of query strings `words`. A query word is **stretchy** if it can be made to be equal to `s` by any number of applications of the following extension operation: choose a group consisting of characters `c`, and add some number of characters `c` to the group so that the size of the group is **three or more**.\n\n\n* For example, starting with `\"hello\"`, we could do an extension on the group `\"o\"` to get `\"hellooo\"`, but we cannot get `\"helloo\"` since the group `\"oo\"` has a size less than three. Also, we could do another extension like `\"ll\" -> \"lllll\"` to get `\"helllllooo\"`. If `s = \"helllllooo\"`, then the query word `\"hello\"` would be **stretchy** because of these two extension operations: `query = \"hello\" -> \"hellooo\" -> \"helllllooo\" = s`.\n\n\nReturn *the number of query strings that are **stretchy***.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** s = \"heeellooo\", words = [\"hello\", \"hi\", \"helo\"]\n**Output:** 1\n**Explanation:** \nWe can extend \"e\" and \"o\" in the word \"hello\" to get \"heeellooo\".\nWe can't extend \"helo\" to get \"heeellooo\" because the group \"ll\" is not size 3 or more.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** s = \"zzzzzyyyyy\", words = [\"zzyy\",\"zy\",\"zyy\"]\n**Output:** 3\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= s.length, words.length <= 100`\n* `1 <= words[i].length <= 100`\n* `s` and `words[i]` consist of lowercase letters.\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def expressiveWords(self, s: str, words: List[str]) -> int:\n        def check(s, t):\n            m, n = len(s), len(t)\n            if n > m:\n                return False\n            i = j = 0\n            while i < m and j < n:\n                if s[i] != t[j]:\n                    return False\n                k = i\n                while k < m and s[k] == s[i]:\n                    k += 1\n                c1 = k - i\n                i, k = k, j\n                while k < n and t[k] == t[j]:\n                    k += 1\n                c2 = k - j\n                j = k\n                if c1 < c2 or (c1 < 3 and c1 != c2):\n                    return False\n            return (i == m or all(s[i] == s[i+1] and s[i] != s[i+2] for i in range(i, m))) and (j == n or all(t[j] == t[j+1] and t[j] != t[j+2] for j in range(j, n)))\n\n        return sum(check(s, t) for t in words)\n\n### Efficient Solution:\nclass Solution:\n    def expressiveWords(self, s: str, words: List[str]) -> int:\n        def check(s, t):\n            m, n = len(s), len(t)\n            if n > m:\n                return False\n            i = j = 0\n            while i < m and j < n:\n                if s[i] != t[j]:\n                    return False\n                k = i\n                while k < m and s[k] == s[i]:\n                    k += 1\n                c1 = k - i\n                i, k = k, j\n                while k < n and t[k] == t[j]:\n                    k += 1\n                c2 = k - j\n                j = k\n                if c1 < c2 or (c1 < 3 and c1 != c2):\n                    return False\n            return i == m and j == n\n\n        return sum(check(s, t) for t in words)\n<|eot_id|>",
    "model_generation": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nSometimes people repeat letters to represent extra feeling. For example:\n\n\n* `\"hello\" -> \"heeellooo\"`\n* `\"hi\" -> \"hiiii\"`\n\n\nIn these strings like `\"heeellooo\"`, we have groups of adjacent letters that are all the same: `\"h\"`, `\"eee\"`, `\"ll\"`, `\"ooo\"`.\n\n\nYou are given a string `s` and an array of query strings `words`. A query word is **stretchy** if it can be made to be equal to `s` by any number of applications of the following extension operation: choose a group consisting of characters `c`, and add some number of characters `c` to the group so that the size of the group is **three or more**.\n\n\n* For example, starting with `\"hello\"`, we could do an extension on the group `\"o\"` to get `\"hellooo\"`, but we cannot get `\"helloo\"` since the group `\"oo\"` has a size less than three. Also, we could do another extension like `\"ll\" -> \"lllll\"` to get `\"helllllooo\"`. If `s = \"helllllooo\"`, then the query word `\"hello\"` would be **stretchy** because of these two extension operations: `query = \"hello\" -> \"hellooo\" -> \"helllllooo\" = s`.\n\n\nReturn *the number of query strings that are **stretchy***.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** s = \"heeellooo\", words = [\"hello\", \"hi\", \"helo\"]\n**Output:** 1\n**Explanation:** \nWe can extend \"e\" and \"o\" in the word \"hello\" to get \"heeellooo\".\nWe can't extend \"helo\" to get \"heeellooo\" because the group \"ll\" is not size 3 or more.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** s = \"zzzzzyyyyy\", words = [\"zzyy\",\"zy\",\"zyy\"]\n**Output:** 3\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= s.length, words.length <= 100`\n* `1 <= words[i].length <= 100`\n* `s` and `words[i]` consist of lowercase letters.\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def expressiveWords(self, s: str, words: List[str]) -> int:\n        def check(s, t):\n            m, n = len(s), len(t)\n            if n > m:\n                return False\n            i = j = 0\n            while i < m and j < n:\n                if s[i]!= t[j]:\n                    return False\n                k = i\n                while k < m and s[k] == s[i]:\n                    k += 1\n                c1 = k - i\n                i, k = k, j\n                while k < n and t[k] == t[j]:\n                    k += 1\n                c2 = k - j\n                j = k\n                if c1 < c2 or (c1 < 3 and c1!= c2):\n                    return False\n            return (i == m or all(s[i] == s[i+1] and s[i]!= s[i+2] for i in range(i, m))) and (j == n or all(t[j] == t[j+1] and t[j]!= t[j+2] for j in range(j, n)))\n\n        return sum(check(s, t) for t in words)\n\n### Efficient Solution:\nclass Solution:\n    def expressiveWords(self, s: str, words: List[str]) -> int:\n        def check(s, t):\n            m, n = len(s), len(t)\n            if n > m:\n                return False\n            i = j = 0\n            while i < m and j < n:\n                if s[i]!= t[j]:\n                    return False\n                x, y = 0, 0\n                while i < m and s[i] == s[i + 1]:\n                    x += 1\n                    i += 1\n                while j < n and t[j] == t[j + 1]:\n                    y += 1\n                    j += 1\n                if x < y or (x < 3 and x!= y):\n                    return False\n                i, j = i + 1, j + 1\n            return i == m and j == n\n\n        return sum(check(s, t) for t in words)\n",
    "model_solution": "class Solution:\n    def expressiveWords(self, s: str, words: List[str]) -> int:\n        def check(s, t):\n            m, n = len(s), len(t)\n            if n > m:\n                return False\n            i = j = 0\n            while i < m and j < n:\n                if s[i]!= t[j]:\n                    return False\n                x, y = 0, 0\n                while i < m and s[i] == s[i + 1]:\n                    x += 1\n                    i += 1\n                while j < n and t[j] == t[j + 1]:\n                    y += 1\n                    j += 1\n                if x < y or (x < 3 and x!= y):\n                    return False\n                i, j = i + 1, j + 1\n            return i == m and j == n\n\n        return sum(check(s, t) for t in words)"
}