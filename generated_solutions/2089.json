{
    "problem_idx": "2089",
    "description": "\nYou are given a **0-indexed** integer array `nums` and a target element `target`.\n\n\nA **target index** is an index `i` such that `nums[i] == target`.\n\n\nReturn *a list of the target indices of* `nums` after *sorting* `nums` *in **non-decreasing** order*. If there are no target indices, return *an **empty** list*. The returned list must be sorted in **increasing** order.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** nums = [1,2,5,2,3], target = 2\n**Output:** [1,2]\n**Explanation:** After sorting, nums is [1,**2**,**2**,3,5].\nThe indices where nums[i] == 2 are 1 and 2.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** nums = [1,2,5,2,3], target = 3\n**Output:** [3]\n**Explanation:** After sorting, nums is [1,2,2,**3**,5].\nThe index where nums[i] == 3 is 3.\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** nums = [1,2,5,2,3], target = 5\n**Output:** [4]\n**Explanation:** After sorting, nums is [1,2,2,3,**5**].\nThe index where nums[i] == 5 is 4.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= nums.length <= 100`\n* `1 <= nums[i], target <= 100`\n\n\n",
    "inefficient_solution": "class Solution:\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\n        nums2 = []\n        for i in range(len(nums)):\n            for j in range(len(nums)):\n                nums2.append(nums[j])\n        \n        nums2.sort()\n        result = []\n        for i in range(len(nums2)):\n            if nums2[i] == target:\n                result.append(i)\n        \n        return result",
    "efficient_solution": "class Solution:\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\n        nums.sort()\n        return [i for i, v in enumerate(nums) if v == target]\n",
    "text": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nYou are given a **0-indexed** integer array `nums` and a target element `target`.\n\n\nA **target index** is an index `i` such that `nums[i] == target`.\n\n\nReturn *a list of the target indices of* `nums` after *sorting* `nums` *in **non-decreasing** order*. If there are no target indices, return *an **empty** list*. The returned list must be sorted in **increasing** order.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** nums = [1,2,5,2,3], target = 2\n**Output:** [1,2]\n**Explanation:** After sorting, nums is [1,**2**,**2**,3,5].\nThe indices where nums[i] == 2 are 1 and 2.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** nums = [1,2,5,2,3], target = 3\n**Output:** [3]\n**Explanation:** After sorting, nums is [1,2,2,**3**,5].\nThe index where nums[i] == 3 is 3.\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** nums = [1,2,5,2,3], target = 5\n**Output:** [4]\n**Explanation:** After sorting, nums is [1,2,2,3,**5**].\nThe index where nums[i] == 5 is 4.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= nums.length <= 100`\n* `1 <= nums[i], target <= 100`\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\n        nums2 = []\n        for i in range(len(nums)):\n            for j in range(len(nums)):\n                nums2.append(nums[j])\n        \n        nums2.sort()\n        result = []\n        for i in range(len(nums2)):\n            if nums2[i] == target:\n                result.append(i)\n        \n        return result\n\n### Efficient Solution:\nclass Solution:\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\n        nums.sort()\n        return [i for i, v in enumerate(nums) if v == target]\n<|eot_id|>",
    "model_generation": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nYou are given a **0-indexed** integer array `nums` and a target element `target`.\n\n\nA **target index** is an index `i` such that `nums[i] == target`.\n\n\nReturn *a list of the target indices of* `nums` after *sorting* `nums` *in **non-decreasing** order*. If there are no target indices, return *an **empty** list*. The returned list must be sorted in **increasing** order.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** nums = [1,2,5,2,3], target = 2\n**Output:** [1,2]\n**Explanation:** After sorting, nums is [1,**2**,**2**,3,5].\nThe indices where nums[i] == 2 are 1 and 2.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** nums = [1,2,5,2,3], target = 3\n**Output:** [3]\n**Explanation:** After sorting, nums is [1,2,2,**3**,5].\nThe index where nums[i] == 3 is 3.\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** nums = [1,2,5,2,3], target = 5\n**Output:** [4]\n**Explanation:** After sorting, nums is [1,2,2,3,**5**].\nThe index where nums[i] == 5 is 4.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= nums.length <= 100`\n* `1 <= nums[i], target <= 100`\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\n        nums2 = []\n        for i in range(len(nums)):\n            for j in range(len(nums)):\n                nums2.append(nums[j])\n        \n        nums2.sort()\n        result = []\n        for i in range(len(nums2)):\n            if nums2[i] == target:\n                result.append(i)\n        \n        return result\n\n### Efficient Solution:\nclass Solution:\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\n        mi = bisect_left(nums, target)\n        return list(range(mi, len(nums) - bisect_left(nums, target + 1)))\n",
    "model_solution": "class Solution:\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\n        mi = bisect_left(nums, target)\n        return list(range(mi, len(nums) - bisect_left(nums, target + 1)))"
}