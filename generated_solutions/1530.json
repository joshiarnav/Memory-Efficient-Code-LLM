{
    "problem_idx": "1530",
    "description": "\nYou are given the `root` of a binary tree and an integer `distance`. A pair of two different **leaf** nodes of a binary tree is said to be good if the length of **the shortest path** between them is less than or equal to `distance`.\n\n\nReturn *the number of good leaf node pairs* in the tree.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1500-1599/1530.Number%20of%20Good%20Leaf%20Nodes%20Pairs/images/e1.jpg)\n\n```\n\n**Input:** root = [1,2,3,null,4], distance = 3\n**Output:** 1\n**Explanation:** The leaf nodes of the tree are 3 and 4 and the length of the shortest path between them is 3. This is the only good pair.\n\n```\n\n**Example 2:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1500-1599/1530.Number%20of%20Good%20Leaf%20Nodes%20Pairs/images/e2.jpg)\n\n```\n\n**Input:** root = [1,2,3,4,5,6,7], distance = 3\n**Output:** 2\n**Explanation:** The good pairs are [4,5] and [6,7] with shortest path = 2. The pair [4,6] is not good because the length of ther shortest path between them is 4.\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** root = [7,1,4,6,null,5,3,null,null,null,null,null,2], distance = 3\n**Output:** 1\n**Explanation:** The only good pair is [2,5].\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* The number of nodes in the `tree` is in the range `[1, 210].`\n* `1 <= Node.val <= 100`\n* `1 <= distance <= 10`\n\n\n",
    "inefficient_solution": "",
    "efficient_solution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def countPairs(self, root: TreeNode, distance: int) -> int:\n        def dfs(root, cnt, i):\n            if root is None or i >= distance:\n                return\n            if root.left is None and root.right is None:\n                cnt[i] += 1\n                return\n            dfs(root.left, cnt, i + 1)\n            dfs(root.right, cnt, i + 1)\n\n        if root is None:\n            return 0\n        ans = self.countPairs(root.left, distance) + self.countPairs(\n            root.right, distance\n        )\n        cnt1 = Counter()\n        cnt2 = Counter()\n        dfs(root.left, cnt1, 1)\n        dfs(root.right, cnt2, 1)\n\n        for k1, v1 in cnt1.items():\n            for k2, v2 in cnt2.items():\n                if k1 + k2 <= distance:\n                    ans += v1 * v2\n        return ans\n",
    "text": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nYou are given the `root` of a binary tree and an integer `distance`. A pair of two different **leaf** nodes of a binary tree is said to be good if the length of **the shortest path** between them is less than or equal to `distance`.\n\n\nReturn *the number of good leaf node pairs* in the tree.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1500-1599/1530.Number%20of%20Good%20Leaf%20Nodes%20Pairs/images/e1.jpg)\n\n```\n\n**Input:** root = [1,2,3,null,4], distance = 3\n**Output:** 1\n**Explanation:** The leaf nodes of the tree are 3 and 4 and the length of the shortest path between them is 3. This is the only good pair.\n\n```\n\n**Example 2:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1500-1599/1530.Number%20of%20Good%20Leaf%20Nodes%20Pairs/images/e2.jpg)\n\n```\n\n**Input:** root = [1,2,3,4,5,6,7], distance = 3\n**Output:** 2\n**Explanation:** The good pairs are [4,5] and [6,7] with shortest path = 2. The pair [4,6] is not good because the length of ther shortest path between them is 4.\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** root = [7,1,4,6,null,5,3,null,null,null,null,null,2], distance = 3\n**Output:** 1\n**Explanation:** The only good pair is [2,5].\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* The number of nodes in the `tree` is in the range `[1, 210].`\n* `1 <= Node.val <= 100`\n* `1 <= distance <= 10`\n\n\n\n\n### Inefficient Solution:\n\n\n### Efficient Solution:\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def countPairs(self, root: TreeNode, distance: int) -> int:\n        def dfs(root, cnt, i):\n            if root is None or i >= distance:\n                return\n            if root.left is None and root.right is None:\n                cnt[i] += 1\n                return\n            dfs(root.left, cnt, i + 1)\n            dfs(root.right, cnt, i + 1)\n\n        if root is None:\n            return 0\n        ans = self.countPairs(root.left, distance) + self.countPairs(\n            root.right, distance\n        )\n        cnt1 = Counter()\n        cnt2 = Counter()\n        dfs(root.left, cnt1, 1)\n        dfs(root.right, cnt2, 1)\n\n        for k1, v1 in cnt1.items():\n            for k2, v2 in cnt2.items():\n                if k1 + k2 <= distance:\n                    ans += v1 * v2\n        return ans\n<|eot_id|>",
    "model_generation": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nYou are given the `root` of a binary tree and an integer `distance`. A pair of two different **leaf** nodes of a binary tree is said to be good if the length of **the shortest path** between them is less than or equal to `distance`.\n\n\nReturn *the number of good leaf node pairs* in the tree.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1500-1599/1530.Number%20of%20Good%20Leaf%20Nodes%20Pairs/images/e1.jpg)\n\n```\n\n**Input:** root = [1,2,3,null,4], distance = 3\n**Output:** 1\n**Explanation:** The leaf nodes of the tree are 3 and 4 and the length of the shortest path between them is 3. This is the only good pair.\n\n```\n\n**Example 2:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1500-1599/1530.Number%20of%20Good%20Leaf%20Nodes%20Pairs/images/e2.jpg)\n\n```\n\n**Input:** root = [1,2,3,4,5,6,7], distance = 3\n**Output:** 2\n**Explanation:** The good pairs are [4,5] and [6,7] with shortest path = 2. The pair [4,6] is not good because the length of ther shortest path between them is 4.\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** root = [7,1,4,6,null,5,3,null,null,null,null,null,2], distance = 3\n**Output:** 1\n**Explanation:** The only good pair is [2,5].\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* The number of nodes in the `tree` is in the range `[1, 210].`\n* `1 <= Node.val <= 100`\n* `1 <= distance <= 10`\n\n\n\n\n### Inefficient Solution:\n\n\n### Efficient Solution:\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def countPairs(self, root: Optional[TreeNode], distance: int) -> int:\n        def dfs(root):\n            if root is None:\n                return []\n            l, r = dfs(root.left), dfs(root.right)\n            ans = j = 0\n            for i, v in enumerate(l):\n                if v <= distance:\n                    ans += j\n                    j += 1\n            j = 0\n            for i, v in enumerate(r):\n                if v <= distance:\n                    ans += j\n                    j += 1\n            return [0] + [v - 1 for v in l + r]\n\n        l, r = dfs(root.left), dfs(root.right)\n        ans = j = 0\n        for i, v in enumerate(l):\n            if v <= distance:\n                ans += j\n                j += 1\n        j = 0\n        for i, v in enumerate(r):\n            if v <= distance:\n                ans += j\n                j += 1\n        return ans\n",
    "model_solution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def countPairs(self, root: Optional[TreeNode], distance: int) -> int:\n        def dfs(root):\n            if root is None:\n                return []\n            l, r = dfs(root.left), dfs(root.right)\n            ans = j = 0\n            for i, v in enumerate(l):\n                if v <= distance:\n                    ans += j\n                    j += 1\n            j = 0\n            for i, v in enumerate(r):\n                if v <= distance:\n                    ans += j\n                    j += 1\n            return [0] + [v - 1 for v in l + r]\n\n        l, r = dfs(root.left), dfs(root.right)\n        ans = j = 0\n        for i, v in enumerate(l):\n            if v <= distance:\n                ans += j\n                j += 1\n        j = 0\n        for i, v in enumerate(r):\n            if v <= distance:\n                ans += j\n                j += 1\n        return ans"
}