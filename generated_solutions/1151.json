{
    "problem_idx": "1151",
    "description": "\nGiven a\u00a0binary array `data`, return\u00a0the minimum number of swaps required to group all `1`\u2019s present in the array together in **any place** in the array.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** data = [1,0,1,0,1]\n**Output:** 1\n**Explanation:** There are 3 ways to group all 1's together:\n[1,1,1,0,0] using 1 swap.\n[0,1,1,1,0] using 2 swaps.\n[0,0,1,1,1] using 1 swap.\nThe minimum is 1.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** data = [0,0,0,1,0]\n**Output:** 0\n**Explanation:** Since there is only one 1 in the array, no swaps are needed.\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** data = [1,0,1,0,1,0,0,1,1,0,1]\n**Output:** 3\n**Explanation:** One possible solution that uses 3 swaps is [0,0,0,0,0,1,1,1,1,1,1].\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= data.length <= 105`\n* `data[i]` is either `0` or `1`.\n\n\n",
    "inefficient_solution": "class Solution:\n    def minSwaps(self, data: List[int]) -> int:\n        all_ones = [1] * data.count(1)\n        all_zeros = [0] * len(data) - len(all_ones)\n        result = []\n        for i in range(len(data)):\n            temp = []\n            for j in range(len(data)):\n                if j < i:\n                    temp.append(data[j])\n                else:\n                    if j - i < len(all_ones):\n                        temp.append(all_ones[-(j - i)])\n                    else:\n                        temp.append(all_zeros[-(j - i) + len(all_ones)])\n            result.append(temp)\n        min_swaps = float('inf')\n        for arrangement in result:\n            swaps = 0\n            for i in range(len(arrangement)):\n                if arrangement[i] != 1:\n                    swaps += 1\n                    j = i\n                    while j < len(arrangement) and arrangement[j] != 1:\n                        j += 1\n                    if j == len(arrangement):\n                        break\n                    temp = arrangement[i:j+1]\n                    temp.sort()\n                    arrangement[i:j+1] = temp\n                    swaps += j - i\n            min_swaps = min(min_swaps, swaps)\n        return min_swaps",
    "efficient_solution": "class Solution:\n    def minSwaps(self, data: List[int]) -> int:\n        k = data.count(1)\n        t = sum(data[:k])\n        mx = t\n        for i in range(k, len(data)):\n            t += data[i]\n            t -= data[i - k]\n            mx = max(mx, t)\n        return k - mx\n",
    "text": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nGiven a\u00a0binary array `data`, return\u00a0the minimum number of swaps required to group all `1`\u2019s present in the array together in **any place** in the array.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** data = [1,0,1,0,1]\n**Output:** 1\n**Explanation:** There are 3 ways to group all 1's together:\n[1,1,1,0,0] using 1 swap.\n[0,1,1,1,0] using 2 swaps.\n[0,0,1,1,1] using 1 swap.\nThe minimum is 1.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** data = [0,0,0,1,0]\n**Output:** 0\n**Explanation:** Since there is only one 1 in the array, no swaps are needed.\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** data = [1,0,1,0,1,0,0,1,1,0,1]\n**Output:** 3\n**Explanation:** One possible solution that uses 3 swaps is [0,0,0,0,0,1,1,1,1,1,1].\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= data.length <= 105`\n* `data[i]` is either `0` or `1`.\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def minSwaps(self, data: List[int]) -> int:\n        all_ones = [1] * data.count(1)\n        all_zeros = [0] * len(data) - len(all_ones)\n        result = []\n        for i in range(len(data)):\n            temp = []\n            for j in range(len(data)):\n                if j < i:\n                    temp.append(data[j])\n                else:\n                    if j - i < len(all_ones):\n                        temp.append(all_ones[-(j - i)])\n                    else:\n                        temp.append(all_zeros[-(j - i) + len(all_ones)])\n            result.append(temp)\n        min_swaps = float('inf')\n        for arrangement in result:\n            swaps = 0\n            for i in range(len(arrangement)):\n                if arrangement[i] != 1:\n                    swaps += 1\n                    j = i\n                    while j < len(arrangement) and arrangement[j] != 1:\n                        j += 1\n                    if j == len(arrangement):\n                        break\n                    temp = arrangement[i:j+1]\n                    temp.sort()\n                    arrangement[i:j+1] = temp\n                    swaps += j - i\n            min_swaps = min(min_swaps, swaps)\n        return min_swaps\n\n### Efficient Solution:\nclass Solution:\n    def minSwaps(self, data: List[int]) -> int:\n        k = data.count(1)\n        t = sum(data[:k])\n        mx = t\n        for i in range(k, len(data)):\n            t += data[i]\n            t -= data[i - k]\n            mx = max(mx, t)\n        return k - mx\n<|eot_id|>",
    "model_generation": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nGiven a\u00a0binary array `data`, return\u00a0the minimum number of swaps required to group all `1`\u2019s present in the array together in **any place** in the array.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** data = [1,0,1,0,1]\n**Output:** 1\n**Explanation:** There are 3 ways to group all 1's together:\n[1,1,1,0,0] using 1 swap.\n[0,1,1,1,0] using 2 swaps.\n[0,0,1,1,1] using 1 swap.\nThe minimum is 1.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** data = [0,0,0,1,0]\n**Output:** 0\n**Explanation:** Since there is only one 1 in the array, no swaps are needed.\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** data = [1,0,1,0,1,0,0,1,1,0,1]\n**Output:** 3\n**Explanation:** One possible solution that uses 3 swaps is [0,0,0,0,0,1,1,1,1,1,1].\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= data.length <= 105`\n* `data[i]` is either `0` or `1`.\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def minSwaps(self, data: List[int]) -> int:\n        all_ones = [1] * data.count(1)\n        all_zeros = [0] * len(data) - len(all_ones)\n        result = []\n        for i in range(len(data)):\n            temp = []\n            for j in range(len(data)):\n                if j < i:\n                    temp.append(data[j])\n                else:\n                    if j - i < len(all_ones):\n                        temp.append(all_ones[-(j - i)])\n                    else:\n                        temp.append(all_zeros[-(j - i) + len(all_ones)])\n            result.append(temp)\n        min_swaps = float('inf')\n        for arrangement in result:\n            swaps = 0\n            for i in range(len(arrangement)):\n                if arrangement[i]!= 1:\n                    swaps += 1\n                    j = i\n                    while j < len(arrangement) and arrangement[j]!= 1:\n                        j += 1\n                    if j == len(arrangement):\n                        break\n                    temp = arrangement[i:j+1]\n                    temp.sort()\n                    arrangement[i:j+1] = temp\n                    swaps += j - i\n            min_swaps = min(min_swaps, swaps)\n        return min_swaps\n\n### Efficient Solution:\nclass Solution:\n    def minSwaps(self, data: List[int]) -> int:\n        cnt = data.count(1)\n        l = r = 0\n        ans = cnt - 1\n        while r < len(data):\n            if data[r]:\n                l, r = r, r + 1\n                ans += 1\n            else:\n                r += 1\n        return ans\n",
    "model_solution": "class Solution:\n    def minSwaps(self, data: List[int]) -> int:\n        cnt = data.count(1)\n        l = r = 0\n        ans = cnt - 1\n        while r < len(data):\n            if data[r]:\n                l, r = r, r + 1\n                ans += 1\n            else:\n                r += 1\n        return ans"
}