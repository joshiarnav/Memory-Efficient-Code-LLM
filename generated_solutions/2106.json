{
    "problem_idx": "2106",
    "description": "\nFruits are available at some positions on an infinite x-axis. You are given a 2D integer array `fruits` where `fruits[i] = [positioni, amounti]` depicts `amounti` fruits at the position `positioni`. `fruits` is already **sorted** by `positioni` in **ascending order**, and each `positioni` is **unique**.\n\n\nYou are also given an integer `startPos` and an integer `k`. Initially, you are at the position `startPos`. From any position, you can either walk to the **left or right**. It takes **one step** to move **one unit** on the x-axis, and you can walk **at most** `k` steps in total. For every position you reach, you harvest all the fruits at that position, and the fruits will disappear from that position.\n\n\nReturn *the **maximum total number** of fruits you can harvest*.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2100-2199/2106.Maximum%20Fruits%20Harvested%20After%20at%20Most%20K%20Steps/images/1.png)\n\n```\n\n**Input:** fruits = [[2,8],[6,3],[8,6]], startPos = 5, k = 4\n**Output:** 9\n**Explanation:** \nThe optimal way is to:\n- Move right to position 6 and harvest 3 fruits\n- Move right to position 8 and harvest 6 fruits\nYou moved 3 steps and harvested 3 + 6 = 9 fruits in total.\n\n```\n\n**Example 2:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2100-2199/2106.Maximum%20Fruits%20Harvested%20After%20at%20Most%20K%20Steps/images/2.png)\n\n```\n\n**Input:** fruits = [[0,9],[4,1],[5,7],[6,2],[7,4],[10,9]], startPos = 5, k = 4\n**Output:** 14\n**Explanation:** \nYou can move at most k = 4 steps, so you cannot reach position 0 nor 10.\nThe optimal way is to:\n- Harvest the 7 fruits at the starting position 5\n- Move left to position 4 and harvest 1 fruit\n- Move right to position 6 and harvest 2 fruits\n- Move right to position 7 and harvest 4 fruits\nYou moved 1 + 3 = 4 steps and harvested 7 + 1 + 2 + 4 = 14 fruits in total.\n\n```\n\n**Example 3:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2100-2199/2106.Maximum%20Fruits%20Harvested%20After%20at%20Most%20K%20Steps/images/3.png)\n\n```\n\n**Input:** fruits = [[0,3],[6,4],[8,5]], startPos = 3, k = 2\n**Output:** 0\n**Explanation:**\nYou can move at most k = 2 steps and cannot reach any position with fruits.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= fruits.length <= 105`\n* `fruits[i].length == 2`\n* `0 <= startPos, positioni <= 2 * 105`\n* `positioni-1 < positioni` for any `i > 0`\u00a0(**0-indexed**)\n* `1 <= amounti <= 104`\n* `0 <= k <= 2 * 105`\n\n\n",
    "inefficient_solution": "class Solution:\n    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:\n        n = len(fruits)\n        memo = [[0]*n for _ in range(2*n+1)]\n        for i in range(n):\n            for j in range(2*n+1):\n                memo[j][i] = -1\n        def dfs(pos, steps):\n            if pos < 0 or pos >= 2*n or steps < 0:\n                return 0\n            if memo[pos][steps] != -1:\n                return memo[pos][steps]\n            res = 0\n            if steps > 0:\n                res = dfs(pos-1, steps-1)\n            if steps > 0:\n                res = max(res, dfs(pos+1, steps-1))\n            for i in range(n):\n                if abs(pos-fruits[i][0]) <= steps:\n                    res = max(res, fruits[i][1] + dfs(pos-fruits[i][0], steps-2*abs(pos-fruits[i][0])))\n            memo[pos][steps] = res\n            return res\n        ans = 0\n        for i in range(n):\n            if abs(startPos-fruits[i][0]) <= k:\n                ans = max(ans, dfs(fruits[i][0], k-2*abs(startPos-fruits[i][0])))\n        return ans",
    "efficient_solution": "class Solution:\n    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:\n        ans = i = s = 0\n        for j, (pj, fj) in enumerate(fruits):\n            s += fj\n            while (\n                i <= j\n                and pj\n                - fruits[i][0]\n                + min(abs(startPos - fruits[i][0]), abs(startPos - fruits[j][0]))\n                > k\n            ):\n                s -= fruits[i][1]\n                i += 1\n            ans = max(ans, s)\n        return ans\n",
    "text": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nFruits are available at some positions on an infinite x-axis. You are given a 2D integer array `fruits` where `fruits[i] = [positioni, amounti]` depicts `amounti` fruits at the position `positioni`. `fruits` is already **sorted** by `positioni` in **ascending order**, and each `positioni` is **unique**.\n\n\nYou are also given an integer `startPos` and an integer `k`. Initially, you are at the position `startPos`. From any position, you can either walk to the **left or right**. It takes **one step** to move **one unit** on the x-axis, and you can walk **at most** `k` steps in total. For every position you reach, you harvest all the fruits at that position, and the fruits will disappear from that position.\n\n\nReturn *the **maximum total number** of fruits you can harvest*.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2100-2199/2106.Maximum%20Fruits%20Harvested%20After%20at%20Most%20K%20Steps/images/1.png)\n\n```\n\n**Input:** fruits = [[2,8],[6,3],[8,6]], startPos = 5, k = 4\n**Output:** 9\n**Explanation:** \nThe optimal way is to:\n- Move right to position 6 and harvest 3 fruits\n- Move right to position 8 and harvest 6 fruits\nYou moved 3 steps and harvested 3 + 6 = 9 fruits in total.\n\n```\n\n**Example 2:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2100-2199/2106.Maximum%20Fruits%20Harvested%20After%20at%20Most%20K%20Steps/images/2.png)\n\n```\n\n**Input:** fruits = [[0,9],[4,1],[5,7],[6,2],[7,4],[10,9]], startPos = 5, k = 4\n**Output:** 14\n**Explanation:** \nYou can move at most k = 4 steps, so you cannot reach position 0 nor 10.\nThe optimal way is to:\n- Harvest the 7 fruits at the starting position 5\n- Move left to position 4 and harvest 1 fruit\n- Move right to position 6 and harvest 2 fruits\n- Move right to position 7 and harvest 4 fruits\nYou moved 1 + 3 = 4 steps and harvested 7 + 1 + 2 + 4 = 14 fruits in total.\n\n```\n\n**Example 3:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2100-2199/2106.Maximum%20Fruits%20Harvested%20After%20at%20Most%20K%20Steps/images/3.png)\n\n```\n\n**Input:** fruits = [[0,3],[6,4],[8,5]], startPos = 3, k = 2\n**Output:** 0\n**Explanation:**\nYou can move at most k = 2 steps and cannot reach any position with fruits.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= fruits.length <= 105`\n* `fruits[i].length == 2`\n* `0 <= startPos, positioni <= 2 * 105`\n* `positioni-1 < positioni` for any `i > 0`\u00a0(**0-indexed**)\n* `1 <= amounti <= 104`\n* `0 <= k <= 2 * 105`\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:\n        n = len(fruits)\n        memo = [[0]*n for _ in range(2*n+1)]\n        for i in range(n):\n            for j in range(2*n+1):\n                memo[j][i] = -1\n        def dfs(pos, steps):\n            if pos < 0 or pos >= 2*n or steps < 0:\n                return 0\n            if memo[pos][steps] != -1:\n                return memo[pos][steps]\n            res = 0\n            if steps > 0:\n                res = dfs(pos-1, steps-1)\n            if steps > 0:\n                res = max(res, dfs(pos+1, steps-1))\n            for i in range(n):\n                if abs(pos-fruits[i][0]) <= steps:\n                    res = max(res, fruits[i][1] + dfs(pos-fruits[i][0], steps-2*abs(pos-fruits[i][0])))\n            memo[pos][steps] = res\n            return res\n        ans = 0\n        for i in range(n):\n            if abs(startPos-fruits[i][0]) <= k:\n                ans = max(ans, dfs(fruits[i][0], k-2*abs(startPos-fruits[i][0])))\n        return ans\n\n### Efficient Solution:\nclass Solution:\n    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:\n        ans = i = s = 0\n        for j, (pj, fj) in enumerate(fruits):\n            s += fj\n            while (\n                i <= j\n                and pj\n                - fruits[i][0]\n                + min(abs(startPos - fruits[i][0]), abs(startPos - fruits[j][0]))\n                > k\n            ):\n                s -= fruits[i][1]\n                i += 1\n            ans = max(ans, s)\n        return ans\n<|eot_id|>",
    "model_generation": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nFruits are available at some positions on an infinite x-axis. You are given a 2D integer array `fruits` where `fruits[i] = [positioni, amounti]` depicts `amounti` fruits at the position `positioni`. `fruits` is already **sorted** by `positioni` in **ascending order**, and each `positioni` is **unique**.\n\n\nYou are also given an integer `startPos` and an integer `k`. Initially, you are at the position `startPos`. From any position, you can either walk to the **left or right**. It takes **one step** to move **one unit** on the x-axis, and you can walk **at most** `k` steps in total. For every position you reach, you harvest all the fruits at that position, and the fruits will disappear from that position.\n\n\nReturn *the **maximum total number** of fruits you can harvest*.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2100-2199/2106.Maximum%20Fruits%20Harvested%20After%20at%20Most%20K%20Steps/images/1.png)\n\n```\n\n**Input:** fruits = [[2,8],[6,3],[8,6]], startPos = 5, k = 4\n**Output:** 9\n**Explanation:** \nThe optimal way is to:\n- Move right to position 6 and harvest 3 fruits\n- Move right to position 8 and harvest 6 fruits\nYou moved 3 steps and harvested 3 + 6 = 9 fruits in total.\n\n```\n\n**Example 2:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2100-2199/2106.Maximum%20Fruits%20Harvested%20After%20at%20Most%20K%20Steps/images/2.png)\n\n```\n\n**Input:** fruits = [[0,9],[4,1],[5,7],[6,2],[7,4],[10,9]], startPos = 5, k = 4\n**Output:** 14\n**Explanation:** \nYou can move at most k = 4 steps, so you cannot reach position 0 nor 10.\nThe optimal way is to:\n- Harvest the 7 fruits at the starting position 5\n- Move left to position 4 and harvest 1 fruit\n- Move right to position 6 and harvest 2 fruits\n- Move right to position 7 and harvest 4 fruits\nYou moved 1 + 3 = 4 steps and harvested 7 + 1 + 2 + 4 = 14 fruits in total.\n\n```\n\n**Example 3:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2100-2199/2106.Maximum%20Fruits%20Harvested%20After%20at%20Most%20K%20Steps/images/3.png)\n\n```\n\n**Input:** fruits = [[0,3],[6,4],[8,5]], startPos = 3, k = 2\n**Output:** 0\n**Explanation:**\nYou can move at most k = 2 steps and cannot reach any position with fruits.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= fruits.length <= 105`\n* `fruits[i].length == 2`\n* `0 <= startPos, positioni <= 2 * 105`\n* `positioni-1 < positioni` for any `i > 0`\u00a0(**0-indexed**)\n* `1 <= amounti <= 104`\n* `0 <= k <= 2 * 105`\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:\n        n = len(fruits)\n        memo = [[0]*n for _ in range(2*n+1)]\n        for i in range(n):\n            for j in range(2*n+1):\n                memo[j][i] = -1\n        def dfs(pos, steps):\n            if pos < 0 or pos >= 2*n or steps < 0:\n                return 0\n            if memo[pos][steps]!= -1:\n                return memo[pos][steps]\n            res = 0\n            if steps > 0:\n                res = dfs(pos-1, steps-1)\n            if steps > 0:\n                res = max(res, dfs(pos+1, steps-1))\n            for i in range(n):\n                if abs(pos-fruits[i][0]) <= steps:\n                    res = max(res, fruits[i][1] + dfs(pos-fruits[i][0], steps-2*abs(pos-fruits[i][0])))\n            memo[pos][steps] = res\n            return res\n        ans = 0\n        for i in range(n):\n            if abs(startPos-fruits[i][0]) <= k:\n                ans = max(ans, dfs(fruits[i][0], k-2*abs(startPos-fruits[i][0])))\n        return ans\n\n### Efficient Solution:\nclass Solution:\n    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:\n        s = list(accumulate((v for _, v in fruits), initial=0))\n        n = len(fruits)\n        f = [0] * (n + 1)\n        for i in range(n - 1, -1, -1):\n            f[i] = f[i + 1] + s[i]\n        l, r = 0, n\n        while l < r:\n            mid = (l + r + 1) >> 1\n            ok = 1\n            for i in range(n):\n                d = abs(startPos - fruits[i][0])\n                if d <= k:\n                    j = bisect_left(f, s[i] + f[i] - (s[mid - 1] if i < mid - 1 else 0))\n                    if j - l <= k - d:\n                        ok = 0\n                        break\n                if fruits[i][0] <= startPos:\n                    l = i + 1\n                else:\n                    r = i\n            if not ok:\n                r -= 1\n            else:\n                l += 1\n        return s[l - 1] + f[l - 1]\n",
    "model_solution": "class Solution:\n    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:\n        s = list(accumulate((v for _, v in fruits), initial=0))\n        n = len(fruits)\n        f = [0] * (n + 1)\n        for i in range(n - 1, -1, -1):\n            f[i] = f[i + 1] + s[i]\n        l, r = 0, n\n        while l < r:\n            mid = (l + r + 1) >> 1\n            ok = 1\n            for i in range(n):\n                d = abs(startPos - fruits[i][0])\n                if d <= k:\n                    j = bisect_left(f, s[i] + f[i] - (s[mid - 1] if i < mid - 1 else 0))\n                    if j - l <= k - d:\n                        ok = 0\n                        break\n                if fruits[i][0] <= startPos:\n                    l = i + 1\n                else:\n                    r = i\n            if not ok:\n                r -= 1\n            else:\n                l += 1\n        return s[l - 1] + f[l - 1]"
}