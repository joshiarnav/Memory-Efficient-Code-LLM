{
    "problem_idx": "1007",
    "description": "\nIn a row of dominoes, `tops[i]` and `bottoms[i]` represent the top and bottom halves of the `ith` domino. (A domino is a tile with two numbers from 1 to 6 - one on each half of the tile.)\n\n\nWe may rotate the `ith` domino, so that `tops[i]` and `bottoms[i]` swap values.\n\n\nReturn the minimum number of rotations so that all the values in `tops` are the same, or all the values in `bottoms` are the same.\n\n\nIf it cannot be done, return `-1`.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1000-1099/1007.Minimum%20Domino%20Rotations%20For%20Equal%20Row/images/domino.png)\n\n```\n\n**Input:** tops = [2,1,2,4,2,2], bottoms = [5,2,6,2,3,2]\n**Output:** 2\n**Explanation:** \nThe first figure represents the dominoes as given by tops and bottoms: before we do any rotations.\nIf we rotate the second and fourth dominoes, we can make every value in the top row equal to 2, as indicated by the second figure.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** tops = [3,5,1,2,3], bottoms = [3,6,3,3,4]\n**Output:** -1\n**Explanation:** \nIn this case, it is not possible to rotate the dominoes to make one row of values equal.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `2 <= tops.length <= 2 * 104`\n* `bottoms.length == tops.length`\n* `1 <= tops[i], bottoms[i] <= 6`\n\n\n",
    "inefficient_solution": "class Solution:\n    def minDominoRotations(self, tops, bottoms):\n        def f(x):\n            cnt1 = cnt2 = 0\n            for a, b in zip(tops, bottoms):\n                y = list(map(int, str(a) + str(b)))\n                if x not in y:\n                    return float('inf')\n                cnt1 += str(x) in str(a)\n                cnt2 += str(x) in str(b)\n            return len(tops) - max(cnt1, cnt2)\n\n        ans = min(f(tops[0]), f(bottoms[0]))\n        return -1 if ans == float('inf') else ans\n\n    def f2(self, tops, bottoms):\n        return sum(map(lambda x: x[0] == x[1], zip(tops, bottoms))) + sum(map(lambda x: x[0] != x[1], zip(tops, bottoms)))\n\n    def f3(self, tops, bottoms):\n        return sum(map(lambda x: x[0] == x[1] or x[0] == x[2], zip(tops, bottoms, [[0]*len(tops)]*len(tops)))) + sum(map(lambda x: x[0] == x[1] or x[1] == x[2], zip(tops, bottoms, [[0]*len(tops)]*len(tops))))\n\n    def f4(self, tops, bottoms):\n        result = []\n        for i in range(len(tops)):\n            result.append(list(map(int, str(tops[i]) + str(bottoms[i]))))\n        return sum(map(lambda x: x[0] in x[1:], result)) + sum(map(lambda x: x[1] in x[0:], result))\n\n    def f5(self, tops, bottoms):\n        return sum(map(lambda x: x[0] in (x[1], x[2]), zip(tops, bottoms, [[0]*len(tops)]*len(tops)))) + sum(map(lambda x: x[1] in (x[0], x[2]), zip(tops, bottoms, [[0]*len(tops)]*len(tops))))\n\n    def f6(self, tops, bottoms):\n        result = []\n        for i in range(len(tops)):\n            result.append(list(map(int, str(tops[i]) + str(bottoms[i]))))\n        return sum(map(lambda x: x[0] in x[1:], result)) + sum(map(lambda x: x[1] in x[0:], result))\n\n    def f7(self, tops, bottoms):\n        result = []\n        for i in range(len(tops)):\n            result.append(list(map(int, str(tops[i]) + str(bottoms[i]))))\n        return sum(map(lambda x: x[0] in x[1:], result)) + sum(map(lambda x: x[1] in x[0:], result))\n\n    def f8(self, tops, bottoms):\n        result = []\n        for i in range(len(tops)):\n            result.append(list(map(int, str(tops[i]) + str(bottoms[i]))))\n        return sum(map(lambda x: x[0] in x[1:], result)) + sum(map(lambda x: x[1] in x[0:], result))",
    "efficient_solution": "class Solution:\n    def minDominoRotations(self, tops: List[int], bottoms: List[int]) -> int:\n        def f(x: int) -> int:\n            cnt1 = cnt2 = 0\n            for a, b in zip(tops, bottoms):\n                if x not in (a, b):\n                    return inf\n                cnt1 += a == x\n                cnt2 += b == x\n            return len(tops) - max(cnt1, cnt2)\n\n        ans = min(f(tops[0]), f(bottoms[0]))\n        return -1 if ans == inf else ans\n",
    "text": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nIn a row of dominoes, `tops[i]` and `bottoms[i]` represent the top and bottom halves of the `ith` domino. (A domino is a tile with two numbers from 1 to 6 - one on each half of the tile.)\n\n\nWe may rotate the `ith` domino, so that `tops[i]` and `bottoms[i]` swap values.\n\n\nReturn the minimum number of rotations so that all the values in `tops` are the same, or all the values in `bottoms` are the same.\n\n\nIf it cannot be done, return `-1`.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1000-1099/1007.Minimum%20Domino%20Rotations%20For%20Equal%20Row/images/domino.png)\n\n```\n\n**Input:** tops = [2,1,2,4,2,2], bottoms = [5,2,6,2,3,2]\n**Output:** 2\n**Explanation:** \nThe first figure represents the dominoes as given by tops and bottoms: before we do any rotations.\nIf we rotate the second and fourth dominoes, we can make every value in the top row equal to 2, as indicated by the second figure.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** tops = [3,5,1,2,3], bottoms = [3,6,3,3,4]\n**Output:** -1\n**Explanation:** \nIn this case, it is not possible to rotate the dominoes to make one row of values equal.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `2 <= tops.length <= 2 * 104`\n* `bottoms.length == tops.length`\n* `1 <= tops[i], bottoms[i] <= 6`\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def minDominoRotations(self, tops, bottoms):\n        def f(x):\n            cnt1 = cnt2 = 0\n            for a, b in zip(tops, bottoms):\n                y = list(map(int, str(a) + str(b)))\n                if x not in y:\n                    return float('inf')\n                cnt1 += str(x) in str(a)\n                cnt2 += str(x) in str(b)\n            return len(tops) - max(cnt1, cnt2)\n\n        ans = min(f(tops[0]), f(bottoms[0]))\n        return -1 if ans == float('inf') else ans\n\n    def f2(self, tops, bottoms):\n        return sum(map(lambda x: x[0] == x[1], zip(tops, bottoms))) + sum(map(lambda x: x[0] != x[1], zip(tops, bottoms)))\n\n    def f3(self, tops, bottoms):\n        return sum(map(lambda x: x[0] == x[1] or x[0] == x[2], zip(tops, bottoms, [[0]*len(tops)]*len(tops)))) + sum(map(lambda x: x[0] == x[1] or x[1] == x[2], zip(tops, bottoms, [[0]*len(tops)]*len(tops))))\n\n    def f4(self, tops, bottoms):\n        result = []\n        for i in range(len(tops)):\n            result.append(list(map(int, str(tops[i]) + str(bottoms[i]))))\n        return sum(map(lambda x: x[0] in x[1:], result)) + sum(map(lambda x: x[1] in x[0:], result))\n\n    def f5(self, tops, bottoms):\n        return sum(map(lambda x: x[0] in (x[1], x[2]), zip(tops, bottoms, [[0]*len(tops)]*len(tops)))) + sum(map(lambda x: x[1] in (x[0], x[2]), zip(tops, bottoms, [[0]*len(tops)]*len(tops))))\n\n    def f6(self, tops, bottoms):\n        result = []\n        for i in range(len(tops)):\n            result.append(list(map(int, str(tops[i]) + str(bottoms[i]))))\n        return sum(map(lambda x: x[0] in x[1:], result)) + sum(map(lambda x: x[1] in x[0:], result))\n\n    def f7(self, tops, bottoms):\n        result = []\n        for i in range(len(tops)):\n            result.append(list(map(int, str(tops[i]) + str(bottoms[i]))))\n        return sum(map(lambda x: x[0] in x[1:], result)) + sum(map(lambda x: x[1] in x[0:], result))\n\n    def f8(self, tops, bottoms):\n        result = []\n        for i in range(len(tops)):\n            result.append(list(map(int, str(tops[i]) + str(bottoms[i]))))\n        return sum(map(lambda x: x[0] in x[1:], result)) + sum(map(lambda x: x[1] in x[0:], result))\n\n### Efficient Solution:\nclass Solution:\n    def minDominoRotations(self, tops: List[int], bottoms: List[int]) -> int:\n        def f(x: int) -> int:\n            cnt1 = cnt2 = 0\n            for a, b in zip(tops, bottoms):\n                if x not in (a, b):\n                    return inf\n                cnt1 += a == x\n                cnt2 += b == x\n            return len(tops) - max(cnt1, cnt2)\n\n        ans = min(f(tops[0]), f(bottoms[0]))\n        return -1 if ans == inf else ans\n<|eot_id|>",
    "model_generation": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nIn a row of dominoes, `tops[i]` and `bottoms[i]` represent the top and bottom halves of the `ith` domino. (A domino is a tile with two numbers from 1 to 6 - one on each half of the tile.)\n\n\nWe may rotate the `ith` domino, so that `tops[i]` and `bottoms[i]` swap values.\n\n\nReturn the minimum number of rotations so that all the values in `tops` are the same, or all the values in `bottoms` are the same.\n\n\nIf it cannot be done, return `-1`.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1000-1099/1007.Minimum%20Domino%20Rotations%20For%20Equal%20Row/images/domino.png)\n\n```\n\n**Input:** tops = [2,1,2,4,2,2], bottoms = [5,2,6,2,3,2]\n**Output:** 2\n**Explanation:** \nThe first figure represents the dominoes as given by tops and bottoms: before we do any rotations.\nIf we rotate the second and fourth dominoes, we can make every value in the top row equal to 2, as indicated by the second figure.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** tops = [3,5,1,2,3], bottoms = [3,6,3,3,4]\n**Output:** -1\n**Explanation:** \nIn this case, it is not possible to rotate the dominoes to make one row of values equal.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `2 <= tops.length <= 2 * 104`\n* `bottoms.length == tops.length`\n* `1 <= tops[i], bottoms[i] <= 6`\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def minDominoRotations(self, tops, bottoms):\n        def f(x):\n            cnt1 = cnt2 = 0\n            for a, b in zip(tops, bottoms):\n                y = list(map(int, str(a) + str(b)))\n                if x not in y:\n                    return float('inf')\n                cnt1 += str(x) in str(a)\n                cnt2 += str(x) in str(b)\n            return len(tops) - max(cnt1, cnt2)\n\n        ans = min(f(tops[0]), f(bottoms[0]))\n        return -1 if ans == float('inf') else ans\n\n    def f2(self, tops, bottoms):\n        return sum(map(lambda x: x[0] == x[1], zip(tops, bottoms))) + sum(map(lambda x: x[0]!= x[1], zip(tops, bottoms)))\n\n    def f3(self, tops, bottoms):\n        return sum(map(lambda x: x[0] == x[1] or x[0] == x[2], zip(tops, bottoms, [[0]*len(tops)]*len(tops)))) + sum(map(lambda x: x[0] == x[1] or x[1] == x[2], zip(tops, bottoms, [[0]*len(tops)]*len(tops))))\n\n    def f4(self, tops, bottoms):\n        result = []\n        for i in range(len(tops)):\n            result.append(list(map(int, str(tops[i]) + str(bottoms[i]))))\n        return sum(map(lambda x: x[0] in x[1:], result)) + sum(map(lambda x: x[1] in x[0:], result))\n\n    def f5(self, tops, bottoms):\n        return sum(map(lambda x: x[0] in (x[1], x[2]), zip(tops, bottoms, [[0]*len(tops)]*len(tops)))) + sum(map(lambda x: x[1] in (x[0], x[2]), zip(tops, bottoms, [[0]*len(tops)]*len(tops))))\n\n    def f6(self, tops, bottoms):\n        result = []\n        for i in range(len(tops)):\n            result.append(list(map(int, str(tops[i]) + str(bottoms[i]))))\n        return sum(map(lambda x: x[0] in x[1:], result)) + sum(map(lambda x: x[1] in x[0:], result))\n\n    def f7(self, tops, bottoms):\n        result = []\n        for i in range(len(tops)):\n            result.append(list(map(int, str(tops[i]) + str(bottoms[i]))))\n        return sum(map(lambda x: x[0] in x[1:], result)) + sum(map(lambda x: x[1] in x[0:], result))\n\n    def f8(self, tops, bottoms):\n        result = []\n        for i in range(len(tops)):\n            result.append(list(map(int, str(tops[i]) + str(bottoms[i]))))\n        return sum(map(lambda x: x[0] in x[1:], result)) + sum(map(lambda x: x[1] in x[0:], result))\n\n### Efficient Solution:\nclass Solution:\n    def minDominoRotations(self, tops: List[int], bottoms: List[int]) -> int:\n        def f(x):\n            cnt1 = cnt2 = 0\n            for a, b in zip(tops, bottoms):\n                if x not in (a, b):\n                    return len(tops)\n                cnt1 += a == x\n                cnt2 += b == x\n            return len(tops) - max(cnt1, cnt2)\n\n        ans = min(f(tops[0]), f(bottoms[0]))\n        return -1 if ans == len(tops) else ans\n",
    "model_solution": "class Solution:\n    def minDominoRotations(self, tops: List[int], bottoms: List[int]) -> int:\n        def f(x):\n            cnt1 = cnt2 = 0\n            for a, b in zip(tops, bottoms):\n                if x not in (a, b):\n                    return len(tops)\n                cnt1 += a == x\n                cnt2 += b == x\n            return len(tops) - max(cnt1, cnt2)\n\n        ans = min(f(tops[0]), f(bottoms[0]))\n        return -1 if ans == len(tops) else ans"
}