{
    "problem_idx": "1987",
    "description": "\nYou are given a binary string `binary`. A **subsequence** of `binary` is considered **good** if it is **not empty** and has **no leading zeros** (with the exception of `\"0\"`).\n\n\nFind the number of **unique good subsequences** of `binary`.\n\n\n* For example, if `binary = \"001\"`, then all the **good** subsequences are `[\"0\", \"0\", \"1\"]`, so the **unique** good subsequences are `\"0\"` and `\"1\"`. Note that subsequences `\"00\"`, `\"01\"`, and `\"001\"` are not good because they have leading zeros.\n\n\nReturn *the number of **unique good subsequences** of* `binary`. Since the answer may be very large, return it **modulo** `109 + 7`.\n\n\nA **subsequence** is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** binary = \"001\"\n**Output:** 2\n**Explanation:** The good subsequences of binary are [\"0\", \"0\", \"1\"].\nThe unique good subsequences are \"0\" and \"1\".\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** binary = \"11\"\n**Output:** 2\n**Explanation:** The good subsequences of binary are [\"1\", \"1\", \"11\"].\nThe unique good subsequences are \"1\" and \"11\".\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** binary = \"101\"\n**Output:** 5\n**Explanation:** The good subsequences of binary are [\"1\", \"0\", \"1\", \"10\", \"11\", \"101\"]. \nThe unique good subsequences are \"0\", \"1\", \"10\", \"11\", and \"101\".\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= binary.length <= 105`\n* `binary` consists of only `'0'`s and `'1'`s.\n\n\n",
    "inefficient_solution": "class Solution:\n    def numberOfUniqueGoodSubsequences(self, binary: str) -> int:\n        dp = [0] * len(binary)\n        for i, c in enumerate(binary):\n            if c == \"0\":\n                for j in range(i):\n                    dp[i] += dp[j]\n            else:\n                for j in range(i):\n                    dp[i] += dp[j] + 1\n            dp[i] %= 10**9 + 7\n        unique_subseq = set()\n        for num in dp:\n            unique_subseq.add(chr(num % 2))\n        return len(unique_subseq)",
    "efficient_solution": "class Solution:\n    def numberOfUniqueGoodSubsequences(self, binary: str) -> int:\n        f = g = 0\n        ans = 0\n        mod = 10**9 + 7\n        for c in binary:\n            if c == \"0\":\n                g = (g + f) % mod\n                ans = 1\n            else:\n                f = (f + g + 1) % mod\n        ans = (ans + f + g) % mod\n        return ans\n",
    "text": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nYou are given a binary string `binary`. A **subsequence** of `binary` is considered **good** if it is **not empty** and has **no leading zeros** (with the exception of `\"0\"`).\n\n\nFind the number of **unique good subsequences** of `binary`.\n\n\n* For example, if `binary = \"001\"`, then all the **good** subsequences are `[\"0\", \"0\", \"1\"]`, so the **unique** good subsequences are `\"0\"` and `\"1\"`. Note that subsequences `\"00\"`, `\"01\"`, and `\"001\"` are not good because they have leading zeros.\n\n\nReturn *the number of **unique good subsequences** of* `binary`. Since the answer may be very large, return it **modulo** `109 + 7`.\n\n\nA **subsequence** is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** binary = \"001\"\n**Output:** 2\n**Explanation:** The good subsequences of binary are [\"0\", \"0\", \"1\"].\nThe unique good subsequences are \"0\" and \"1\".\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** binary = \"11\"\n**Output:** 2\n**Explanation:** The good subsequences of binary are [\"1\", \"1\", \"11\"].\nThe unique good subsequences are \"1\" and \"11\".\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** binary = \"101\"\n**Output:** 5\n**Explanation:** The good subsequences of binary are [\"1\", \"0\", \"1\", \"10\", \"11\", \"101\"]. \nThe unique good subsequences are \"0\", \"1\", \"10\", \"11\", and \"101\".\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= binary.length <= 105`\n* `binary` consists of only `'0'`s and `'1'`s.\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def numberOfUniqueGoodSubsequences(self, binary: str) -> int:\n        dp = [0] * len(binary)\n        for i, c in enumerate(binary):\n            if c == \"0\":\n                for j in range(i):\n                    dp[i] += dp[j]\n            else:\n                for j in range(i):\n                    dp[i] += dp[j] + 1\n            dp[i] %= 10**9 + 7\n        unique_subseq = set()\n        for num in dp:\n            unique_subseq.add(chr(num % 2))\n        return len(unique_subseq)\n\n### Efficient Solution:\nclass Solution:\n    def numberOfUniqueGoodSubsequences(self, binary: str) -> int:\n        f = g = 0\n        ans = 0\n        mod = 10**9 + 7\n        for c in binary:\n            if c == \"0\":\n                g = (g + f) % mod\n                ans = 1\n            else:\n                f = (f + g + 1) % mod\n        ans = (ans + f + g) % mod\n        return ans\n<|eot_id|>",
    "model_generation": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nYou are given a binary string `binary`. A **subsequence** of `binary` is considered **good** if it is **not empty** and has **no leading zeros** (with the exception of `\"0\"`).\n\n\nFind the number of **unique good subsequences** of `binary`.\n\n\n* For example, if `binary = \"001\"`, then all the **good** subsequences are `[\"0\", \"0\", \"1\"]`, so the **unique** good subsequences are `\"0\"` and `\"1\"`. Note that subsequences `\"00\"`, `\"01\"`, and `\"001\"` are not good because they have leading zeros.\n\n\nReturn *the number of **unique good subsequences** of* `binary`. Since the answer may be very large, return it **modulo** `109 + 7`.\n\n\nA **subsequence** is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** binary = \"001\"\n**Output:** 2\n**Explanation:** The good subsequences of binary are [\"0\", \"0\", \"1\"].\nThe unique good subsequences are \"0\" and \"1\".\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** binary = \"11\"\n**Output:** 2\n**Explanation:** The good subsequences of binary are [\"1\", \"1\", \"11\"].\nThe unique good subsequences are \"1\" and \"11\".\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** binary = \"101\"\n**Output:** 5\n**Explanation:** The good subsequences of binary are [\"1\", \"0\", \"1\", \"10\", \"11\", \"101\"]. \nThe unique good subsequences are \"0\", \"1\", \"10\", \"11\", and \"101\".\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= binary.length <= 105`\n* `binary` consists of only `'0'`s and `'1'`s.\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def numberOfUniqueGoodSubsequences(self, binary: str) -> int:\n        dp = [0] * len(binary)\n        for i, c in enumerate(binary):\n            if c == \"0\":\n                for j in range(i):\n                    dp[i] += dp[j]\n            else:\n                for j in range(i):\n                    dp[i] += dp[j] + 1\n            dp[i] %= 10**9 + 7\n        unique_subseq = set()\n        for num in dp:\n            unique_subseq.add(chr(num % 2))\n        return len(unique_subseq)\n\n### Efficient Solution:\nclass Solution:\n    def numberOfUniqueGoodSubsequences(self, binary: str) -> int:\n        a = b = 0\n        mod = 10**9 + 7\n        for c in binary:\n            if c == \"0\":\n                a = (a + b) % mod\n            else:\n                b = (b + a + 1) % mod\n        return a + b + 1\n",
    "model_solution": "class Solution:\n    def numberOfUniqueGoodSubsequences(self, binary: str) -> int:\n        a = b = 0\n        mod = 10**9 + 7\n        for c in binary:\n            if c == \"0\":\n                a = (a + b) % mod\n            else:\n                b = (b + a + 1) % mod\n        return a + b + 1"
}