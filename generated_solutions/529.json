{
    "problem_idx": "529",
    "description": "\nLet's play the minesweeper game ([Wikipedia](https://en.wikipedia.org/wiki/Minesweeper_(video_game)), [online game](http://minesweeperonline.com))!\n\n\nYou are given an `m x n` char matrix `board` representing the game board where:\n\n\n* `'M'` represents an unrevealed mine,\n* `'E'` represents an unrevealed empty square,\n* `'B'` represents a revealed blank square that has no adjacent mines (i.e., above, below, left, right, and all 4 diagonals),\n* digit (`'1'` to `'8'`) represents how many mines are adjacent to this revealed square, and\n* `'X'` represents a revealed mine.\n\n\nYou are also given an integer array `click` where `click = [clickr, clickc]` represents the next click position among all the unrevealed squares (`'M'` or `'E'`).\n\n\nReturn *the board after revealing this position according to the following rules*:\n\n\n1. If a mine `'M'` is revealed, then the game is over. You should change it to `'X'`.\n2. If an empty square `'E'` with no adjacent mines is revealed, then change it to a revealed blank `'B'` and all of its adjacent unrevealed squares should be revealed recursively.\n3. If an empty square `'E'` with at least one adjacent mine is revealed, then change it to a digit (`'1'` to `'8'`) representing the number of adjacent mines.\n4. Return the board when no more squares will be revealed.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0500-0599/0529.Minesweeper/images/untitled.jpeg)\n\n```\n\n**Input:** board = [[\"E\",\"E\",\"E\",\"E\",\"E\"],[\"E\",\"E\",\"M\",\"E\",\"E\"],[\"E\",\"E\",\"E\",\"E\",\"E\"],[\"E\",\"E\",\"E\",\"E\",\"E\"]], click = [3,0]\n**Output:** [[\"B\",\"1\",\"E\",\"1\",\"B\"],[\"B\",\"1\",\"M\",\"1\",\"B\"],[\"B\",\"1\",\"1\",\"1\",\"B\"],[\"B\",\"B\",\"B\",\"B\",\"B\"]]\n\n```\n\n**Example 2:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0500-0599/0529.Minesweeper/images/untitled-2.jpeg)\n\n```\n\n**Input:** board = [[\"B\",\"1\",\"E\",\"1\",\"B\"],[\"B\",\"1\",\"M\",\"1\",\"B\"],[\"B\",\"1\",\"1\",\"1\",\"B\"],[\"B\",\"B\",\"B\",\"B\",\"B\"]], click = [1,2]\n**Output:** [[\"B\",\"1\",\"E\",\"1\",\"B\"],[\"B\",\"1\",\"X\",\"1\",\"B\"],[\"B\",\"1\",\"1\",\"1\",\"B\"],[\"B\",\"B\",\"B\",\"B\",\"B\"]]\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `m == board.length`\n* `n == board[i].length`\n* `1 <= m, n <= 50`\n* `board[i][j]` is either `'M'`, `'E'`, `'B'`, or a digit from `'1'` to `'8'`.\n* `click.length == 2`\n* `0 <= clickr < m`\n* `0 <= clickc < n`\n* `board[clickr][clickc]` is either `'M'` or `'E'`.\n\n\n",
    "inefficient_solution": "class Solution:\n    def updateBoard(self, board, click):\n        def dfs(i, j):\n            cnt = 0\n            adjacent = []\n            for x in range(i - 1, i + 2):\n                for y in range(j - 1, j + 2):\n                    adjacent.append((x, y))\n            for x, y in adjacent:\n                if 0 <= x < m and 0 <= y < n:\n                    if board[x][y] == \"M\":\n                        cnt += 1\n            if cnt:\n                board[i][j] = str(cnt)\n            else:\n                board[i][j] = \"B\"\n                for x, y in adjacent:\n                    if 0 <= x < m and 0 <= y < n and board[x][y] == \"E\":\n                        board[x][y] = \"E\"\n                        dfs(x, y)\n            return\n\n        m, n = len(board), len(board[0])\n        i, j = click\n        temp_board = [[cell for cell in row] for row in board]\n        temp_board[i][j] = \"T\"  # create a temporary board to avoid modifying the original board\n        dfs(i, j)\n        board = [[temp_board[row][col] for col in range(n)] for row in range(m)]\n        if board[i][j] == \"T\":\n            board[i][j] = board[i][j + 1]  # restore the original board\n            for x in range(m):\n                for y in range(n - 1):\n                    if board[x][y] == board[x][y + 1]:\n                        board[x][y] = board[x][y + 1]\n        return board",
    "efficient_solution": "class Solution:\n    def updateBoard(self, board: List[List[str]], click: List[int]) -> List[List[str]]:\n        def dfs(i: int, j: int):\n            cnt = 0\n            for x in range(i - 1, i + 2):\n                for y in range(j - 1, j + 2):\n                    if 0 <= x < m and 0 <= y < n and board[x][y] == \"M\":\n                        cnt += 1\n            if cnt:\n                board[i][j] = str(cnt)\n            else:\n                board[i][j] = \"B\"\n                for x in range(i - 1, i + 2):\n                    for y in range(j - 1, j + 2):\n                        if 0 <= x < m and 0 <= y < n and board[x][y] == \"E\":\n                            dfs(x, y)\n\n        m, n = len(board), len(board[0])\n        i, j = click\n        if board[i][j] == \"M\":\n            board[i][j] = \"X\"\n        else:\n            dfs(i, j)\n        return board\n",
    "text": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nLet's play the minesweeper game ([Wikipedia](https://en.wikipedia.org/wiki/Minesweeper_(video_game)), [online game](http://minesweeperonline.com))!\n\n\nYou are given an `m x n` char matrix `board` representing the game board where:\n\n\n* `'M'` represents an unrevealed mine,\n* `'E'` represents an unrevealed empty square,\n* `'B'` represents a revealed blank square that has no adjacent mines (i.e., above, below, left, right, and all 4 diagonals),\n* digit (`'1'` to `'8'`) represents how many mines are adjacent to this revealed square, and\n* `'X'` represents a revealed mine.\n\n\nYou are also given an integer array `click` where `click = [clickr, clickc]` represents the next click position among all the unrevealed squares (`'M'` or `'E'`).\n\n\nReturn *the board after revealing this position according to the following rules*:\n\n\n1. If a mine `'M'` is revealed, then the game is over. You should change it to `'X'`.\n2. If an empty square `'E'` with no adjacent mines is revealed, then change it to a revealed blank `'B'` and all of its adjacent unrevealed squares should be revealed recursively.\n3. If an empty square `'E'` with at least one adjacent mine is revealed, then change it to a digit (`'1'` to `'8'`) representing the number of adjacent mines.\n4. Return the board when no more squares will be revealed.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0500-0599/0529.Minesweeper/images/untitled.jpeg)\n\n```\n\n**Input:** board = [[\"E\",\"E\",\"E\",\"E\",\"E\"],[\"E\",\"E\",\"M\",\"E\",\"E\"],[\"E\",\"E\",\"E\",\"E\",\"E\"],[\"E\",\"E\",\"E\",\"E\",\"E\"]], click = [3,0]\n**Output:** [[\"B\",\"1\",\"E\",\"1\",\"B\"],[\"B\",\"1\",\"M\",\"1\",\"B\"],[\"B\",\"1\",\"1\",\"1\",\"B\"],[\"B\",\"B\",\"B\",\"B\",\"B\"]]\n\n```\n\n**Example 2:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0500-0599/0529.Minesweeper/images/untitled-2.jpeg)\n\n```\n\n**Input:** board = [[\"B\",\"1\",\"E\",\"1\",\"B\"],[\"B\",\"1\",\"M\",\"1\",\"B\"],[\"B\",\"1\",\"1\",\"1\",\"B\"],[\"B\",\"B\",\"B\",\"B\",\"B\"]], click = [1,2]\n**Output:** [[\"B\",\"1\",\"E\",\"1\",\"B\"],[\"B\",\"1\",\"X\",\"1\",\"B\"],[\"B\",\"1\",\"1\",\"1\",\"B\"],[\"B\",\"B\",\"B\",\"B\",\"B\"]]\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `m == board.length`\n* `n == board[i].length`\n* `1 <= m, n <= 50`\n* `board[i][j]` is either `'M'`, `'E'`, `'B'`, or a digit from `'1'` to `'8'`.\n* `click.length == 2`\n* `0 <= clickr < m`\n* `0 <= clickc < n`\n* `board[clickr][clickc]` is either `'M'` or `'E'`.\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def updateBoard(self, board, click):\n        def dfs(i, j):\n            cnt = 0\n            adjacent = []\n            for x in range(i - 1, i + 2):\n                for y in range(j - 1, j + 2):\n                    adjacent.append((x, y))\n            for x, y in adjacent:\n                if 0 <= x < m and 0 <= y < n:\n                    if board[x][y] == \"M\":\n                        cnt += 1\n            if cnt:\n                board[i][j] = str(cnt)\n            else:\n                board[i][j] = \"B\"\n                for x, y in adjacent:\n                    if 0 <= x < m and 0 <= y < n and board[x][y] == \"E\":\n                        board[x][y] = \"E\"\n                        dfs(x, y)\n            return\n\n        m, n = len(board), len(board[0])\n        i, j = click\n        temp_board = [[cell for cell in row] for row in board]\n        temp_board[i][j] = \"T\"  # create a temporary board to avoid modifying the original board\n        dfs(i, j)\n        board = [[temp_board[row][col] for col in range(n)] for row in range(m)]\n        if board[i][j] == \"T\":\n            board[i][j] = board[i][j + 1]  # restore the original board\n            for x in range(m):\n                for y in range(n - 1):\n                    if board[x][y] == board[x][y + 1]:\n                        board[x][y] = board[x][y + 1]\n        return board\n\n### Efficient Solution:\nclass Solution:\n    def updateBoard(self, board: List[List[str]], click: List[int]) -> List[List[str]]:\n        def dfs(i: int, j: int):\n            cnt = 0\n            for x in range(i - 1, i + 2):\n                for y in range(j - 1, j + 2):\n                    if 0 <= x < m and 0 <= y < n and board[x][y] == \"M\":\n                        cnt += 1\n            if cnt:\n                board[i][j] = str(cnt)\n            else:\n                board[i][j] = \"B\"\n                for x in range(i - 1, i + 2):\n                    for y in range(j - 1, j + 2):\n                        if 0 <= x < m and 0 <= y < n and board[x][y] == \"E\":\n                            dfs(x, y)\n\n        m, n = len(board), len(board[0])\n        i, j = click\n        if board[i][j] == \"M\":\n            board[i][j] = \"X\"\n        else:\n            dfs(i, j)\n        return board\n<|eot_id|>",
    "model_generation": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nLet's play the minesweeper game ([Wikipedia](https://en.wikipedia.org/wiki/Minesweeper_(video_game)), [online game](http://minesweeperonline.com))!\n\n\nYou are given an `m x n` char matrix `board` representing the game board where:\n\n\n* `'M'` represents an unrevealed mine,\n* `'E'` represents an unrevealed empty square,\n* `'B'` represents a revealed blank square that has no adjacent mines (i.e., above, below, left, right, and all 4 diagonals),\n* digit (`'1'` to `'8'`) represents how many mines are adjacent to this revealed square, and\n* `'X'` represents a revealed mine.\n\n\nYou are also given an integer array `click` where `click = [clickr, clickc]` represents the next click position among all the unrevealed squares (`'M'` or `'E'`).\n\n\nReturn *the board after revealing this position according to the following rules*:\n\n\n1. If a mine `'M'` is revealed, then the game is over. You should change it to `'X'`.\n2. If an empty square `'E'` with no adjacent mines is revealed, then change it to a revealed blank `'B'` and all of its adjacent unrevealed squares should be revealed recursively.\n3. If an empty square `'E'` with at least one adjacent mine is revealed, then change it to a digit (`'1'` to `'8'`) representing the number of adjacent mines.\n4. Return the board when no more squares will be revealed.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0500-0599/0529.Minesweeper/images/untitled.jpeg)\n\n```\n\n**Input:** board = [[\"E\",\"E\",\"E\",\"E\",\"E\"],[\"E\",\"E\",\"M\",\"E\",\"E\"],[\"E\",\"E\",\"E\",\"E\",\"E\"],[\"E\",\"E\",\"E\",\"E\",\"E\"]], click = [3,0]\n**Output:** [[\"B\",\"1\",\"E\",\"1\",\"B\"],[\"B\",\"1\",\"M\",\"1\",\"B\"],[\"B\",\"1\",\"1\",\"1\",\"B\"],[\"B\",\"B\",\"B\",\"B\",\"B\"]]\n\n```\n\n**Example 2:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0500-0599/0529.Minesweeper/images/untitled-2.jpeg)\n\n```\n\n**Input:** board = [[\"B\",\"1\",\"E\",\"1\",\"B\"],[\"B\",\"1\",\"M\",\"1\",\"B\"],[\"B\",\"1\",\"1\",\"1\",\"B\"],[\"B\",\"B\",\"B\",\"B\",\"B\"]], click = [1,2]\n**Output:** [[\"B\",\"1\",\"E\",\"1\",\"B\"],[\"B\",\"1\",\"X\",\"1\",\"B\"],[\"B\",\"1\",\"1\",\"1\",\"B\"],[\"B\",\"B\",\"B\",\"B\",\"B\"]]\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `m == board.length`\n* `n == board[i].length`\n* `1 <= m, n <= 50`\n* `board[i][j]` is either `'M'`, `'E'`, `'B'`, or a digit from `'1'` to `'8'`.\n* `click.length == 2`\n* `0 <= clickr < m`\n* `0 <= clickc < n`\n* `board[clickr][clickc]` is either `'M'` or `'E'`.\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def updateBoard(self, board, click):\n        def dfs(i, j):\n            cnt = 0\n            adjacent = []\n            for x in range(i - 1, i + 2):\n                for y in range(j - 1, j + 2):\n                    adjacent.append((x, y))\n            for x, y in adjacent:\n                if 0 <= x < m and 0 <= y < n:\n                    if board[x][y] == \"M\":\n                        cnt += 1\n            if cnt:\n                board[i][j] = str(cnt)\n            else:\n                board[i][j] = \"B\"\n                for x, y in adjacent:\n                    if 0 <= x < m and 0 <= y < n and board[x][y] == \"E\":\n                        board[x][y] = \"E\"\n                        dfs(x, y)\n            return\n\n        m, n = len(board), len(board[0])\n        i, j = click\n        temp_board = [[cell for cell in row] for row in board]\n        temp_board[i][j] = \"T\"  # create a temporary board to avoid modifying the original board\n        dfs(i, j)\n        board = [[temp_board[row][col] for col in range(n)] for row in range(m)]\n        if board[i][j] == \"T\":\n            board[i][j] = board[i][j + 1]  # restore the original board\n            for x in range(m):\n                for y in range(n - 1):\n                    if board[x][y] == board[x][y + 1]:\n                        board[x][y] = board[x][y + 1]\n        return board\n\n### Efficient Solution:\nclass Solution:\n    def updateBoard(self, board: List[List[str]], click: List[int]) -> List[List[str]]:\n        def dfs(i, j):\n            if i < 0 or j < 0 or i >= m or j >= n or board[i][j] in \"BM\":\n                return\n            if board[i][j] == \"M\":\n                board[i][j] = \"X\"\n                return\n            cnt = 0\n            for x in range(i - 1, i + 2):\n                for y in range(j - 1, j + 2):\n                    if 0 <= x < m and 0 <= y < n and board[x][y] == \"M\":\n                        cnt += 1\n            if cnt:\n                board[i][j] = str(cnt)\n            else:\n                board[i][j] = \"B\"\n                for x in range(i - 1, i + 2):\n                    for y in range(j - 1, j + 2):\n                        if 0 <= x < m and 0 <= y < n and board[x][y] == \"E\":\n                            dfs(x, y)\n\n        m, n = len(board), len(board[0])\n        i, j = click\n        dfs(i, j)\n        return board\n",
    "model_solution": "class Solution:\n    def updateBoard(self, board: List[List[str]], click: List[int]) -> List[List[str]]:\n        def dfs(i, j):\n            if i < 0 or j < 0 or i >= m or j >= n or board[i][j] in \"BM\":\n                return\n            if board[i][j] == \"M\":\n                board[i][j] = \"X\"\n                return\n            cnt = 0\n            for x in range(i - 1, i + 2):\n                for y in range(j - 1, j + 2):\n                    if 0 <= x < m and 0 <= y < n and board[x][y] == \"M\":\n                        cnt += 1\n            if cnt:\n                board[i][j] = str(cnt)\n            else:\n                board[i][j] = \"B\"\n                for x in range(i - 1, i + 2):\n                    for y in range(j - 1, j + 2):\n                        if 0 <= x < m and 0 <= y < n and board[x][y] == \"E\":\n                            dfs(x, y)\n\n        m, n = len(board), len(board[0])\n        i, j = click\n        dfs(i, j)\n        return board"
}