{
    "problem_idx": "1469",
    "description": "\nIn a binary tree, a **lonely** node is a node that is the only child of its parent node. The root of the tree is not lonely because it does not have a parent node.\n\n\nGiven the `root` of a binary tree, return *an array containing the values of all lonely nodes* in the tree. Return the list **in any order**.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1400-1499/1469.Find%20All%20The%20Lonely%20Nodes/images/e1.png)\n\n```\n\n**Input:** root = [1,2,3,null,4]\n**Output:** [4]\n**Explanation:** Light blue node is the only lonely node.\nNode 1 is the root and is not lonely.\nNodes 2 and 3 have the same parent and are not lonely.\n\n```\n\n**Example 2:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1400-1499/1469.Find%20All%20The%20Lonely%20Nodes/images/e2.png)\n\n```\n\n**Input:** root = [7,1,4,6,null,5,3,null,null,null,null,null,2]\n**Output:** [6,2]\n**Explanation:** Light blue nodes are lonely nodes.\nPlease remember that order doesn't matter, [2,6] is also an acceptable answer.\n\n```\n\n**Example 3:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1400-1499/1469.Find%20All%20The%20Lonely%20Nodes/images/tree.png)\n\n```\n\n**Input:** root = [11,99,88,77,null,null,66,55,null,null,44,33,null,null,22]\n**Output:** [77,55,33,66,44,22]\n**Explanation:** Nodes 99 and 88 share the same parent. Node 11 is the root.\nAll other nodes are lonely.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* The number of nodes in the `tree` is in the range `[1, 1000].`\n* `1 <= Node.val <= 106`\n\n\n",
    "inefficient_solution": "",
    "efficient_solution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def getLonelyNodes(self, root: Optional[TreeNode]) -> List[int]:\n        def dfs(root):\n            if root is None or (root.left is None and root.right is None):\n                return\n            if root.left is None:\n                ans.append(root.right.val)\n            if root.right is None:\n                ans.append(root.left.val)\n            dfs(root.left)\n            dfs(root.right)\n\n        ans = []\n        dfs(root)\n        return ans\n",
    "text": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nIn a binary tree, a **lonely** node is a node that is the only child of its parent node. The root of the tree is not lonely because it does not have a parent node.\n\n\nGiven the `root` of a binary tree, return *an array containing the values of all lonely nodes* in the tree. Return the list **in any order**.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1400-1499/1469.Find%20All%20The%20Lonely%20Nodes/images/e1.png)\n\n```\n\n**Input:** root = [1,2,3,null,4]\n**Output:** [4]\n**Explanation:** Light blue node is the only lonely node.\nNode 1 is the root and is not lonely.\nNodes 2 and 3 have the same parent and are not lonely.\n\n```\n\n**Example 2:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1400-1499/1469.Find%20All%20The%20Lonely%20Nodes/images/e2.png)\n\n```\n\n**Input:** root = [7,1,4,6,null,5,3,null,null,null,null,null,2]\n**Output:** [6,2]\n**Explanation:** Light blue nodes are lonely nodes.\nPlease remember that order doesn't matter, [2,6] is also an acceptable answer.\n\n```\n\n**Example 3:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1400-1499/1469.Find%20All%20The%20Lonely%20Nodes/images/tree.png)\n\n```\n\n**Input:** root = [11,99,88,77,null,null,66,55,null,null,44,33,null,null,22]\n**Output:** [77,55,33,66,44,22]\n**Explanation:** Nodes 99 and 88 share the same parent. Node 11 is the root.\nAll other nodes are lonely.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* The number of nodes in the `tree` is in the range `[1, 1000].`\n* `1 <= Node.val <= 106`\n\n\n\n\n### Inefficient Solution:\n\n\n### Efficient Solution:\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def getLonelyNodes(self, root: Optional[TreeNode]) -> List[int]:\n        def dfs(root):\n            if root is None or (root.left is None and root.right is None):\n                return\n            if root.left is None:\n                ans.append(root.right.val)\n            if root.right is None:\n                ans.append(root.left.val)\n            dfs(root.left)\n            dfs(root.right)\n\n        ans = []\n        dfs(root)\n        return ans\n<|eot_id|>",
    "model_generation": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nIn a binary tree, a **lonely** node is a node that is the only child of its parent node. The root of the tree is not lonely because it does not have a parent node.\n\n\nGiven the `root` of a binary tree, return *an array containing the values of all lonely nodes* in the tree. Return the list **in any order**.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1400-1499/1469.Find%20All%20The%20Lonely%20Nodes/images/e1.png)\n\n```\n\n**Input:** root = [1,2,3,null,4]\n**Output:** [4]\n**Explanation:** Light blue node is the only lonely node.\nNode 1 is the root and is not lonely.\nNodes 2 and 3 have the same parent and are not lonely.\n\n```\n\n**Example 2:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1400-1499/1469.Find%20All%20The%20Lonely%20Nodes/images/e2.png)\n\n```\n\n**Input:** root = [7,1,4,6,null,5,3,null,null,null,null,null,2]\n**Output:** [6,2]\n**Explanation:** Light blue nodes are lonely nodes.\nPlease remember that order doesn't matter, [2,6] is also an acceptable answer.\n\n```\n\n**Example 3:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1400-1499/1469.Find%20All%20The%20Lonely%20Nodes/images/tree.png)\n\n```\n\n**Input:** root = [11,99,88,77,null,null,66,55,null,null,44,33,null,null,22]\n**Output:** [77,55,33,66,44,22]\n**Explanation:** Nodes 99 and 88 share the same parent. Node 11 is the root.\nAll other nodes are lonely.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* The number of nodes in the `tree` is in the range `[1, 1000].`\n* `1 <= Node.val <= 106`\n\n\n\n\n### Inefficient Solution:\n\n\n### Efficient Solution:\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def getLonelyNodes(self, root: Optional[TreeNode]) -> List[int]:\n        def dfs(root):\n            if root is None:\n                return\n            if root.left is None and root.right is None:\n                ans.append(root.val)\n            dfs(root.left)\n            dfs(root.right)\n\n        ans = []\n        dfs(root)\n        return ans\n",
    "model_solution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def getLonelyNodes(self, root: Optional[TreeNode]) -> List[int]:\n        def dfs(root):\n            if root is None:\n                return\n            if root.left is None and root.right is None:\n                ans.append(root.val)\n            dfs(root.left)\n            dfs(root.right)\n\n        ans = []\n        dfs(root)\n        return ans"
}