{
    "problem_idx": "872",
    "description": "\nConsider all the leaves of a binary tree, from\u00a0left to right order, the values of those\u00a0leaves form a **leaf value sequence***.*\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0800-0899/0872.Leaf-Similar%20Trees/images/tree.png)\n\n\nFor example, in the given tree above, the leaf value sequence is `(6, 7, 4, 9, 8)`.\n\n\nTwo binary trees are considered *leaf-similar*\u00a0if their leaf value sequence is the same.\n\n\nReturn `true` if and only if the two given trees with head nodes `root1` and `root2` are leaf-similar.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0800-0899/0872.Leaf-Similar%20Trees/images/leaf-similar-1.jpg)\n\n```\n\n**Input:** root1 = [3,5,1,6,2,9,8,null,null,7,4], root2 = [3,5,1,6,7,4,2,null,null,null,null,null,null,9,8]\n**Output:** true\n\n```\n\n**Example 2:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0800-0899/0872.Leaf-Similar%20Trees/images/leaf-similar-2.jpg)\n\n```\n\n**Input:** root1 = [1,2,3], root2 = [1,3,2]\n**Output:** false\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* The number of nodes in each tree will be in the range `[1, 200]`.\n* Both of the given trees will have values in the range `[0, 200]`.\n\n\n",
    "inefficient_solution": "class Solution:\n    def leafSimilar(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> bool:\n        def dfs(root):\n            if root is None:\n                return []\n            ans = []\n            stack = [(root, 0)]\n            while stack:\n                node, direction = stack.pop()\n                if node is not None:\n                    stack.append((node.left, 1))\n                    stack.append((node.right, 0))\n                    if node.left is None and node.right is None:\n                        if direction == 0:\n                            ans.append(node.val)\n                        else:\n                            ans.extend([node.val] * 10000)\n            return ans\n\n        return dfs(root1) == dfs(root2)",
    "efficient_solution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def leafSimilar(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> bool:\n        def dfs(root):\n            if root is None:\n                return []\n            ans = dfs(root.left) + dfs(root.right)\n            return ans or [root.val]\n\n        return dfs(root1) == dfs(root2)\n",
    "text": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nConsider all the leaves of a binary tree, from\u00a0left to right order, the values of those\u00a0leaves form a **leaf value sequence***.*\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0800-0899/0872.Leaf-Similar%20Trees/images/tree.png)\n\n\nFor example, in the given tree above, the leaf value sequence is `(6, 7, 4, 9, 8)`.\n\n\nTwo binary trees are considered *leaf-similar*\u00a0if their leaf value sequence is the same.\n\n\nReturn `true` if and only if the two given trees with head nodes `root1` and `root2` are leaf-similar.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0800-0899/0872.Leaf-Similar%20Trees/images/leaf-similar-1.jpg)\n\n```\n\n**Input:** root1 = [3,5,1,6,2,9,8,null,null,7,4], root2 = [3,5,1,6,7,4,2,null,null,null,null,null,null,9,8]\n**Output:** true\n\n```\n\n**Example 2:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0800-0899/0872.Leaf-Similar%20Trees/images/leaf-similar-2.jpg)\n\n```\n\n**Input:** root1 = [1,2,3], root2 = [1,3,2]\n**Output:** false\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* The number of nodes in each tree will be in the range `[1, 200]`.\n* Both of the given trees will have values in the range `[0, 200]`.\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def leafSimilar(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> bool:\n        def dfs(root):\n            if root is None:\n                return []\n            ans = []\n            stack = [(root, 0)]\n            while stack:\n                node, direction = stack.pop()\n                if node is not None:\n                    stack.append((node.left, 1))\n                    stack.append((node.right, 0))\n                    if node.left is None and node.right is None:\n                        if direction == 0:\n                            ans.append(node.val)\n                        else:\n                            ans.extend([node.val] * 10000)\n            return ans\n\n        return dfs(root1) == dfs(root2)\n\n### Efficient Solution:\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def leafSimilar(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> bool:\n        def dfs(root):\n            if root is None:\n                return []\n            ans = dfs(root.left) + dfs(root.right)\n            return ans or [root.val]\n\n        return dfs(root1) == dfs(root2)\n<|eot_id|>",
    "model_generation": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nConsider all the leaves of a binary tree, from\u00a0left to right order, the values of those\u00a0leaves form a **leaf value sequence***.*\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0800-0899/0872.Leaf-Similar%20Trees/images/tree.png)\n\n\nFor example, in the given tree above, the leaf value sequence is `(6, 7, 4, 9, 8)`.\n\n\nTwo binary trees are considered *leaf-similar*\u00a0if their leaf value sequence is the same.\n\n\nReturn `true` if and only if the two given trees with head nodes `root1` and `root2` are leaf-similar.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0800-0899/0872.Leaf-Similar%20Trees/images/leaf-similar-1.jpg)\n\n```\n\n**Input:** root1 = [3,5,1,6,2,9,8,null,null,7,4], root2 = [3,5,1,6,7,4,2,null,null,null,null,null,null,9,8]\n**Output:** true\n\n```\n\n**Example 2:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0800-0899/0872.Leaf-Similar%20Trees/images/leaf-similar-2.jpg)\n\n```\n\n**Input:** root1 = [1,2,3], root2 = [1,3,2]\n**Output:** false\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* The number of nodes in each tree will be in the range `[1, 200]`.\n* Both of the given trees will have values in the range `[0, 200]`.\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def leafSimilar(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> bool:\n        def dfs(root):\n            if root is None:\n                return []\n            ans = []\n            stack = [(root, 0)]\n            while stack:\n                node, direction = stack.pop()\n                if node is not None:\n                    stack.append((node.left, 1))\n                    stack.append((node.right, 0))\n                    if node.left is None and node.right is None:\n                        if direction == 0:\n                            ans.append(node.val)\n                        else:\n                            ans.extend([node.val] * 10000)\n            return ans\n\n        return dfs(root1) == dfs(root2)\n\n### Efficient Solution:\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def leafSimilar(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> bool:\n        def dfs(root):\n            if root is None:\n                return []\n            if root.left is None and root.right is None:\n                return [root.val]\n            return np.concatenate(([root.val], dfs(root.left), dfs(root.right)))\n\n        return np.array(dfs(root1)) == np.array(dfs(root2))\n",
    "model_solution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def leafSimilar(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> bool:\n        def dfs(root):\n            if root is None:\n                return []\n            if root.left is None and root.right is None:\n                return [root.val]\n            return np.concatenate(([root.val], dfs(root.left), dfs(root.right)))\n\n        return np.array(dfs(root1)) == np.array(dfs(root2))"
}