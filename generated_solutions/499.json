{
    "problem_idx": "499",
    "description": "\nThere is a ball in a `maze` with empty spaces (represented as `0`) and walls (represented as `1`). The ball can go through the empty spaces by rolling **up, down, left or right**, but it won't stop rolling until hitting a wall. When the ball stops, it could choose the next direction. There is also a hole in this maze. The ball will drop into the hole if it rolls onto the hole.\n\n\nGiven the `m x n` `maze`, the ball's position `ball` and the hole's position `hole`, where `ball = [ballrow, ballcol]` and `hole = [holerow, holecol]`, return *a string* `instructions` *of all the instructions that the ball should follow to drop in the hole with the **shortest distance** possible*. If there are multiple valid instructions, return the **lexicographically minimum** one. If the ball can't drop in the hole, return `\"impossible\"`.\n\n\nIf there is a way for the ball to drop in the hole, the answer `instructions` should contain the characters `'u'` (i.e., up), `'d'` (i.e., down), `'l'` (i.e., left), and `'r'` (i.e., right).\n\n\nThe **distance** is the number of **empty spaces** traveled by the ball from the start position (excluded) to the destination (included).\n\n\nYou may assume that **the borders of the maze are all walls** (see examples).\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0400-0499/0499.The%20Maze%20III/images/maze3-1-grid.jpg)\n\n```\n\n**Input:** maze = [[0,0,0,0,0],[1,1,0,0,1],[0,0,0,0,0],[0,1,0,0,1],[0,1,0,0,0]], ball = [4,3], hole = [0,1]\n**Output:** \"lul\"\n**Explanation:** There are two shortest ways for the ball to drop into the hole.\nThe first way is left -> up -> left, represented by \"lul\".\nThe second way is up -> left, represented by 'ul'.\nBoth ways have shortest distance 6, but the first way is lexicographically smaller because 'l' < 'u'. So the output is \"lul\".\n\n```\n\n**Example 2:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0400-0499/0499.The%20Maze%20III/images/maze3-2-grid.jpg)\n\n```\n\n**Input:** maze = [[0,0,0,0,0],[1,1,0,0,1],[0,0,0,0,0],[0,1,0,0,1],[0,1,0,0,0]], ball = [4,3], hole = [3,0]\n**Output:** \"impossible\"\n**Explanation:** The ball cannot reach the hole.\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** maze = [[0,0,0,0,0,0,0],[0,0,1,0,0,1,0],[0,0,0,0,1,0,0],[0,0,0,0,0,0,1]], ball = [0,4], hole = [3,5]\n**Output:** \"dldr\"\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `m == maze.length`\n* `n == maze[i].length`\n* `1 <= m, n <= 100`\n* `maze[i][j]` is `0` or `1`.\n* `ball.length == 2`\n* `hole.length == 2`\n* `0 <= ballrow, holerow <= m`\n* `0 <= ballcol, holecol <= n`\n* Both the ball and the hole exist in an empty space, and they will not be in the same position initially.\n* The maze contains **at least 2 empty spaces**.\n\n\n",
    "inefficient_solution": "class Solution:\n    def findShortestWay(\n        self, maze: List[List[int]], ball: List[int], hole: List[int]\n    ) -> str:\n        m, n = len(maze), len(maze[0])\n        directions = [(-1, 0, 'u'), (1, 0, 'd'), (0, -1, 'l'), (0, 1, 'r')]\n        q, dist = deque(), {}\n        for i, j in [(ball[0], ball[1])]:\n            dist[(i, j)] = 0\n            q.append((i, j, ''))\n\n        while q:\n            for _ in range(len(q)):\n                i, j, path = q.popleft()\n                for a, b, d in directions:\n                    x, y, step = i, j, dist[(i, j)]\n                    while (\n                        0 <= x + a < m\n                        and 0 <= y + b < n\n                        and maze[x + a][y + b] == 0\n                        and (x != hole[0] or y != hole[1])\n                    ):\n                        x, y = x + a, y + b\n                        step += 1\n                    new_path = path + d\n                    if (x, y) not in dist or (\n                        dist[(x, y)] > step\n                        or (\n                            dist[(x, y)] == step\n                            and new_path < dist[(x, y)]\n                        )\n                    ):\n                        dist[(x, y)] = step\n                        q.append((x, y, new_path))\n\n        return dist.get((hole[0], hole[1]), 'impossible') or 'impossible'",
    "efficient_solution": "class Solution:\n    def findShortestWay(\n        self, maze: List[List[int]], ball: List[int], hole: List[int]\n    ) -> str:\n        m, n = len(maze), len(maze[0])\n        r, c = ball\n        rh, ch = hole\n        q = deque([(r, c)])\n        dist = [[inf] * n for _ in range(m)]\n        dist[r][c] = 0\n        path = [[None] * n for _ in range(m)]\n        path[r][c] = ''\n        while q:\n            i, j = q.popleft()\n            for a, b, d in [(-1, 0, 'u'), (1, 0, 'd'), (0, -1, 'l'), (0, 1, 'r')]:\n                x, y, step = i, j, dist[i][j]\n                while (\n                    0 <= x + a < m\n                    and 0 <= y + b < n\n                    and maze[x + a][y + b] == 0\n                    and (x != rh or y != ch)\n                ):\n                    x, y = x + a, y + b\n                    step += 1\n                if dist[x][y] > step or (\n                    dist[x][y] == step and path[i][j] + d < path[x][y]\n                ):\n                    dist[x][y] = step\n                    path[x][y] = path[i][j] + d\n                    if x != rh or y != ch:\n                        q.append((x, y))\n        return path[rh][ch] or 'impossible'\n",
    "text": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nThere is a ball in a `maze` with empty spaces (represented as `0`) and walls (represented as `1`). The ball can go through the empty spaces by rolling **up, down, left or right**, but it won't stop rolling until hitting a wall. When the ball stops, it could choose the next direction. There is also a hole in this maze. The ball will drop into the hole if it rolls onto the hole.\n\n\nGiven the `m x n` `maze`, the ball's position `ball` and the hole's position `hole`, where `ball = [ballrow, ballcol]` and `hole = [holerow, holecol]`, return *a string* `instructions` *of all the instructions that the ball should follow to drop in the hole with the **shortest distance** possible*. If there are multiple valid instructions, return the **lexicographically minimum** one. If the ball can't drop in the hole, return `\"impossible\"`.\n\n\nIf there is a way for the ball to drop in the hole, the answer `instructions` should contain the characters `'u'` (i.e., up), `'d'` (i.e., down), `'l'` (i.e., left), and `'r'` (i.e., right).\n\n\nThe **distance** is the number of **empty spaces** traveled by the ball from the start position (excluded) to the destination (included).\n\n\nYou may assume that **the borders of the maze are all walls** (see examples).\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0400-0499/0499.The%20Maze%20III/images/maze3-1-grid.jpg)\n\n```\n\n**Input:** maze = [[0,0,0,0,0],[1,1,0,0,1],[0,0,0,0,0],[0,1,0,0,1],[0,1,0,0,0]], ball = [4,3], hole = [0,1]\n**Output:** \"lul\"\n**Explanation:** There are two shortest ways for the ball to drop into the hole.\nThe first way is left -> up -> left, represented by \"lul\".\nThe second way is up -> left, represented by 'ul'.\nBoth ways have shortest distance 6, but the first way is lexicographically smaller because 'l' < 'u'. So the output is \"lul\".\n\n```\n\n**Example 2:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0400-0499/0499.The%20Maze%20III/images/maze3-2-grid.jpg)\n\n```\n\n**Input:** maze = [[0,0,0,0,0],[1,1,0,0,1],[0,0,0,0,0],[0,1,0,0,1],[0,1,0,0,0]], ball = [4,3], hole = [3,0]\n**Output:** \"impossible\"\n**Explanation:** The ball cannot reach the hole.\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** maze = [[0,0,0,0,0,0,0],[0,0,1,0,0,1,0],[0,0,0,0,1,0,0],[0,0,0,0,0,0,1]], ball = [0,4], hole = [3,5]\n**Output:** \"dldr\"\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `m == maze.length`\n* `n == maze[i].length`\n* `1 <= m, n <= 100`\n* `maze[i][j]` is `0` or `1`.\n* `ball.length == 2`\n* `hole.length == 2`\n* `0 <= ballrow, holerow <= m`\n* `0 <= ballcol, holecol <= n`\n* Both the ball and the hole exist in an empty space, and they will not be in the same position initially.\n* The maze contains **at least 2 empty spaces**.\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def findShortestWay(\n        self, maze: List[List[int]], ball: List[int], hole: List[int]\n    ) -> str:\n        m, n = len(maze), len(maze[0])\n        directions = [(-1, 0, 'u'), (1, 0, 'd'), (0, -1, 'l'), (0, 1, 'r')]\n        q, dist = deque(), {}\n        for i, j in [(ball[0], ball[1])]:\n            dist[(i, j)] = 0\n            q.append((i, j, ''))\n\n        while q:\n            for _ in range(len(q)):\n                i, j, path = q.popleft()\n                for a, b, d in directions:\n                    x, y, step = i, j, dist[(i, j)]\n                    while (\n                        0 <= x + a < m\n                        and 0 <= y + b < n\n                        and maze[x + a][y + b] == 0\n                        and (x != hole[0] or y != hole[1])\n                    ):\n                        x, y = x + a, y + b\n                        step += 1\n                    new_path = path + d\n                    if (x, y) not in dist or (\n                        dist[(x, y)] > step\n                        or (\n                            dist[(x, y)] == step\n                            and new_path < dist[(x, y)]\n                        )\n                    ):\n                        dist[(x, y)] = step\n                        q.append((x, y, new_path))\n\n        return dist.get((hole[0], hole[1]), 'impossible') or 'impossible'\n\n### Efficient Solution:\nclass Solution:\n    def findShortestWay(\n        self, maze: List[List[int]], ball: List[int], hole: List[int]\n    ) -> str:\n        m, n = len(maze), len(maze[0])\n        r, c = ball\n        rh, ch = hole\n        q = deque([(r, c)])\n        dist = [[inf] * n for _ in range(m)]\n        dist[r][c] = 0\n        path = [[None] * n for _ in range(m)]\n        path[r][c] = ''\n        while q:\n            i, j = q.popleft()\n            for a, b, d in [(-1, 0, 'u'), (1, 0, 'd'), (0, -1, 'l'), (0, 1, 'r')]:\n                x, y, step = i, j, dist[i][j]\n                while (\n                    0 <= x + a < m\n                    and 0 <= y + b < n\n                    and maze[x + a][y + b] == 0\n                    and (x != rh or y != ch)\n                ):\n                    x, y = x + a, y + b\n                    step += 1\n                if dist[x][y] > step or (\n                    dist[x][y] == step and path[i][j] + d < path[x][y]\n                ):\n                    dist[x][y] = step\n                    path[x][y] = path[i][j] + d\n                    if x != rh or y != ch:\n                        q.append((x, y))\n        return path[rh][ch] or 'impossible'\n<|eot_id|>",
    "model_generation": "Below is a programming problem description and an inefficient solution. Your task is to provide a more efficient solution.\n\n### Problem Description:\n\nThere is a ball in a `maze` with empty spaces (represented as `0`) and walls (represented as `1`). The ball can go through the empty spaces by rolling **up, down, left or right**, but it won't stop rolling until hitting a wall. When the ball stops, it could choose the next direction. There is also a hole in this maze. The ball will drop into the hole if it rolls onto the hole.\n\n\nGiven the `m x n` `maze`, the ball's position `ball` and the hole's position `hole`, where `ball = [ballrow, ballcol]` and `hole = [holerow, holecol]`, return *a string* `instructions` *of all the instructions that the ball should follow to drop in the hole with the **shortest distance** possible*. If there are multiple valid instructions, return the **lexicographically minimum** one. If the ball can't drop in the hole, return `\"impossible\"`.\n\n\nIf there is a way for the ball to drop in the hole, the answer `instructions` should contain the characters `'u'` (i.e., up), `'d'` (i.e., down), `'l'` (i.e., left), and `'r'` (i.e., right).\n\n\nThe **distance** is the number of **empty spaces** traveled by the ball from the start position (excluded) to the destination (included).\n\n\nYou may assume that **the borders of the maze are all walls** (see examples).\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0400-0499/0499.The%20Maze%20III/images/maze3-1-grid.jpg)\n\n```\n\n**Input:** maze = [[0,0,0,0,0],[1,1,0,0,1],[0,0,0,0,0],[0,1,0,0,1],[0,1,0,0,0]], ball = [4,3], hole = [0,1]\n**Output:** \"lul\"\n**Explanation:** There are two shortest ways for the ball to drop into the hole.\nThe first way is left -> up -> left, represented by \"lul\".\nThe second way is up -> left, represented by 'ul'.\nBoth ways have shortest distance 6, but the first way is lexicographically smaller because 'l' < 'u'. So the output is \"lul\".\n\n```\n\n**Example 2:**\n\n\n![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0400-0499/0499.The%20Maze%20III/images/maze3-2-grid.jpg)\n\n```\n\n**Input:** maze = [[0,0,0,0,0],[1,1,0,0,1],[0,0,0,0,0],[0,1,0,0,1],[0,1,0,0,0]], ball = [4,3], hole = [3,0]\n**Output:** \"impossible\"\n**Explanation:** The ball cannot reach the hole.\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** maze = [[0,0,0,0,0,0,0],[0,0,1,0,0,1,0],[0,0,0,0,1,0,0],[0,0,0,0,0,0,1]], ball = [0,4], hole = [3,5]\n**Output:** \"dldr\"\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `m == maze.length`\n* `n == maze[i].length`\n* `1 <= m, n <= 100`\n* `maze[i][j]` is `0` or `1`.\n* `ball.length == 2`\n* `hole.length == 2`\n* `0 <= ballrow, holerow <= m`\n* `0 <= ballcol, holecol <= n`\n* Both the ball and the hole exist in an empty space, and they will not be in the same position initially.\n* The maze contains **at least 2 empty spaces**.\n\n\n\n\n### Inefficient Solution:\nclass Solution:\n    def findShortestWay(\n        self, maze: List[List[int]], ball: List[int], hole: List[int]\n    ) -> str:\n        m, n = len(maze), len(maze[0])\n        directions = [(-1, 0, 'u'), (1, 0, 'd'), (0, -1, 'l'), (0, 1, 'r')]\n        q, dist = deque(), {}\n        for i, j in [(ball[0], ball[1])]:\n            dist[(i, j)] = 0\n            q.append((i, j, ''))\n\n        while q:\n            for _ in range(len(q)):\n                i, j, path = q.popleft()\n                for a, b, d in directions:\n                    x, y, step = i, j, dist[(i, j)]\n                    while (\n                        0 <= x + a < m\n                        and 0 <= y + b < n\n                        and maze[x + a][y + b] == 0\n                        and (x!= hole[0] or y!= hole[1])\n                    ):\n                        x, y = x + a, y + b\n                        step += 1\n                    new_path = path + d\n                    if (x, y) not in dist or (\n                        dist[(x, y)] > step\n                        or (\n                            dist[(x, y)] == step\n                            and new_path < dist[(x, y)]\n                        )\n                    ):\n                        dist[(x, y)] = step\n                        q.append((x, y, new_path))\n\n        return dist.get((hole[0], hole[1]), 'impossible') or 'impossible'\n\n### Efficient Solution:\nclass Solution:\n    def findShortestWay(\n        self, maze: List[List[int]], ball: List[int], hole: List[int]\n    ) -> str:\n        m, n = len(maze), len(maze[0])\n        dirs = (-1, 0, 'u'), (1, 0, 'd'), (0, -1, 'l'), (0, 1, 'r')\n        q = deque([((ball[0] * 100 + ball[1]), '')])\n        dist = {(ball[0] * 100 + ball[1]): 0}\n        while q:\n            i, path = q.popleft()\n            x, y = i // 100, i % 100\n            for a, b, d in dirs:\n                x1, y1, step = x, y, dist[i]\n                while (\n                    0 <= x1 + a < m\n                    and 0 <= y1 + b < n\n                    and maze[x1 + a][y1 + b] == 0\n                    and (x1!= hole[0] or y1!= hole[1])\n                ):\n                    x1, y1 = x1 + a, y1 + b\n                    step += 1\n                if (x1 * 100 + y1) not in dist or (\n                    dist[x1 * 100 + y1] > step\n                    or (\n                        dist[x1 * 100 + y1] == step\n                        and path + d < dist[x1 * 100 + y1]\n                    )\n                ):\n                    dist[x1 * 100 + y1] = step\n                    q.append(((x1 * 100 + y1), path + d))\n        return dist.get((hole[0] * 100 + hole[1]), 'impossible')\n",
    "model_solution": "class Solution:\n    def findShortestWay(\n        self, maze: List[List[int]], ball: List[int], hole: List[int]\n    ) -> str:\n        m, n = len(maze), len(maze[0])\n        dirs = (-1, 0, 'u'), (1, 0, 'd'), (0, -1, 'l'), (0, 1, 'r')\n        q = deque([((ball[0] * 100 + ball[1]), '')])\n        dist = {(ball[0] * 100 + ball[1]): 0}\n        while q:\n            i, path = q.popleft()\n            x, y = i // 100, i % 100\n            for a, b, d in dirs:\n                x1, y1, step = x, y, dist[i]\n                while (\n                    0 <= x1 + a < m\n                    and 0 <= y1 + b < n\n                    and maze[x1 + a][y1 + b] == 0\n                    and (x1!= hole[0] or y1!= hole[1])\n                ):\n                    x1, y1 = x1 + a, y1 + b\n                    step += 1\n                if (x1 * 100 + y1) not in dist or (\n                    dist[x1 * 100 + y1] > step\n                    or (\n                        dist[x1 * 100 + y1] == step\n                        and path + d < dist[x1 * 100 + y1]\n                    )\n                ):\n                    dist[x1 * 100 + y1] = step\n                    q.append(((x1 * 100 + y1), path + d))\n        return dist.get((hole[0] * 100 + hole[1]), 'impossible')"
}