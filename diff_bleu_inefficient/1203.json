{
  "problem_idx": "1203",
  "metrics": {
    "bleu_score": 0.5462425850123402,
    "edit_similarity": 0.38985507246376816,
    "ast_similarity": 0.9722222222222222,
    "diff_bleu_score": 1.0
  },
  "inefficient_solution": "class Solution:\n    def sortItems(\n        self, n: int, m: int, group: List[int], beforeItems: List[List[int]]\n    ) -> List[int]:\n        idx = m\n        group_items = [[] for _ in range(n + m)]\n        for i, g in enumerate(group):\n            if g == -1:\n                group[i] = idx\n                idx += 1\n            group_items[group[i]].append(i)\n\n        item_degree = [0] * n\n        group_degree = [0] * (n + m)\n        item_graph = [[] for _ in range(n)]\n        group_graph = [[] for _ in range(n + m)]\n        for i, gi in enumerate(group):\n            for j in beforeItems[i]:\n                gj = group[j]\n                if gi == gj:\n                    item_degree[i] += 1\n                    item_graph[j].append(i)\n                else:\n                    group_degree[gi] += 1\n                    group_graph[gj].append(gi)\n\n        group_order = self.topo_sort(group_degree, group_graph, range(n + m), n + m)\n        if not group_order:\n            return []\n        ans = []\n        for gi in group_order:\n            items = group_items[gi]\n            item_order = self.topo_sort(item_degree, item_graph, items, n)\n            if len(items) != len(item_order):\n                return []\n            ans.extend(item_order)\n        return ans\n\n    def topo_sort(self, degree, graph, items, max_item):\n        q = deque(i for _, i in enumerate(items) if degree[i] == 0)\n        res = []\n        while q:\n            i = q.popleft()\n            res.append(i)\n            for j in graph[i]:\n                degree[j] -= 1\n                if degree[j] >= 0:\n                    q.append(j)\n        return res if len(res) == len(items) else []\n\n    def check_topo_sort(self, degree, graph, items):\n        count = 0\n        for i in range(len(degree)):\n            if degree[i] == 0:\n                count += 1\n        if count == 0:\n            return False\n        res = []\n        q = deque(i for i in range(len(degree)) if degree[i] == 0)\n        while q:\n            i = q.popleft()\n            res.append(i)\n            for j in graph[i]:\n                degree[j] -= 1\n                if degree[j] >= 0:\n                    q.append(j)\n        return len(res) == len(items)\n\n    def dfs(self, degree, graph, items, max_item):\n        for i in range(len(degree)):\n            if degree[i] == 0:\n                self.dfs_util(degree, graph, items, max_item, i)\n\n    def dfs_util(self, degree, graph, items, max_item, i):\n        res = []\n        q = deque(i)\n        while q:\n            i = q.popleft()\n            res.append(i)\n            for j in graph[i]:\n                degree[j] -= 1\n                if degree[j] >= 0:\n                    q.append(j)\n        if len(res) != len(items):\n            return False\n        return True",
  "canonical_solution": "class Solution:\n    def sortItems(\n        self, n: int, m: int, group: List[int], beforeItems: List[List[int]]\n    ) -> List[int]:\n        def topo_sort(degree, graph, items):\n            q = deque(i for _, i in enumerate(items) if degree[i] == 0)\n            res = []\n            while q:\n                i = q.popleft()\n                res.append(i)\n                for j in graph[i]:\n                    degree[j] -= 1\n                    if degree[j] == 0:\n                        q.append(j)\n            return res if len(res) == len(items) else []\n\n        idx = m\n        group_items = [[] for _ in range(n + m)]\n        for i, g in enumerate(group):\n            if g == -1:\n                group[i] = idx\n                idx += 1\n            group_items[group[i]].append(i)\n\n        item_degree = [0] * n\n        group_degree = [0] * (n + m)\n        item_graph = [[] for _ in range(n)]\n        group_graph = [[] for _ in range(n + m)]\n        for i, gi in enumerate(group):\n            for j in beforeItems[i]:\n                gj = group[j]\n                if gi == gj:\n                    item_degree[i] += 1\n                    item_graph[j].append(i)\n                else:\n                    group_degree[gi] += 1\n                    group_graph[gj].append(gi)\n\n        group_order = topo_sort(group_degree, group_graph, range(n + m))\n        if not group_order:\n            return []\n        ans = []\n        for gi in group_order:\n            items = group_items[gi]\n            item_order = topo_sort(item_degree, item_graph, items)\n            if len(items) != len(item_order):\n                return []\n            ans.extend(item_order)\n        return ans\n",
  "is_python": true
}