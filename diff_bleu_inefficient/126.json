{
  "problem_idx": "126",
  "metrics": {
    "bleu_score": 0.7268544913936432,
    "edit_similarity": 0.7928531546621999,
    "ast_similarity": 0.9705882352941176,
    "diff_bleu_score": 1.0
  },
  "inefficient_solution": "class Solution:\n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\n        def dfs(cur, path):\n            if cur == beginWord:\n                ans.append(path[::-1])\n                return\n            for precursor in prev[cur]:\n                path.append(precursor)\n                dfs(precursor, path)\n                path.pop()\n            for i in range(len(path)):\n                for j in range(i+1, len(path)):\n                    path[i], path[j] = path[j], path[i]\n                    dfs(cur, path)\n                    path[i], path[j] = path[j], path[i]\n\n        ans = []\n        words = set(wordList)\n        if endWord not in words:\n            return ans\n        words.discard(beginWord)\n        dist = {beginWord: 0}\n        prev = defaultdict(set)\n        q = deque([beginWord])\n        found = False\n        step = 0\n        while q and not found:\n            step += 1\n            for _ in range(len(q)):\n                p = q.popleft()\n                s = list(p)\n                for i in range(len(s)):\n                    for j in range(26):\n                        s[i] = chr(ord('a') + j)\n                        t = ''.join(s)\n                        if dist.get(t, 0) == step:\n                            prev[t].add(p)\n                        if t not in words:\n                            continue\n                        prev[t].add(p)\n                        words.discard(t)\n                        q.append(t)\n                        dist[t] = step\n                        if endWord == t:\n                            found = True\n                    s[i] = p[i]\n            if q:\n                q.append(beginWord)\n        if found:\n            path = [endWord]\n            dfs(endWord, path)\n        return ans",
  "canonical_solution": "class Solution:\n    def findLadders(\n        self, beginWord: str, endWord: str, wordList: List[str]\n    ) -> List[List[str]]:\n        def dfs(path, cur):\n            if cur == beginWord:\n                ans.append(path[::-1])\n                return\n            for precursor in prev[cur]:\n                path.append(precursor)\n                dfs(path, precursor)\n                path.pop()\n\n        ans = []\n        words = set(wordList)\n        if endWord not in words:\n            return ans\n        words.discard(beginWord)\n        dist = {beginWord: 0}\n        prev = defaultdict(set)\n        q = deque([beginWord])\n        found = False\n        step = 0\n        while q and not found:\n            step += 1\n            for i in range(len(q), 0, -1):\n                p = q.popleft()\n                s = list(p)\n                for i in range(len(s)):\n                    ch = s[i]\n                    for j in range(26):\n                        s[i] = chr(ord('a') + j)\n                        t = ''.join(s)\n                        if dist.get(t, 0) == step:\n                            prev[t].add(p)\n                        if t not in words:\n                            continue\n                        prev[t].add(p)\n                        words.discard(t)\n                        q.append(t)\n                        dist[t] = step\n                        if endWord == t:\n                            found = True\n                    s[i] = ch\n        if found:\n            path = [endWord]\n            dfs(path, endWord)\n        return ans\n",
  "is_python": true
}