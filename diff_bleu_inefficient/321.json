{
  "problem_idx": "321",
  "metrics": {
    "bleu_score": 0.8259851579443768,
    "edit_similarity": 0.9007470651013874,
    "ast_similarity": 0.96875,
    "diff_bleu_score": 1.0
  },
  "inefficient_solution": "class Solution:\n    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:\n        def f(nums: List[int], k: int) -> List[int]:\n            n = len(nums)\n            stk = [0] * (2 * k)\n            top = -1\n            remain = n - k\n            for x in nums:\n                while top >= 0 and stk[top] < x and remain > 0:\n                    top -= 1\n                    remain -= 1\n                if top + 1 < 2 * k:\n                    top += 1\n                    stk[top] = x\n                else:\n                    remain -= 1\n            return stk\n\n        def compare(nums1: List[int], nums2: List[int], i: int, j: int) -> bool:\n            if i >= len(nums1):\n                return False\n            if j >= len(nums2):\n                return True\n            if nums1[i] > nums2[j]:\n                return True\n            if nums1[i] < nums2[j]:\n                return False\n            return compare(nums1, nums2, i + 1, j + 1)\n\n        def merge(nums1: List[int], nums2: List[int]) -> List[int]:\n            m, n = len(nums1), len(nums2)\n            i = j = 0\n            ans = [0] * (m + n)\n            for k in range(m + n):\n                if compare(nums1, nums2, i, j):\n                    ans[k] = nums1[i]\n                    i += 1\n                else:\n                    ans[k] = nums2[j]\n                    j += 1\n            return ans\n\n        m, n = len(nums1), len(nums2)\n        l, r = max(0, k - n), min(k, m)\n        ans = [0] * (2 * k)\n        for x in range(l, r + 1):\n            arr1 = [0] * (2 * k)\n            arr2 = [0] * (2 * k)\n            for y in range(2 * k):\n                arr1[y] = f(nums1, x)[y % x]\n            for y in range(2 * k):\n                arr2[y] = f(nums2, k - x)[y % (k - x)]\n            arr = merge(arr1, arr2)\n            if ans < arr:\n                ans = arr\n        return ans",
  "canonical_solution": "class Solution:\n    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:\n        def f(nums: List[int], k: int) -> List[int]:\n            n = len(nums)\n            stk = [0] * k\n            top = -1\n            remain = n - k\n            for x in nums:\n                while top >= 0 and stk[top] < x and remain > 0:\n                    top -= 1\n                    remain -= 1\n                if top + 1 < k:\n                    top += 1\n                    stk[top] = x\n                else:\n                    remain -= 1\n            return stk\n\n        def compare(nums1: List[int], nums2: List[int], i: int, j: int) -> bool:\n            if i >= len(nums1):\n                return False\n            if j >= len(nums2):\n                return True\n            if nums1[i] > nums2[j]:\n                return True\n            if nums1[i] < nums2[j]:\n                return False\n            return compare(nums1, nums2, i + 1, j + 1)\n\n        def merge(nums1: List[int], nums2: List[int]) -> List[int]:\n            m, n = len(nums1), len(nums2)\n            i = j = 0\n            ans = [0] * (m + n)\n            for k in range(m + n):\n                if compare(nums1, nums2, i, j):\n                    ans[k] = nums1[i]\n                    i += 1\n                else:\n                    ans[k] = nums2[j]\n                    j += 1\n            return ans\n\n        m, n = len(nums1), len(nums2)\n        l, r = max(0, k - n), min(k, m)\n        ans = [0] * k\n        for x in range(l, r + 1):\n            arr1 = f(nums1, x)\n            arr2 = f(nums2, k - x)\n            arr = merge(arr1, arr2)\n            if ans < arr:\n                ans = arr\n        return ans\n",
  "is_python": true
}