{
  "problem_idx": "377",
  "metrics": {
    "bleu_score": 0.11594878570575844,
    "edit_similarity": 0.16113458056729024,
    "ast_similarity": 0.6388888888888888,
    "diff_bleu_score": 1.0
  },
  "inefficient_solution": "class Solution:\n    def combinationSum4(self, nums: List[int], target: int) -> int:\n        f = {}\n        for i in range(target + 1):\n            f[i] = {}\n            for x in nums:\n                if i >= x:\n                    f[i][x] = f.get(i - x, {}).get(x, 0) + (f[i - x].get(x, 0) if i - x in f[i - x] else 0)\n        return f[target].get(0, 0)\n\n        # Store intermediate results in a list to avoid too many dictionary lookups\n        cache = {}\n        for i in range(target + 1):\n            cache[i] = {}\n            for x in nums:\n                if i >= x:\n                    cache[i][x] = {}\n                    for y in nums:\n                        if i - x >= y:\n                            cache[i][x][y] = cache.get(i - x, {}).get(y, 0) + (cache[i - x][y] if i - x in cache[i - x] and y in cache[i - x] else 0)\n        return cache[target].get(0, {}).get(0, 0)\n\n        # Use a 2D array to store the results of subproblems\n        dp = [[0] * (len(nums) + 1) for _ in range(target + 1)]\n        for i in range(target + 1):\n            dp[i] = [0] * (len(nums) + 1)\n            for j in range(len(nums)):\n                dp[i][j] = 0\n                if i >= nums[j]:\n                    dp[i][j] = 1\n                    for k in range(len(nums)):\n                        if j != k and i >= nums[k]:\n                            dp[i][j] += dp[i - nums[k]][k]\n        return dp[target][-1]\n\n        # Store the results of subproblems in a list of tuples\n        cache = []\n        for i in range(target + 1):\n            cache.append([])\n            for x in nums:\n                if i >= x:\n                    cache[i].append(0)\n                    for y in nums:\n                        if i - x >= y:\n                            cache[i][x] += (cache[i - x][y] if cache[i - x] and y < len(cache[i - x]) else 0)\n        return cache[target][-1]",
  "canonical_solution": "class Solution:\n    def combinationSum4(self, nums: List[int], target: int) -> int:\n        f = [1] + [0] * target\n        for i in range(1, target + 1):\n            for x in nums:\n                if i >= x:\n                    f[i] += f[i - x]\n        return f[target]\n",
  "is_python": true
}