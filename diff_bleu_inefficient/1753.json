{
  "problem_idx": "1753",
  "metrics": {
    "bleu_score": 0.1423146422390429,
    "edit_similarity": 0.17759838546922302,
    "ast_similarity": 0.5862068965517241,
    "diff_bleu_score": 1.0
  },
  "inefficient_solution": "class Solution:\n    def maximumScore(self, a: int, b: int, c: int) -> int:\n        # Create a list to store all possible moves\n        moves = [(a, b, c)]\n\n        # Initialize a dictionary to store the results of each move\n        results = {}\n\n        # Initialize a set to store the visited moves\n        visited = set()\n\n        # Function to calculate the score for a given move\n        def calculate_score(a, b, c):\n            # Calculate the score by taking one stone from each pile\n            score = min(a, b, c) * 2\n            return score\n\n        # Function to apply the move and update the results\n        def apply_move(a, b, c):\n            # Check if the move has been visited before\n            if (a, b, c) in visited:\n                return\n\n            # Mark the move as visited\n            visited.add((a, b, c))\n\n            # Calculate the score for the move\n            score = calculate_score(a, b, c)\n\n            # Update the results dictionary\n            results[(a, b, c)] = score\n\n            # Generate new moves by applying the take one stone from each pile operation\n            new_moves = []\n            if a > 0:\n                new_moves.append((a - 1, b, c))\n            if b > 0:\n                new_moves.append((a, b - 1, c))\n            if c > 0:\n                new_moves.append((a, b, c - 1))\n\n            # Recursively apply the moves and update the results\n            for new_a, new_b, new_c in new_moves:\n                apply_move(new_a, new_b, new_c)\n\n        # Apply the initial move and update the results\n        apply_move(a, b, c)\n\n        # Find the maximum score\n        max_score = 0\n        for a, b, c in moves:\n            score = results.get((a, b, c), 0)\n            max_score = max(max_score, score)\n\n        # Return the maximum score\n        return max_score",
  "canonical_solution": "class Solution:\n    def maximumScore(self, a: int, b: int, c: int) -> int:\n        a, b, c = sorted([a, b, c])\n        if a + b < c:\n            return a + b\n        return (a + b + c) >> 1\n",
  "is_python": true
}