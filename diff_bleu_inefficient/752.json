{
  "problem_idx": "752",
  "metrics": {
    "bleu_score": 0.9142073820184123,
    "edit_similarity": 0.8870738636363636,
    "ast_similarity": 1.0,
    "diff_bleu_score": 1.0
  },
  "inefficient_solution": "class Solution:\n    def openLock(self, deadends: List[str], target: str) -> int:\n        def next(s):\n            res = []\n            for i in range(4):\n                c = s[i]\n                for d in range(10):\n                    s[i] = str(d)\n                    res.append(''.join(s))\n                    s[i] = c\n                s[i] = '0' if c == '9' else str(int(c) + 1)\n                res.append(''.join(s))\n                s[i] = '9' if c == '0' else str(int(c) - 1)\n                res.append(''.join(s))\n            return res\n\n        def extend(m1, m2, q):\n            for _ in range(len(q)):\n                p = q.popleft()\n                step = m1[p]\n                for t in next(p):\n                    if t in s or t in m1:\n                        continue\n                    if t in m2:\n                        return step + 1 + m2[t]\n                    m1[t] = step + 1\n                    q.append(t)\n            return -1\n\n        def bfs():\n            m1, m2 = {\"0000\": 0}, {target: 0}\n            q1, q2 = deque([('0000')]), deque([(target)])\n            while q1 and q2:\n                t = extend(m1, m2, q1) if len(q1) <= len(q2) else extend(m2, m1, q2)\n                if t != -1:\n                    return t\n            return -1\n\n        if target == '0000':\n            return 0\n        s = set(deadends)\n        if '0000' in s:\n            return -1\n        return bfs()",
  "canonical_solution": "class Solution:\n    def openLock(self, deadends: List[str], target: str) -> int:\n        def next(s):\n            res = []\n            s = list(s)\n            for i in range(4):\n                c = s[i]\n                s[i] = '9' if c == '0' else str(int(c) - 1)\n                res.append(''.join(s))\n                s[i] = '0' if c == '9' else str(int(c) + 1)\n                res.append(''.join(s))\n                s[i] = c\n            return res\n\n        def extend(m1, m2, q):\n            for _ in range(len(q)):\n                p = q.popleft()\n                step = m1[p]\n                for t in next(p):\n                    if t in s or t in m1:\n                        continue\n                    if t in m2:\n                        return step + 1 + m2[t]\n                    m1[t] = step + 1\n                    q.append(t)\n            return -1\n\n        def bfs():\n            m1, m2 = {\"0000\": 0}, {target: 0}\n            q1, q2 = deque([('0000')]), deque([(target)])\n            while q1 and q2:\n                t = extend(m1, m2, q1) if len(q1) <= len(q2) else extend(m2, m1, q2)\n                if t != -1:\n                    return t\n            return -1\n\n        if target == '0000':\n            return 0\n        s = set(deadends)\n        if '0000' in s:\n            return -1\n        return bfs()\n",
  "is_python": true
}