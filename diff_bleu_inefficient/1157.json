{
  "problem_idx": "1157",
  "metrics": {
    "bleu_score": 0.05028874461495045,
    "edit_similarity": 0.2640812557710065,
    "ast_similarity": 0.7105263157894737,
    "diff_bleu_score": 1.0
  },
  "inefficient_solution": "class MajorityChecker:\n    def __init__(self, arr: List[int]):\n        self.arr = [x for x in arr for _ in range(len(arr))]\n        self.d = defaultdict(list)\n        for i, x in enumerate(arr):\n            self.d[x].append(i)\n        self.index_map = {x: i for i, x in enumerate(arr)}\n\n    def query(self, left: int, right: int, threshold: int) -> int:\n        x = random.choice(list(self.d.keys()))\n        l = bisect_left(self.d[x], left)\n        r = bisect_left(self.d[x], right + 1)\n        if r - l >= threshold:\n            return x\n        else:\n            for y in self.d.keys():\n                if y != x:\n                    l = bisect_left(self.d[y], left)\n                    r = bisect_left(self.d[y], right + 1)\n                    if r - l >= threshold:\n                        return y\n            return -1",
  "canonical_solution": "class Node:\n    __slots__ = (\"l\", \"r\", \"x\", \"cnt\")\n\n    def __init__(self):\n        self.l = self.r = 0\n        self.x = self.cnt = 0\n\n\nclass SegmentTree:\n    def __init__(self, nums):\n        self.nums = nums\n        n = len(nums)\n        self.tr = [Node() for _ in range(n << 2)]\n        self.build(1, 1, n)\n\n    def build(self, u, l, r):\n        self.tr[u].l, self.tr[u].r = l, r\n        if l == r:\n            self.tr[u].x = self.nums[l - 1]\n            self.tr[u].cnt = 1\n            return\n        mid = (l + r) >> 1\n        self.build(u << 1, l, mid)\n        self.build(u << 1 | 1, mid + 1, r)\n        self.pushup(u)\n\n    def query(self, u, l, r):\n        if self.tr[u].l >= l and self.tr[u].r <= r:\n            return self.tr[u].x, self.tr[u].cnt\n        mid = (self.tr[u].l + self.tr[u].r) >> 1\n        if r <= mid:\n            return self.query(u << 1, l, r)\n        if l > mid:\n            return self.query(u << 1 | 1, l, r)\n        x1, cnt1 = self.query(u << 1, l, r)\n        x2, cnt2 = self.query(u << 1 | 1, l, r)\n        if x1 == x2:\n            return x1, cnt1 + cnt2\n        if cnt1 >= cnt2:\n            return x1, cnt1 - cnt2\n        else:\n            return x2, cnt2 - cnt1\n\n    def pushup(self, u):\n        if self.tr[u << 1].x == self.tr[u << 1 | 1].x:\n            self.tr[u].x = self.tr[u << 1].x\n            self.tr[u].cnt = self.tr[u << 1].cnt + self.tr[u << 1 | 1].cnt\n        elif self.tr[u << 1].cnt >= self.tr[u << 1 | 1].cnt:\n            self.tr[u].x = self.tr[u << 1].x\n            self.tr[u].cnt = self.tr[u << 1].cnt - self.tr[u << 1 | 1].cnt\n        else:\n            self.tr[u].x = self.tr[u << 1 | 1].x\n            self.tr[u].cnt = self.tr[u << 1 | 1].cnt - self.tr[u << 1].cnt\n\n\nclass MajorityChecker:\n    def __init__(self, arr: List[int]):\n        self.tree = SegmentTree(arr)\n        self.d = defaultdict(list)\n        for i, x in enumerate(arr):\n            self.d[x].append(i)\n\n    def query(self, left: int, right: int, threshold: int) -> int:\n        x, _ = self.tree.query(1, left + 1, right + 1)\n        l = bisect_left(self.d[x], left)\n        r = bisect_left(self.d[x], right + 1)\n        return x if r - l >= threshold else -1\n\n\n# Your MajorityChecker object will be instantiated and called as such:\n# obj = MajorityChecker(arr)\n# param_1 = obj.query(left,right,threshold)\n",
  "is_python": true
}