{
  "problem_idx": "549",
  "metrics": {
    "bleu_score": 0.4291213030903503,
    "edit_similarity": 0.5840368380660015,
    "ast_similarity": 0.7333333333333333,
    "diff_bleu_score": 1.0
  },
  "inefficient_solution": "class Solution:\n    def longestConsecutive(self, root: TreeNode) -> int:\n        def dfs(root):\n            if root is None:\n                return [0] * 1000\n            ans = [0] * 1000\n            incr = decr = 1\n            i1 = dfs(root.left)\n            i2 = dfs(root.right)\n            if root.left:\n                for j in range(root.left.val - root.val, 0, -1):\n                    if i1[j] == 0:\n                        break\n                    if root.left.val + j == root.val:\n                        incr = max(incr, i1[j] + 1)\n                    if root.left.val - j == root.val:\n                        decr = max(decr, i1[j + 1] + 1)\n            if root.right:\n                for j in range(root.right.val - root.val, 0, -1):\n                    if i2[j] == 0:\n                        break\n                    if root.right.val + j == root.val:\n                        incr = max(incr, i2[j] + 1)\n                    if root.right.val - j == root.val:\n                        decr = max(decr, i2[j + 1] + 1)\n            ans[incr] = 1\n            ans[decr] = 1\n            ans[incr + decr - 1] = 1\n            return ans\n\n        ans = [0] * 1000\n        dfs(root)\n        max_val = max(ans)\n        for i in range(len(ans)):\n            if ans[i] == max_val:\n                return i",
  "canonical_solution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestConsecutive(self, root: TreeNode) -> int:\n        def dfs(root):\n            if root is None:\n                return [0, 0]\n            nonlocal ans\n            incr = decr = 1\n            i1, d1 = dfs(root.left)\n            i2, d2 = dfs(root.right)\n            if root.left:\n                if root.left.val + 1 == root.val:\n                    incr = i1 + 1\n                if root.left.val - 1 == root.val:\n                    decr = d1 + 1\n            if root.right:\n                if root.right.val + 1 == root.val:\n                    incr = max(incr, i2 + 1)\n                if root.right.val - 1 == root.val:\n                    decr = max(decr, d2 + 1)\n            ans = max(ans, incr + decr - 1)\n            return [incr, decr]\n\n        ans = 0\n        dfs(root)\n        return ans\n",
  "is_python": true
}