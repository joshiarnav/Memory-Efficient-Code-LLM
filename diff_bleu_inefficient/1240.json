{
  "problem_idx": "1240",
  "metrics": {
    "bleu_score": 0.81108788517452,
    "edit_similarity": 0.8649425287356322,
    "ast_similarity": 0.0,
    "diff_bleu_score": 1.0
  },
  "inefficient_solution": "class Solution:\n    def tilingRectangle(self, n: int, m: int) -> int:\n        def dfs(i: int, j: int, t: int, cache):\n            nonlocal ans\n            if j == m:\n                i += 1\n                j = 0\n            if i == n:\n                ans = t\n                return\n            if cache.get((i, j), None) is not None:\n                return cache[(i, j)]\n            if filled[i] >> j & 1:\n                dfs(i, j + 1, t, cache)\n            elif t + 1 < ans:\n                r = c = 0\n                for k in range(i, n):\n                    if filled[k] >> j & 1:\n                        break\n                    r += 1\n                for k in range(j, m):\n                    if filled[i] >> k & 1:\n                        break\n                    c += 1\n                mx = min(r, c)\n                for x in range(i, i + mx):\n                    for y in range(j, j + mx):\n                        filled[x] |= 1 << y\n                for w in range(mx, 0, -1):\n                    dfs(i, j + w, t + 1, cache)\n                    for k in range(w):\n                        filled[i + w - 1] ^= 1 << (j + k)\n                        if k < w - 1:\n                            filled[i + k] ^= 1 << (j + w - 1)\n                return cache[(i, j)] = t + 1\n\n        ans = n * m\n        filled = [0] * (n * 10)\n        cache = {}\n        dfs(0, 0, 0, cache)\n        return ans",
  "canonical_solution": "class Solution:\n    def tilingRectangle(self, n: int, m: int) -> int:\n        def dfs(i: int, j: int, t: int):\n            nonlocal ans\n            if j == m:\n                i += 1\n                j = 0\n            if i == n:\n                ans = t\n                return\n            if filled[i] >> j & 1:\n                dfs(i, j + 1, t)\n            elif t + 1 < ans:\n                r = c = 0\n                for k in range(i, n):\n                    if filled[k] >> j & 1:\n                        break\n                    r += 1\n                for k in range(j, m):\n                    if filled[i] >> k & 1:\n                        break\n                    c += 1\n                mx = min(r, c)\n                for x in range(i, i + mx):\n                    for y in range(j, j + mx):\n                        filled[x] |= 1 << y\n                for w in range(mx, 0, -1):\n                    dfs(i, j + w, t + 1)\n                    for k in range(w):\n                        filled[i + w - 1] ^= 1 << (j + k)\n                        if k < w - 1:\n                            filled[i + k] ^= 1 << (j + w - 1)\n\n        ans = n * m\n        filled = [0] * n\n        dfs(0, 0, 0)\n        return ans\n",
  "is_python": true
}