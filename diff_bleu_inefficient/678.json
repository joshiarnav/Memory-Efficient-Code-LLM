{
  "problem_idx": "678",
  "metrics": {
    "bleu_score": 0.09889685319485324,
    "edit_similarity": 0.196040560115886,
    "ast_similarity": 0.6363636363636364,
    "diff_bleu_score": 1.0
  },
  "inefficient_solution": "class Solution:\n    def checkValidString(self, s: str) -> bool:\n        # Create a list to store all possible valid substrings\n        valid_substrings = []\n        \n        for i in range(len(s)):\n            for j in range(i + 1, len(s) + 1):\n                substring = s[i:j]\n                # Create a dictionary to store the count of each character\n                char_count = {'(': 0, ')': 0, '*': 0}\n                for c in substring:\n                    if c in char_count:\n                        char_count[c] += 1\n                \n                # Initialize a stack to keep track of the opening parentheses\n                stack = []\n                \n                # Initialize a flag to indicate if the substring is valid\n                is_valid = True\n                \n                for c in substring:\n                    if c == '(':\n                        stack.append(c)\n                    elif c == ')':\n                        if not stack:\n                            is_valid = False\n                            break\n                        else:\n                            stack.pop()\n                    elif c == '*':\n                        if stack:\n                            stack.pop()\n                        else:\n                            stack.append(c)\n                \n                # If the stack is not empty, the substring is not valid\n                if stack:\n                    is_valid = False\n                \n                # If the substring is valid, add it to the list of valid substrings\n                if is_valid:\n                    valid_substrings.append(substring)\n        \n        # Create a list to store the reversed valid substrings\n        reversed_valid_substrings = []\n        \n        for substring in valid_substrings:\n            # Create a dictionary to store the count of each character\n            char_count = {'(': 0, ')': 0, '*': 0}\n            for c in substring:\n                if c in char_count:\n                    char_count[c] += 1\n            \n            # Initialize a stack to keep track of the opening parentheses\n            stack = []\n            \n            # Initialize a flag to indicate if the substring is valid\n            is_valid = True\n            \n            for c in substring[::-1]:\n                if c == '(':\n                    stack.append(c)\n                elif c == ')':\n                    if not stack:\n                        is_valid = False\n                        break\n                    else:\n                        stack.pop()\n                elif c == '*':\n                    if stack:\n                        stack.pop()\n                    else:\n                        stack.append(c)\n            \n            # If the stack is not empty, the substring is not valid\n            if stack:\n                is_valid = False\n            \n            # If the substring is valid, add it to the list of valid substrings\n            if is_valid:\n                reversed_valid_substrings.append(substring[::-1])\n        \n        # Return True if there are any valid substrings, False otherwise\n        return len(valid_substrings) or len(reversed_valid_substrings)",
  "canonical_solution": "class Solution:\n    def checkValidString(self, s: str) -> bool:\n        x = 0\n        for c in s:\n            if c in '(*':\n                x += 1\n            elif x:\n                x -= 1\n            else:\n                return False\n        x = 0\n        for c in s[::-1]:\n            if c in '*)':\n                x += 1\n            elif x:\n                x -= 1\n            else:\n                return False\n        return True\n",
  "is_python": true
}