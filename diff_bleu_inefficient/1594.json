{
  "problem_idx": "1594",
  "metrics": {
    "bleu_score": 0.557559970147552,
    "edit_similarity": 0.6820809248554913,
    "ast_similarity": 0.967741935483871,
    "diff_bleu_score": 1.0
  },
  "inefficient_solution": "class Solution:\n    def maxProductPath(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        mod = 10**9 + 7\n        dp = [[[0] * 2 for _ in range(n * 10**6)] for _ in range(m * 10**6)]\n        for i in range(m * 10**6):\n            for j in range(n * 10**6):\n                dp[i][j] = [0, 0]\n        for i in range(m):\n            for j in range(n):\n                dp[i * 10**6 + i][j * 10**6 + j] = [grid[i][j], grid[i][j]]\n        for i in range(m * 10**6):\n            for j in range(n * 10**6):\n                if dp[i][j][0] >= 0:\n                    dp[i][j + 10**6][0] = min(dp[i][j][0], dp[i + 10**6][j][0]) * dp[i][j][1]\n                    dp[i][j + 10**6][1] = max(dp[i][j][0], dp[i + 10**6][j][1]) * dp[i][j][1]\n                else:\n                    dp[i][j + 10**6][0] = max(dp[i][j][0], dp[i + 10**6][j][1]) * dp[i][j][1]\n                    dp[i][j + 10**6][1] = min(dp[i][j][0], dp[i + 10**6][j][0]) * dp[i][j][1]\n        ans = dp[-1][-1][1]\n        return -1 if ans < 0 else ans % mod",
  "canonical_solution": "class Solution:\n    def maxProductPath(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        mod = 10**9 + 7\n        dp = [[[grid[0][0]] * 2 for _ in range(n)] for _ in range(m)]\n        for i in range(1, m):\n            dp[i][0] = [dp[i - 1][0][0] * grid[i][0]] * 2\n        for j in range(1, n):\n            dp[0][j] = [dp[0][j - 1][0] * grid[0][j]] * 2\n        for i in range(1, m):\n            for j in range(1, n):\n                v = grid[i][j]\n                if v >= 0:\n                    dp[i][j][0] = min(dp[i - 1][j][0], dp[i][j - 1][0]) * v\n                    dp[i][j][1] = max(dp[i - 1][j][1], dp[i][j - 1][1]) * v\n                else:\n                    dp[i][j][0] = max(dp[i - 1][j][1], dp[i][j - 1][1]) * v\n                    dp[i][j][1] = min(dp[i - 1][j][0], dp[i][j - 1][0]) * v\n        ans = dp[-1][-1][1]\n        return -1 if ans < 0 else ans % mod\n",
  "is_python": true
}