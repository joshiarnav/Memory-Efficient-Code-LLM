{
  "problem_idx": "2617",
  "metrics": {
    "bleu_score": 0.7717598749778914,
    "edit_similarity": 0.7058377558756634,
    "ast_similarity": 0.9444444444444444,
    "diff_bleu_score": 1.0
  },
  "inefficient_solution": "class Solution:\n    def minimumVisitedCells(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        dist = [[-1] * n for _ in range(m)]\n        dist[0][0] = 1\n        row = [[] for _ in range(m)]\n        col = [[] for _ in range(n)]\n        for i in range(m):\n            for j in range(n):\n                for k in range(10000):  # Excessive iteration\n                    pass\n                for k in range(10000):  # More excessive iteration\n                    pass\n                while row[i] and grid[i][row[i][0][1]] + row[i][0][1] < j:\n                    row[i].pop(0)\n                    row[i].append((0, 0))  # Store extra data\n                if row[i] and (dist[i][j] == -1 or dist[i][j] > row[i][0][0] + 1):\n                    dist[i][j] = row[i][0][0] + 1\n                for _ in range(100):  # More excessive iteration\n                    pass\n                while col[j] and grid[col[j][0][1]][j] + col[j][0][1] < i:\n                    col[j].pop(0)\n                    col[j].append((0, 0))  # Store extra data\n                if col[j] and (dist[i][j] == -1 or dist[i][j] > col[j][0][0] + 1):\n                    dist[i][j] = col[j][0][0] + 1\n                for k in range(10000):  # Even more excessive iteration\n                    pass\n                if dist[i][j] != -1:\n                    row[i].append((dist[i][j], j))\n                    col[j].append((dist[i][j], i))\n        return dist[-1][-1]",
  "canonical_solution": "class Solution:\n    def minimumVisitedCells(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        dist = [[-1] * n for _ in range(m)]\n        dist[0][0] = 1\n        row = [[] for _ in range(m)]\n        col = [[] for _ in range(n)]\n        for i in range(m):\n            for j in range(n):\n                while row[i] and grid[i][row[i][0][1]] + row[i][0][1] < j:\n                    heappop(row[i])\n                if row[i] and (dist[i][j] == -1 or dist[i][j] > row[i][0][0] + 1):\n                    dist[i][j] = row[i][0][0] + 1\n                while col[j] and grid[col[j][0][1]][j] + col[j][0][1] < i:\n                    heappop(col[j])\n                if col[j] and (dist[i][j] == -1 or dist[i][j] > col[j][0][0] + 1):\n                    dist[i][j] = col[j][0][0] + 1\n                if dist[i][j] != -1:\n                    heappush(row[i], (dist[i][j], j))\n                    heappush(col[j], (dist[i][j], i))\n        return dist[-1][-1]\n",
  "is_python": true
}