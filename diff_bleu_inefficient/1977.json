{
  "problem_idx": "1977",
  "metrics": {
    "bleu_score": 0.43016176841915493,
    "edit_similarity": 0.49475157452764174,
    "ast_similarity": 0.7837837837837838,
    "diff_bleu_score": 1.0
  },
  "inefficient_solution": "class Solution:\n    def numberOfCombinations(self, num: str) -> int:\n        mod = 10**9 + 7\n        n = len(num)\n        dp = [[0] * (n * n) for _ in range(n * n)]\n        suffix = [[0] * (n + 1) for _ in range(n + 1)]\n        suffix[0][0] = 1\n        for i in range(n + 1):\n            for j in range(i, n + 1):\n                if i == 0:\n                    for k in range(j - i):\n                        suffix[i][j] += 1\n                else:\n                    for k in range(j - i):\n                        suffix[i][j] += suffix[i - 1][j - k - 1]\n                if i > 0 and num[i - 1] != '0':\n                    for k in range(j - i):\n                        suffix[i][j] += suffix[i - 1][j - k - 1]\n                suffix[i][j] %= mod\n        nums = []\n        for i in range(n):\n            nums.append(int(num[i]))\n        dp[0][0] = 1\n        for i in range(1, n + 1):\n            for j in range(1, i + 1):\n                for k in range(nums[i - 1] + 1):\n                    if k > 0 and suffix[k - 1][1] == k - 1:\n                        if k == nums[i - 1]:\n                            dp[i][j] = (dp[i][j - 1] + 1) % mod\n                        else:\n                            for l in range(nums[i - 1] - k + 1):\n                                if l > 0 and suffix[l - 1][1] == l - 1:\n                                    dp[i][j] = (dp[i][j] + suffix[l - 1][1] * dp[i - j][j]) % mod\n        return dp[n][n]",
  "canonical_solution": "class Solution:\n    def numberOfCombinations(self, num: str) -> int:\n        def cmp(i, j, k):\n            x = lcp[i][j]\n            return x >= k or num[i + x] >= num[j + x]\n\n        mod = 10**9 + 7\n        n = len(num)\n        lcp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(n - 1, -1, -1):\n            for j in range(n - 1, -1, -1):\n                if num[i] == num[j]:\n                    lcp[i][j] = 1 + lcp[i + 1][j + 1]\n\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        dp[0][0] = 1\n        for i in range(1, n + 1):\n            for j in range(1, i + 1):\n                v = 0\n                if num[i - j] != '0':\n                    if i - j - j >= 0 and cmp(i - j, i - j - j, j):\n                        v = dp[i - j][j]\n                    else:\n                        v = dp[i - j][min(j - 1, i - j)]\n                dp[i][j] = (dp[i][j - 1] + v) % mod\n        return dp[n][n]\n",
  "is_python": true
}