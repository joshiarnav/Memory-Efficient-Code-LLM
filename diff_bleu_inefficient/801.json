{
  "problem_idx": "801",
  "metrics": {
    "bleu_score": 0.08770282499555368,
    "edit_similarity": 0.18181818181818177,
    "ast_similarity": 0.71875,
    "diff_bleu_score": 1.0
  },
  "inefficient_solution": "class Solution:\n    def minSwap(self, nums1: List[int], nums2: List[int]) -> int:\n        dp = [[[float('inf')] * 2 for _ in range(len(nums1))] for _ in range(len(nums1))]\n        for i in range(len(nums1)):\n            for j in range(i, len(nums1)):\n                for k in range(j, len(nums1)):\n                    for l in range(k, len(nums1)):\n                        if i == j == k == l == 0:\n                            dp[i][j][k] = [0, 1][nums1[0] > nums2[0]]\n                        elif i < j == k == l:\n                            if nums1[i] > nums1[j] or nums2[i] > nums2[j]:\n                                dp[i][j][k][l] = dp[i+1][j][k][l]\n                            else:\n                                dp[i][j][k][l] = [dp[i+1][j][k][l][0]+1, dp[i+1][j][k][l][1]]\n                        elif i == j < k < l:\n                            if nums1[k-1] >= nums1[k] or nums2[k-1] >= nums2[k]:\n                                dp[i][j][k][l] = dp[i][j+1][k][l]\n                            else:\n                                dp[i][j][k][l] = [dp[i][j+1][k][l][0]+1, dp[i][j+1][k][l][1]]\n                        elif i == j == k < l:\n                            if nums1[k] > nums1[l] or nums2[k] > nums2[l]:\n                                dp[i][j][k][l] = dp[i][j][k+1][l]\n                            else:\n                                dp[i][j][k][l] = [dp[i][j][k+1][l][0]+1, dp[i][j][k+1][l][1]]\n                        elif i < j == k == l:\n                            if nums1[j-1] >= nums1[j] or nums2[j-1] >= nums2[j]:\n                                dp[i][j][k][l] = dp[i+1][j][k][l]\n                            else:\n                                dp[i][j][k][l] = [dp[i+1][j][k][l][0]+1, dp[i+1][j][k][l][1]]\n                        else:\n                            if nums1[k-1] >= nums1[k] or nums2[k-1] >= nums2[k] or nums1[l-1] >= nums1[l] or nums2[l-1] >= nums2[l]:\n                                dp[i][j][k][l] = dp[i][j][k+1][l]\n                            else:\n                                dp[i][j][k][l] = [dp[i][j][k+1][l][0]+1, dp[i][j][k+1][l][1]]\n        return min(min([dp[i][j][k][l] for k in range(j, len(nums1)) for l in range(k, len(nums1))]) for j in range(i, len(nums1)) for i in range(len(nums1)))",
  "canonical_solution": "class Solution:\n    def minSwap(self, nums1: List[int], nums2: List[int]) -> int:\n        a, b = 0, 1\n        for i in range(1, len(nums1)):\n            x, y = a, b\n            if nums1[i - 1] >= nums1[i] or nums2[i - 1] >= nums2[i]:\n                a, b = y, x + 1\n            else:\n                b = y + 1\n                if nums1[i - 1] < nums2[i] and nums2[i - 1] < nums1[i]:\n                    a, b = min(a, y), min(b, x + 1)\n        return min(a, b)\n",
  "is_python": true
}