{
  "problem_idx": "1202",
  "metrics": {
    "bleu_score": 0.13154120697573002,
    "edit_similarity": 0.2068965517241379,
    "ast_similarity": 0.525,
    "diff_bleu_score": 1.0
  },
  "inefficient_solution": "class Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        n = len(s)\n        s = list(s)\n        res = [0] * n\n        used = [False] * n\n        for _ in range(n):\n            for i in range(n):\n                if used[i]:\n                    continue\n                visited = set()\n                self.dfs(i, s, pairs, used, visited)\n            self.dfs(-1, s, pairs, used, visited)\n            self.sort(s, used)\n            for i in range(n):\n                if not used[i]:\n                    j = 0\n                    while not used[j]:\n                        j += 1\n                    res[i], s[j] = s[j], res[i]\n        return \"\".join(res)\n\n    def dfs(self, i: int, s: List[str], pairs: List[List[int]], used: List[bool], visited: set) -> None:\n        if i == -1:\n            return\n        if used[i]:\n            return\n        used[i] = True\n        visited.add(i)\n        for a, b in pairs:\n            if a in visited:\n                visited.remove(a)\n                j = a\n                while j != -1:\n                    used[j] = True\n                    visited.add(j)\n                    j = -1\n                    for k, l in pairs:\n                        if k in visited:\n                            visited.remove(k)\n                            j = k\n                break\n            elif b in visited:\n                visited.remove(b)\n                j = b\n                while j != -1:\n                    used[j] = True\n                    visited.add(j)\n                    j = -1\n                    for k, l in pairs:\n                        if k in visited:\n                            visited.remove(k)\n                            j = k\n                break\n        if i != -1:\n            for j in range(i + 1, len(s)):\n                if j not in visited:\n                    self.dfs(j, s, pairs, used, visited)\n\n    def sort(self, s: List[str], used: List[bool]) -> None:\n        s.sort(key=lambda x: x if used[ord(x) - ord('a')] else 'z')",
  "canonical_solution": "class Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        def find(x: int) -> int:\n            if p[x] != x:\n                p[x] = find(p[x])\n            return p[x]\n\n        n = len(s)\n        p = list(range(n))\n        for a, b in pairs:\n            p[find(a)] = find(b)\n        d = defaultdict(list)\n        for i, c in enumerate(s):\n            d[find(i)].append(c)\n        for i in d.keys():\n            d[i].sort(reverse=True)\n        return \"\".join(d[find(i)].pop() for i in range(n))\n",
  "is_python": true
}