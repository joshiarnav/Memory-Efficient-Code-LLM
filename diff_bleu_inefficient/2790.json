{
  "problem_idx": "2790",
  "metrics": {
    "bleu_score": 0.11102957121017826,
    "edit_similarity": 0.19999999999999996,
    "ast_similarity": 0.6774193548387096,
    "diff_bleu_score": 1.0
  },
  "inefficient_solution": "class Solution:\n    def maxIncreasingGroups(self, usageLimits: List[int]) -> int:\n        # Create a list of tuples containing the index and usage limit\n        idx_usage = [(i, u) for i, u in enumerate(usageLimits)]\n        \n        # Create a list of lists with all possible combinations of indices\n        combos = []\n        def generate_combos(current, start):\n            if current:\n                combos.append(current[:])\n            for i in range(start, len(idx_usage)):\n                current.append(i)\n                generate_combos(current, i + 1)\n                current.pop()\n                \n        generate_combos([], 0)\n        \n        # Sort the list of tuples by the usage limit in ascending order\n        idx_usage.sort(key=lambda x: x[1])\n        \n        # Initialize variables to keep track of the maximum number of groups and the current total usage\n        max_groups = 0\n        total_usage = 0\n        \n        # Iterate over the combinations\n        for combo in combos:\n            # Sort the current combination of indices in ascending order\n            combo.sort()\n            \n            # Initialize variables to keep track of the current group and its total usage\n            group = []\n            group_usage = 0\n            \n            # Iterate over the current combination\n            for i in combo:\n                # If adding the current index to the group would exceed the usage limit, break\n                if group_usage + 1 > idx_usage[i][1]:\n                    break\n                # Add the current index to the group and update the group's total usage\n                group.append(i)\n                group_usage += 1\n                \n            # If the group is not empty, update the maximum number of groups and the current total usage\n            if group:\n                max_groups += 1\n                total_usage += group_usage\n                \n                # Check if we can form a new group using the remaining indices\n                new_group = True\n                for i in group:\n                    if idx_usage[i][1] > group_usage:\n                        new_group = False\n                        break\n                \n                # If we can form a new group, update the maximum number of groups and the current total usage\n                if new_group:\n                    max_groups += 1\n                    total_usage += group_usage\n                \n        return max_groups",
  "canonical_solution": "class Solution:\n    def maxIncreasingGroups(self, usageLimits: List[int]) -> int:\n        usageLimits.sort()\n        k = s = 0\n        for x in usageLimits:\n            s += x\n            if s > k:\n                k += 1\n                s -= k\n        return k\n",
  "is_python": true
}