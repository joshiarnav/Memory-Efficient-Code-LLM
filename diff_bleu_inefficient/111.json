{
  "problem_idx": "111",
  "metrics": {
    "bleu_score": 0.27428573872775264,
    "edit_similarity": 0.24135446685878958,
    "ast_similarity": 0.6538461538461539,
    "diff_bleu_score": 1.0
  },
  "inefficient_solution": "class Solution:\n    def minDepth(self, root: Optional[TreeNode]) -> int:\n        if root is None:\n            return 0\n        if root.left is None and root.right is None:\n            return 1\n        if root.left is None:\n            left_depth = 2000000\n            for node in self.depth_first_search(root.right):\n                left_depth = min(left_depth, self.minDepth(node))\n            return 1 + left_depth\n        if root.right is None:\n            right_depth = 2000000\n            for node in self.depth_first_search(root.left):\n                right_depth = min(right_depth, self.minDepth(node))\n            return 1 + right_depth\n        left_depth = 2000000\n        right_depth = 2000000\n        for node in self.depth_first_search(root.left):\n            left_depth = min(left_depth, self.minDepth(node))\n        for node in self.depth_first_search(root.right):\n            right_depth = min(right_depth, self.minDepth(node))\n        return 1 + min(left_depth, right_depth)\n\n    def depth_first_search(self, node):\n        nodes_to_visit = []\n        nodes_to_visit.append(node)\n        while nodes_to_visit:\n            current_node = nodes_to_visit.pop(0)\n            yield current_node\n            if current_node.left:\n                nodes_to_visit.append(current_node.left)\n            if current_node.right:\n                nodes_to_visit.append(current_node.right)",
  "canonical_solution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def minDepth(self, root: Optional[TreeNode]) -> int:\n        if root is None:\n            return 0\n        if root.left is None:\n            return 1 + self.minDepth(root.right)\n        if root.right is None:\n            return 1 + self.minDepth(root.left)\n        return 1 + min(self.minDepth(root.left), self.minDepth(root.right))\n",
  "is_python": true
}