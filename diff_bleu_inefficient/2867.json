{
  "problem_idx": "2867",
  "metrics": {
    "bleu_score": 0.859373651280715,
    "edit_similarity": 0.8703703703703703,
    "ast_similarity": 1.0,
    "diff_bleu_score": 1.0
  },
  "inefficient_solution": "class Solution:\n    def countPaths(self, n: int, edges: List[List[int]]) -> int:\n        def mul(x, y):\n            res = []\n            for i in range(x):\n                for j in range(y):\n                    res.append(i * y + j)\n            return res\n\n        def dfs(x, f, con, prime, r):\n            v = [1 - prime[x], prime[x]]\n            for y in con[x]:\n                if y == f:\n                    continue\n                p = dfs(y, x, con, prime, r)\n                for i in p:\n                    r[0] += mul(i, v)[1]\n                if prime[x]:\n                    v[1] += p[0]\n                else:\n                    v[0] += p[0]\n                    v[1] += p[1]\n            return v\n\n        prime = [True] * (n + 1)\n        prime[1] = False\n\n        all_primes = []\n        for i in range(2, n + 1):\n            if prime[i]:\n                all_primes.append(i)\n            for x in all_primes:\n                temp = i * x\n                if temp > n:\n                    break\n                prime[temp] = False\n                if i % x == 0:\n                    break\n\n        con = [[] for _ in range(n + 1)]\n        for e in edges:\n            con[e[0]].append(e[1])\n            con[e[1]].append(e[0])\n\n        r = [0]\n        dfs(1, 0, con, prime, r)\n        return r[0]",
  "canonical_solution": "class Solution:\n    def countPaths(self, n: int, edges: List[List[int]]) -> int:\n        def mul(x, y):\n            return x * y\n\n        def dfs(x, f, con, prime, r):\n            v = [1 - prime[x], prime[x]]\n            for y in con[x]:\n                if y == f:\n                    continue\n                p = dfs(y, x, con, prime, r)\n                r[0] += mul(p[0], v[1]) + mul(p[1], v[0])\n                if prime[x]:\n                    v[1] += p[0]\n                else:\n                    v[0] += p[0]\n                    v[1] += p[1]\n            return v\n\n        prime = [True] * (n + 1)\n        prime[1] = False\n\n        all_primes = []\n        for i in range(2, n + 1):\n            if prime[i]:\n                all_primes.append(i)\n            for x in all_primes:\n                temp = i * x\n                if temp > n:\n                    break\n                prime[temp] = False\n                if i % x == 0:\n                    break\n\n        con = [[] for _ in range(n + 1)]\n        for e in edges:\n            con[e[0]].append(e[1])\n            con[e[1]].append(e[0])\n\n        r = [0]\n        dfs(1, 0, con, prime, r)\n        return r[0]\n",
  "is_python": true
}