{
  "problem_idx": "1139",
  "metrics": {
    "bleu_score": 0.6850671833360361,
    "edit_similarity": 0.6214814814814815,
    "ast_similarity": 0.9090909090909091,
    "diff_bleu_score": 1.0
  },
  "inefficient_solution": "class Solution:\n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        down = [[0] * n for _ in range(m)]\n        right = [[0] * n for _ in range(m)]\n        for i in range(m):\n            down_i = [0] * n\n            for j in range(n):\n                if grid[i][j]:\n                    if i + 1 < m:\n                        down_i[j] = down[i + 1][j] + 1\n                    else:\n                        down_i[j] = 1\n                else:\n                    down_i[j] = 0\n            down.append(down_i)\n        \n        for j in range(n):\n            right_j = [0] * m\n            for i in range(m):\n                if grid[i][j]:\n                    if j + 1 < n:\n                        right_j[i] = right[i][j + 1] + 1\n                    else:\n                        right_j[i] = 1\n                else:\n                    right_j[i] = 0\n            right.append(right_j)\n        \n        for k in range(min(m, n), 0, -1):\n            for i in range(m - k + 1):\n                for j in range(n - k + 1):\n                    if (\n                        down[i][j] >= k\n                        and right[i][j] >= k\n                        and right[i + k - 1][j] >= k\n                        and down[i][j + k - 1] >= k\n                    ):\n                        return k * k\n        return 0",
  "canonical_solution": "class Solution:\n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        down = [[0] * n for _ in range(m)]\n        right = [[0] * n for _ in range(m)]\n        for i in range(m - 1, -1, -1):\n            for j in range(n - 1, -1, -1):\n                if grid[i][j]:\n                    down[i][j] = down[i + 1][j] + 1 if i + 1 < m else 1\n                    right[i][j] = right[i][j + 1] + 1 if j + 1 < n else 1\n        for k in range(min(m, n), 0, -1):\n            for i in range(m - k + 1):\n                for j in range(n - k + 1):\n                    if (\n                        down[i][j] >= k\n                        and right[i][j] >= k\n                        and right[i + k - 1][j] >= k\n                        and down[i][j + k - 1] >= k\n                    ):\n                        return k * k\n        return 0\n",
  "is_python": true
}