{
  "problem_idx": "2332",
  "metrics": {
    "bleu_score": 0.17906755887284817,
    "edit_similarity": 0.28030788967286724,
    "ast_similarity": 0.6097560975609756,
    "diff_bleu_score": 1.0
  },
  "inefficient_solution": "class Solution:\n    def latestTimeCatchTheBus(\n        self, buses: List[int], passengers: List[int], capacity: int\n    ) -> int:\n        # Create lists of bus and passenger indices for efficient lookup\n        bus_indices = [i for i in range(len(buses))]\n        passenger_indices = [i for i in range(len(passengers))]\n        \n        # Create a list to store the earliest passenger arrival time for each bus\n        earliest_arrivals = [float('inf')] * len(buses)\n        \n        # Create a list to store the latest bus departure time for each passenger\n        latest_departures = [float('-inf')] * len(passengers)\n        \n        for i, departure in enumerate(buses):\n            # Find all passengers who can board the current bus\n            for j, arrival in enumerate(passengers):\n                if arrival <= departure:\n                    # Update the earliest arrival time for the current bus\n                    earliest_arrivals[i] = min(earliest_arrivals[i], arrival)\n                    # Update the latest departure time for the current passenger\n                    latest_departures[j] = departure\n        \n        # Sort the buses by their earliest arrival time\n        buses.sort(key=lambda x: earliest_arrivals[x])\n        \n        # Sort the passengers by their arrival time in non-decreasing order\n        passengers.sort()\n        \n        # Initialize the current time and the number of passengers waiting for a bus\n        current_time = 0\n        waiting_passengers = 0\n        \n        for i, departure in enumerate(buses):\n            # Find all passengers who can board the current bus\n            waiting_passengers = 0\n            for j, arrival in enumerate(passengers):\n                if arrival <= departure:\n                    waiting_passengers += 1\n            # If the current bus has enough capacity, board as many passengers as possible\n            if waiting_passengers <= capacity:\n                current_time = departure\n                break\n            else:\n                # Otherwise, board the passengers with the earliest arrival times\n                for j in range(waiting_passengers - capacity):\n                    current_time = passengers[j]\n                    passengers.pop(j)\n                    waiting_passengers -= 1\n        \n        # Find the latest time that can board the last bus\n        latest_time = float('-inf')\n        for i in range(len(passengers) - 1, -1, -1):\n            if passengers[i] > current_time:\n                latest_time = passengers[i]\n                break\n        \n        # Return the latest time that can board a bus\n        return max(latest_time, current_time)",
  "canonical_solution": "class Solution:\n    def latestTimeCatchTheBus(\n        self, buses: List[int], passengers: List[int], capacity: int\n    ) -> int:\n        buses.sort()\n        passengers.sort()\n        j = 0\n        for t in buses:\n            c = capacity\n            while c and j < len(passengers) and passengers[j] <= t:\n                c, j = c - 1, j + 1\n        j -= 1\n        ans = buses[-1] if c else passengers[j]\n        while ~j and passengers[j] == ans:\n            ans, j = ans - 1, j - 1\n        return ans\n",
  "is_python": true
}