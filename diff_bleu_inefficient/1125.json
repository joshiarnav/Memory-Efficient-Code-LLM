{
  "problem_idx": "1125",
  "metrics": {
    "bleu_score": 0.387603369406908,
    "edit_similarity": 0.4614928909952607,
    "ast_similarity": 0.8205128205128205,
    "diff_bleu_score": 1.0
  },
  "inefficient_solution": "class Solution:\n    def smallestSufficientTeam(\n        self, req_skills: List[str], people: List[List[str]]\n    ) -> List[int]:\n        d = {s: i for i, s in enumerate(req_skills)}\n        m, n = len(req_skills), len(people)\n        p = [0] * n\n        for i, ss in enumerate(people):\n            for s in ss:\n                p[i] |= 1 << d[s]\n\n        # Create a large dictionary to store intermediate results\n        mem = {}\n        for i in range(len(people)):\n            for j in range(len(people)):\n                if i == j:\n                    continue\n                mem[(i, j)] = []\n\n        # Create a large list to store intermediate results\n        dp = [-1] * (1 << m)\n        dp[0] = 0\n\n        # Iterate over all possible subsets of people\n        for i in range(1 << m):\n            if dp[i] == -1:\n                continue\n\n            # For each person\n            for j in range(len(people)):\n                # If the person has the required skills\n                if self.has_required_skills(people[j], req_skills, d):\n                    # Check if the person is already in the team\n                    if not self.is_in_team(i, people[j], mem):\n                        # Add the person to the team\n                        new_state = i | (1 << d[people[j][0]])\n                        dp[new_state] = dp[i] + 1\n                        # Store the person in the team\n                        mem[(i, j)] = people[j]\n\n        # Find the smallest sufficient team\n        i = (1 << m) - 1\n        ans = []\n        while i:\n            # Find the person who was added last\n            j = self.find_last_added_person(i, dp, mem)\n            # Add the person to the team\n            ans.append(j)\n            # Update the state\n            i = i & ~(1 << d[people[j][0]])\n\n        return ans\n\n    def has_required_skills(self, person, req_skills, d):\n        for s in req_skills:\n            if (1 << d[s]) & person == 0:\n                return False\n        return True\n\n    def is_in_team(self, i, person, mem):\n        for k, v in mem.items():\n            if k[1] == person:\n                return True\n        return False\n\n    def find_last_added_person(self, i, dp, mem):\n        for k, v in mem.items():\n            if k[0] == i:\n                return k[1]\n        return -1",
  "canonical_solution": "class Solution:\n    def smallestSufficientTeam(\n        self, req_skills: List[str], people: List[List[str]]\n    ) -> List[int]:\n        d = {s: i for i, s in enumerate(req_skills)}\n        m, n = len(req_skills), len(people)\n        p = [0] * n\n        for i, ss in enumerate(people):\n            for s in ss:\n                p[i] |= 1 << d[s]\n        f = [inf] * (1 << m)\n        g = [0] * (1 << m)\n        h = [0] * (1 << m)\n        f[0] = 0\n        for i in range(1 << m):\n            if f[i] == inf:\n                continue\n            for j in range(n):\n                if f[i] + 1 < f[i | p[j]]:\n                    f[i | p[j]] = f[i] + 1\n                    g[i | p[j]] = j\n                    h[i | p[j]] = i\n        i = (1 << m) - 1\n        ans = []\n        while i:\n            ans.append(g[i])\n            i = h[i]\n        return ans\n",
  "is_python": true
}