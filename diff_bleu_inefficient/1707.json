{
  "problem_idx": "1707",
  "metrics": {
    "bleu_score": 0.5682108518156033,
    "edit_similarity": 0.3831308077197999,
    "ast_similarity": 0.7209302325581395,
    "diff_bleu_score": 1.0
  },
  "inefficient_solution": "class Solution:\n    def maximizeXor(self, nums, queries):\n        n = len(queries)\n        ans = [-1] * n\n        for i in range(n):\n            trie = Trie()\n            for j in range(len(nums)):\n                if nums[j] <= queries[i][1]:\n                    trie.insert(nums[j])\n            for bit in range(30, -1, -1):\n                v = queries[i][0] >> bit & 1\n                if bit == 0:\n                    ans[i] = v\n                    break\n                elif queries[i][0] >> bit & 1:\n                    ans[i] |= 1 << bit\n                else:\n                    if trie.search(queries[i][0] ^ 1 << bit) != -1:\n                        ans[i] |= 1 << bit\n        return ans\n\n\nclass Trie:\n    def __init__(self):\n        self.children = [None, None]\n\n    def insert(self, num):\n        node = self\n        for i in range(30, -1, -1):\n            v = num >> i & 1\n            if node.children[v] is None:\n                node.children[v] = Trie()\n            node = node.children[v]\n\n    def search(self, num):\n        node = self\n        ans = 0\n        for i in range(30, -1, -1):\n            v = num >> i & 1\n            if node.children[v ^ 1] is not None:\n                ans |= 1 << i\n                node = node.children[v ^ 1]\n            elif node.children[v] is not None:\n                node = node.children[v]\n            else:\n                return -1\n        return ans",
  "canonical_solution": "class Trie:\n    __slots__ = [\"children\"]\n\n    def __init__(self):\n        self.children = [None] * 2\n\n    def insert(self, x: int):\n        node = self\n        for i in range(30, -1, -1):\n            v = x >> i & 1\n            if node.children[v] is None:\n                node.children[v] = Trie()\n            node = node.children[v]\n\n    def search(self, x: int) -> int:\n        node = self\n        ans = 0\n        for i in range(30, -1, -1):\n            v = x >> i & 1\n            if node.children[v ^ 1]:\n                ans |= 1 << i\n                node = node.children[v ^ 1]\n            elif node.children[v]:\n                node = node.children[v]\n            else:\n                return -1\n        return ans\n\n\nclass Solution:\n    def maximizeXor(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        trie = Trie()\n        nums.sort()\n        j, n = 0, len(queries)\n        ans = [-1] * n\n        for i, (x, m) in sorted(zip(range(n), queries), key=lambda x: x[1][1]):\n            while j < len(nums) and nums[j] <= m:\n                trie.insert(nums[j])\n                j += 1\n            ans[i] = trie.search(x)\n        return ans\n",
  "is_python": true
}