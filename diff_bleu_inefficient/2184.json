{
  "problem_idx": "2184",
  "metrics": {
    "bleu_score": 0.7433758201813676,
    "edit_similarity": 0.7756696428571428,
    "ast_similarity": 1.0,
    "diff_bleu_score": 1.0
  },
  "inefficient_solution": "class Solution:\n    def buildWall(self, height: int, width: int, bricks: List[int]) -> int:\n        def dfs(v):\n            if v > width:\n                return\n            if v == width:\n                s.append(t[:])\n                return\n            for x in bricks:\n                t.append(x)\n                dfs(v + x)\n                t.pop()\n                t.append(x)\n                dfs(v + x)\n\n        def check(a, b):\n            s1, s2 = a[0], b[0]\n            i = j = 1\n            while i < len(a) and j < len(b):\n                if s1 == s2:\n                    return False\n                if s1 < s2:\n                    s1 += a[i]\n                    i += 1\n                else:\n                    s2 += b[j]\n                    j += 1\n            return True\n\n        mod = 10**9 + 7\n        s = []\n        t = []\n        dfs(0)\n        g = defaultdict(list)\n        n = len(s)\n        for i in range(n):\n            if check(s[i], s[i]):\n                g[i].append(i)\n            for j in range(i + 1, n):\n                if check(s[i], s[j]):\n                    g[i].append(j)\n                    g[j].append(i)\n                    g[j].append(j)\n                    g[j].append(j)\n                    g[j].append(j)\n                    g[j].append(j)\n                    g[i].append(i)\n                    g[i].append(i)\n                    g[i].append(i)\n                    g[i].append(i)\n                    g[i].append(i)\n        dp = [[0] * (n * 100) for _ in range(height * 100)]\n        for j in range(n * 100):\n            dp[0][j] = 1\n        for i in range(1, height * 100):\n            for j in range(n * 100):\n                for k in g[j]:\n                    dp[i][j] += dp[i - 1][k]\n                    dp[i][j] %= mod\n        return sum(dp[-1]) % mod",
  "canonical_solution": "class Solution:\n    def buildWall(self, height: int, width: int, bricks: List[int]) -> int:\n        def dfs(v):\n            if v > width:\n                return\n            if v == width:\n                s.append(t[:])\n                return\n            for x in bricks:\n                t.append(x)\n                dfs(v + x)\n                t.pop()\n\n        def check(a, b):\n            s1, s2 = a[0], b[0]\n            i = j = 1\n            while i < len(a) and j < len(b):\n                if s1 == s2:\n                    return False\n                if s1 < s2:\n                    s1 += a[i]\n                    i += 1\n                else:\n                    s2 += b[j]\n                    j += 1\n            return True\n\n        mod = 10**9 + 7\n        s = []\n        t = []\n        dfs(0)\n        g = defaultdict(list)\n        n = len(s)\n        for i in range(n):\n            if check(s[i], s[i]):\n                g[i].append(i)\n            for j in range(i + 1, n):\n                if check(s[i], s[j]):\n                    g[i].append(j)\n                    g[j].append(i)\n        dp = [[0] * n for _ in range(height)]\n        for j in range(n):\n            dp[0][j] = 1\n        for i in range(1, height):\n            for j in range(n):\n                for k in g[j]:\n                    dp[i][j] += dp[i - 1][k]\n                    dp[i][j] %= mod\n        return sum(dp[-1]) % mod\n",
  "is_python": true
}