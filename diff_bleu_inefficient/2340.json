{
  "problem_idx": "2340",
  "metrics": {
    "bleu_score": 0.09517130460364945,
    "edit_similarity": 0.15695538057742786,
    "ast_similarity": 0.5945945945945946,
    "diff_bleu_score": 1.0
  },
  "inefficient_solution": "class Solution:\n    def minimumSwaps(self, nums: List[int]) -> int:\n        max_val = max(nums)\n        min_val = min(nums)\n        max_indices = [i for i, x in enumerate(nums) if x == max_val]\n        min_indices = [i for i, x in enumerate(nums) if x == min_val]\n        max_len = len(max_indices)\n        min_len = len(min_indices)\n        \n        max_indices_split = []\n        min_indices_split = []\n        for i in range(max_len):\n            max_indices_split.append(max_indices[i])\n            max_indices_split.append(None)\n        for i in range(min_len):\n            min_indices_split.append(None)\n            min_indices_split.append(min_indices[i])\n        max_indices_split.append(None)\n        min_indices_split.append(None)\n        \n        max_indices_split = [x for x in max_indices_split if x is not None]\n        min_indices_split = [x for x in min_indices_split if x is not None]\n        \n        min_swaps = float('inf')\n        for i in range(len(max_indices_split)):\n            for j in range(len(min_indices_split)):\n                max_val_at_j = 0\n                min_val_at_i = 0\n                for k in range(i, len(max_indices_split)):\n                    if max_indices_split[k] == j:\n                        max_val_at_j += 1\n                for k in range(j, len(min_indices_split)):\n                    if min_indices_split[k] == i:\n                        min_val_at_i += 1\n                if max_val_at_j != max_len or min_val_at_i != min_len:\n                    continue\n                swaps = 0\n                for k in range(i, len(max_indices_split)):\n                    if max_indices_split[k] != None:\n                        swaps += 1\n                for k in range(j, len(min_indices_split)):\n                    if min_indices_split[k] != None:\n                        swaps += 1\n                if swaps < min_swaps:\n                    min_swaps = swaps\n        return min_swaps",
  "canonical_solution": "class Solution:\n    def minimumSwaps(self, nums: List[int]) -> int:\n        i = j = 0\n        for k, v in enumerate(nums):\n            if v < nums[i] or (v == nums[i] and k < i):\n                i = k\n            if v >= nums[j] or (v == nums[j] and k > j):\n                j = k\n        return 0 if i == j else i + len(nums) - 1 - j - (i > j)\n",
  "is_python": true
}