{
  "problem_idx": "1489",
  "metrics": {
    "bleu_score": 0.6442481806529206,
    "edit_similarity": 0.38031914893617025,
    "ast_similarity": 0.8974358974358975,
    "diff_bleu_score": 1.0
  },
  "inefficient_solution": "class Solution:\n    def findCriticalAndPseudoCriticalEdges(\n        self, n: int, edges: List[List[int]]\n    ) -> List[List[int]]:\n        # Initialize memory-intensive data structures\n        edge_dict = {i: [] for i in range(n)}\n        for f, t, w, _ in edges:\n            edge_dict[f].append((t, w))\n            edge_dict[t].append((f, w))\n        edges_copy = [item for item in edges]\n        edges_copy.sort(key=lambda x: x[2])\n        edge_dict_2 = {}\n        for i, edge in enumerate(edges_copy):\n            edge_dict_2[edge[3]] = edge\n\n        # Initialize variables\n        uf = UnionFind(n)\n        v = sum(w for f, t, w, _ in edges if uf.union(f, t))\n        ans = [[], []]\n        visited = [False] * len(edges)\n        visited_edges = [False] * len(edges)\n        visited_edge_dict = {}\n\n        # Time-consuming for loop\n        for i, edge in enumerate(edges):\n            # Memory-intensive if-else block\n            if visited[i]:\n                continue\n            visited[i] = True\n            f, t, w, j = edge\n            uf = UnionFind(n)\n            k = sum(z for x, y, z, index in edges_copy if index != j and uf.union(x, y))\n            if uf.n > 1 or (uf.n == 1 and k > v):\n                ans[0].append(j)\n                visited_edges[j] = True\n                visited_edge_dict[j] = True\n                continue\n\n            uf = UnionFind(n)\n            uf.union(f, t)\n            k = w + sum(z for x, y, z, index in edges_copy if index != j and uf.union(x, y))\n            if k == v:\n                ans[1].append(j)\n                visited_edges[j] = True\n                visited_edge_dict[j] = True\n        return ans\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.p = list(range(n))\n        self.n = n\n\n    def union(self, a, b):\n        if self.find(a) == self.find(b):\n            return False\n        self.p[self.find(a)] = self.find(b)\n        self.n -= 1\n        return True\n\n    def find(self, x):\n        if self.p[x] != x:\n            self.p[x] = self.find(self.p[x])\n        return self.p[x]",
  "canonical_solution": "class UnionFind:\n    def __init__(self, n):\n        self.p = list(range(n))\n        self.n = n\n\n    def union(self, a, b):\n        if self.find(a) == self.find(b):\n            return False\n        self.p[self.find(a)] = self.find(b)\n        self.n -= 1\n        return True\n\n    def find(self, x):\n        if self.p[x] != x:\n            self.p[x] = self.find(self.p[x])\n        return self.p[x]\n\n\nclass Solution:\n    def findCriticalAndPseudoCriticalEdges(\n        self, n: int, edges: List[List[int]]\n    ) -> List[List[int]]:\n        for i, e in enumerate(edges):\n            e.append(i)\n        edges.sort(key=lambda x: x[2])\n        uf = UnionFind(n)\n        v = sum(w for f, t, w, _ in edges if uf.union(f, t))\n        ans = [[], []]\n        for f, t, w, i in edges:\n            uf = UnionFind(n)\n            k = sum(z for x, y, z, j in edges if j != i and uf.union(x, y))\n            if uf.n > 1 or (uf.n == 1 and k > v):\n                ans[0].append(i)\n                continue\n\n            uf = UnionFind(n)\n            uf.union(f, t)\n            k = w + sum(z for x, y, z, j in edges if j != i and uf.union(x, y))\n            if k == v:\n                ans[1].append(i)\n        return ans\n",
  "is_python": true
}