{
  "problem_idx": "499",
  "metrics": {
    "bleu_score": 0.5577296236872492,
    "edit_similarity": 0.626188734455011,
    "ast_similarity": 0.8717948717948718,
    "diff_bleu_score": 1.0
  },
  "inefficient_solution": "class Solution:\n    def findShortestWay(\n        self, maze: List[List[int]], ball: List[int], hole: List[int]\n    ) -> str:\n        m, n = len(maze), len(maze[0])\n        directions = [(-1, 0, 'u'), (1, 0, 'd'), (0, -1, 'l'), (0, 1, 'r')]\n        q, dist = deque(), {}\n        for i, j in [(ball[0], ball[1])]:\n            dist[(i, j)] = 0\n            q.append((i, j, ''))\n\n        while q:\n            for _ in range(len(q)):\n                i, j, path = q.popleft()\n                for a, b, d in directions:\n                    x, y, step = i, j, dist[(i, j)]\n                    while (\n                        0 <= x + a < m\n                        and 0 <= y + b < n\n                        and maze[x + a][y + b] == 0\n                        and (x != hole[0] or y != hole[1])\n                    ):\n                        x, y = x + a, y + b\n                        step += 1\n                    new_path = path + d\n                    if (x, y) not in dist or (\n                        dist[(x, y)] > step\n                        or (\n                            dist[(x, y)] == step\n                            and new_path < dist[(x, y)]\n                        )\n                    ):\n                        dist[(x, y)] = step\n                        q.append((x, y, new_path))\n\n        return dist.get((hole[0], hole[1]), 'impossible') or 'impossible'",
  "canonical_solution": "class Solution:\n    def findShortestWay(\n        self, maze: List[List[int]], ball: List[int], hole: List[int]\n    ) -> str:\n        m, n = len(maze), len(maze[0])\n        r, c = ball\n        rh, ch = hole\n        q = deque([(r, c)])\n        dist = [[inf] * n for _ in range(m)]\n        dist[r][c] = 0\n        path = [[None] * n for _ in range(m)]\n        path[r][c] = ''\n        while q:\n            i, j = q.popleft()\n            for a, b, d in [(-1, 0, 'u'), (1, 0, 'd'), (0, -1, 'l'), (0, 1, 'r')]:\n                x, y, step = i, j, dist[i][j]\n                while (\n                    0 <= x + a < m\n                    and 0 <= y + b < n\n                    and maze[x + a][y + b] == 0\n                    and (x != rh or y != ch)\n                ):\n                    x, y = x + a, y + b\n                    step += 1\n                if dist[x][y] > step or (\n                    dist[x][y] == step and path[i][j] + d < path[x][y]\n                ):\n                    dist[x][y] = step\n                    path[x][y] = path[i][j] + d\n                    if x != rh or y != ch:\n                        q.append((x, y))\n        return path[rh][ch] or 'impossible'\n",
  "is_python": true
}