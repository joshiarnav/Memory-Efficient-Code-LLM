{
  "problem_idx": "2258",
  "metrics": {
    "bleu_score": 0.6837298554111063,
    "edit_similarity": 0.8111067657411029,
    "ast_similarity": 1.0,
    "diff_bleu_score": 1.0
  },
  "inefficient_solution": "class Solution:\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\n        def spread(q: list) -> list:\n            new_q = []\n            for i, j in q:\n                for a, b in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                    x, y = i + a, j + b\n                    if (\n                        0 <= x < m\n                        and 0 <= y < n\n                        and not fire[x][y]\n                        and grid[x][y] == 0\n                    ):\n                        fire[x][y] = True\n                        new_q.append((x, y))\n            return new_q\n\n        def check(t: int) -> bool:\n            for i in range(m):\n                for j in range(n):\n                    fire[i][j] = False\n            tmp_q1 = []\n            for i, row in enumerate(grid):\n                for j, x in enumerate(row):\n                    if x == 1:\n                        fire[i][j] = True\n                        tmp_q1.append((i, j))\n            while t and tmp_q1:\n                tmp_q1 = spread(tmp_q1)\n                t -= 1\n            if fire[0][0]:\n                return False\n            tmp_q2 = [(0, 0)]\n            tmp_vis = [[False] * n for _ in range(m)]\n            tmp_vis[0][0] = True\n            while tmp_q2:\n                for _ in range(len(tmp_q2)):\n                    i, j = tmp_q2.pop(0)\n                    if fire[i][j]:\n                        continue\n                    for a, b in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                        x, y = i + a, j + b\n                        if (\n                            0 <= x < m\n                            and 0 <= y < n\n                            and not tmp_vis[x][y]\n                            and not fire[x][y]\n                            and grid[x][y] == 0\n                        ):\n                            if x == m - 1 and y == n - 1:\n                                return True\n                            tmp_vis[x][y] = True\n                            tmp_q2.append((x, y))\n                tmp_q1 = spread(tmp_q1)\n            return False\n\n        m, n = len(grid), len(grid[0])\n        l, r = -1, m * n\n        fire = [[False] * n for _ in range(m)]\n        for _ in range(m * n):\n            fire.append([False] * n)\n        for _ in range(m):\n            fire.append([False] * n)\n        dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        while l < r:\n            mid = (l + r + 1) >> 1\n            if check(mid):\n                l = mid\n            else:\n                r = mid - 1\n        return int(1e9) if l == m * n else l",
  "canonical_solution": "class Solution:\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\n        def spread(q: Deque[int]) -> Deque[int]:\n            nq = deque()\n            while q:\n                i, j = q.popleft()\n                for a, b in pairwise(dirs):\n                    x, y = i + a, j + b\n                    if 0 <= x < m and 0 <= y < n and not fire[x][y] and grid[x][y] == 0:\n                        fire[x][y] = True\n                        nq.append((x, y))\n            return nq\n\n        def check(t: int) -> bool:\n            for i in range(m):\n                for j in range(n):\n                    fire[i][j] = False\n            q1 = deque()\n            for i, row in enumerate(grid):\n                for j, x in enumerate(row):\n                    if x == 1:\n                        fire[i][j] = True\n                        q1.append((i, j))\n            while t and q1:\n                q1 = spread(q1)\n                t -= 1\n            if fire[0][0]:\n                return False\n            q2 = deque([(0, 0)])\n            vis = [[False] * n for _ in range(m)]\n            vis[0][0] = True\n            while q2:\n                for _ in range(len(q2)):\n                    i, j = q2.popleft()\n                    if fire[i][j]:\n                        continue\n                    for a, b in pairwise(dirs):\n                        x, y = i + a, j + b\n                        if (\n                            0 <= x < m\n                            and 0 <= y < n\n                            and not vis[x][y]\n                            and not fire[x][y]\n                            and grid[x][y] == 0\n                        ):\n                            if x == m - 1 and y == n - 1:\n                                return True\n                            vis[x][y] = True\n                            q2.append((x, y))\n                q1 = spread(q1)\n            return False\n\n        m, n = len(grid), len(grid[0])\n        l, r = -1, m * n\n        dirs = (-1, 0, 1, 0, -1)\n        fire = [[False] * n for _ in range(m)]\n        while l < r:\n            mid = (l + r + 1) >> 1\n            if check(mid):\n                l = mid\n            else:\n                r = mid - 1\n        return int(1e9) if l == m * n else l\n",
  "is_python": true
}