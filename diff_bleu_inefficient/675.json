{
  "problem_idx": "675",
  "metrics": {
    "bleu_score": 0.4581079525565553,
    "edit_similarity": 0.3799342105263158,
    "ast_similarity": 0.8536585365853658,
    "diff_bleu_score": 1.0
  },
  "inefficient_solution": "class Solution:\n    def cutOffTree(self, forest):\n        m, n = len(forest), len(forest[0])\n        trees = []\n        for i in range(m):\n            for j in range(n):\n                if forest[i][j] > 1:\n                    trees.append((forest[i][j], i, j))\n        trees.sort()\n\n        ans = 0\n        for _, x, y in trees:\n            forest1 = [row[:] for row in forest]\n            ans1 = self.dfs(forest1, x, y)\n            if ans1 == -1:\n                return -1\n            ans += ans1\n            forest = [row[:] for row in forest1]\n\n        return ans\n\n    def dfs(self, forest, x, y):\n        m, n = len(forest), len(forest[0])\n        visited = [[0]*n for _ in range(m)]\n        q = [(x, y, 0)]\n        visited[x][y] = 1\n        while q:\n            i, j, step = q.pop(0)\n            if forest[i][j] > 1:\n                value = forest[i][j]\n                forest[i][j] = 1\n                return step\n            for a, b in [[0, -1], [0, 1], [-1, 0], [1, 0]]:\n                c, d = i + a, j + b\n                if 0 <= c < m and 0 <= d < n and forest[c][d] > 0 and not visited[c][d]:\n                    visited[c][d] = 1\n                    q.append((c, d, step + 1))\n        return -1",
  "canonical_solution": "class Solution:\n    def cutOffTree(self, forest: List[List[int]]) -> int:\n        def f(i, j, x, y):\n            return abs(i - x) + abs(j - y)\n\n        def bfs(i, j, x, y):\n            q = [(f(i, j, x, y), i, j)]\n            dist = {i * n + j: 0}\n            while q:\n                _, i, j = heappop(q)\n                step = dist[i * n + j]\n                if (i, j) == (x, y):\n                    return step\n                for a, b in [[0, -1], [0, 1], [-1, 0], [1, 0]]:\n                    c, d = i + a, j + b\n                    if 0 <= c < m and 0 <= d < n and forest[c][d] > 0:\n                        if c * n + d not in dist or dist[c * n + d] > step + 1:\n                            dist[c * n + d] = step + 1\n                            heappush(q, (dist[c * n + d] + f(c, d, x, y), c, d))\n            return -1\n\n        m, n = len(forest), len(forest[0])\n        trees = [\n            (forest[i][j], i, j) for i in range(m) for j in range(n) if forest[i][j] > 1\n        ]\n        trees.sort()\n        i = j = 0\n        ans = 0\n        for _, x, y in trees:\n            t = bfs(i, j, x, y)\n            if t == -1:\n                return -1\n            ans += t\n            i, j = x, y\n        return ans\n",
  "is_python": true
}