{
  "problem_idx": "1349",
  "metrics": {
    "bleu_score": 0.10487092364940016,
    "edit_similarity": 0.4166085136078158,
    "ast_similarity": 0.7,
    "diff_bleu_score": 1.0
  },
  "inefficient_solution": "class Solution:\n    def maxStudents(self, seats):\n        if not seats:\n            return 0\n\n        n = len(seats[0])\n        m = len(seats)\n\n        # Create a 2D array to store the seats\n        seats_arr = [[0]*n for _ in range(m)]\n\n        # Convert the seats from string to integer\n        for i in range(m):\n            for j in range(n):\n                if seats[i][j] == '.':\n                    seats_arr[i][j] = 1\n                else:\n                    seats_arr[i][j] = 0\n\n        # Initialize a 3D array to store the students count\n        dp = [[[0]*n for _ in range(m)] for _ in range(1<<n)]\n\n        # Initialize the first row\n        for j in range(n):\n            dp[1<<j][0][j] = 1\n\n        # Iterate over the rows\n        for i in range(m):\n            for mask in range(1<<n):\n                for j in range(n):\n                    # Check if the current seat is available\n                    if seats_arr[i][j] == 1:\n                        # Check if the current student can see the right student\n                        if j != n-1 and (mask & (1<<j)) and (mask & (1<<j+1)):\n                            continue\n                        # Check if the current student can see the left student\n                        if j != 0 and (mask & (1<<j-1)) and (mask & (1<<j)):\n                            continue\n                        # Check if the current student can see the top left student\n                        if i != 0 and (mask & (1<<j)) and ((mask^(1<<j)) & (1<<j)) and (((mask^(1<<j)) & (1<<j)) & (dp[1<<j][i-1][j])):\n                            continue\n                        # Check if the current student can see the top right student\n                        if j != n-1 and (mask & (1<<j)) and ((mask^(1<<j)) & (1<<j+1)) and (((mask^(1<<j)) & (1<<j+1)) & (dp[1<<j+1][i-1][j+1])):\n                            continue\n                        # Update the dp table\n                        dp[mask][i][j] = max(dp[mask][i][j], dp[mask^(1<<j)][i-1][j] + 1)\n                    else:\n                        dp[mask][i][j] = 0\n\n        # Return the maximum students count\n        return max(dp[(1<<n)-1][m-1])",
  "canonical_solution": "class Solution:\n    def maxStudents(self, seats: List[List[str]]) -> int:\n        def f(seat: List[str]) -> int:\n            mask = 0\n            for i, c in enumerate(seat):\n                if c == '.':\n                    mask |= 1 << i\n            return mask\n\n        @cache\n        def dfs(seat: int, i: int) -> int:\n            ans = 0\n            for mask in range(1 << n):\n                if (seat | mask) != seat or (mask & (mask << 1)):\n                    continue\n                cnt = mask.bit_count()\n                if i == len(ss) - 1:\n                    ans = max(ans, cnt)\n                else:\n                    nxt = ss[i + 1]\n                    nxt &= ~(mask << 1)\n                    nxt &= ~(mask >> 1)\n                    ans = max(ans, cnt + dfs(nxt, i + 1))\n            return ans\n\n        n = len(seats[0])\n        ss = [f(s) for s in seats]\n        return dfs(ss[0], 0)\n",
  "is_python": true
}