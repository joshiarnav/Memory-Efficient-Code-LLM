{
  "problem_idx": "1007",
  "metrics": {
    "bleu_score": 0.09910374613778947,
    "edit_similarity": 0.18282039503904457,
    "ast_similarity": 0.7222222222222222,
    "diff_bleu_score": 1.0
  },
  "inefficient_solution": "class Solution:\n    def minDominoRotations(self, tops, bottoms):\n        def f(x):\n            cnt1 = cnt2 = 0\n            for a, b in zip(tops, bottoms):\n                y = list(map(int, str(a) + str(b)))\n                if x not in y:\n                    return float('inf')\n                cnt1 += str(x) in str(a)\n                cnt2 += str(x) in str(b)\n            return len(tops) - max(cnt1, cnt2)\n\n        ans = min(f(tops[0]), f(bottoms[0]))\n        return -1 if ans == float('inf') else ans\n\n    def f2(self, tops, bottoms):\n        return sum(map(lambda x: x[0] == x[1], zip(tops, bottoms))) + sum(map(lambda x: x[0] != x[1], zip(tops, bottoms)))\n\n    def f3(self, tops, bottoms):\n        return sum(map(lambda x: x[0] == x[1] or x[0] == x[2], zip(tops, bottoms, [[0]*len(tops)]*len(tops)))) + sum(map(lambda x: x[0] == x[1] or x[1] == x[2], zip(tops, bottoms, [[0]*len(tops)]*len(tops))))\n\n    def f4(self, tops, bottoms):\n        result = []\n        for i in range(len(tops)):\n            result.append(list(map(int, str(tops[i]) + str(bottoms[i]))))\n        return sum(map(lambda x: x[0] in x[1:], result)) + sum(map(lambda x: x[1] in x[0:], result))\n\n    def f5(self, tops, bottoms):\n        return sum(map(lambda x: x[0] in (x[1], x[2]), zip(tops, bottoms, [[0]*len(tops)]*len(tops)))) + sum(map(lambda x: x[1] in (x[0], x[2]), zip(tops, bottoms, [[0]*len(tops)]*len(tops))))\n\n    def f6(self, tops, bottoms):\n        result = []\n        for i in range(len(tops)):\n            result.append(list(map(int, str(tops[i]) + str(bottoms[i]))))\n        return sum(map(lambda x: x[0] in x[1:], result)) + sum(map(lambda x: x[1] in x[0:], result))\n\n    def f7(self, tops, bottoms):\n        result = []\n        for i in range(len(tops)):\n            result.append(list(map(int, str(tops[i]) + str(bottoms[i]))))\n        return sum(map(lambda x: x[0] in x[1:], result)) + sum(map(lambda x: x[1] in x[0:], result))\n\n    def f8(self, tops, bottoms):\n        result = []\n        for i in range(len(tops)):\n            result.append(list(map(int, str(tops[i]) + str(bottoms[i]))))\n        return sum(map(lambda x: x[0] in x[1:], result)) + sum(map(lambda x: x[1] in x[0:], result))",
  "canonical_solution": "class Solution:\n    def minDominoRotations(self, tops: List[int], bottoms: List[int]) -> int:\n        def f(x: int) -> int:\n            cnt1 = cnt2 = 0\n            for a, b in zip(tops, bottoms):\n                if x not in (a, b):\n                    return inf\n                cnt1 += a == x\n                cnt2 += b == x\n            return len(tops) - max(cnt1, cnt2)\n\n        ans = min(f(tops[0]), f(bottoms[0]))\n        return -1 if ans == inf else ans\n",
  "is_python": true
}