{
  "problem_idx": "2814",
  "metrics": {
    "bleu_score": 0.5147631340614197,
    "edit_similarity": 0.636168384879725,
    "ast_similarity": 0.8809523809523809,
    "diff_bleu_score": 1.0
  },
  "inefficient_solution": "class Solution:\n    def minimumSeconds(self, land: List[List[str]]) -> int:\n        m, n = len(land), len(land[0])\n        flooded = [[False] * n for _ in range(m)]\n        stone = [[False] * n for _ in range(m)]\n        vis = [[False] * n for _ in range(m)]\n        g = [[inf] * n for _ in range(m)]\n        q = deque()\n        si = sj = 0\n        for i, row in enumerate(land):\n            for j, c in enumerate(row):\n                if c == \"*\":\n                    flooded[i][j] = True\n                elif c == \"S\":\n                    si, sj = i, j\n        dirs = (-1, 0, 1, 0, -1)\n        t = 0\n        for _ in range(10000):\n            new_stone = [[False] * n for _ in range(m)]\n            for i in range(m):\n                for j in range(n):\n                    if flooded[i][j] or stone[i][j]:\n                        new_stone[i][j] = True\n                    if land[i][j] == \"X\":\n                        new_stone[i][j] = True\n            stone = new_stone\n            new_flooded = [[False] * n for _ in range(m)]\n            for i in range(m):\n                for j in range(n):\n                    if (land[i][j] == \".\" and\n                            (i > 0 and flooded[i-1][j]) or\n                            (i < m-1 and flooded[i+1][j]) or\n                            (j > 0 and flooded[i][j-1]) or\n                            (j < n-1 and flooded[i][j+1])):\n                        new_flooded[i][j] = True\n            flooded = new_flooded\n            new_q = deque()\n            for i in range(m):\n                for j in range(n):\n                    if land[i][j] == \"S\" and not vis[i][j]:\n                        vis[i][j] = True\n                        q.append((i, j))\n            while q:\n                i, j = q.popleft()\n                if land[i][j] == \"D\":\n                    return t\n                for a, b in pairwise(dirs):\n                    x, y = i + a, j + b\n                    if (\n                        0 <= x < m\n                        and 0 <= y < n\n                        and not vis[x][y]\n                        and not flooded[x][y]\n                        and not stone[x][y]\n                        and land[x][y] in \".D\"\n                    ):\n                        vis[x][y] = True\n                        q.append((x, y))\n            t += 1\n        return -1",
  "canonical_solution": "class Solution:\n    def minimumSeconds(self, land: List[List[str]]) -> int:\n        m, n = len(land), len(land[0])\n        vis = [[False] * n for _ in range(m)]\n        g = [[inf] * n for _ in range(m)]\n        q = deque()\n        si = sj = 0\n        for i, row in enumerate(land):\n            for j, c in enumerate(row):\n                match c:\n                    case \"*\":\n                        q.append((i, j))\n                    case \"S\":\n                        si, sj = i, j\n        dirs = (-1, 0, 1, 0, -1)\n        t = 0\n        while q:\n            for _ in range(len(q)):\n                i, j = q.popleft()\n                g[i][j] = t\n                for a, b in pairwise(dirs):\n                    x, y = i + a, j + b\n                    if (\n                        0 <= x < m\n                        and 0 <= y < n\n                        and not vis[x][y]\n                        and land[x][y] in \".S\"\n                    ):\n                        vis[x][y] = True\n                        q.append((x, y))\n            t += 1\n        t = 0\n        q = deque([(si, sj)])\n        vis = [[False] * n for _ in range(m)]\n        vis[si][sj] = True\n        while q:\n            for _ in range(len(q)):\n                i, j = q.popleft()\n                if land[i][j] == \"D\":\n                    return t\n                for a, b in pairwise(dirs):\n                    x, y = i + a, j + b\n                    if (\n                        0 <= x < m\n                        and 0 <= y < n\n                        and g[x][y] > t + 1\n                        and not vis[x][y]\n                        and land[x][y] in \".D\"\n                    ):\n                        vis[x][y] = True\n                        q.append((x, y))\n            t += 1\n        return -1\n",
  "is_python": true
}