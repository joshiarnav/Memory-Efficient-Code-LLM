{
  "problem_idx": "782",
  "metrics": {
    "bleu_score": 0.16863205413653082,
    "edit_similarity": 0.360625,
    "ast_similarity": 0.6578947368421053,
    "diff_bleu_score": 1.0
  },
  "inefficient_solution": "class Solution:\n    def movesToChessboard(self, board):\n        n = len(board)\n        moves = 0\n        rowMoves = [0] * n\n        colMoves = [0] * n\n        targetRow = [0] * n\n        targetCol = [0] * n\n\n        for i in range(n):\n            for j in range(n):\n                if board[i][j] == 1:\n                    rowMoves[i] += 1\n                    colMoves[j] += 1\n                    targetRow[i] = 1\n                    targetCol[j] = 1\n\n        for i in range(n):\n            if rowMoves[i] != (n + 1) // 2:\n                targetRow[i] = 0\n            if colMoves[i] != (n + 1) // 2:\n                targetCol[i] = 0\n\n        moves += self.countMoves(rowMoves, targetRow)\n        moves += self.countMoves(colMoves, targetCol)\n\n        return moves\n\n    def countMoves(self, moves, target):\n        minMoves = float('inf')\n        for i in range(len(moves)):\n            if moves[i] != target[i]:\n                moves[i] = 0\n        for i in range(len(moves)):\n            if moves[i] != 0:\n                for j in range(len(moves)):\n                    if moves[j] == 0:\n                        moves[j], moves[i] = moves[i], moves[j]\n                        minMoves = min(minMoves, self.getMoves(moves, target))\n                        moves[j], moves[i] = moves[i], moves[j]\n        return minMoves\n\n    def getMoves(self, moves, target):\n        count = 0\n        for i in range(len(moves)):\n            if moves[i] != target[i]:\n                count += 1\n                if i + 1 < len(moves):\n                    moves[i], moves[i + 1] = moves[i + 1], moves[i]\n        return count",
  "canonical_solution": "class Solution:\n    def movesToChessboard(self, board: List[List[int]]) -> int:\n        def f(mask, cnt):\n            ones = mask.bit_count()\n            if n & 1:\n                if abs(n - 2 * ones) != 1 or abs(n - 2 * cnt) != 1:\n                    return -1\n                if ones == n // 2:\n                    return n // 2 - (mask & 0xAAAAAAAA).bit_count()\n                return (n + 1) // 2 - (mask & 0x55555555).bit_count()\n            else:\n                if ones != n // 2 or cnt != n // 2:\n                    return -1\n                cnt0 = n // 2 - (mask & 0xAAAAAAAA).bit_count()\n                cnt1 = n // 2 - (mask & 0x55555555).bit_count()\n                return min(cnt0, cnt1)\n\n        n = len(board)\n        mask = (1 << n) - 1\n        rowMask = colMask = 0\n        for i in range(n):\n            rowMask |= board[0][i] << i\n            colMask |= board[i][0] << i\n        revRowMask = mask ^ rowMask\n        revColMask = mask ^ colMask\n        sameRow = sameCol = 0\n        for i in range(n):\n            curRowMask = curColMask = 0\n            for j in range(n):\n                curRowMask |= board[i][j] << j\n                curColMask |= board[j][i] << j\n            if curRowMask not in (rowMask, revRowMask) or curColMask not in (\n                colMask,\n                revColMask,\n            ):\n                return -1\n            sameRow += curRowMask == rowMask\n            sameCol += curColMask == colMask\n        t1 = f(rowMask, sameRow)\n        t2 = f(colMask, sameCol)\n        return -1 if t1 == -1 or t2 == -1 else t1 + t2\n",
  "is_python": true
}