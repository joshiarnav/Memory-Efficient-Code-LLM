{
  "problem_idx": "1467",
  "metrics": {
    "bleu_score": 0.16785997505710754,
    "edit_similarity": 0.35860838537020523,
    "ast_similarity": 0.6216216216216216,
    "diff_bleu_score": 1.0
  },
  "inefficient_solution": "class Solution:\n    def getProbability(self, balls: List[int]) -> float:\n        k = len(balls)\n        total_balls = sum(balls)\n        n = total_balls // 2\n\n        # Initialize a 2D array to store the number of ways to distribute the balls\n        dp = [[[0 for _ in range(n + 1)] for _ in range(n + 1)] for _ in range(k + 1)]\n\n        # Initialize the base case where there are no balls left\n        for i in range(k + 1):\n            dp[i][0][0] = 1\n\n        # Calculate the number of ways to distribute the balls\n        for i in range(1, k + 1):\n            for j in range(1, n + 1):\n                for x in range(balls[i - 1] + 1):\n                    dp[i][j][x] = dp[i - 1][j - x][x] if x <= j else 0\n\n        # Calculate the total number of ways to distribute the balls\n        total_ways = sum(sum(row) for row in dp[k])\n\n        # Initialize a 2D array to store the number of ways to have the same number of distinct balls\n        same_distinct = [[[0 for _ in range(n + 1)] for _ in range(n + 1)] for _ in range(k + 1)]\n\n        # Calculate the number of ways to have the same number of distinct balls\n        for i in range(k + 1):\n            for j in range(1, n + 1):\n                for x in range(balls[i - 1] + 1):\n                    if i == 0:\n                        same_distinct[i][j][x] = 0 if j < 1 else 1\n                    else:\n                        same_distinct[i][j][x] = same_distinct[i - 1][j - x][x] if x <= j else 0\n\n        # Calculate the number of ways to have the same number of distinct balls\n        same_distinct_ways = sum(sum(sum(row) for row in col) for col in same_distinct)\n\n        # Return the probability\n        return same_distinct_ways / total_ways",
  "canonical_solution": "class Solution:\n    def getProbability(self, balls: List[int]) -> float:\n        @cache\n        def dfs(i: int, j: int, diff: int) -> float:\n            if i >= k:\n                return 1 if j == 0 and diff == 0 else 0\n            if j < 0:\n                return 0\n            ans = 0\n            for x in range(balls[i] + 1):\n                y = 1 if x == balls[i] else (-1 if x == 0 else 0)\n                ans += dfs(i + 1, j - x, diff + y) * comb(balls[i], x)\n            return ans\n\n        n = sum(balls) >> 1\n        k = len(balls)\n        return dfs(0, n, 0) / comb(n << 1, n)\n",
  "is_python": true
}