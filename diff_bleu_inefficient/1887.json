{
  "problem_idx": "1887",
  "metrics": {
    "bleu_score": 0.06970085859946382,
    "edit_similarity": 0.11111111111111116,
    "ast_similarity": 0.5833333333333334,
    "diff_bleu_score": 1.0
  },
  "inefficient_solution": "class Solution:\n    def reductionOperations(self, nums: List[int]) -> int:\n        max_val = float('-inf')\n        max_index = -1\n        max_values = []\n        \n        for i, v in enumerate(nums):\n            if v > max_val:\n                max_val = v\n                max_index = i\n                max_values = [v]\n            elif v == max_val:\n                max_values.append(v)\n        \n        next_largest_values = {}\n        for i, v in enumerate(nums):\n            if i not in next_largest_values and v < max_val:\n                next_largest_values[v] = [max_val]\n            elif i in next_largest_values and v < max_val:\n                next_largest_values[v].append(max_val)\n        \n        next_largest_dfs = {}\n        for v, vs in next_largest_values.items():\n            next_largest_dfs[v] = self.dfs(v, vs, nums)\n        \n        ans = 0\n        for v, vs in next_largest_dfs.items():\n            if len(vs) == 0:\n                continue\n            for i, val in enumerate(vs):\n                if val == v:\n                    ans += i\n                    break\n        \n        return ans\n    \n    def dfs(self, v, vs, nums):\n        if v not in vs:\n            return []\n        \n        max_val = float('-inf')\n        max_index = -1\n        max_values = []\n        \n        for i, x in enumerate(nums):\n            if x > max_val and x < v:\n                max_val = x\n                max_index = i\n                max_values = [x]\n            elif x == max_val and x < v:\n                max_values.append(x)\n        \n        if len(max_values) == 0:\n            return [v]\n        \n        next_largest_values = {}\n        for i, x in enumerate(nums):\n            if i not in next_largest_values and x < v:\n                next_largest_values[x] = [max_val]\n            elif i in next_largest_values and x < v:\n                next_largest_values[x].append(max_val)\n        \n        next_largest_dfs = {}\n        for x, xs in next_largest_values.items():\n            next_largest_dfs[x] = self.dfs(x, xs, nums)\n        \n        ans = []\n        for x, xs in next_largest_dfs.items():\n            if len(xs) == 0:\n                continue\n            for i, val in enumerate(xs):\n                if val == x:\n                    ans.append(v)\n                    break\n        \n        return ans",
  "canonical_solution": "class Solution:\n    def reductionOperations(self, nums: List[int]) -> int:\n        nums.sort()\n        ans = cnt = 0\n        for i, v in enumerate(nums[1:]):\n            if v != nums[i]:\n                cnt += 1\n            ans += cnt\n        return ans\n",
  "is_python": true
}