{
    "problem_idx": "252",
    "description": "\nGiven an array of meeting time `intervals`\u00a0where `intervals[i] = [starti, endi]`, determine if a person could attend all meetings.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n**Input:** intervals = [[0,30],[5,10],[15,20]]\n**Output:** false\n\n```\n**Example 2:**\n\n\n\n```\n**Input:** intervals = [[7,10],[2,4]]\n**Output:** true\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `0 <= intervals.length <= 104`\n* `intervals[i].length == 2`\n* `0 <= starti <\u00a0endi <= 106`\n\n\n",
    "inefficient_solution": "class Solution:\n    def canAttendMeetings(self, intervals: List[List[int]]) -> bool:\n        intervals_dict = {}\n        for i, interval in enumerate(intervals):\n            intervals_dict[i] = interval\n\n        all_intervals = list(intervals_dict.values())\n        intervals_sorted = []\n\n        for i in range(len(all_intervals)):\n            for j in range(i + 1, len(all_intervals)):\n                if all_intervals[j][0] >= all_intervals[i][1]:\n                    intervals_sorted.append([all_intervals[i], all_intervals[j]])\n\n        for i in range(0, len(intervals_sorted), 2):\n            if intervals_sorted[i][1][1] > intervals_sorted[i + 1][0][0]:\n                return False\n\n        return True",
    "efficient_solution": "class Solution:\n    def canAttendMeetings(self, intervals: List[List[int]]) -> bool:\n        intervals.sort()\n        return all(a[1] <= b[0] for a, b in pairwise(intervals))\n",
    "model_generation": "### Efficient Solution:\n\nWe can solve this problem more efficiently by sorting the intervals based on their start times and then iterating over them to check for any conflicts.\n\nHere's the improved solution:\n\n```python\nclass Solution:\n    def canAttendMeetings(self, intervals: List[List[int]]) -> bool:\n        # Sort the intervals based on their start times\n        intervals.sort(key=lambda x: x[0])\n        \n        # Iterate over the sorted intervals and check for any conflicts\n        for i in range(1, len(intervals)):\n            if intervals[i][0] < intervals[i-1][1]:\n                return False\n        \n        return True\n```\n\n### Explanation:\n\n1.  We first sort the intervals based on their start times using the `sort` method and a lambda function as the key.\n2.  Then, we iterate over the sorted intervals starting from the second interval (index 1).\n3.  For each interval, we check if its start time is less than the end time of the previous interval. If it is, that means there's a conflict, and we return False.\n4.  If we don't find any conflicts after iterating over all intervals, we return True, indicating that it's possible to attend all meetings.\n\nThis solution has a time complexity of O(n log n) due to the sorting step, where n is the number of intervals. The subsequent iteration over the sorted intervals has a time complexity of O(n), so the overall time complexity remains O(n log n). This is more efficient than the original solution, which had a time complexity of O(n^2) due to the nested loops.",
    "model_solution": "class Solution:\n    def canAttendMeetings(self, intervals: List[List[int]]) -> bool:\n        # Sort the intervals based on their start times\n        intervals.sort(key=lambda x: x[0])\n        \n        # Iterate over the sorted intervals and check for any conflicts\n        for i in range(1, len(intervals)):\n            if intervals[i][0] < intervals[i-1][1]:\n                return False\n        \n        return True",
    "is_python": true
}