{
    "problem_idx": "556",
    "description": "\nGiven a positive integer `n`, find *the smallest integer which has exactly the same digits existing in the integer* `n` *and is greater in value than* `n`. If no such positive integer exists, return `-1`.\n\n\n**Note** that the returned integer should fit in **32-bit integer**, if there is a valid answer but it does not fit in **32-bit integer**, return `-1`.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n**Input:** n = 12\n**Output:** 21\n\n```\n**Example 2:**\n\n\n\n```\n**Input:** n = 21\n**Output:** -1\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= n <= 231 - 1`\n\n\n",
    "inefficient_solution": "class Solution:\n    def nextGreaterElement(self, n: int) -> int:\n        # Convert the number to a list of integers with 1 million elements each\n        n_list = [int(d) for d in str(n)] * 1000000\n        \n        # Convert each integer in the list to a string and store them in a new list\n        str_list = [str(d) for d in n_list]\n        \n        # Create a list of tuples where each tuple contains a string and its index\n        str_index_list = [(s, i) for i, s in enumerate(str_list)]\n        \n        # Sort the list of tuples based on the strings\n        str_index_list.sort(key=lambda x: x[0])\n        \n        # Initialize variables to keep track of the current index and the previous character\n        i, prev_char = 0, -1\n        \n        # Iterate over the sorted list of tuples\n        while i < len(str_index_list):\n            # If the current string is the same as the previous character, increment the index\n            if str_index_list[i][0] == '0':\n                i += 1\n            # If the current string is greater than the previous character, swap them and increment the index\n            elif str_index_list[i][0] > prev_char:\n                prev_char, str_index_list[i] = str_index_list[i], (prev_char, i)\n                i += 1\n            # Otherwise, increment the index\n            else:\n                i += 1\n        \n        # Initialize a list to store the result\n        result = []\n        \n        # Initialize variables to keep track of the current index and the previous character\n        i, prev_char = 0, -1\n        \n        # Iterate over the sorted list of tuples\n        while i < len(str_index_list):\n            # If the current string is the same as the previous character, append the character to the result\n            if str_index_list[i][0] == '0':\n                result.append(int(str_index_list[i][0]))\n            # If the current string is greater than the previous character, append the character to the result and increment the index\n            elif str_index_list[i][0] > prev_char:\n                result.append(int(str_index_list[i][0]))\n                prev_char = str_index_list[i][0]\n                i += 1\n            # Otherwise, increment the index\n            else:\n                i += 1\n        \n        # Join the characters in the result list to form a string\n        result_str = ''.join(map(str, result))\n        \n        # Initialize a list to store the final result\n        final_result = []\n        \n        # Iterate over the characters in the result string\n        for char in result_str:\n            # Append the character to the final result list 1000000 times\n            final_result.extend([int(char)] * 1000000)\n        \n        # Join the characters in the final result list to form a string\n        final_result_str = ''.join(map(str, final_result))\n        \n        # Convert the final result string to an integer and return it\n        return int(final_result_str)",
    "efficient_solution": "class Solution:\n    def nextGreaterElement(self, n: int) -> int:\n        cs = list(str(n))\n        n = len(cs)\n        i, j = n - 2, n - 1\n        while i >= 0 and cs[i] >= cs[i + 1]:\n            i -= 1\n        if i < 0:\n            return -1\n        while cs[i] >= cs[j]:\n            j -= 1\n        cs[i], cs[j] = cs[j], cs[i]\n        cs[i + 1 :] = cs[i + 1 :][::-1]\n        ans = int(''.join(cs))\n        return -1 if ans > 2**31 - 1 else ans\n",
    "model_generation": "### Efficient Solution\n\n```python\nclass Solution:\n    def nextGreaterElement(self, n: int) -> int:\n        # Convert the number to a list of digits\n        digits = [int(d) for d in str(n)]\n        \n        # Find the first digit from the right that is smaller than the digit to its right\n        i = len(digits) - 1\n        while i > 0 and digits[i - 1] >= digits[i]:\n            i -= 1\n        \n        # If no such digit is found, return -1\n        if i == 0:\n            return -1\n        \n        # Find the smallest digit to the right of the found digit that is greater than it\n        j = len(digits) - 1\n        while digits[j] <= digits[i - 1]:\n            j -= 1\n        \n        # Swap the found digits\n        digits[i - 1], digits[j] = digits[j], digits[i - 1]\n        \n        # Sort the digits to the right of the found digit in ascending order\n        digits[i:] = sorted(digits[i:])\n        \n        # Join the digits to form a string and convert it to an integer\n        result = int(''.join(map(str, digits)))\n        \n        # If the result is outside the 32-bit integer range, return -1\n        if result > 2**31 - 1:\n            return -1\n        \n        # Otherwise, return the result\n        return result\n```\n\n### Explanation\n\nThe provided solution is inefficient because it involves converting the number to a list of 1 million integers, sorting the list, and then reconstructing the number from the sorted list. This is unnecessary and can be avoided by directly manipulating the digits of the number.\n\nThe efficient solution works as follows:\n\n1. Convert the number to a list of digits.\n2. Find the first digit from the right that is smaller than the digit to its right. If no such digit is found, return -1.\n3. Find the smallest digit to the right of the found digit that is greater than it.\n4. Swap the found digits.\n5. Sort the digits to the right of the found digit in ascending order.\n6. Join the digits to form a string and convert it to an integer.\n7. If the result is outside the 32-bit integer range, return -1. Otherwise, return the result.\n\nThis solution has a time complexity of O(n log n) due to the sorting step, where n is the number of digits in the number.",
    "model_solution": "class Solution:\n    def nextGreaterElement(self, n: int) -> int:\n        # Convert the number to a list of digits\n        digits = [int(d) for d in str(n)]\n        \n        # Find the first digit from the right that is smaller than the digit to its right\n        i = len(digits) - 1\n        while i > 0 and digits[i - 1] >= digits[i]:\n            i -= 1\n        \n        # If no such digit is found, return -1\n        if i == 0:\n            return -1\n        \n        # Find the smallest digit to the right of the found digit that is greater than it\n        j = len(digits) - 1\n        while digits[j] <= digits[i - 1]:\n            j -= 1\n        \n        # Swap the found digits\n        digits[i - 1], digits[j] = digits[j], digits[i - 1]\n        \n        # Sort the digits to the right of the found digit in ascending order\n        digits[i:] = sorted(digits[i:])\n        \n        # Join the digits to form a string and convert it to an integer\n        result = int(''.join(map(str, digits)))\n        \n        # If the result is outside the 32-bit integer range, return -1\n        if result > 2**31 - 1:\n            return -1\n        \n        # Otherwise, return the result\n        return result",
    "is_python": true
}