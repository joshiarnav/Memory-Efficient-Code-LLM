{
    "problem_idx": "1626",
    "description": "\nYou are the manager of a basketball team. For the upcoming tournament, you want to choose the team with the highest overall score. The score of the team is the **sum** of scores of all the players in the team.\n\n\nHowever, the basketball team is not allowed to have **conflicts**. A **conflict** exists if a younger player has a **strictly higher** score than an older player. A conflict does **not** occur between players of the same age.\n\n\nGiven two lists, `scores` and `ages`, where each `scores[i]` and `ages[i]` represents the score and age of the `ith` player, respectively, return *the highest overall score of all possible basketball teams*.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** scores = [1,3,5,10,15], ages = [1,2,3,4,5]\n**Output:** 34\n**Explanation:**\u00a0You can choose all the players.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** scores = [4,5,6,5], ages = [2,1,2,1]\n**Output:** 16\n**Explanation:**\u00a0It is best to choose the last 3 players. Notice that you are allowed to choose multiple people of the same age.\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** scores = [1,2,3,5], ages = [8,9,10,1]\n**Output:** 6\n**Explanation:**\u00a0It is best to choose the first 3 players. \n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= scores.length, ages.length <= 1000`\n* `scores.length == ages.length`\n* `1 <= scores[i] <= 106`\n* `1 <= ages[i] <= 1000`\n\n\n",
    "inefficient_solution": "class Solution:\n    def bestTeamScore(self, scores, ages):\n        n = len(scores)\n        res = 0\n        for i in range(n):\n            for j in range(i, n):\n                if scores[j] >= scores[i]:\n                    temp_sum = 0\n                    for k in range(i, j+1):\n                        temp_sum += scores[k]\n                    res = max(res, temp_sum)\n        return res",
    "efficient_solution": "class BinaryIndexedTree:\n    def __init__(self, n):\n        self.n = n\n        self.c = [0] * (n + 1)\n\n    def update(self, x, val):\n        while x <= self.n:\n            self.c[x] = max(self.c[x], val)\n            x += x & -x\n\n    def query(self, x):\n        s = 0\n        while x:\n            s = max(s, self.c[x])\n            x -= x & -x\n        return s\n\n\nclass Solution:\n    def bestTeamScore(self, scores: List[int], ages: List[int]) -> int:\n        m = max(ages)\n        tree = BinaryIndexedTree(m)\n        for score, age in sorted(zip(scores, ages)):\n            tree.update(age, score + tree.query(age))\n        return tree.query(m)\n",
    "model_generation": "### Efficient Solution\n\nWe can use dynamic programming to solve this problem efficiently. The idea is to sort both the scores and ages lists first, and then iterate over them. For each player, we consider including them in the team or not, and update the maximum team score accordingly.\n\n```python\nclass Solution:\n    def bestTeamScore(self, scores, ages):\n        # Combine scores and ages into a list of tuples\n        players = sorted(zip(ages, scores))\n        \n        # Initialize a list to store the maximum score for each player\n        max_scores = [0] * len(players)\n        \n        # Initialize the maximum overall score\n        max_overall_score = 0\n        \n        # Iterate over the players\n        for i in range(len(players)):\n            # Initialize the maximum score for the current player\n            max_scores[i] = players[i][1]\n            \n            # Iterate over the previous players\n            for j in range(i):\n                # If the current player has a higher age or the same age but a higher score\n                if players[i][0] >= players[j][0] or players[i][0] == players[j][0] and players[i][1] >= players[j][1]:\n                    # Update the maximum score for the current player\n                    max_scores[i] = max(max_scores[i], max_scores[j] + players[i][1])\n            \n            # Update the maximum overall score\n            max_overall_score = max(max_overall_score, max_scores[i])\n        \n        # Return the maximum overall score\n        return max_overall_score\n```\n\n### Explanation\n\n1. First, we combine the scores and ages lists into a list of tuples, sorted by age.\n2. We initialize a list `max_scores` to store the maximum score for each player.\n3. We iterate over the players, and for each player, we consider including them in the team or not by iterating over the previous players.\n4. If the current player has a higher age or the same age but a higher score than a previous player, we update the maximum score for the current player by adding the score of the previous player to the maximum score of the previous player.\n5. We update the maximum overall score by taking the maximum of the current maximum overall score and the maximum score for the current player.\n6. Finally, we return the maximum overall score.\n\n### Time Complexity\n\nThe time complexity of this solution is O(n^2), where n is the number of players, since we iterate over the players and for each player, we iterate over the previous players.\n\n### Space Complexity\n\nThe space complexity of this solution is O(n), since we store the maximum score for each player in the `max_scores` list.",
    "model_solution": "class Solution:\n    def bestTeamScore(self, scores, ages):\n        # Combine scores and ages into a list of tuples\n        players = sorted(zip(ages, scores))\n        \n        # Initialize a list to store the maximum score for each player\n        max_scores = [0] * len(players)\n        \n        # Initialize the maximum overall score\n        max_overall_score = 0\n        \n        # Iterate over the players\n        for i in range(len(players)):\n            # Initialize the maximum score for the current player\n            max_scores[i] = players[i][1]\n            \n            # Iterate over the previous players\n            for j in range(i):\n                # If the current player has a higher age or the same age but a higher score\n                if players[i][0] >= players[j][0] or players[i][0] == players[j][0] and players[i][1] >= players[j][1]:\n                    # Update the maximum score for the current player\n                    max_scores[i] = max(max_scores[i], max_scores[j] + players[i][1])\n            \n            # Update the maximum overall score\n            max_overall_score = max(max_overall_score, max_scores[i])\n        \n        # Return the maximum overall score\n        return max_overall_score",
    "is_python": true
}