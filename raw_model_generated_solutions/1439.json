{
    "problem_idx": "1439",
    "description": "\nYou are given an `m x n` matrix `mat` that has its rows sorted in non-decreasing order and an integer `k`.\n\n\nYou are allowed to choose **exactly one element** from each row to form an array.\n\n\nReturn *the* `kth` *smallest array sum among all possible arrays*.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** mat = [[1,3,11],[2,4,6]], k = 5\n**Output:** 7\n**Explanation:** Choosing one element from each row, the first k smallest sum are:\n[1,2], [1,4], [3,2], [3,4], [1,6]. Where the 5th sum is 7.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** mat = [[1,3,11],[2,4,6]], k = 9\n**Output:** 17\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** mat = [[1,10,10],[1,4,5],[2,3,6]], k = 7\n**Output:** 9\n**Explanation:** Choosing one element from each row, the first k smallest sum are:\n[1,1,2], [1,1,3], [1,4,2], [1,4,3], [1,1,6], [1,5,2], [1,5,3]. Where the 7th sum is 9.  \n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `m == mat.length`\n* `n == mat.length[i]`\n* `1 <= m, n <= 40`\n* `1 <= mat[i][j] <= 5000`\n* `1 <= k <= min(200, nm)`\n* `mat[i]` is a non-decreasing array.\n\n\n",
    "inefficient_solution": "class Solution:\n    def kthSmallest(self, mat: List[List[int]], k: int) -> int:\n        n = len(mat)\n        arr = [list(map(tuple, zip(*row))) for row in mat]\n        pre = [[(0, 0) for _ in range(n)] for _ in range(n)]\n        pre[0][0] = (mat[0][0], 0)\n        for i in range(n):\n            for j in range(n):\n                pre[i][j] = sorted((a + b, i, j) for i, a in enumerate(pre[i]) for j, b in enumerate(arr[i][j]) if a + b <= 5000)[:k]\n        return pre[-1][-1][0]",
    "efficient_solution": "class Solution:\n    def kthSmallest(self, mat: List[List[int]], k: int) -> int:\n        pre = [0]\n        for cur in mat:\n            pre = sorted(a + b for a in pre for b in cur[:k])[:k]\n        return pre[-1]\n",
    "model_generation": "### Efficient Solution\n\nWe can use a priority queue to solve this problem efficiently. This approach takes advantage of the fact that the rows of the matrix are sorted in non-decreasing order.\n\n```python\nimport heapq\nfrom typing import List\n\nclass Solution:\n    def kthSmallest(self, mat: List[List[int]], k: int) -> int:\n        n = len(mat[0])\n        pq = [(0, 0) * n]\n        heapq.heapify(pq)\n        vis = set((0,) * n)\n        \n        while pq:\n            s, idx = heapq.heappop(pq)\n            if idx == n - 1:\n                return s\n            for i in range(n):\n                if idx + i + 1 not in vis:\n                    vis.add(idx + i + 1)\n                    heapq.heappush(pq, (s + mat[i][idx + i + 1], idx + i + 1))\n            vis.remove(idx)\n```\n\n### Explanation\n\n*   We initialize a priority queue `pq` with the first element of each row.\n*   We use a set `vis` to keep track of the indices we've visited.\n*   In each step of the algorithm, we pop the smallest element from the priority queue `pq`.\n*   If we've reached the last column, it means we've found the `k`-th smallest array sum, so we return it.\n*   Otherwise, we add the next element from the same row to the priority queue if we haven't visited that row yet.\n*   Finally, we remove the current index from the `vis` set, so we can visit it again in the next step.\n\nThis solution has a time complexity of O(k \\* n), which is much more efficient than the original solution for large inputs.",
    "model_solution": "import heapq\nfrom typing import List\n\nclass Solution:\n    def kthSmallest(self, mat: List[List[int]], k: int) -> int:\n        n = len(mat[0])\n        pq = [(0, 0) * n]\n        heapq.heapify(pq)\n        vis = set((0,) * n)\n        \n        while pq:\n            s, idx = heapq.heappop(pq)\n            if idx == n - 1:\n                return s\n            for i in range(n):\n                if idx + i + 1 not in vis:\n                    vis.add(idx + i + 1)\n                    heapq.heappush(pq, (s + mat[i][idx + i + 1], idx + i + 1))\n            vis.remove(idx)",
    "is_python": true
}