{
    "problem_idx": "907",
    "description": "\nGiven an array of integers arr, find the sum of `min(b)`, where `b` ranges over every (contiguous) subarray of `arr`. Since the answer may be large, return the answer **modulo** `109 + 7`.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** arr = [3,1,2,4]\n**Output:** 17\n**Explanation:** \nSubarrays are [3], [1], [2], [4], [3,1], [1,2], [2,4], [3,1,2], [1,2,4], [3,1,2,4]. \nMinimums are 3, 1, 2, 4, 1, 1, 2, 1, 1, 1.\nSum is 17.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** arr = [11,81,94,43,3]\n**Output:** 444\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= arr.length <= 3 * 104`\n* `1 <= arr[i] <= 3 * 104`\n\n\n",
    "inefficient_solution": "class Solution:\n    def sumSubarrayMins(self, arr: List[int]) -> int:\n        n = len(arr)\n        left = [0] * (n * n)\n        right = [0] * (n * n)\n        stack = []\n        for i, v in enumerate(arr):\n            temp = []\n            while stack and arr[stack[-1]] >= v:\n                temp.append(stack.pop())\n            for j in temp:\n                left[i * n + j] = 1\n            left[i * n + i] = -1\n            stack.append(i * n + i)\n\n        stack = []\n        for i in range(n * n - 1, -1, -1):\n            temp = []\n            while stack and arr[stack[-1] // n] > arr[i // n]:\n                temp.append(stack.pop())\n            for j in temp:\n                right[j] = 1\n            right[i] = 0\n            stack.append(i)\n\n        mod = 10**9 + 7\n        total = 0\n        for i, v in enumerate(arr):\n            for j in range(n):\n                total += (i * n + j - 1) * (right[i * n + j]) * (left[i * n + j]) * (v % mod)\n                total %= mod\n        return total",
    "efficient_solution": "class Solution:\n    def sumSubarrayMins(self, arr: List[int]) -> int:\n        n = len(arr)\n        left = [-1] * n\n        right = [n] * n\n        stk = []\n        for i, v in enumerate(arr):\n            while stk and arr[stk[-1]] >= v:\n                stk.pop()\n            if stk:\n                left[i] = stk[-1]\n            stk.append(i)\n\n        stk = []\n        for i in range(n - 1, -1, -1):\n            while stk and arr[stk[-1]] > arr[i]:\n                stk.pop()\n            if stk:\n                right[i] = stk[-1]\n            stk.append(i)\n        mod = 10**9 + 7\n        return sum((i - left[i]) * (right[i] - i) * v for i, v in enumerate(arr)) % mod\n",
    "model_generation": "Here's an efficient solution for the problem. This solution uses a stack to keep track of the indices of the elements in the array, and it only iterates over the array once to calculate the sum of `min(b)`, where `b` ranges over every contiguous subarray of `arr`.\n\n```python\nclass Solution:\n    def sumSubarrayMins(self, arr: List[int]) -> int:\n        n = len(arr)\n        mod = 10**9 + 7\n        total = 0\n        stack = []\n        \n        for i in range(n):\n            while stack and arr[stack[-1]] >= arr[i]:\n                # When the current element is smaller than the top of the stack, \n                # it means that all the elements on the stack are out of the subarrays that contain the current element\n                # So we calculate the sum of `min(b)` for these subarrays\n                top = stack.pop()\n                left = 0 if not stack else stack[-1] + 1\n                right = i - 1\n                total += (left + top) * (top - right) * arr[top] % mod\n                total %= mod\n            stack.append(i)\n        \n        # For the elements that are still on the stack, \n        # they are out of the subarrays that contain the last element\n        # So we calculate the sum of `min(b)` for these subarrays\n        while stack:\n            top = stack.pop()\n            left = 0 if not stack else stack[-1] + 1\n            right = n - 1\n            total += (left + top) * (top - right) * arr[top] % mod\n            total %= mod\n        \n        return total\n```\n\nThis solution works as follows:\n- We use a stack to keep track of the indices of the elements in the array.\n- We iterate over the array once, and for each element, we pop the elements from the stack that are out of the subarrays that contain the current element, and calculate the sum of `min(b)` for these subarrays.\n- After the iteration, we pop the remaining elements from the stack, and calculate the sum of `min(b)` for these subarrays.\n- We return the total sum modulo `10^9 + 7`.",
    "model_solution": "class Solution:\n    def sumSubarrayMins(self, arr: List[int]) -> int:\n        n = len(arr)\n        mod = 10**9 + 7\n        total = 0\n        stack = []\n        \n        for i in range(n):\n            while stack and arr[stack[-1]] >= arr[i]:\n                # When the current element is smaller than the top of the stack, \n                # it means that all the elements on the stack are out of the subarrays that contain the current element\n                # So we calculate the sum of `min(b)` for these subarrays\n                top = stack.pop()\n                left = 0 if not stack else stack[-1] + 1\n                right = i - 1\n                total += (left + top) * (top - right) * arr[top] % mod\n                total %= mod\n            stack.append(i)\n        \n        # For the elements that are still on the stack, \n        # they are out of the subarrays that contain the last element\n        # So we calculate the sum of `min(b)` for these subarrays\n        while stack:\n            top = stack.pop()\n            left = 0 if not stack else stack[-1] + 1\n            right = n - 1\n            total += (left + top) * (top - right) * arr[top] % mod\n            total %= mod\n        \n        return total",
    "is_python": true
}