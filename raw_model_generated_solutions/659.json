{
    "problem_idx": "659",
    "description": "\nYou are given an integer array `nums` that is **sorted in non-decreasing order**.\n\n\nDetermine if it is possible to split `nums` into **one or more subsequences** such that **both** of the following conditions are true:\n\n\n* Each subsequence is a **consecutive increasing sequence** (i.e. each integer is **exactly one** more than the previous integer).\n* All subsequences have a length of `3` **or more**.\n\n\nReturn `true` *if you can split* `nums` *according to the above conditions, or* `false` *otherwise*.\n\n\nA **subsequence** of an array is a new array that is formed from the original array by deleting some (can be none) of the elements without disturbing the relative positions of the remaining elements. (i.e., `[1,3,5]` is a subsequence of `[1,2,3,4,5]` while `[1,3,2]` is not).\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** nums = [1,2,3,3,4,5]\n**Output:** true\n**Explanation:** nums can be split into the following subsequences:\n[**1**,**2**,**3**,3,4,5] --> 1, 2, 3\n[1,2,3,**3**,**4**,**5**] --> 3, 4, 5\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** nums = [1,2,3,3,4,4,5,5]\n**Output:** true\n**Explanation:** nums can be split into the following subsequences:\n[**1**,**2**,**3**,3,**4**,4,**5**,5] --> 1, 2, 3, 4, 5\n[1,2,3,**3**,4,**4**,5,**5**] --> 3, 4, 5\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** nums = [1,2,3,4,4,5]\n**Output:** false\n**Explanation:** It is impossible to split nums into consecutive increasing subsequences of length 3 or more.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= nums.length <= 104`\n* `-1000 <= nums[i] <= 1000`\n* `nums` is sorted in **non-decreasing** order.\n\n\n",
    "inefficient_solution": "class Solution:\n    def isPossible(self, nums: List[int]) -> bool:\n        d = defaultdict(list)\n        for v in nums:\n            tmp = []\n            for h in d[v - 1][:]:\n                if h > 2:\n                    heappush(tmp, h + 1)\n                else:\n                    break\n            for h in tmp:\n                heappush(d[v], h)\n            if not d[v - 1]:\n                heappush(d[v], 1)\n            else:\n                heappush(d[v], heappop(d[v - 1]) + 1)\n            if d[v - 1]:\n                heappush(d[v], heappop(d[v - 1]) + 1)\n            else:\n                heappush(d[v], 1)\n        return all(not v or v and v[0] > 2 for v in d.values())",
    "efficient_solution": "class Solution:\n    def isPossible(self, nums: List[int]) -> bool:\n        d = defaultdict(list)\n        for v in nums:\n            if h := d[v - 1]:\n                heappush(d[v], heappop(h) + 1)\n            else:\n                heappush(d[v], 1)\n        return all(not v or v and v[0] > 2 for v in d.values())\n",
    "model_generation": "### Efficient Solution:\n\n```python\nimport heapq\n\nclass Solution:\n    def isPossible(self, nums: List[int]) -> bool:\n        d = {}\n        \n        for v in nums:\n            if v - 1 not in d:\n                heapq.heappush(d.get(v, []), 1)\n            else:\n                length = heapq.heappop(d[v - 1])\n                if length > 2:\n                    heapq.heappush(d.get(v, []), length + 1)\n                else:\n                    heapq.heappush(d.get(v, []), 1)\n        \n        return all(not v or v and v[0] > 2 for v in d.values())\n```\n\n### Explanation:\n\nThis solution is more efficient than the previous one as it uses a dictionary to store the lengths of subsequences ending at each number, instead of using a defaultdict of heaps. This reduces the time complexity of the solution from O(n log n) to O(n).\n\nHere's how it works:\n\n1. We iterate over the input array `nums`.\n2. For each number `v`, we check if `v - 1` is in the dictionary `d`. If it's not, we initialize a new list with a single element `1` in `d[v]`.\n3. If `v - 1` is in `d`, we pop the smallest length from `d[v - 1]` and check if it's greater than 2. If it is, we push the length + 1 into `d[v]`. Otherwise, we push 1 into `d[v]`.\n4. After iterating over all numbers, we check if all lengths in the dictionary are greater than 2. If they are, we return True. Otherwise, we return False.\n\nThis solution has a time complexity of O(n) and a space complexity of O(n), where n is the length of the input array `nums`.",
    "model_solution": "import heapq\n\nclass Solution:\n    def isPossible(self, nums: List[int]) -> bool:\n        d = {}\n        \n        for v in nums:\n            if v - 1 not in d:\n                heapq.heappush(d.get(v, []), 1)\n            else:\n                length = heapq.heappop(d[v - 1])\n                if length > 2:\n                    heapq.heappush(d.get(v, []), length + 1)\n                else:\n                    heapq.heappush(d.get(v, []), 1)\n        \n        return all(not v or v and v[0] > 2 for v in d.values())",
    "is_python": true
}