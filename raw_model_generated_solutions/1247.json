{
    "problem_idx": "1247",
    "description": "\nYou are given two strings `s1` and `s2` of equal length consisting of letters `\"x\"` and `\"y\"` **only**. Your task is to make these two strings equal to each other. You can swap any two characters that belong to **different** strings, which means: swap `s1[i]` and `s2[j]`.\n\n\nReturn the minimum number of swaps required to make `s1` and `s2` equal, or return `-1` if it is impossible to do so.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** s1 = \"xx\", s2 = \"yy\"\n**Output:** 1\n**Explanation:** Swap s1[0] and s2[1], s1 = \"yx\", s2 = \"yx\".\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** s1 = \"xy\", s2 = \"yx\"\n**Output:** 2\n**Explanation:** Swap s1[0] and s2[0], s1 = \"yy\", s2 = \"xx\".\nSwap s1[0] and s2[1], s1 = \"xy\", s2 = \"xy\".\nNote that you cannot swap s1[0] and s1[1] to make s1 equal to \"yx\", cause we can only swap chars in different strings.\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** s1 = \"xx\", s2 = \"xy\"\n**Output:** -1\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= s1.length, s2.length <= 1000`\n* `s1.length == s2.length`\n* `s1, s2` only contain `'x'` or `'y'`.\n\n\n",
    "inefficient_solution": "class Solution:\n    def minimumSwap(self, s1: str, s2: str) -> int:\n        char_counts = {}\n        for char in s1 + s2:\n            if char not in char_counts:\n                char_counts[char] = 0\n            char_counts[char] += 1\n\n        if char_counts['x'] != char_counts['y']:\n            return -1\n\n        swap_pairs = {}\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                swap_pairs[(s1[i], s2[i])] = swap_pairs.get((s1[i], s2[i]), 0) + 1\n\n        if len(swap_pairs) == 0:\n            return 0\n\n        max_swaps = 0\n        for pair, count in swap_pairs.items():\n            max_swaps = max(max_swaps, count)\n\n        swaps_required = max_swaps\n        for pair, count in swap_pairs.items():\n            swaps_required += (count - 1) // 2\n\n        return swaps_required",
    "efficient_solution": "class Solution:\n    def minimumSwap(self, s1: str, s2: str) -> int:\n        xy = yx = 0\n        for a, b in zip(s1, s2):\n            xy += a < b\n            yx += a > b\n        if (xy + yx) % 2:\n            return -1\n        return xy // 2 + yx // 2 + xy % 2 + yx % 2\n",
    "model_generation": "### Efficient Solution\n\n```python\nclass Solution:\n    def minimumSwap(self, s1: str, s2: str) -> int:\n        def is_possible(swaps: int) -> bool:\n            x_count = 0\n            y_count = 0\n            x_to_swap = 0\n            y_to_swap = 0\n            for i in range(len(s1)):\n                if s1[i] != s2[i]:\n                    if s1[i] == 'x':\n                        x_to_swap += 1\n                    else:\n                        y_to_swap += 1\n                if s1[i] == 'x':\n                    x_count += 1\n                else:\n                    y_count += 1\n            x_diff = x_count - x_to_swap\n            y_diff = y_count - y_to_swap\n            return x_diff % 2 == 0 and y_diff % 2 == 0 and swaps >= max(x_diff // 2, y_diff // 2)\n\n        left, right = 0, len(s1) - 1\n        while left < right and s1[left] != s2[left]:\n            left += 1\n        while left < right and s1[right] != s2[right]:\n            right -= 1\n        if left >= right:\n            return -1\n        return left + (right - left + 1) // 2 - (right - left + 1) % 2\n```\n\n### Explanation\n\nThe efficient solution works by first finding the smallest range `[left, right]` where `s1[i] != s2[i]` for all `i in [left, right]`. This range represents the minimum swaps required to make `s1` and `s2` equal in this part. If the length of the range is even, we can make the strings equal in this part by swapping `s1[left]` and `s2[left]` for all `i in [left, right]`. If the length of the range is odd, we need to swap `s1[left]` and `s2[left]` only for `left`, and swap `s1[left + 1]` and `s2[left + 1]` for all `i in [left + 1, right]`. We return the number of swaps required to make the strings equal in the entire string.\n\nThis solution has a time complexity of O(n), where n is the length of the string, because we are making a single pass through the string to find the range `[left, right]`. The space complexity is O(1), which means the space required does not change with the size of the input string.",
    "model_solution": "class Solution:\n    def minimumSwap(self, s1: str, s2: str) -> int:\n        def is_possible(swaps: int) -> bool:\n            x_count = 0\n            y_count = 0\n            x_to_swap = 0\n            y_to_swap = 0\n            for i in range(len(s1)):\n                if s1[i] != s2[i]:\n                    if s1[i] == 'x':\n                        x_to_swap += 1\n                    else:\n                        y_to_swap += 1\n                if s1[i] == 'x':\n                    x_count += 1\n                else:\n                    y_count += 1\n            x_diff = x_count - x_to_swap\n            y_diff = y_count - y_to_swap\n            return x_diff % 2 == 0 and y_diff % 2 == 0 and swaps >= max(x_diff // 2, y_diff // 2)\n\n        left, right = 0, len(s1) - 1\n        while left < right and s1[left] != s2[left]:\n            left += 1\n        while left < right and s1[right] != s2[right]:\n            right -= 1\n        if left >= right:\n            return -1\n        return left + (right - left + 1) // 2 - (right - left + 1) % 2",
    "is_python": true
}