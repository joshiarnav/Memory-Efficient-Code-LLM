{
    "problem_idx": "126",
    "description": "\nA **transformation sequence** from word `beginWord` to word `endWord` using a dictionary `wordList` is a sequence of words `beginWord -> s1 -> s2 -> ... -> sk` such that:\n\n\n* Every adjacent pair of words differs by a single letter.\n* Every `si` for `1 <= i <= k` is in `wordList`. Note that `beginWord` does not need to be in `wordList`.\n* `sk == endWord`\n\n\nGiven two words, `beginWord` and `endWord`, and a dictionary `wordList`, return *all the **shortest transformation sequences** from* `beginWord` *to* `endWord`*, or an empty list if no such sequence exists. Each sequence should be returned as a list of the words* `[beginWord, s1, s2, ..., sk]`.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\n**Output:** [[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]\n**Explanation:**\u00a0There are 2 shortest transformation sequences:\n\"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\"\n\"hit\" -> \"hot\" -> \"lot\" -> \"log\" -> \"cog\"\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\n**Output:** []\n**Explanation:** The endWord \"cog\" is not in wordList, therefore there is no valid transformation sequence.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= beginWord.length <= 5`\n* `endWord.length == beginWord.length`\n* `1 <= wordList.length <= 500`\n* `wordList[i].length == beginWord.length`\n* `beginWord`, `endWord`, and `wordList[i]` consist of lowercase English letters.\n* `beginWord != endWord`\n* All the words in `wordList` are **unique**.\n* The **sum** of all shortest transformation sequences does not exceed `105`.\n\n\n",
    "inefficient_solution": "class Solution:\n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\n        def dfs(cur, path):\n            if cur == beginWord:\n                ans.append(path[::-1])\n                return\n            for precursor in prev[cur]:\n                path.append(precursor)\n                dfs(precursor, path)\n                path.pop()\n            for i in range(len(path)):\n                for j in range(i+1, len(path)):\n                    path[i], path[j] = path[j], path[i]\n                    dfs(cur, path)\n                    path[i], path[j] = path[j], path[i]\n\n        ans = []\n        words = set(wordList)\n        if endWord not in words:\n            return ans\n        words.discard(beginWord)\n        dist = {beginWord: 0}\n        prev = defaultdict(set)\n        q = deque([beginWord])\n        found = False\n        step = 0\n        while q and not found:\n            step += 1\n            for _ in range(len(q)):\n                p = q.popleft()\n                s = list(p)\n                for i in range(len(s)):\n                    for j in range(26):\n                        s[i] = chr(ord('a') + j)\n                        t = ''.join(s)\n                        if dist.get(t, 0) == step:\n                            prev[t].add(p)\n                        if t not in words:\n                            continue\n                        prev[t].add(p)\n                        words.discard(t)\n                        q.append(t)\n                        dist[t] = step\n                        if endWord == t:\n                            found = True\n                    s[i] = p[i]\n            if q:\n                q.append(beginWord)\n        if found:\n            path = [endWord]\n            dfs(endWord, path)\n        return ans",
    "efficient_solution": "class Solution:\n    def findLadders(\n        self, beginWord: str, endWord: str, wordList: List[str]\n    ) -> List[List[str]]:\n        def dfs(path, cur):\n            if cur == beginWord:\n                ans.append(path[::-1])\n                return\n            for precursor in prev[cur]:\n                path.append(precursor)\n                dfs(path, precursor)\n                path.pop()\n\n        ans = []\n        words = set(wordList)\n        if endWord not in words:\n            return ans\n        words.discard(beginWord)\n        dist = {beginWord: 0}\n        prev = defaultdict(set)\n        q = deque([beginWord])\n        found = False\n        step = 0\n        while q and not found:\n            step += 1\n            for i in range(len(q), 0, -1):\n                p = q.popleft()\n                s = list(p)\n                for i in range(len(s)):\n                    ch = s[i]\n                    for j in range(26):\n                        s[i] = chr(ord('a') + j)\n                        t = ''.join(s)\n                        if dist.get(t, 0) == step:\n                            prev[t].add(p)\n                        if t not in words:\n                            continue\n                        prev[t].add(p)\n                        words.discard(t)\n                        q.append(t)\n                        dist[t] = step\n                        if endWord == t:\n                            found = True\n                    s[i] = ch\n        if found:\n            path = [endWord]\n            dfs(path, endWord)\n        return ans\n",
    "model_generation": "### Efficient Solution:\n\nWe can solve this problem using BFS (Breadth-First Search) to find the shortest paths from `beginWord` to `endWord`, and then use DFS (Depth-First Search) to find the transformation sequences.\n\n```python\nfrom collections import deque\nfrom typing import List\n\nclass Solution:\n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\n        wordSet = set(wordList)\n        if endWord not in wordSet:\n            return []\n        wordSet.discard(beginWord)\n        \n        # Build a graph using BFS\n        graph = {}\n        queue = deque([beginWord])\n        level = {beginWord: 0}\n        while queue:\n            word = queue.popleft()\n            level[word] += 1\n            for i inrupa(word):\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    next_word = word[:i] + c + word[i+1:]\n                    if next_word in wordSet:\n                        if next_word not in graph:\n                            graph[next_word] = []\n                        graph[next_word].append(word)\n                        wordSet.discard(next_word)\n                        queue.append(next_word)\n        \n        # If there's no path from beginWord to endWord\n        if endWord not in graph:\n            return []\n        \n        # Build the result using DFS\n        result = []\n        self.dfs(graph, endWord, [endWord], result)\n        return result\n\n    def dfs(self, graph, cur, path, result):\n        if cur == self.beginWord:\n            result.append(path[:])\n            return\n        for neighbor in graph[cur]:\n            path.append(neighbor)\n            self.dfs(graph, neighbor, path, result)\n            path.pop()\n\n    def inrupa(self, word):\n        return range(len(word))\n```\n\n### Explanation:\n\n1.  We use a set to store the words in `wordList` for efficient lookups.\n2.  We use a graph to store the neighbors of each word. We build the graph using BFS, where each node represents a word and each edge represents a single-character difference between two words.\n3.  We use DFS to find the transformation sequences from `endWord` to `beginWord`. We start from `endWord` and recursively explore its neighbors until we reach `beginWord`.\n4.  If there's no path from `beginWord` to `endWord`, we return an empty list.\n\n### Time Complexity:\n\nThe time complexity of this solution is O(N \\* 26^L), where N is the number of words in `wordList` and L is the length of each word. This is because we need to explore all possible single-character differences for each word.\n\n### Space Complexity:\n\nThe space complexity of this solution is O(N \\* 26^L), where N is the number of words in `wordList` and L is the length of each word. This is because we need to store the graph and the result.",
    "model_solution": "from collections import deque\nfrom typing import List\n\nclass Solution:\n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\n        wordSet = set(wordList)\n        if endWord not in wordSet:\n            return []\n        wordSet.discard(beginWord)\n        \n        # Build a graph using BFS\n        graph = {}\n        queue = deque([beginWord])\n        level = {beginWord: 0}\n        while queue:\n            word = queue.popleft()\n            level[word] += 1\n            for i inrupa(word):\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    next_word = word[:i] + c + word[i+1:]\n                    if next_word in wordSet:\n                        if next_word not in graph:\n                            graph[next_word] = []\n                        graph[next_word].append(word)\n                        wordSet.discard(next_word)\n                        queue.append(next_word)\n        \n        # If there's no path from beginWord to endWord\n        if endWord not in graph:\n            return []\n        \n        # Build the result using DFS\n        result = []\n        self.dfs(graph, endWord, [endWord], result)\n        return result\n\n    def dfs(self, graph, cur, path, result):\n        if cur == self.beginWord:\n            result.append(path[:])\n            return\n        for neighbor in graph[cur]:\n            path.append(neighbor)\n            self.dfs(graph, neighbor, path, result)\n            path.pop()\n\n    def inrupa(self, word):\n        return range(len(word))",
    "is_python": true
}