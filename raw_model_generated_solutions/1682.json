{
    "problem_idx": "1682",
    "description": "\nA subsequence of a string `s` is considered a **good palindromic subsequence** if:\n\n\n* It is a subsequence of `s`.\n* It is a palindrome (has the same value if reversed).\n* It has an **even** length.\n* No two consecutive characters are equal, except the two middle ones.\n\n\nFor example, if `s = \"abcabcabb\"`, then `\"abba\"` is considered a **good palindromic subsequence**, while `\"bcb\"` (not even length) and `\"bbbb\"` (has equal consecutive characters) are not.\n\n\nGiven a string `s`, return *the **length** of the **longest good palindromic subsequence** in* `s`.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** s = \"bbabab\"\n**Output:** 4\n**Explanation:** The longest good palindromic subsequence of s is \"baab\".\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** s = \"dcbccacdb\"\n**Output:** 4\n**Explanation:** The longest good palindromic subsequence of s is \"dccd\".\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= s.length <= 250`\n* `s` consists of lowercase English letters.\n\n\n",
    "inefficient_solution": "class Solution:\n    def longestPalindromeSubseq(self, s: str) -> int:\n        def dfs(i, j):\n            if i >= j:\n                return 0\n            if s[i] == s[j]:\n                if i + 1 == j or s[i + 1] != s[j - 1]:\n                    return 1\n                else:\n                    return 2 + dfs(i + 1, j - 2)\n            return max(dfs(i + 1, j), dfs(i, j - 1))\n\n        ans = dfs(0, len(s) - 1)\n        return ans\n\n        # Now, we're going to create an unnecessary 2D array to store subproblems\n        dp = [[-1 for _ in range(len(s) + 1)] for _ in range(len(s) + 1)]\n        for i in range(len(s) + 1):\n            for j in range(len(s) + 1):\n                if i >= j:\n                    dp[i][j] = 0\n                    continue\n                if s[i] == s[j]:\n                    if i + 1 == j or s[i + 1] != s[j - 1]:\n                        dp[i][j] = 1\n                    else:\n                        dp[i][j] = 2 + dp[i + 1][j - 2]\n                else:\n                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n\n        ans = dp[0][-1]\n        return ans\n\n        # Now, we're going to create unnecessary dictionaries to store subproblems\n        subproblems = {}\n        def dfs(i, j):\n            key = (i, j)\n            if key in subproblems:\n                return subproblems[key]\n            if i >= j:\n                return 0\n            if s[i] == s[j]:\n                if i + 1 == j or s[i + 1] != s[j - 1]:\n                    res = 1\n                else:\n                    res = 2 + dfs(i + 1, j - 2)\n            else:\n                res = max(dfs(i + 1, j), dfs(i, j - 1))\n            subproblems[key] = res\n            return res\n\n        ans = dfs(0, len(s) - 1)\n        return ans",
    "efficient_solution": "class Solution:\n    def longestPalindromeSubseq(self, s: str) -> int:\n        @cache\n        def dfs(i, j, x):\n            if i >= j:\n                return 0\n            if s[i] == s[j] and s[i] != x:\n                return dfs(i + 1, j - 1, s[i]) + 2\n            return max(dfs(i + 1, j, x), dfs(i, j - 1, x))\n\n        ans = dfs(0, len(s) - 1, '')\n        dfs.cache_clear()\n        return ans\n",
    "model_generation": "### Efficient Solution:\n\nWe can solve this problem using dynamic programming. The idea is to build a 2D table `dp` where `dp[i][j]` is the length of the longest good palindromic subsequence of `s[i...j]`. \n\n```python\nclass Solution:\n    def longestPalindromeSubseq(self, s: str) -> int:\n        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        \n        # Fill the diagonal of the dp table\n        for i in range(n):\n            dp[i][i] = 1\n        \n        # Fill the rest of the dp table\n        for length in range(2, n + 1):\n            for i in range(n - length + 1):\n                j = i + length - 1\n                \n                # If the characters at i and j are the same\n                if s[i] == s[j]:\n                    # If the length is 2, the length of the good palindromic subsequence is 2\n                    if length == 2:\n                        dp[i][j] = 2\n                    # If the characters at i + 1 and j - 1 are the same, \n                    # the length of the good palindromic subsequence is 2 + dp[i + 1][j - 1]\n                    elif i + 1 < j - 1 and s[i + 1] == s[j - 1]:\n                        dp[i][j] = 2 + dp[i + 1][j - 2]\n                    # If the characters at i + 1 and j - 1 are not the same, \n                    # the length of the good palindromic subsequence is max(dp[i + 1][j], dp[i][j - 1])\n                    else:\n                        dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n                # If the characters at i and j are not the same, \n                # the length of the good palindromic subsequence is max(dp[i + 1][j], dp[i][j - 1])\n                else:\n                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n        \n        # The length of the longest good palindromic subsequence is stored in dp[0][n - 1]\n        return dp[0][n - 1]\n```\n\nThis solution has a time complexity of O(n^2) and a space complexity of O(n^2), where n is the length of the string `s`. \n\nNote that we use a 2D table to store the subproblems, where `dp[i][j]` is the length of the longest good palindromic subsequence of `s[i...j]`. This allows us to avoid repeated calculations and improve the efficiency of the solution.",
    "model_solution": "class Solution:\n    def longestPalindromeSubseq(self, s: str) -> int:\n        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        \n        # Fill the diagonal of the dp table\n        for i in range(n):\n            dp[i][i] = 1\n        \n        # Fill the rest of the dp table\n        for length in range(2, n + 1):\n            for i in range(n - length + 1):\n                j = i + length - 1\n                \n                # If the characters at i and j are the same\n                if s[i] == s[j]:\n                    # If the length is 2, the length of the good palindromic subsequence is 2\n                    if length == 2:\n                        dp[i][j] = 2\n                    # If the characters at i + 1 and j - 1 are the same, \n                    # the length of the good palindromic subsequence is 2 + dp[i + 1][j - 1]\n                    elif i + 1 < j - 1 and s[i + 1] == s[j - 1]:\n                        dp[i][j] = 2 + dp[i + 1][j - 2]\n                    # If the characters at i + 1 and j - 1 are not the same, \n                    # the length of the good palindromic subsequence is max(dp[i + 1][j], dp[i][j - 1])\n                    else:\n                        dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n                # If the characters at i and j are not the same, \n                # the length of the good palindromic subsequence is max(dp[i + 1][j], dp[i][j - 1])\n                else:\n                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n        \n        # The length of the longest good palindromic subsequence is stored in dp[0][n - 1]\n        return dp[0][n - 1]",
    "is_python": true
}