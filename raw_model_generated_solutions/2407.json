{
    "problem_idx": "2407",
    "description": "\nYou are given an integer array `nums` and an integer `k`.\n\n\nFind the longest subsequence of `nums` that meets the following requirements:\n\n\n* The subsequence is **strictly increasing** and\n* The difference between adjacent elements in the subsequence is **at most** `k`.\n\n\nReturn *the length of the **longest** **subsequence** that meets the requirements.*\n\n\nA **subsequence** is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** nums = [4,2,1,4,3,4,5,8,15], k = 3\n**Output:** 5\n**Explanation:**\nThe longest subsequence that meets the requirements is [1,3,4,5,8].\nThe subsequence has a length of 5, so we return 5.\nNote that the subsequence [1,3,4,5,8,15] does not meet the requirements because 15 - 8 = 7 is larger than 3.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** nums = [7,4,5,1,8,12,4,7], k = 5\n**Output:** 4\n**Explanation:**\nThe longest subsequence that meets the requirements is [4,5,8,12].\nThe subsequence has a length of 4, so we return 4.\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** nums = [1,5], k = 1\n**Output:** 1\n**Explanation:**\nThe longest subsequence that meets the requirements is [1].\nThe subsequence has a length of 1, so we return 1.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= nums.length <= 105`\n* `1 <= nums[i], k <= 105`\n\n\n",
    "inefficient_solution": "class Solution:\n    def lengthOfLIS(self, nums, k):\n        table = {}\n        for i, v in enumerate(nums):\n            j = v - k\n            while j in table and table[j] < i:\n                j = table[j] + 1\n            table[v] = i\n            ans = 0\n            for u in table:\n                if u >= j:\n                    ans = max(ans, i - table[u])\n            ans = max(ans, 1)\n            table[v] = i - ans + 1\n        return max(table.values())",
    "efficient_solution": "class Node:\n    def __init__(self):\n        self.l = 0\n        self.r = 0\n        self.v = 0\n\n\nclass SegmentTree:\n    def __init__(self, n):\n        self.tr = [Node() for _ in range(4 * n)]\n        self.build(1, 1, n)\n\n    def build(self, u, l, r):\n        self.tr[u].l = l\n        self.tr[u].r = r\n        if l == r:\n            return\n        mid = (l + r) >> 1\n        self.build(u << 1, l, mid)\n        self.build(u << 1 | 1, mid + 1, r)\n\n    def modify(self, u, x, v):\n        if self.tr[u].l == x and self.tr[u].r == x:\n            self.tr[u].v = v\n            return\n        mid = (self.tr[u].l + self.tr[u].r) >> 1\n        if x <= mid:\n            self.modify(u << 1, x, v)\n        else:\n            self.modify(u << 1 | 1, x, v)\n        self.pushup(u)\n\n    def pushup(self, u):\n        self.tr[u].v = max(self.tr[u << 1].v, self.tr[u << 1 | 1].v)\n\n    def query(self, u, l, r):\n        if self.tr[u].l >= l and self.tr[u].r <= r:\n            return self.tr[u].v\n        mid = (self.tr[u].l + self.tr[u].r) >> 1\n        v = 0\n        if l <= mid:\n            v = self.query(u << 1, l, r)\n        if r > mid:\n            v = max(v, self.query(u << 1 | 1, l, r))\n        return v\n\n\nclass Solution:\n    def lengthOfLIS(self, nums: List[int], k: int) -> int:\n        tree = SegmentTree(max(nums))\n        ans = 1\n        for v in nums:\n            t = tree.query(1, v - k, v - 1) + 1\n            ans = max(ans, t)\n            tree.modify(1, v, t)\n        return ans\n",
    "model_generation": "Here's a more efficient solution to the problem. This solution uses dynamic programming to keep track of the length of the longest subsequence ending at each position in the array.\n\n```python\nclass Solution:\n    def lengthOfLIS(self, nums, k):\n        dp = []\n        for num in nums:\n            idx = bisect.bisect_left(dp, num - k)\n            if idx == len(dp):\n                dp.append(num)\n            else:\n                dp[idx] = num\n        return len(dp)\n```\n\nIn this solution, we use a list `dp` to keep track of the longest subsequence ending at each position. For each number in the input list, we find the first index `idx` in `dp` such that the number at that index is greater than or equal to the current number minus `k`. If such an index does not exist, we append the current number to `dp`. Otherwise, we update the number at index `idx` to be the current number.\n\nThis solution works because the longest subsequence ending at a position can either end at the previous position and include the current number, or not include the current number at all. Therefore, we can dynamically update the longest subsequence ending at each position as we process the input list.\n\nThe time complexity of this solution is O(n log n) due to the binary search operation, where n is the length of the input list. The space complexity is O(n), where n is the length of the longest subsequence.\n\nNote that you will need to import the `bisect` module to use this solution.\n\n```python\nimport bisect\n```\n\nThis solution is more efficient than the original solution because it uses dynamic programming to avoid recomputing the length of the longest subsequence ending at each position. It also uses binary search to find the correct index in the `dp` list in O(log n) time, which reduces the overall time complexity of the solution.",
    "model_solution": "class Solution:\n    def lengthOfLIS(self, nums, k):\n        dp = []\n        for num in nums:\n            idx = bisect.bisect_left(dp, num - k)\n            if idx == len(dp):\n                dp.append(num)\n            else:\n                dp[idx] = num\n        return len(dp)",
    "is_python": true
}