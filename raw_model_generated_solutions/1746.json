{
    "problem_idx": "1746",
    "description": "\nYou are given an integer array `nums`. You must perform **exactly one** operation\u00a0where you can **replace** one\u00a0element `nums[i]` with `nums[i] * nums[i]`.\u00a0\n\n\nReturn *the **maximum** possible subarray sum after **exactly\u00a0one** operation*. The subarray must be non-empty.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** nums = [2,-1,-4,-3]\n**Output:** 17\n**Explanation:** You can perform the operation on index 2 (0-indexed) to make nums = [2,-1,**16**,-3]. Now, the maximum subarray sum is 2 + -1 + 16 = 17.\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** nums = [1,-1,1,1,-1,-1,1]\n**Output:** 4\n**Explanation:** You can perform the operation on index 1 (0-indexed) to make nums = [1,**1**,1,1,-1,-1,1]. Now, the maximum subarray sum is 1 + 1 + 1 + 1 = 4.\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= nums.length <= 105`\n* `-104\u00a0<= nums[i] <= 104`\n\n\n",
    "inefficient_solution": "class Solution:\n    def maxSumAfterOperation(self, nums: List[int]) -> int:\n        # Create a list to store the intermediate results\n        dp = [[-float('inf')] * 2 for _ in range(len(nums))]\n        \n        # Initialize the first element\n        dp[0][0] = nums[0]\n        dp[0][1] = nums[0] ** 2\n        \n        # Initialize the maximum sum\n        max_sum = -float('inf')\n        \n        # Iterate through the array\n        for i in range(1, len(nums)):\n            # Create a new list to store the current intermediate results\n            new_dp = [[-float('inf')] * 2 for _ in range(i + 1)]\n            \n            # Iterate through the previous intermediate results\n            for j in range(i):\n                # Calculate the maximum sum without operation\n                no_op = max(dp[j][0], 0) + nums[i]\n                # Calculate the maximum sum with operation\n                op = max(max(dp[j][0], 0) + nums[i] ** 2, dp[j][1] + nums[i])\n                # Update the current intermediate results\n                new_dp[j][0] = max(new_dp[j][0], no_op)\n                new_dp[j][1] = max(new_dp[j][1], op)\n            \n            # Update the maximum sum\n            max_sum = max(max_sum, new_dp[i-1][0], new_dp[i-1][1])\n            \n            # Update the current intermediate results\n            dp[i][0] = new_dp[i-1][0]\n            dp[i][1] = new_dp[i-1][1]\n        \n        return max_sum",
    "efficient_solution": "class Solution:\n    def maxSumAfterOperation(self, nums: List[int]) -> int:\n        f = g = 0\n        ans = -inf\n        for x in nums:\n            ff = max(f, 0) + x\n            gg = max(max(f, 0) + x * x, g + x)\n            f, g = ff, gg\n            ans = max(ans, f, g)\n        return ans\n",
    "model_generation": "### Efficient Solution:\n\n```python\nclass Solution:\n    def maxSumAfterOperation(self, nums: List[int]) -> int:\n        max_sum = float('-inf')\n        max_no_op = 0\n        \n        for num in nums:\n            # Calculate the maximum sum without operation\n            no_op = max(max_no_op, 0) + num\n            \n            # Calculate the maximum sum with operation\n            op = max(max_no_op, 0) + num ** 2\n            \n            # Update the maximum sum\n            max_sum = max(max_sum, no_op, op)\n            \n            # Update the maximum sum without operation\n            max_no_op = max(max_no_op, no_op)\n        \n        return max_sum\n```\n\n### Explanation:\n\n* We use two variables: `max_sum` to store the maximum possible subarray sum after exactly one operation, and `max_no_op` to store the maximum subarray sum without any operation.\n* We iterate through the array, and for each number, we calculate the maximum sum without operation (`no_op`) and the maximum sum with operation (`op`).\n* We update `max_sum` with the maximum of `max_sum`, `no_op`, and `op`.\n* We also update `max_no_op` with the maximum of `max_no_op` and `no_op`, so that we can use it to calculate the maximum sum without operation in the next iteration.\n* Finally, we return `max_sum`.\n\n### Time Complexity:\n\n* The time complexity is O(n), where n is the length of the array.\n\n### Space Complexity:\n\n* The space complexity is O(1), as we only use a constant amount of space to store the variables `max_sum` and `max_no_op`.",
    "model_solution": "class Solution:\n    def maxSumAfterOperation(self, nums: List[int]) -> int:\n        max_sum = float('-inf')\n        max_no_op = 0\n        \n        for num in nums:\n            # Calculate the maximum sum without operation\n            no_op = max(max_no_op, 0) + num\n            \n            # Calculate the maximum sum with operation\n            op = max(max_no_op, 0) + num ** 2\n            \n            # Update the maximum sum\n            max_sum = max(max_sum, no_op, op)\n            \n            # Update the maximum sum without operation\n            max_no_op = max(max_no_op, no_op)\n        \n        return max_sum",
    "is_python": true
}