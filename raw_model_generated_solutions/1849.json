{
    "problem_idx": "1849",
    "description": "\nYou are given a string `s` that consists of only digits.\n\n\nCheck if we can split `s` into **two or more non-empty substrings** such that the **numerical values** of the substrings are in **descending order** and the **difference** between numerical values of every two **adjacent** **substrings** is equal to `1`.\n\n\n* For example, the string `s = \"0090089\"` can be split into `[\"0090\", \"089\"]` with numerical values `[90,89]`. The values are in descending order and adjacent values differ by `1`, so this way is valid.\n* Another example, the string `s = \"001\"` can be split into `[\"0\", \"01\"]`, `[\"00\", \"1\"]`, or `[\"0\", \"0\", \"1\"]`. However all the ways are invalid because they have numerical values `[0,1]`, `[0,1]`, and `[0,0,1]` respectively, all of which are not in descending order.\n\n\nReturn `true` *if it is possible to split* `s`\u200b\u200b\u200b\u200b\u200b\u200b *as described above**, or* `false` *otherwise.*\n\n\nA **substring** is a contiguous sequence of characters in a string.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** s = \"1234\"\n**Output:** false\n**Explanation:** There is no valid way to split s.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** s = \"050043\"\n**Output:** true\n**Explanation:** s can be split into [\"05\", \"004\", \"3\"] with numerical values [5,4,3].\nThe values are in descending order with adjacent values differing by 1.\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** s = \"9080701\"\n**Output:** false\n**Explanation:** There is no valid way to split s.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= s.length <= 20`\n* `s` only consists of digits.\n\n\n",
    "inefficient_solution": "def splitString(s):\n    def dfs(i, x, k):\n        if i == len(s):\n            return k > 1\n        for j in range(i, len(s)):\n            y = 0\n            for digit in s[j:]:\n                y = y * 10 + int(digit)\n                if (x == -1 or x - y == 1) and dfs(j + 1, y, k + 1):\n                    return True\n        return False\n\n    for i in range(len(s)):\n        for j in range(i, len(s)):\n            for k in range(j, len(s)):\n                for l in range(k, len(s)):\n                    y = 0\n                    for digit in s[:j]:\n                        y = y * 10 + int(digit)\n                    z = 0\n                    for digit in s[j:k]:\n                        z = z * 10 + int(digit)\n                    w = 0\n                    for digit in s[k:l]:\n                        w = w * 10 + int(digit)\n                    v = 0\n                    for digit in s[l:]:\n                        v = v * 10 + int(digit)\n                    if (y == -1 or y - z == 1) and (z == -1 or z - w == 1) and (w == -1 or w - v == 1):\n                        return True\n    return False",
    "efficient_solution": "class Solution:\n    def splitString(self, s: str) -> bool:\n        def dfs(i, x, k):\n            if i == len(s):\n                return k > 1\n            y = 0\n            for j in range(i, len(s)):\n                y = y * 10 + int(s[j])\n                if (x == -1 or x - y == 1) and dfs(j + 1, y, k + 1):\n                    return True\n            return False\n\n        return dfs(0, -1, 0)\n",
    "model_generation": "Here's a more efficient solution using a backtracking approach:\n\n```python\ndef splitString(s):\n    def dfs(i, prev_val, prev_diff, prev_count):\n        if i == len(s):\n            return prev_count > 1\n        for j in range(i + 1, len(s)):\n            val = 0\n            for k in range(j, len(s)):\n                val = val * 10 + int(s[k])\n                if (prev_val == -1 or prev_val - val == prev_diff) and dfs(j + 1, val, prev_diff, prev_count + 1):\n                    return True\n        return False\n\n    for i in range(1, len(s)):\n        if dfs(i, -1, -1, 1):\n            return True\n    return False\n```\n\nHowever, this solution still has an exponential time complexity because it performs multiple DFS calls from each position in the string.\n\nHere's a more efficient solution that uses a single DFS call and has a time complexity of O(n^2):\n\n```python\ndef splitString(s):\n    def dfs(i, prev_val, prev_diff):\n        if i == len(s):\n            return True\n        for j in range(i + 1, len(s)):\n            val = 0\n            for k in range(j, len(s)):\n                val = val * 10 + int(s[k])\n                if (prev_val == -1 or prev_val - val == prev_diff) and dfs(k + 1, val, 1 if val == prev_val + 1 else -1):\n                    return True\n        return False\n\n    for i in range(len(s)):\n        if dfs(i + 1, -1, -1):\n            return True\n    return False\n```\n\nThis solution works by performing a single DFS call and maintaining the previous value and difference between values. It returns True as soon as it finds a valid split. If it exhausts all possibilities without finding a valid split, it returns False.",
    "model_solution": "def splitString(s):\n    def dfs(i, prev_val, prev_diff, prev_count):\n        if i == len(s):\n            return prev_count > 1\n        for j in range(i + 1, len(s)):\n            val = 0\n            for k in range(j, len(s)):\n                val = val * 10 + int(s[k])\n                if (prev_val == -1 or prev_val - val == prev_diff) and dfs(j + 1, val, prev_diff, prev_count + 1):\n                    return True\n        return False\n\n    for i in range(1, len(s)):\n        if dfs(i, -1, -1, 1):\n            return True\n    return False",
    "is_python": true
}