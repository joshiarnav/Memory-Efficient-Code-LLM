{
    "problem_idx": "2940",
    "description": "\nYou are given a **0-indexed** array `heights` of positive integers, where `heights[i]` represents the height of the `ith` building.\n\n\nIf a person is in building `i`, they can move to any other building `j` if and only if `i < j` and `heights[i] < heights[j]`.\n\n\nYou are also given another array `queries` where `queries[i] = [ai, bi]`. On the `ith` query, Alice is in building `ai` while Bob is in building `bi`.\n\n\nReturn *an array* `ans` *where* `ans[i]` *is **the index of the leftmost building** where Alice and Bob can meet on the* `ith` *query*. *If Alice and Bob cannot move to a common building on query* `i`, *set* `ans[i]` *to* `-1`.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** heights = [6,4,8,5,2,7], queries = [[0,1],[0,3],[2,4],[3,4],[2,2]]\n**Output:** [2,5,-1,5,2]\n**Explanation:** In the first query, Alice and Bob can move to building 2 since heights[0] < heights[2] and heights[1] < heights[2]. \nIn the second query, Alice and Bob can move to building 5 since heights[0] < heights[5] and heights[3] < heights[5]. \nIn the third query, Alice cannot meet Bob since Alice cannot move to any other building.\nIn the fourth query, Alice and Bob can move to building 5 since heights[3] < heights[5] and heights[4] < heights[5].\nIn the fifth query, Alice and Bob are already in the same building.  \nFor ans[i] != -1, It can be shown that ans[i] is the leftmost building where Alice and Bob can meet.\nFor ans[i] == -1, It can be shown that there is no building where Alice and Bob can meet.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** heights = [5,3,8,2,6,1,4,6], queries = [[0,7],[3,5],[5,2],[3,0],[1,6]]\n**Output:** [7,6,-1,4,6]\n**Explanation:** In the first query, Alice can directly move to Bob's building since heights[0] < heights[7].\nIn the second query, Alice and Bob can move to building 6 since heights[3] < heights[6] and heights[5] < heights[6].\nIn the third query, Alice cannot meet Bob since Bob cannot move to any other building.\nIn the fourth query, Alice and Bob can move to building 4 since heights[3] < heights[4] and heights[0] < heights[4].\nIn the fifth query, Alice can directly move to Bob's building since heights[1] < heights[6].\nFor ans[i] != -1, It can be shown that ans[i] is the leftmost building where Alice and Bob can meet.\nFor ans[i] == -1, It can be shown that there is no building where Alice and Bob can meet.\n\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= heights.length <= 5 * 104`\n* `1 <= heights[i] <= 109`\n* `1 <= queries.length <= 5 * 104`\n* `queries[i] = [ai, bi]`\n* `0 <= ai, bi <= heights.length - 1`\n\n\n",
    "inefficient_solution": "class Solution:\n    def leftmostBuildingQueries(self, heights, queries):\n        n = len(heights)\n        m = len(queries)\n        for i in range(m):\n            queries[i].append(i)\n        heights = [[h, i] for i, h in enumerate(heights)]\n        heights.sort()\n        queries.sort(key=lambda x: x[2])\n        ans = [-1] * m\n        tree1 = {}\n        tree2 = {}\n        for i, (h, j) in enumerate(heights):\n            tree1[h] = i\n            tree2[h] = j\n        for i, (l, r, idx) in enumerate(queries):\n            while True:\n                if l in tree1 and tree1[l] <= tree2[r]:\n                    if any(tree2[h] > r for h in range(l + 1, r + 1) if h in tree1):\n                        ans[idx] = r\n                        break\n                    else:\n                        l = r\n                        r = tree2[r]\n                else:\n                    break\n            if ans[idx] != -1:\n                break\n        return ans",
    "efficient_solution": "class BinaryIndexedTree:\n    __slots__ = [\"n\", \"c\"]\n\n    def __init__(self, n: int):\n        self.n = n\n        self.c = [inf] * (n + 1)\n\n    def update(self, x: int, v: int):\n        while x <= self.n:\n            self.c[x] = min(self.c[x], v)\n            x += x & -x\n\n    def query(self, x: int) -> int:\n        mi = inf\n        while x:\n            mi = min(mi, self.c[x])\n            x -= x & -x\n        return -1 if mi == inf else mi\n\n\nclass Solution:\n    def leftmostBuildingQueries(\n        self, heights: List[int], queries: List[List[int]]\n    ) -> List[int]:\n        n, m = len(heights), len(queries)\n        for i in range(m):\n            queries[i] = [min(queries[i]), max(queries[i])]\n        j = n - 1\n        s = sorted(set(heights))\n        ans = [-1] * m\n        tree = BinaryIndexedTree(n)\n        for i in sorted(range(m), key=lambda i: -queries[i][1]):\n            l, r = queries[i]\n            while j > r:\n                k = n - bisect_left(s, heights[j]) + 1\n                tree.update(k, j)\n                j -= 1\n            if l == r or heights[l] < heights[r]:\n                ans[i] = r\n            else:\n                k = n - bisect_left(s, heights[l])\n                ans[i] = tree.query(k)\n        return ans\n",
    "model_generation": "To solve this problem more efficiently, we can use a Binary Indexed Tree (BIT) to keep track of the minimum height of the buildings that Alice and Bob can move to.\n\nHere's the efficient solution:\n\n```python\nclass Solution:\n    def leftmostBuildingQueries(self, heights, queries):\n        n = len(heights)\n        m = len(queries)\n        for i in range(m):\n            queries[i].append(i)\n        heights = [[h, i] for i, h in enumerate(heights)]\n        heights.sort()\n        queries.sort(key=lambda x: x[2])\n        \n        # Initialize the BIT to keep track of the minimum height\n        bit = [0] * (n + 1)\n        \n        def update(i, val):\n            while i <= n:\n                bit[i] = max(bit[i], val)\n                i += i & -i\n        \n        def query(i):\n            ans = 0\n            while i:\n                ans = max(ans, bit[i])\n                i -= i & -i\n            return ans\n        \n        ans = [-1] * m\n        for i in range(m):\n            l, r = queries[i][0], queries[i][1]\n            idx = queries[i][2]\n            val = heights[l][0]\n            ans[idx] = query(r + 1)\n            if ans[idx] >= heights[l][0]:\n                update(l, heights[l][0] + 1)\n        \n        return ans\n```\n\nIn this solution, we first sort the `heights` array and the `queries` array based on the height of the building and the index of the query respectively. Then, we initialize a Binary Indexed Tree (BIT) to keep track of the minimum height of the buildings that Alice and Bob can move to.\n\nFor each query, we first update the BIT by setting the value at index `l` to `heights[l][0] + 1` if Alice can move to building `r`. Then, we query the BIT to find the maximum height of the buildings that Alice and Bob can move to, which is the index of the leftmost building where Alice and Bob can meet. If the maximum height is greater than or equal to the height of building `l`, we update the answer for the current query.\n\nThis solution has a time complexity of O((n + m) log n) and a space complexity of O(n), where n is the number of buildings and m is the number of queries.",
    "model_solution": "class Solution:\n    def leftmostBuildingQueries(self, heights, queries):\n        n = len(heights)\n        m = len(queries)\n        for i in range(m):\n            queries[i].append(i)\n        heights = [[h, i] for i, h in enumerate(heights)]\n        heights.sort()\n        queries.sort(key=lambda x: x[2])\n        \n        # Initialize the BIT to keep track of the minimum height\n        bit = [0] * (n + 1)\n        \n        def update(i, val):\n            while i <= n:\n                bit[i] = max(bit[i], val)\n                i += i & -i\n        \n        def query(i):\n            ans = 0\n            while i:\n                ans = max(ans, bit[i])\n                i -= i & -i\n            return ans\n        \n        ans = [-1] * m\n        for i in range(m):\n            l, r = queries[i][0], queries[i][1]\n            idx = queries[i][2]\n            val = heights[l][0]\n            ans[idx] = query(r + 1)\n            if ans[idx] >= heights[l][0]:\n                update(l, heights[l][0] + 1)\n        \n        return ans",
    "is_python": true
}