{
    "problem_idx": "2578",
    "description": "\nGiven a positive integer `num`, split it into two non-negative integers `num1` and `num2` such that:\n\n\n* The concatenation of `num1` and `num2` is a permutation of `num`.\n\t+ In other words, the sum of the number of occurrences of each digit in `num1` and `num2` is equal to the number of occurrences of that digit in `num`.\n* `num1` and `num2` can contain leading zeros.\n\n\nReturn *the **minimum** possible sum of* `num1` *and* `num2`.\n\n\n**Notes:**\n\n\n* It is guaranteed that `num` does not contain any leading zeros.\n* The order of occurrence of the digits in `num1` and `num2` may differ from the order of occurrence of `num`.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** num = 4325\n**Output:** 59\n**Explanation:** We can split 4325 so that num1 is 24 and num2 is 35, giving a sum of 59. We can prove that 59 is indeed the minimal possible sum.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** num = 687\n**Output:** 75\n**Explanation:** We can split 687 so that num1 is 68 and num2 is 7, which would give an optimal sum of 75.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `10 <= num <= 109`\n\n\n",
    "inefficient_solution": "class Solution:\n    def splitNum(self, num: int) -> int:\n        digits = [int(i) for i in str(num)]\n        len_num = len(digits)\n        max_digits = 10**len_num\n        min_num1 = 10**(len_num//2) - 1\n        min_num2 = 10**(len_num-len_num//2) - 1\n        min_sum = float('inf')\n        for i in range(max_digits):\n            num1 = i\n            for j in range(i+1, max_digits):\n                num2 = j\n                if self.check_digits(num1, num2, digits):\n                    min_sum = min(min_sum, num1 + num2)\n        return min_sum\n\n    def check_digits(self, num1, num2, digits):\n        num1 = str(num1)\n        num2 = str(num2)\n        if len(num1) + len(num2) != len(str(digits)):\n            return False\n        cnt1 = [0] * 10\n        cnt2 = [0] * 10\n        for i in num1:\n            cnt1[int(i)] += 1\n        for i in num2:\n            cnt2[int(i)] += 1\n        for i in range(10):\n            if cnt1[i] + cnt2[i] != digits.count(i):\n                return False\n        return True",
    "efficient_solution": "class Solution:\n    def splitNum(self, num: int) -> int:\n        cnt = Counter()\n        n = 0\n        while num:\n            cnt[num % 10] += 1\n            num //= 10\n            n += 1\n        ans = [0] * 2\n        j = 0\n        for i in range(n):\n            while cnt[j] == 0:\n                j += 1\n            cnt[j] -= 1\n            ans[i & 1] = ans[i & 1] * 10 + j\n        return sum(ans)\n",
    "model_generation": "Here is an efficient solution using a two-pointer technique.\n\n```python\nclass Solution:\n    def splitNum(self, num: int) -> int:\n        digits = [int(i) for i in str(num)]\n        num_dict = {}\n        for digit in digits:\n            if digit not in num_dict:\n                num_dict[digit] = 1\n            else:\n                num_dict[digit] += 1\n\n        num_str = sorted(map(str, digits))\n        low, high = 0, len(num_str) - 1\n        min_sum = float('inf')\n\n        while low <= high:\n            num1 = int(''.join(num_str[low:high+1]))\n            num2 = int(''.join(num_str[high:low-1:-1]))\n            if self.check_digits(num1, num2, num_dict):\n                min_sum = min(min_sum, num1 + num2)\n            low += 1\n            high -= 1\n        return min_sum\n\n    def check_digits(self, num1, num2, num_dict):\n        cnt1 = [0] * 10\n        cnt2 = [0] * 10\n        for i in str(num1):\n            cnt1[int(i)] += 1\n        for i in str(num2):\n            cnt2[int(i)] += 1\n        for i in range(10):\n            if cnt1[i] + cnt2[i] != num_dict.get(i, 0):\n                return False\n        return True\n```\n\nThis solution works as follows:\n\n- First, we count the occurrences of each digit in the original number using a dictionary.\n- Then, we sort the digits in ascending order and use two pointers, `low` and `high`, to generate all possible combinations of digits.\n- For each combination, we check if the sum of the occurrences of each digit in `num1` and `num2` is equal to the occurrences of that digit in the original number using the `check_digits` function.\n- If the sum is equal, we update `min_sum` with the sum of `num1` and `num2`.\n- Finally, we return `min_sum`.\n\nThis solution has a time complexity of O(n log n) due to the sorting step, where n is the number of digits in the original number. The space complexity is O(n) for storing the occurrences of each digit in the original number.",
    "model_solution": "class Solution:\n    def splitNum(self, num: int) -> int:\n        digits = [int(i) for i in str(num)]\n        num_dict = {}\n        for digit in digits:\n            if digit not in num_dict:\n                num_dict[digit] = 1\n            else:\n                num_dict[digit] += 1\n\n        num_str = sorted(map(str, digits))\n        low, high = 0, len(num_str) - 1\n        min_sum = float('inf')\n\n        while low <= high:\n            num1 = int(''.join(num_str[low:high+1]))\n            num2 = int(''.join(num_str[high:low-1:-1]))\n            if self.check_digits(num1, num2, num_dict):\n                min_sum = min(min_sum, num1 + num2)\n            low += 1\n            high -= 1\n        return min_sum\n\n    def check_digits(self, num1, num2, num_dict):\n        cnt1 = [0] * 10\n        cnt2 = [0] * 10\n        for i in str(num1):\n            cnt1[int(i)] += 1\n        for i in str(num2):\n            cnt2[int(i)] += 1\n        for i in range(10):\n            if cnt1[i] + cnt2[i] != num_dict.get(i, 0):\n                return False\n        return True",
    "is_python": true
}