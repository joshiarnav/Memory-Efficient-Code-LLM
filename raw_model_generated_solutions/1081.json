{
    "problem_idx": "1081",
    "description": "\nGiven a string `s`, return *the* *lexicographically smallest* *subsequence* *of* `s` *that contains all the distinct characters of* `s` *exactly once*.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** s = \"bcabc\"\n**Output:** \"abc\"\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** s = \"cbacdcbc\"\n**Output:** \"acdb\"\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= s.length <= 1000`\n* `s` consists of lowercase English letters.\n\n\n\u00a0\n\n\n**Note:** This question is the same as 316: <https://leetcode.com/problems/remove-duplicate-letters/>\n",
    "inefficient_solution": "class Solution:\n    def smallestSubsequence(self, s: str) -> str:\n        last = {c: i for i, c in enumerate(s)}\n        stk = []\n        vis = set()\n        counts = {}\n        for c in s:\n            counts[c] = counts.get(c, 0) + 1\n        for i, c in enumerate(s):\n            if c in vis:\n                counts[c] -= 1\n                continue\n            while stk and stk[-1] > c and last[stk[-1]] > i:\n                stk.pop()\n                vis.remove(stk[-1])\n                counts[stk[-1]] += 1\n            stk.append(c)\n            stk.append(c)  # duplicate\n            vis.add(c)\n            vis.add(c)     # duplicate\n        return \"\".join(stk)",
    "efficient_solution": "class Solution:\n    def smallestSubsequence(self, s: str) -> str:\n        last = {c: i for i, c in enumerate(s)}\n        stk = []\n        vis = set()\n        for i, c in enumerate(s):\n            if c in vis:\n                continue\n            while stk and stk[-1] > c and last[stk[-1]] > i:\n                vis.remove(stk.pop())\n            stk.append(c)\n            vis.add(c)\n        return \"\".join(stk)\n",
    "model_generation": "### Efficient Solution\n\nThe inefficient solution has some duplicate operations, including adding the same character to the stack and set twice. Here's the corrected and efficient solution:\n\n```python\nclass Solution:\n    def smallestSubsequence(self, s: str) -> str:\n        last = {c: i for i, c in enumerate(s)}\n        stk = []\n        vis = set()\n        counts = {}\n        for c in s:\n            counts[c] = counts.get(c, 0) + 1\n        \n        for i, c in enumerate(s):\n            if c in vis:\n                counts[c] -= 1\n                continue\n            while stk and stk[-1] > c and last[stk[-1]] > i:\n                stk.pop()\n                vis.remove(stk[-1])\n                counts[stk[-1]] += 1\n            stk.append(c)\n            vis.add(c)\n            counts[c] -= 1  # update count\n        \n        return \"\".join(stk)\n```\n\n### Explanation\n\n*   We maintain a dictionary `last` to store the index of each character's last occurrence in the string.\n*   We use a stack `stk` to store the characters of the lexicographically smallest subsequence.\n*   We use a set `vis` to keep track of the characters that have been added to the stack.\n*   We use a dictionary `counts` to store the count of each character in the string.\n*   We iterate through the string, and for each character, we check if it has been added to the stack. If not, we pop characters from the stack that are larger than the current character and have not been added to the stack yet. We then add the current character to the stack and update its count.\n*   Finally, we return the string formed by the characters in the stack.",
    "model_solution": "class Solution:\n    def smallestSubsequence(self, s: str) -> str:\n        last = {c: i for i, c in enumerate(s)}\n        stk = []\n        vis = set()\n        counts = {}\n        for c in s:\n            counts[c] = counts.get(c, 0) + 1\n        \n        for i, c in enumerate(s):\n            if c in vis:\n                counts[c] -= 1\n                continue\n            while stk and stk[-1] > c and last[stk[-1]] > i:\n                stk.pop()\n                vis.remove(stk[-1])\n                counts[stk[-1]] += 1\n            stk.append(c)\n            vis.add(c)\n            counts[c] -= 1  # update count\n        \n        return \"\".join(stk)",
    "is_python": true
}