{
    "problem_idx": "2401",
    "description": "\nYou are given an array `nums` consisting of **positive** integers.\n\n\nWe call a subarray of `nums` **nice** if the bitwise **AND** of every pair of elements that are in **different** positions in the subarray is equal to `0`.\n\n\nReturn *the length of the **longest** nice subarray*.\n\n\nA **subarray** is a **contiguous** part of an array.\n\n\n**Note** that subarrays of length `1` are always considered nice.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** nums = [1,3,8,48,10]\n**Output:** 3\n**Explanation:** The longest nice subarray is [3,8,48]. This subarray satisfies the conditions:\n- 3 AND 8 = 0.\n- 3 AND 48 = 0.\n- 8 AND 48 = 0.\nIt can be proven that no longer nice subarray can be obtained, so we return 3.\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** nums = [3,1,5,11,13]\n**Output:** 1\n**Explanation:** The length of the longest nice subarray is 1. Any subarray of length 1 can be chosen.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= nums.length <= 105`\n* `1 <= nums[i] <= 109`\n\n\n",
    "inefficient_solution": "class Solution:\n    def longestNiceSubarray(self, nums):\n        ans = []\n        for x in nums:\n            new_ans = []\n            for i, old_ans in enumerate(ans):\n                if not (old_ans & x):\n                    new_ans.append(old_ans)\n            if not any(old_ans & x for old_ans in ans):\n                new_ans.append(x)\n            ans = new_ans\n            ans.append(x)\n        return len(max(ans, key=len))",
    "efficient_solution": "class Solution:\n    def longestNiceSubarray(self, nums: List[int]) -> int:\n        ans = j = mask = 0\n        for i, x in enumerate(nums):\n            while mask & x:\n                mask ^= nums[j]\n                j += 1\n            ans = max(ans, i - j + 1)\n            mask |= x\n        return ans\n",
    "model_generation": "Here's a more efficient solution using bit manipulation. The idea is to maintain a prefix mask, where each bit in the mask corresponds to a position in the array. The bit is set to 1 if the corresponding position has a number with a non-zero bit in the current position.\n\n```python\nclass Solution:\n    def longestNiceSubarray(self, nums):\n        max_len = 0\n        mask = 0\n        for x in nums:\n            new_mask = mask | x\n            while new_mask & -new_mask != new_mask:\n                new_mask ^= mask & -mask\n            max_len = max(max_len, bin(new_mask).count('1'))\n            mask = new_mask\n        return max_len\n```\n\nIn this solution, we iterate over the array and maintain a prefix mask. We update the mask by performing a bitwise OR operation with the current number. Then, we find the first set bit in the mask (which corresponds to the position where the current subarray becomes nice) by performing a bitwise AND operation with the bitwise NOT of the mask. We update the mask by performing a bitwise XOR operation with the prefix mask and the first set bit of the prefix mask. Finally, we update the maximum length of the nice subarray.\n\nNote that we use the count method of the string representation of the number in binary to find the length of the nice subarray. This is because the len function in Python returns the number of characters in the string, not the number of bits.\n\nThis solution has a time complexity of O(n log m), where n is the length of the array and m is the maximum number in the array. The space complexity is O(1), as we only use a constant amount of space to store the prefix mask and other variables.",
    "model_solution": "class Solution:\n    def longestNiceSubarray(self, nums):\n        max_len = 0\n        mask = 0\n        for x in nums:\n            new_mask = mask | x\n            while new_mask & -new_mask != new_mask:\n                new_mask ^= mask & -mask\n            max_len = max(max_len, bin(new_mask).count('1'))\n            mask = new_mask\n        return max_len",
    "is_python": true
}