{
    "problem_idx": "2593",
    "description": "\nYou are given an array `nums` consisting of positive integers.\n\n\nStarting with `score = 0`, apply the following algorithm:\n\n\n* Choose the smallest integer of the array that is not marked. If there is a tie, choose the one with the smallest index.\n* Add the value of the chosen integer to `score`.\n* Mark **the chosen element and its two adjacent elements if they exist**.\n* Repeat until all the array elements are marked.\n\n\nReturn *the score you get after applying the above algorithm*.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** nums = [2,1,3,4,5,2]\n**Output:** 7\n**Explanation:** We mark the elements as follows:\n- 1 is the smallest unmarked element, so we mark it and its two adjacent elements: [2,1,3,4,5,2].\n- 2 is the smallest unmarked element, so we mark it and its left adjacent element: [2,1,3,4,5,2].\n- 4 is the only remaining unmarked element, so we mark it: [2,1,3,4,5,2].\nOur score is 1 + 2 + 4 = 7.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** nums = [2,3,5,1,3,2]\n**Output:** 5\n**Explanation:** We mark the elements as follows:\n- 1 is the smallest unmarked element, so we mark it and its two adjacent elements: [2,3,5,1,3,2].\n- 2 is the smallest unmarked element, since there are two of them, we choose the left-most one, so we mark the one at index 0 and its right adjacent element: [2,3,5,1,3,2].\n- 2 is the only remaining unmarked element, so we mark it: [2,3,5,1,3,2].\nOur score is 1 + 2 + 2 = 5.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= nums.length <= 105`\n* `1 <= nums[i] <= 106`\n\n\n",
    "inefficient_solution": "class Solution:\n    def findScore(self, nums: List[int]) -> int:\n        n = len(nums)\n        vis = [False] * (10**6)\n        q = [(x, i) for i, x in enumerate(nums)]\n        marked = [False] * (10**6)\n        score = [0] * n\n        ans = 0\n        for _ in range(n):\n            temp_q = q.copy()\n            q = []\n            for x, i in temp_q:\n                if not marked[i]:\n                    q.append((x, i))\n                    marked[i] = True\n            while q:\n                x, i = q.pop()\n                ans += x\n                marked[i] = True\n                for j in (i - 1, i + 1):\n                    if 0 <= j < n:\n                        marked[j] = True\n        return ans",
    "efficient_solution": "class Solution:\n    def findScore(self, nums: List[int]) -> int:\n        n = len(nums)\n        vis = [False] * n\n        q = [(x, i) for i, x in enumerate(nums)]\n        heapify(q)\n        ans = 0\n        while q:\n            x, i = heappop(q)\n            ans += x\n            vis[i] = True\n            for j in (i - 1, i + 1):\n                if 0 <= j < n:\n                    vis[j] = True\n            while q and vis[q[0][1]]:\n                heappop(q)\n        return ans\n",
    "model_generation": "### Efficient Solution:\n\n```python\nclass Solution:\n    def findScore(self, nums: List[int]) -> int:\n        n = len(nums)\n        vis = [False] * n\n        score = 0\n        for i in range(n):\n            if not vis[i]:\n                self.dfs(nums, vis, i, score)\n        return score\n\n    def dfs(self, nums, vis, i, score):\n        if vis[i]:\n            return\n        vis[i] = True\n        score += nums[i]\n        for j in (i - 1, i + 1):\n            if 0 <= j < len(nums):\n                self.dfs(nums, vis, j, score)\n```\n\n### Explanation:\n\nThe main idea is to use a depth-first search (DFS) approach to mark the elements and calculate the score. The DFS function takes the current index `i` and the current score as parameters. If the element at `i` is already marked, the function returns immediately. Otherwise, it marks the element, adds its value to the score, and recursively calls itself for the left and right adjacent elements if they exist.\n\nThis approach is more efficient than the previous one because it avoids unnecessary iterations and uses a more straightforward and intuitive algorithm. The time complexity is still O(n), where n is the length of the input array, but the constant factor is much smaller.",
    "model_solution": "class Solution:\n    def findScore(self, nums: List[int]) -> int:\n        n = len(nums)\n        vis = [False] * n\n        score = 0\n        for i in range(n):\n            if not vis[i]:\n                self.dfs(nums, vis, i, score)\n        return score\n\n    def dfs(self, nums, vis, i, score):\n        if vis[i]:\n            return\n        vis[i] = True\n        score += nums[i]\n        for j in (i - 1, i + 1):\n            if 0 <= j < len(nums):\n                self.dfs(nums, vis, j, score)",
    "is_python": true
}