{
    "problem_idx": "1143",
    "description": "\nGiven two strings `text1` and `text2`, return *the length of their longest **common subsequence**.* If there is no **common subsequence**, return `0`.\n\n\nA **subsequence** of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.\n\n\n* For example, `\"ace\"` is a subsequence of `\"abcde\"`.\n\n\nA **common subsequence** of two strings is a subsequence that is common to both strings.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** text1 = \"abcde\", text2 = \"ace\" \n**Output:** 3  \n**Explanation:** The longest common subsequence is \"ace\" and its length is 3.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** text1 = \"abc\", text2 = \"abc\"\n**Output:** 3\n**Explanation:** The longest common subsequence is \"abc\" and its length is 3.\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** text1 = \"abc\", text2 = \"def\"\n**Output:** 0\n**Explanation:** There is no such common subsequence, so the result is 0.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= text1.length, text2.length <= 1000`\n* `text1` and `text2` consist of only lowercase English characters.\n\n\n",
    "inefficient_solution": "class Solution:\n    def longestCommonSubsequence(self, text1: str, text2: str) -> int:\n        m, n = len(text1), len(text2)\n        f = []\n        for _ in range(m):\n            f.append([])\n            for _ in range(n):\n                f[-1].append(0)\n        for i in range(m):\n            f[i] = f[i][:n]\n            for j in range(n):\n                if i == j == 0:\n                    f[i][j] = 0\n                elif i == 0:\n                    f[i][j] = max(f[i][j-1], 0)\n                elif j == 0:\n                    f[i][j] = max(f[i-1][j], 0)\n                elif text1[i] == text2[j]:\n                    f[i][j] = f[i-1][j-1] + 1\n                elif f[i-1][j] > f[i][j-1]:\n                    f[i][j] = f[i-1][j]\n                else:\n                    f[i][j] = f[i][j-1]\n        return f[m-1][n-1]\n\n    def longestCommonSubsequenceList(self, text1: str, text2: str) -> int:\n        m, n = len(text1), len(text2)\n        f = []\n        for i in range(m):\n            f.append([])\n            for j in range(n):\n                if text1[i] == text2[j]:\n                    if i == 0 or j == 0:\n                        f[i].append(1)\n                    else:\n                        f[i].append(f[i-1][j-1] + 1)\n                else:\n                    f[i].append(0)\n        return max(f[m-1])\n\n    def longestCommonSubsequenceDict(self, text1: str, text2: str) -> int:\n        m, n = len(text1), len(text2)\n        d = {}\n        for i in range(m):\n            d[i] = {}\n            for j in range(n):\n                if text1[i] == text2[j]:\n                    if i == 0 or j == 0:\n                        d[i][j] = 1\n                    else:\n                        d[i][j] = d[i-1][j-1] + 1\n                else:\n                    d[i][j] = 0\n        max_len = 0\n        for i in range(m):\n            for j in range(n):\n                max_len = max(max_len, d[i][j])\n        return max_len",
    "efficient_solution": "class Solution:\n    def longestCommonSubsequence(self, text1: str, text2: str) -> int:\n        m, n = len(text1), len(text2)\n        f = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if text1[i - 1] == text2[j - 1]:\n                    f[i][j] = f[i - 1][j - 1] + 1\n                else:\n                    f[i][j] = max(f[i - 1][j], f[i][j - 1])\n        return f[m][n]\n",
    "model_generation": "### Efficient Solution\n\nThe provided inefficient solutions have a time complexity of O(m*n), where m and n are the lengths of the input strings. We can improve the time complexity to O(m*n) by using dynamic programming in a more optimized way.\n\nThe key idea is to use a single list `f` to store the lengths of the longest common subsequences, instead of creating a 2D list or dictionary. Here's the efficient solution in Python:\n\n```python\nclass Solution:\n    def longestCommonSubsequence(self, text1: str, text2: str) -> int:\n        m, n = len(text1), len(text2)\n        f = [0] * (n + 1)\n        \n        for i in range(1, m + 1):\n            prev_row_prev_col = f[0]\n            f[0] = 0\n            for j in range(1, n + 1):\n                if text1[i - 1] == text2[j - 1]:\n                    f[1 + j] = 1 + prev_row_prev_col\n                else:\n                    f[1 + j] = max(f[j], prev_row_prev_col)\n                prev_row_prev_col = f[j]\n        \n        return f[n]\n```\n\n### Explanation\n\n1.  We create a list `f` of size `n + 1`, where `n` is the length of the second string. This list will store the lengths of the longest common subsequences.\n2.  We iterate over the characters of the first string. For each character, we iterate over the characters of the second string.\n3.  If the current characters in both strings are equal, we set the value of `f[j + 1]` to `1 + prev_row_prev_col`, where `prev_row_prev_col` is the length of the longest common subsequence up to the previous row and column.\n4.  If the current characters are not equal, we set the value of `f[j + 1]` to the maximum of `f[j]` and `prev_row_prev_col`. This means that we choose the longest common subsequence between the current character in the first string and the previous character in the second string, or the longest common subsequence up to the previous row and column.\n5.  Finally, we return the value of `f[n]`, which is the length of the longest common subsequence.\n\nThis efficient solution has a time complexity of O(m*n), where m and n are the lengths of the input strings.",
    "model_solution": "class Solution:\n    def longestCommonSubsequence(self, text1: str, text2: str) -> int:\n        m, n = len(text1), len(text2)\n        f = [0] * (n + 1)\n        \n        for i in range(1, m + 1):\n            prev_row_prev_col = f[0]\n            f[0] = 0\n            for j in range(1, n + 1):\n                if text1[i - 1] == text2[j - 1]:\n                    f[1 + j] = 1 + prev_row_prev_col\n                else:\n                    f[1 + j] = max(f[j], prev_row_prev_col)\n                prev_row_prev_col = f[j]\n        \n        return f[n]",
    "is_python": true
}