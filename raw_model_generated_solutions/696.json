{
    "problem_idx": "696",
    "description": "\nGiven a binary string `s`, return the number of non-empty substrings that have the same number of `0`'s and `1`'s, and all the `0`'s and all the `1`'s in these substrings are grouped consecutively.\n\n\nSubstrings that occur multiple times are counted the number of times they occur.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** s = \"00110011\"\n**Output:** 6\n**Explanation:** There are 6 substrings that have equal number of consecutive 1's and 0's: \"0011\", \"01\", \"1100\", \"10\", \"0011\", and \"01\".\nNotice that some of these substrings repeat and are counted the number of times they occur.\nAlso, \"00110011\" is not a valid substring because all the 0's (and 1's) are not grouped together.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** s = \"10101\"\n**Output:** 4\n**Explanation:** There are 4 substrings: \"10\", \"01\", \"10\", \"01\" that have equal number of consecutive 1's and 0's.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= s.length <= 105`\n* `s[i]` is either `'0'` or `'1'`.\n\n\n",
    "inefficient_solution": "class Solution:\n    def countBinarySubstrings(self, s: str) -> int:\n        i, n = 0, len(s)\n        t = []\n        while i < n:\n            cnt = 1\n            while i + 1 < n and s[i + 1] == s[i]:\n                cnt += 1\n                i += 1\n            temp = [s[i - cnt + 1:i + 1]] * cnt\n            t.extend(temp)\n            i += 1\n        t = [x for x in t if x != '']\n        ans = 0\n        for i in range(1, len(t)):\n            if len(t[i]) != len(t[i - 1]):\n                continue\n            ans += min(t[i - 1], t[i])\n        return ans",
    "efficient_solution": "class Solution:\n    def countBinarySubstrings(self, s: str) -> int:\n        i, n = 0, len(s)\n        t = []\n        while i < n:\n            cnt = 1\n            while i + 1 < n and s[i + 1] == s[i]:\n                cnt += 1\n                i += 1\n            t.append(cnt)\n            i += 1\n        ans = 0\n        for i in range(1, len(t)):\n            ans += min(t[i - 1], t[i])\n        return ans\n",
    "model_generation": "### Efficient Solution\n\n```python\nclass Solution:\n    def countBinarySubstrings(self, s: str) -> int:\n        # Count consecutive occurrences of '0' and '1' in the string\n        groups = [(s[i-1], i) for i in range(1, len(s)+1) if s[i-1] != s[i-2]]\n        \n        # Initialize the count of substrings with equal number of '0's and '1's\n        count = 0\n        \n        # Iterate over the groups\n        for i in range(1, len(groups)):\n            # The number of substrings that can be formed using the current group\n            # and the previous group is min(len(group[i-1]), len(group[i]))\n            count += min(len(groups[i-1]), len(groups[i]))\n        \n        return count\n```\n\n### Explanation\n\nThe inefficient solution works by first splitting the string into substrings of consecutive '0's and '1's. It then iterates over these substrings, counting the number of substrings that can be formed using the current substring and the previous substring. However, this solution has a time complexity of O(n^2), where n is the length of the string.\n\nThe efficient solution works by first counting the number of consecutive occurrences of '0' and '1' in the string. This is done by iterating over the string and creating a list of tuples, where each tuple contains the character and the number of consecutive occurrences.\n\nThen, the solution iterates over the list of tuples, counting the number of substrings that can be formed using the current tuple and the previous tuple. The number of substrings that can be formed is min(len(t[i-1]), len(t[i])), where t[i-1] and t[i] are the current and previous tuples.\n\nThis solution has a time complexity of O(n), where n is the length of the string, because it only needs to iterate over the string once to count the consecutive occurrences of '0' and '1', and then it only needs to iterate over the list of tuples once to count the number of substrings that can be formed.",
    "model_solution": "class Solution:\n    def countBinarySubstrings(self, s: str) -> int:\n        # Count consecutive occurrences of '0' and '1' in the string\n        groups = [(s[i-1], i) for i in range(1, len(s)+1) if s[i-1] != s[i-2]]\n        \n        # Initialize the count of substrings with equal number of '0's and '1's\n        count = 0\n        \n        # Iterate over the groups\n        for i in range(1, len(groups)):\n            # The number of substrings that can be formed using the current group\n            # and the previous group is min(len(group[i-1]), len(group[i]))\n            count += min(len(groups[i-1]), len(groups[i]))\n        \n        return count",
    "is_python": true
}