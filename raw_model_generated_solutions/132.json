{
    "problem_idx": "132",
    "description": "\nGiven a string `s`, partition `s` such that every substring of the partition is a palindrome.\n\n\nReturn *the **minimum** cuts needed for a palindrome partitioning of* `s`.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** s = \"aab\"\n**Output:** 1\n**Explanation:** The palindrome partitioning [\"aa\",\"b\"] could be produced using 1 cut.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** s = \"a\"\n**Output:** 0\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** s = \"ab\"\n**Output:** 1\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= s.length <= 2000`\n* `s` consists of lowercase English letters only.\n\n\n",
    "inefficient_solution": "class Solution:\n    def minCut(self, s: str) -> int:\n        n = len(s)\n        g = [[1] * n for _ in range(n)]\n        for i in range(n - 1, -1, -1):\n            for j in range(i + 1, n):\n                g[i][j] = s[i] == s[j] and g[i + 1][j - 1]\n        f = [[] for _ in range(n)]\n        for i in range(1, n):\n            for j in range(i + 1):\n                if g[j][i]:\n                    f[i].append(1 + f[j - 1][0] if j else 0)\n        return min(f[-1])",
    "efficient_solution": "class Solution:\n    def minCut(self, s: str) -> int:\n        n = len(s)\n        g = [[True] * n for _ in range(n)]\n        for i in range(n - 1, -1, -1):\n            for j in range(i + 1, n):\n                g[i][j] = s[i] == s[j] and g[i + 1][j - 1]\n        f = list(range(n))\n        for i in range(1, n):\n            for j in range(i + 1):\n                if g[j][i]:\n                    f[i] = min(f[i], 1 + f[j - 1] if j else 0)\n        return f[-1]\n",
    "model_generation": "Here is the more efficient solution using dynamic programming:\n\n```python\nclass Solution:\n    def minCut(self, s: str) -> int:\n        n = len(s)\n        is_palindrome = [[False] * n for _ in range(n)]\n        min_cuts = [0] * n\n\n        # Check if each substring is a palindrome\n        for length in range(1, n + 1):\n            for i in range(n - length + 1):\n                j = i + length - 1\n                if length == 1:\n                    is_palindrome[i][j] = True\n                elif length == 2:\n                    is_palindrome[i][j] = s[i] == s[j]\n                else:\n                    is_palindrome[i][j] = (s[i] == s[j] and is_palindrome[i + 1][j - 1])\n\n        # Calculate minimum cuts\n        for i in range(n):\n            if is_palindrome[0][i]:\n                min_cuts[i] = 0\n            else:\n                min_cuts[i] = 1 + min(min_cuts[j] for j in range(i) if is_palindrome[j + 1][i])\n\n        return min_cuts[-1]\n```\n\nIn this solution, we first create a 2D table `is_palindrome` to store whether each substring is a palindrome. Then we calculate the `min_cuts` table in a bottom-up manner, where `min_cuts[i]` represents the minimum cuts needed to partition the substring `s[0:i+1]` into palindromes. Finally, we return `min_cuts[-1]`, which is the minimum cuts needed to partition the entire string `s`.",
    "model_solution": "class Solution:\n    def minCut(self, s: str) -> int:\n        n = len(s)\n        is_palindrome = [[False] * n for _ in range(n)]\n        min_cuts = [0] * n\n\n        # Check if each substring is a palindrome\n        for length in range(1, n + 1):\n            for i in range(n - length + 1):\n                j = i + length - 1\n                if length == 1:\n                    is_palindrome[i][j] = True\n                elif length == 2:\n                    is_palindrome[i][j] = s[i] == s[j]\n                else:\n                    is_palindrome[i][j] = (s[i] == s[j] and is_palindrome[i + 1][j - 1])\n\n        # Calculate minimum cuts\n        for i in range(n):\n            if is_palindrome[0][i]:\n                min_cuts[i] = 0\n            else:\n                min_cuts[i] = 1 + min(min_cuts[j] for j in range(i) if is_palindrome[j + 1][i])\n\n        return min_cuts[-1]",
    "is_python": true
}