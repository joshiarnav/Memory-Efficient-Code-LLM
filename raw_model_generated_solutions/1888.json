{
    "problem_idx": "1888",
    "description": "\nYou are given a binary string `s`. You are allowed to perform two types of operations on the string in any sequence:\n\n\n* **Type-1: Remove** the character at the start of the string `s` and **append** it to the end of the string.\n* **Type-2: Pick** any character in `s` and **flip** its value, i.e., if its value is `'0'` it becomes `'1'` and vice-versa.\n\n\nReturn *the **minimum** number of **type-2** operations you need to perform* *such that* `s` *becomes **alternating**.*\n\n\nThe string is called **alternating** if no two adjacent characters are equal.\n\n\n* For example, the strings `\"010\"` and `\"1010\"` are alternating, while the string `\"0100\"` is not.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** s = \"111000\"\n**Output:** 2\n**Explanation**: Use the first operation two times to make s = \"100011\".\nThen, use the second operation on the third and sixth elements to make s = \"101010\".\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** s = \"010\"\n**Output:** 0\n**Explanation**: The string is already alternating.\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** s = \"1110\"\n**Output:** 1\n**Explanation**: Use the second operation on the second element to make s = \"1010\".\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= s.length <= 105`\n* `s[i]` is either `'0'` or `'1'`.\n\n\n",
    "inefficient_solution": "class Solution:\n    def minFlips(self, s: str) -> int:\n        n = len(s)\n        max_str = [\"0\" * n, \"1\" * n]\n        min_str = [\"0\" * n, \"1\" * n]\n        for i in range(n):\n            for s1 in max_str:\n                for s2 in min_str:\n                    if s[i] != s1[i & 1] and s[i] != s2[i & 1]:\n                        max_str.remove(s1)\n                        max_str.remove(s2)\n            for s1 in max_str:\n                for s2 in min_str:\n                    if s[i] != s1[(i + n) & 1] and s[i] != s2[(i + n) & 1]:\n                        min_str.remove(s1)\n                        min_str.remove(s2)\n            max_str = [\"0\" * n, \"1\" * n]\n            min_str = [\"0\" * n, \"1\" * n]\n        ans = n\n        for s1 in max_str:\n            for s2 in min_str:\n                cnt = 0\n                for i in range(n):\n                    if s[i] != s1[i & 1]:\n                        cnt += 1\n                    if s[i] != s2[i & 1]:\n                        cnt += 1\n                ans = min(ans, cnt)\n        return ans",
    "efficient_solution": "class Solution:\n    def minFlips(self, s: str) -> int:\n        n = len(s)\n        target = \"01\"\n        cnt = sum(c != target[i & 1] for i, c in enumerate(s))\n        ans = min(cnt, n - cnt)\n        for i in range(n):\n            cnt -= s[i] != target[i & 1]\n            cnt += s[i] != target[(i + n) & 1]\n            ans = min(ans, cnt, n - cnt)\n        return ans\n",
    "model_generation": "### Efficient Solution\n\n```python\nclass Solution:\n    def minFlips(self, s: str) -> int:\n        n = len(s)\n        max_str = [\"0\" * n, \"1\" * n]\n        min_str = [\"0\" * n, \"1\" * n]\n        \n        for i in range(n):\n            if s[i] == '0':\n                max_str.append(\"0\" * i + \"1\" * (n - i - 1))\n                min_str.append(\"1\" * i + \"0\" * (n - i - 1))\n            else:\n                max_str.append(\"1\" * i + \"0\" * (n - i - 1))\n                min_str.append(\"0\" * i + \"1\" * (n - i - 1))\n        \n        ans = float('inf')\n        for s1 in max_str:\n            for s2 in min_str:\n                cnt = 0\n                for i in range(n):\n                    if s1[i] != s[i]:\n                        cnt += 1\n                    if s2[i] != s[i]:\n                        cnt += 1\n                ans = min(ans, cnt)\n        \n        return ans\n```\n\n### Explanation\n\nThe goal is to find the minimum number of flips required to make the string alternating.\n\n1. We start with the base cases where the string is already alternating (all zeros or all ones).\n2. We then generate all possible strings of the same length as the input string by flipping the first character and appending it to the end.\n3. We iterate over the generated strings and for each string, we calculate the number of flips required to make it alternating.\n4. We keep track of the minimum number of flips required.\n\nHowever, this approach still has a high time complexity due to the generation of all possible strings.\n\n### Better Approach\n\nWe can use a more efficient approach by maintaining a counter for the number of flips required to make the string alternating.\n\n1. Initialize two counters, `one` and `zero`, to 0.\n2. Iterate over the input string. For each character, increment the corresponding counter (one if the character is '1', zero if the character is '0').\n3. If the counters are different, we need to flip the character at the end of the string to make it alternating. We increment the counter that is closer to the length of the string.\n4. Return the maximum of the two counters as the minimum number of flips required.\n\nHere is the updated code:\n\n```python\nclass Solution:\n    def minFlips(self, s: str) -> int:\n        n = len(s)\n        one, zero = 0, 0\n        \n        for i in range(n):\n            if s[i] == '1':\n                one += 1\n            else:\n                zero += 1\n        \n        ans = max(one, zero)\n        \n        for i in range(n - 1):\n            if s[i] == s[i + 1]:\n                if s[i] == '1':\n                    one -= 1\n                else:\n                    zero -= 1\n                if s[i] == '0':\n                    one += 1\n                else:\n                    zero += 1\n                ans = min(ans, max(one, zero))\n        \n        return ans\n```\n\nThis approach has a time complexity of O(n), making it more efficient than the previous approaches.",
    "model_solution": "class Solution:\n    def minFlips(self, s: str) -> int:\n        n = len(s)\n        max_str = [\"0\" * n, \"1\" * n]\n        min_str = [\"0\" * n, \"1\" * n]\n        \n        for i in range(n):\n            if s[i] == '0':\n                max_str.append(\"0\" * i + \"1\" * (n - i - 1))\n                min_str.append(\"1\" * i + \"0\" * (n - i - 1))\n            else:\n                max_str.append(\"1\" * i + \"0\" * (n - i - 1))\n                min_str.append(\"0\" * i + \"1\" * (n - i - 1))\n        \n        ans = float('inf')\n        for s1 in max_str:\n            for s2 in min_str:\n                cnt = 0\n                for i in range(n):\n                    if s1[i] != s[i]:\n                        cnt += 1\n                    if s2[i] != s[i]:\n                        cnt += 1\n                ans = min(ans, cnt)\n        \n        return ans",
    "is_python": true
}