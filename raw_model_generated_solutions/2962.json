{
    "problem_idx": "2962",
    "description": "\nYou are given an integer array `nums` and a **positive** integer `k`.\n\n\nReturn *the number of subarrays where the **maximum** element of* `nums` *appears **at least*** `k` *times in that subarray.*\n\n\nA **subarray** is a contiguous sequence of elements within an array.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** nums = [1,3,2,3,3], k = 2\n**Output:** 6\n**Explanation:** The subarrays that contain the element 3 at least 2 times are: [1,3,2,3], [1,3,2,3,3], [3,2,3], [3,2,3,3], [2,3,3] and [3,3].\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** nums = [1,4,2,1], k = 3\n**Output:** 0\n**Explanation:** No subarray contains the element 4 at least 3 times.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= nums.length <= 105`\n* `1 <= nums[i] <= 106`\n* `1 <= k <= 105`\n\n\n",
    "inefficient_solution": "class Solution:\n    def countSubarrays(self, nums: List[int], k: int) -> int:\n        mx = max(nums)\n        n = len(nums)\n        ans = 0\n        for i in range(n):\n            cnt = 0\n            subarray = []\n            for j in range(i, n):\n                subarray.append(nums[j])\n                if nums[j] == mx:\n                    cnt += 1\n                if cnt < k:\n                    subarray = []\n                    continue\n                ans += 1\n        return ans",
    "efficient_solution": "class Solution:\n    def countSubarrays(self, nums: List[int], k: int) -> int:\n        mx = max(nums)\n        n = len(nums)\n        ans = cnt = j = 0\n        for x in nums:\n            while j < n and cnt < k:\n                cnt += nums[j] == mx\n                j += 1\n            if cnt < k:\n                break\n            ans += n - j + 1\n            cnt -= x == mx\n        return ans\n",
    "model_generation": "### Efficient Solution:\n\nThe provided inefficient solution has a time complexity of O(n^2) due to the nested loops. We can optimize it by using a hash map to store the frequency of each element in the current subarray. This way, we can skip the inner loop and directly check if the maximum frequency of the maximum element in the subarray meets the condition.\n\nHere is the efficient solution:\n\n```python\nfrom typing import List\n\nclass Solution:\n    def countSubarrays(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        max_val = max(nums)\n        max_freq = nums.count(max_val)\n        \n        # Initialize the hash map to store the frequency of each element in the subarray\n        freq_map = {0: 1}\n        max_freq_in_subarray = 0\n        left = 0\n        count = 0\n        \n        # Traverse the array\n        for right in range(n):\n            # Update the frequency of the current element in the subarray\n            if nums[right] == max_val:\n                max_freq_in_subarray += 1\n            \n            # Update the hash map\n            freq_map[max_freq_in_subarray] = freq_map.get(max_freq_in_subarray, 0) + 1\n        \n        # Count the subarrays that satisfy the condition\n        for max_freq_in_subarray in range(max_freq, n + 1):\n            count += freq_map.get(max_freq_in_subarray, 0)\n        \n        return count\n```\n\n### Time Complexity:\n\nThe time complexity of this efficient solution is O(n), where n is the length of the input array. This is because we make a single pass through the array and use the hash map to store the frequency of each element in the subarray.\n\n### Space Complexity:\n\nThe space complexity of this efficient solution is O(n), where n is the length of the input array. This is because in the worst case, we need to store the frequency of each element in the subarray in the hash map.",
    "model_solution": "from typing import List\n\nclass Solution:\n    def countSubarrays(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        max_val = max(nums)\n        max_freq = nums.count(max_val)\n        \n        # Initialize the hash map to store the frequency of each element in the subarray\n        freq_map = {0: 1}\n        max_freq_in_subarray = 0\n        left = 0\n        count = 0\n        \n        # Traverse the array\n        for right in range(n):\n            # Update the frequency of the current element in the subarray\n            if nums[right] == max_val:\n                max_freq_in_subarray += 1\n            \n            # Update the hash map\n            freq_map[max_freq_in_subarray] = freq_map.get(max_freq_in_subarray, 0) + 1\n        \n        # Count the subarrays that satisfy the condition\n        for max_freq_in_subarray in range(max_freq, n + 1):\n            count += freq_map.get(max_freq_in_subarray, 0)\n        \n        return count",
    "is_python": true
}