{
    "problem_idx": "1876",
    "description": "\nA string is **good** if there are no repeated characters.\n\n\nGiven a string `s`\u200b\u200b\u200b\u200b\u200b, return *the number of **good substrings** of length **three** in* `s`\u200b\u200b\u200b\u200b\u200b\u200b.\n\n\nNote that if there are multiple occurrences of the same substring, every occurrence should be counted.\n\n\nA **substring** is a contiguous sequence of characters in a string.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** s = \"xyzzaz\"\n**Output:** 1\n**Explanation:** There are 4 substrings of size 3: \"xyz\", \"yzz\", \"zza\", and \"zaz\". \nThe only good substring of length 3 is \"xyz\".\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** s = \"aababcabc\"\n**Output:** 4\n**Explanation:** There are 7 substrings of size 3: \"aab\", \"aba\", \"bab\", \"abc\", \"bca\", \"cab\", and \"abc\".\nThe good substrings are \"abc\", \"bca\", \"cab\", and \"abc\".\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= s.length <= 100`\n* `s`\u200b\u200b\u200b\u200b\u200b\u200b consists of lowercase English letters.\n\n\n",
    "inefficient_solution": "class Solution:\n    def countGoodSubstrings(self, s: str) -> int:\n        count = 0\n        for i in range(len(s) - 2):\n            substring = s[i:i+3]\n            substring_set = set(substring)\n            if len(substring_set) == 3:\n                count += 1\n        return count",
    "efficient_solution": "class Solution:\n    def countGoodSubstrings(self, s: str) -> int:\n        count, n = 0, len(s)\n        for i in range(n - 2):\n            count += s[i] != s[i + 1] and s[i] != s[i + 2] and s[i + 1] != s[i + 2]\n        return count\n",
    "model_generation": "### Efficient Solution\n\nWe can improve the efficiency of the solution by using a sliding window approach and a set to keep track of the unique characters in the current substring. This way, we don't need to recreate the set for each substring.\n\n```python\nclass Solution:\n    def countGoodSubstrings(self, s: str) -> int:\n        count = 0\n        char_set = set()\n        \n        for i in range(len(s) - 2):\n            # Remove the leftmost character from the set\n            if len(char_set) == 3:\n                count += 1\n            char_set.discard(s[i])\n            # Add the new character to the set\n            char_set.add(s[i+2])\n        \n        return count\n```\n\n### Explanation\n\n1. We maintain a set `char_set` to store the unique characters in the current substring.\n2. We iterate over the string, but instead of considering substrings of length 3, we consider each character as the start of a potential substring of length 3.\n3. For each character, we remove the leftmost character from the set (if it exists) to simulate the sliding window effect.\n4. We add the new character to the set to keep track of the unique characters in the current substring.\n5. If the set contains exactly 3 unique characters, it means we have found a good substring of length 3, so we increment the count.\n6. Finally, we return the count of good substrings.\n\nThis solution has a time complexity of O(n), where n is the length of the string, because we are iterating over the string once and performing constant-time operations for each character. The space complexity is also O(n) because in the worst case, we might need to store all characters in the set.",
    "model_solution": "class Solution:\n    def countGoodSubstrings(self, s: str) -> int:\n        count = 0\n        char_set = set()\n        \n        for i in range(len(s) - 2):\n            # Remove the leftmost character from the set\n            if len(char_set) == 3:\n                count += 1\n            char_set.discard(s[i])\n            # Add the new character to the set\n            char_set.add(s[i+2])\n        \n        return count",
    "is_python": true
}