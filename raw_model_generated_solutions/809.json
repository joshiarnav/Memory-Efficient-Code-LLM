{
    "problem_idx": "809",
    "description": "\nSometimes people repeat letters to represent extra feeling. For example:\n\n\n* `\"hello\" -> \"heeellooo\"`\n* `\"hi\" -> \"hiiii\"`\n\n\nIn these strings like `\"heeellooo\"`, we have groups of adjacent letters that are all the same: `\"h\"`, `\"eee\"`, `\"ll\"`, `\"ooo\"`.\n\n\nYou are given a string `s` and an array of query strings `words`. A query word is **stretchy** if it can be made to be equal to `s` by any number of applications of the following extension operation: choose a group consisting of characters `c`, and add some number of characters `c` to the group so that the size of the group is **three or more**.\n\n\n* For example, starting with `\"hello\"`, we could do an extension on the group `\"o\"` to get `\"hellooo\"`, but we cannot get `\"helloo\"` since the group `\"oo\"` has a size less than three. Also, we could do another extension like `\"ll\" -> \"lllll\"` to get `\"helllllooo\"`. If `s = \"helllllooo\"`, then the query word `\"hello\"` would be **stretchy** because of these two extension operations: `query = \"hello\" -> \"hellooo\" -> \"helllllooo\" = s`.\n\n\nReturn *the number of query strings that are **stretchy***.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** s = \"heeellooo\", words = [\"hello\", \"hi\", \"helo\"]\n**Output:** 1\n**Explanation:** \nWe can extend \"e\" and \"o\" in the word \"hello\" to get \"heeellooo\".\nWe can't extend \"helo\" to get \"heeellooo\" because the group \"ll\" is not size 3 or more.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** s = \"zzzzzyyyyy\", words = [\"zzyy\",\"zy\",\"zyy\"]\n**Output:** 3\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= s.length, words.length <= 100`\n* `1 <= words[i].length <= 100`\n* `s` and `words[i]` consist of lowercase letters.\n\n\n",
    "inefficient_solution": "class Solution:\n    def expressiveWords(self, s: str, words: List[str]) -> int:\n        def check(s, t):\n            m, n = len(s), len(t)\n            if n > m:\n                return False\n            i = j = 0\n            while i < m and j < n:\n                if s[i] != t[j]:\n                    return False\n                k = i\n                while k < m and s[k] == s[i]:\n                    k += 1\n                c1 = k - i\n                i, k = k, j\n                while k < n and t[k] == t[j]:\n                    k += 1\n                c2 = k - j\n                j = k\n                if c1 < c2 or (c1 < 3 and c1 != c2):\n                    return False\n            return (i == m or all(s[i] == s[i+1] and s[i] != s[i+2] for i in range(i, m))) and (j == n or all(t[j] == t[j+1] and t[j] != t[j+2] for j in range(j, n)))\n\n        return sum(check(s, t) for t in words)",
    "efficient_solution": "class Solution:\n    def expressiveWords(self, s: str, words: List[str]) -> int:\n        def check(s, t):\n            m, n = len(s), len(t)\n            if n > m:\n                return False\n            i = j = 0\n            while i < m and j < n:\n                if s[i] != t[j]:\n                    return False\n                k = i\n                while k < m and s[k] == s[i]:\n                    k += 1\n                c1 = k - i\n                i, k = k, j\n                while k < n and t[k] == t[j]:\n                    k += 1\n                c2 = k - j\n                j = k\n                if c1 < c2 or (c1 < 3 and c1 != c2):\n                    return False\n            return i == m and j == n\n\n        return sum(check(s, t) for t in words)\n",
    "model_generation": "### Efficient Solution\n\n```python\nclass Solution:\n    def expressiveWords(self, s: str, words: List[str]) -> int:\n        def check(s, t):\n            m, n = len(s), len(t)\n            if n > m or s != t:\n                return False\n            i, j = 0, 0\n            while i < m and j < n:\n                if s[i] != t[j]:\n                    return False\n                k = i\n                while k < m and s[k] == s[i]:\n                    k += 1\n                c1 = k - i\n                i, k = k, j\n                while k < n and t[k] == t[j]:\n                    k += 1\n                c2 = k - j\n                j = k\n                if c1 < c2 or (c1 < 3 and c1 != c2):\n                    return False\n            return (i == m and j == n)\n\n        return sum(check(s, t) for t in words)\n```\n\nHowever, the above solution can be further optimized. The condition `i == m and j == n` can be separated as two conditions `i == m` and `j == n` because both are independent. Here is the optimized solution:\n\n```python\nclass Solution:\n    def expressiveWords(self, s: str, words: List[str]) -> int:\n        def check(s, t):\n            m, n = len(s), len(t)\n            if n > m or s != t:\n                return False\n            i, j = 0, 0\n            while i < m and j < n:\n                if s[i] != t[j]:\n                    return False\n                k = i\n                while k < m and s[k] == s[i]:\n                    k += 1\n                c1 = k - i\n                i, k = k, j\n                while k < n and t[k] == t[j]:\n                    k += 1\n                c2 = k - j\n                j = k\n                if c1 < c2 or (c1 < 3 and c1 != c2):\n                    return False\n            return i == m and j == n\n\n        return sum(check(s, t) for t in words)\n```\n\nBut still, the solution can be optimized further, we can stop checking `s` and `t` once we find a mismatch because if `s` and `t` are equal up to some point, and if there are still characters left in `s` and `t`, it means that they are not equal. Here is the most optimized solution:\n\n```python\nclass Solution:\n    def expressiveWords(self, s: str, words: List[str]) -> int:\n        def check(s, t):\n            m, n = len(s), len(t)\n            if n > m:\n                return False\n            i, j = 0, 0\n            while i < m and j < n:\n                if s[i] != t[j]:\n                    return False\n                k = i\n                while k < m and s[k] == s[i]:\n                    k += 1\n                c1 = k - i\n                i, k = k, j\n                while k < n and t[k] == t[j]:\n                    k += 1\n                c2 = k - j\n                j = k\n                if c1 < c2 or (c1 < 3 and c1 != c2):\n                    return False\n            return i == m\n\n        return sum(check(s, t) for t in words)\n```\n\nNote: The above optimized solution assumes that `s` and `t` are equal up to some point and there are still characters left in `t` means that they are not equal. This assumption is valid because if `s` and `t` are equal up to some point and there are still characters left in `t`, it means that `t` has some extra characters which are not present in `s`.",
    "model_solution": "class Solution:\n    def expressiveWords(self, s: str, words: List[str]) -> int:\n        def check(s, t):\n            m, n = len(s), len(t)\n            if n > m or s != t:\n                return False\n            i, j = 0, 0\n            while i < m and j < n:\n                if s[i] != t[j]:\n                    return False\n                k = i\n                while k < m and s[k] == s[i]:\n                    k += 1\n                c1 = k - i\n                i, k = k, j\n                while k < n and t[k] == t[j]:\n                    k += 1\n                c2 = k - j\n                j = k\n                if c1 < c2 or (c1 < 3 and c1 != c2):\n                    return False\n            return (i == m and j == n)\n\n        return sum(check(s, t) for t in words)",
    "is_python": true
}