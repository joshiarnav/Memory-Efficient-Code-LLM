{
    "problem_idx": "2193",
    "description": "\nYou are given a string `s` consisting only of lowercase English letters.\n\n\nIn one **move**, you can select any two **adjacent** characters of `s` and swap them.\n\n\nReturn *the **minimum number of moves** needed to make* `s` *a palindrome*.\n\n\n**Note** that the input will be generated such that `s` can always be converted to a palindrome.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** s = \"aabb\"\n**Output:** 2\n**Explanation:**\nWe can obtain two palindromes from s, \"abba\" and \"baab\". \n- We can obtain \"abba\" from s in 2 moves: \"a**ab**b\" -> \"ab**ab**\" -> \"abba\".\n- We can obtain \"baab\" from s in 2 moves: \"a**ab**b\" -> \"**ab**ab\" -> \"baab\".\nThus, the minimum number of moves needed to make s a palindrome is 2.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** s = \"letelt\"\n**Output:** 2\n**Explanation:**\nOne of the palindromes we can obtain from s in 2 moves is \"lettel\".\nOne of the ways we can obtain it is \"lete**lt**\" -> \"let**et**l\" -> \"lettel\".\nOther palindromes such as \"tleelt\" can also be obtained in 2 moves.\nIt can be shown that it is not possible to obtain a palindrome in less than 2 moves.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= s.length <= 2000`\n* `s` consists only of lowercase English letters.\n* `s` can be converted to a palindrome using a finite number of moves.\n\n\n",
    "inefficient_solution": "class Solution:\n    def minMovesToMakePalindrome(self, s: str) -> int:\n        cs = list(s)\n        ans = 0\n        for i in range(len(s) // 2):\n            for j in range(i, len(s) // 2 + 1):\n                if cs[i] == cs[j]:\n                    temp = cs[i: j + 1]\n                    cs[i: j + 1] = cs[j: i: -1]\n                    for k in range(j, i, -1):\n                        cs[k], cs[k - 1] = cs[k - 1], cs[k]\n                    ans += len(temp) - 1\n                    break\n            else:\n                temp = cs[i: len(s) // 2 + 1]\n                cs[i: len(s) // 2 + 1] = cs[len(s) // 2: i: -1]\n                for k in range(len(s) // 2, i - 1, -1):\n                    cs[k], cs[k - 1] = cs[k - 1], cs[k]\n                ans += len(temp) - 1\n                break\n        return ans",
    "efficient_solution": "class Solution:\n    def minMovesToMakePalindrome(self, s: str) -> int:\n        cs = list(s)\n        ans, n = 0, len(s)\n        i, j = 0, n - 1\n        while i < j:\n            even = False\n            for k in range(j, i, -1):\n                if cs[i] == cs[k]:\n                    even = True\n                    while k < j:\n                        cs[k], cs[k + 1] = cs[k + 1], cs[k]\n                        k += 1\n                        ans += 1\n                    j -= 1\n                    break\n            if not even:\n                ans += n // 2 - i\n            i += 1\n        return ans\n",
    "model_generation": "### Efficient Solution\n\nTo improve the solution, we can use a different approach that avoids the unnecessary swapping and modification of the input string. Instead, we can use a stack to keep track of the characters that don't match the prefix of the string when considering the string as a palindrome.\n\n```python\nclass Solution:\n    def minMovesToMakePalindrome(self, s: str) -> int:\n        n = len(s)\n        left = 0\n        ans = 0\n        for right in range(1, n):\n            if s[right] == s[left]:\n                left += 1\n            else:\n                # If the stack is not empty and the top of the stack is equal to the character at the right index,\n                # we don't need to pop it. We can just increment the left pointer to match the character at the right index.\n                if left > 0 and s[right] == s[left - 1]:\n                    left -= 1\n                else:\n                    # If the stack is empty or the top of the stack is not equal to the character at the right index,\n                    # we need to pop all characters from the stack that are greater than the character at the right index.\n                    while left > 0 and s[right] < s[left - 1]:\n                        left -= 1\n                    # Push the character at the right index onto the stack.\n                    left += 1\n                # Increment the answer by the difference between the current right index and the left index.\n                ans += right - left + 1\n        # Return the answer.\n        return ans\n```\n\nThis solution has a time complexity of O(n) and a space complexity of O(1), where n is the length of the string. It avoids unnecessary swapping and modification of the input string, making it more efficient than the original solution.",
    "model_solution": "class Solution:\n    def minMovesToMakePalindrome(self, s: str) -> int:\n        n = len(s)\n        left = 0\n        ans = 0\n        for right in range(1, n):\n            if s[right] == s[left]:\n                left += 1\n            else:\n                # If the stack is not empty and the top of the stack is equal to the character at the right index,\n                # we don't need to pop it. We can just increment the left pointer to match the character at the right index.\n                if left > 0 and s[right] == s[left - 1]:\n                    left -= 1\n                else:\n                    # If the stack is empty or the top of the stack is not equal to the character at the right index,\n                    # we need to pop all characters from the stack that are greater than the character at the right index.\n                    while left > 0 and s[right] < s[left - 1]:\n                        left -= 1\n                    # Push the character at the right index onto the stack.\n                    left += 1\n                # Increment the answer by the difference between the current right index and the left index.\n                ans += right - left + 1\n        # Return the answer.\n        return ans",
    "is_python": true
}