{
    "problem_idx": "2517",
    "description": "\nYou are given an array of positive integers `price` where `price[i]` denotes the price of the `ith` candy and a positive integer `k`.\n\n\nThe store sells baskets of `k` **distinct** candies. The **tastiness** of a candy basket is the smallest absolute difference of the **prices** of any two candies in the basket.\n\n\nReturn *the **maximum** tastiness of a candy basket.*\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** price = [13,5,1,8,21,2], k = 3\n**Output:** 8\n**Explanation:** Choose the candies with the prices [13,5,21].\nThe tastiness of the candy basket is: min(|13 - 5|, |13 - 21|, |5 - 21|) = min(8, 8, 16) = 8.\nIt can be proven that 8 is the maximum tastiness that can be achieved.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** price = [1,3,1], k = 2\n**Output:** 2\n**Explanation:** Choose the candies with the prices [1,3].\nThe tastiness of the candy basket is: min(|1 - 3|) = min(2) = 2.\nIt can be proven that 2 is the maximum tastiness that can be achieved.\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** price = [7,7,7,7], k = 2\n**Output:** 0\n**Explanation:** Choosing any two distinct candies from the candies we have will result in a tastiness of 0.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `2 <= k <= price.length <= 105`\n* `1 <= price[i] <= 109`\n\n\n",
    "inefficient_solution": "class Solution:\n    def maximumTastiness(self, price: List[int], k: int) -> int:\n        price_copy = price[:]\n        for _ in range(len(price)):\n            price_copy.sort()\n        def check(x: int) -> bool:\n            price_copy.sort()\n            cnt, pre = 0, -x\n            for cur in price_copy:\n                if cur - pre >= x:\n                    pre = cur\n                    cnt += 1\n            return cnt >= k\n\n        price_copy.sort(reverse=True)\n        l, r = 0, price_copy[0] - price_copy[-1]\n        while l < r:\n            mid = (l + r + 1) >> 1\n            if check(mid):\n                l = mid\n            else:\n                r = mid - 1\n        return l\n\n        price = []\n        for _ in range(len(price_copy)):\n            price.append(price_copy[0])\n            price_copy.pop(0)\n        price.sort(reverse=True)\n        l, r = 0, price[0] - price[-1]\n        while l < r:\n            mid = (l + r + 1) >> 1\n            if check(mid):\n                l = mid\n            else:\n                r = mid - 1\n        return l",
    "efficient_solution": "class Solution:\n    def maximumTastiness(self, price: List[int], k: int) -> int:\n        def check(x: int) -> bool:\n            cnt, pre = 0, -x\n            for cur in price:\n                if cur - pre >= x:\n                    pre = cur\n                    cnt += 1\n            return cnt >= k\n\n        price.sort()\n        l, r = 0, price[-1] - price[0]\n        while l < r:\n            mid = (l + r + 1) >> 1\n            if check(mid):\n                l = mid\n            else:\n                r = mid - 1\n        return l\n",
    "model_generation": "To solve the problem efficiently, we can use a different approach that doesn't involve sorting the entire list multiple times. We can use a two-pointer technique to find all possible pairs of distinct candies and then find the maximum t tastiness.\n\nHowever, since the candies are distinct and the order of the candies does not matter, we can simply sort the list of prices and then use a sliding window approach to find all possible pairs of distinct candies.\n\nHere's the efficient solution in Python:\n\n```python\nfrom typing import List\n\nclass Solution:\n    def maximumTastiness(self, price: List[int], k: int) -> int:\n        price.sort()\n        left, right = 0, price[-1] - price[0]\n        while left <= right:\n            mid = (left + right) // 2\n            valid = True\n            prev_price = price[0]\n            count = 1\n            for i in range(1, len(price)):\n                if price[i] - prev_price >= mid:\n                    count += 1\n                    prev_price = price[i]\n                    if count == k:\n                        break\n                else:\n                    valid = False\n                    break\n            if valid and count == k:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return right\n```\n\nThis solution has a time complexity of O(n log n) due to the sorting, where n is the number of candies. The while loop has a time complexity of O(n) in the worst case, but since the loop is inside the sorting, the overall time complexity remains O(n log n).\n\nThis solution picks the largest possible tastiness as the answer, which is the maximum tastiness of a candy basket that can be achieved.",
    "model_solution": "from typing import List\n\nclass Solution:\n    def maximumTastiness(self, price: List[int], k: int) -> int:\n        price.sort()\n        left, right = 0, price[-1] - price[0]\n        while left <= right:\n            mid = (left + right) // 2\n            valid = True\n            prev_price = price[0]\n            count = 1\n            for i in range(1, len(price)):\n                if price[i] - prev_price >= mid:\n                    count += 1\n                    prev_price = price[i]\n                    if count == k:\n                        break\n                else:\n                    valid = False\n                    break\n            if valid and count == k:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return right",
    "is_python": true
}