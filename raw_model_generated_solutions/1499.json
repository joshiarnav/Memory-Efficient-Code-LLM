{
    "problem_idx": "1499",
    "description": "\nYou are given an array `points` containing the coordinates of points on a 2D plane, sorted by the x-values, where `points[i] = [xi, yi]` such that `xi < xj` for all `1 <= i < j <= points.length`. You are also given an integer `k`.\n\n\nReturn *the maximum value of the equation* `yi + yj + |xi - xj|` where `|xi - xj| <= k` and `1 <= i < j <= points.length`.\n\n\nIt is guaranteed that there exists at least one pair of points that satisfy the constraint `|xi - xj| <= k`.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** points = [[1,3],[2,0],[5,10],[6,-10]], k = 1\n**Output:** 4\n**Explanation:** The first two points satisfy the condition |xi - xj| <= 1 and if we calculate the equation we get 3 + 0 + |1 - 2| = 4. Third and fourth points also satisfy the condition and give a value of 10 + -10 + |5 - 6| = 1.\nNo other pairs satisfy the condition, so we return the max of 4 and 1.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** points = [[0,0],[3,0],[9,2]], k = 3\n**Output:** 3\n**Explanation:** Only the first two points have an absolute difference of 3 or less in the x-values, and give the value of 0 + 0 + |0 - 3| = 3.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `2 <= points.length <= 105`\n* `points[i].length == 2`\n* `-108 <= xi, yi <= 108`\n* `0 <= k <= 2 * 108`\n* `xi < xj` for all `1 <= i < j <= points.length`\n* `xi` form a strictly increasing sequence.\n\n\n",
    "inefficient_solution": "from collections import deque\n\nclass Solution:\n    def findMaxValueOfEquation(self, points, k):\n        ans = -float('inf')\n        q = deque()\n        for x, y in points:\n            while len(q) >= 1 and x - q[0][0] > k:\n                q.popleft()\n            if len(q) >= 1:\n                ans = max(ans, x + y + q[0][1] - q[0][0])\n            while len(q) >= 1 and y - x >= q[-1][1] - q[-1][0]:\n                q.pop()\n            q.append((x, y))\n        for _ in range(len(points)):\n            q.append((0, 0))\n        q.popleft()\n        q.append((0, 0))\n        q.popleft()\n        for _ in range(len(points)):\n            q.append((0, 0))\n        q.popleft()\n        q.append((0, 0))\n        q.popleft()\n        for _ in range(len(points)):\n            q.append((0, 0))\n        q.popleft()\n        q.append((0, 0))\n        q.popleft()\n        for _ in range(len(points)):\n            q.append((0, 0))\n        q.popleft()\n        return ans",
    "efficient_solution": "class Solution:\n    def findMaxValueOfEquation(self, points: List[List[int]], k: int) -> int:\n        ans = -inf\n        q = deque()\n        for x, y in points:\n            while q and x - q[0][0] > k:\n                q.popleft()\n            if q:\n                ans = max(ans, x + y + q[0][1] - q[0][0])\n            while q and y - x >= q[-1][1] - q[-1][0]:\n                q.pop()\n            q.append((x, y))\n        return ans\n",
    "model_generation": "Here is the efficient solution:\n\n```python\nfrom sortedcontainers import SortedList\n\nclass Solution:\n    def findMaxValueOfEquation(self, points, k):\n        ans = -float('inf')\n        sl = SortedList()\n        for x, y in points:\n            while len(sl) >= 1 and x - sl[0][0] > k:\n                sl.pop(0)\n            if len(sl) >= 1:\n                ans = max(ans, x + y + sl[0][1] - sl[0][0])\n            sl.add((y-x, x))\n        return ans\n```\n\nIn this solution, we use `SortedList` from the `sortedcontainers` library, which is a sorted list that allows efficient insertion and removal of elements. We initialize an empty `SortedList` and iterate over the points. For each point, we remove all points in the list that are more than `k` units away. We then check if the list is not empty, and if it's not, we update the answer with the maximum value of the equation. We then add the point to the list, where the point is represented as `(y-x, x)`, and `y-x` is used as the primary key, so that points with larger `y-x` values will be placed after points with smaller `y-x` values, which ensures that the point with the maximum `y-x` value that is closest to the current point is always at the beginning of the list.\n\nThis solution runs in O(n log n) time, where n is the number of points, because each insertion and removal operation in the `SortedList` takes O(log n) time. The space complexity is O(n) because in the worst case, we may need to store all points in the `SortedList`.",
    "model_solution": "from sortedcontainers import SortedList\n\nclass Solution:\n    def findMaxValueOfEquation(self, points, k):\n        ans = -float('inf')\n        sl = SortedList()\n        for x, y in points:\n            while len(sl) >= 1 and x - sl[0][0] > k:\n                sl.pop(0)\n            if len(sl) >= 1:\n                ans = max(ans, x + y + sl[0][1] - sl[0][0])\n            sl.add((y-x, x))\n        return ans",
    "is_python": true
}