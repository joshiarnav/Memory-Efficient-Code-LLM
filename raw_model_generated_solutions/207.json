{
    "problem_idx": "207",
    "description": "\nThere are a total of `numCourses` courses you have to take, labeled from `0` to `numCourses - 1`. You are given an array `prerequisites` where `prerequisites[i] = [ai, bi]` indicates that you **must** take course `bi` first if you want to take course `ai`.\n\n\n* For example, the pair `[0, 1]`, indicates that to take course `0` you have to first take course `1`.\n\n\nReturn `true` if you can finish all courses. Otherwise, return `false`.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** numCourses = 2, prerequisites = [[1,0]]\n**Output:** true\n**Explanation:** There are a total of 2 courses to take. \nTo take course 1 you should have finished course 0. So it is possible.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** numCourses = 2, prerequisites = [[1,0],[0,1]]\n**Output:** false\n**Explanation:** There are a total of 2 courses to take. \nTo take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= numCourses <= 2000`\n* `0 <= prerequisites.length <= 5000`\n* `prerequisites[i].length == 2`\n* `0 <= ai, bi < numCourses`\n* All the pairs prerequisites[i] are **unique**.\n\n\n",
    "inefficient_solution": "class Solution:\n    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\n        g = [[] for _ in range(numCourses)]\n        indeg = [0] * numCourses\n        for _ in range(len(prerequisites)):\n            a, b = prerequisites[_]\n            g[b] = list(set(g[b] + [a]))\n            indeg[a] += 1\n        cnt = 0\n        q = deque(i for i, x in enumerate(indeg) if x == 0)\n        while q:\n            i = q.popleft()\n            cnt += 1\n            for j in g[i]:\n                temp_g = g[j].copy()\n                g[j] = []\n                for k in temp_g:\n                    g[k].append(j)\n                    indeg[k] += 1\n                if indeg[j] == 0:\n                    q.append(j)\n        return cnt == numCourses",
    "efficient_solution": "class Solution:\n    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\n        g = defaultdict(list)\n        indeg = [0] * numCourses\n        for a, b in prerequisites:\n            g[b].append(a)\n            indeg[a] += 1\n        cnt = 0\n        q = deque(i for i, x in enumerate(indeg) if x == 0)\n        while q:\n            i = q.popleft()\n            cnt += 1\n            for j in g[i]:\n                indeg[j] -= 1\n                if indeg[j] == 0:\n                    q.append(j)\n        return cnt == numCourses\n",
    "model_generation": "### Efficient Solution\n\nWe can use a Topological Sort to solve this problem efficiently. The idea is to start with all courses and then remove one course at a time if it does not have any prerequisites. If we can remove all courses, it means that it is possible to finish all courses.\n\nHere is the efficient solution in Python:\n\n```python\nfrom collections import deque\nfrom typing import List\n\nclass Solution:\n    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\n        # Create a graph and a map for in-degree\n        g = [[] for _ in range(numCourses)]\n        indeg = [0] * numCourses\n        \n        # Build the graph and in-degree map\n        for a, b in prerequisites:\n            g[b].append(a)\n            indeg[a] += 1\n        \n        # Initialize a queue with courses that have no prerequisites\n        q = deque(i for i, x in enumerate(indeg) if x == 0)\n        \n        # Remove one course at a time if it does not have any prerequisites\n        while q:\n            i = q.popleft()\n            for j in g[i]:\n                indeg[j] -= 1\n                if indeg[j] == 0:\n                    q.append(j)\n        \n        # If we can remove all courses, it means that it is possible to finish all courses\n        return all(x == 0 for x in indeg)\n```\n\nThis solution has a time complexity of O(n + m), where n is the number of courses and m is the number of prerequisites. This is because we are traversing the graph once to build the graph and in-degree map, and then once again to remove one course at a time if it does not have any prerequisites. The space complexity is also O(n + m), which is used to store the graph and the in-degree map.\n\n### Explanation\n\nThe idea behind this solution is to use a Topological Sort to solve the problem. We start with all courses and then remove one course at a time if it does not have any prerequisites. If we can remove all courses, it means that it is possible to finish all courses.\n\nWe use a graph and a map for in-degree to represent the prerequisites and in-degrees of each course. We then build the graph and in-degree map by iterating over the prerequisites. We initialize a queue with courses that have no prerequisites, and then we remove one course at a time if it does not have any prerequisites. We update the in-degrees of the courses that are prerequisites of the removed course, and if a course has no prerequisites, we add it to the queue. We repeat this process until the queue is empty.\n\nFinally, we check if all courses have been removed, and if so, we return True. Otherwise, we return False.\n\n### Example Use Cases\n\n* If we have 2 courses and the prerequisites are [[1, 0]], we can finish all courses, so the function returns True.\n* If we have 2 courses and the prerequisites are [[1, 0], [0, 1]], we cannot finish all courses, so the function returns False.",
    "model_solution": "from collections import deque\nfrom typing import List\n\nclass Solution:\n    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\n        # Create a graph and a map for in-degree\n        g = [[] for _ in range(numCourses)]\n        indeg = [0] * numCourses\n        \n        # Build the graph and in-degree map\n        for a, b in prerequisites:\n            g[b].append(a)\n            indeg[a] += 1\n        \n        # Initialize a queue with courses that have no prerequisites\n        q = deque(i for i, x in enumerate(indeg) if x == 0)\n        \n        # Remove one course at a time if it does not have any prerequisites\n        while q:\n            i = q.popleft()\n            for j in g[i]:\n                indeg[j] -= 1\n                if indeg[j] == 0:\n                    q.append(j)\n        \n        # If we can remove all courses, it means that it is possible to finish all courses\n        return all(x == 0 for x in indeg)",
    "is_python": true
}