{
    "problem_idx": "35",
    "description": "\nGiven a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n\n\nYou must\u00a0write an algorithm with\u00a0`O(log n)` runtime complexity.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** nums = [1,3,5,6], target = 5\n**Output:** 2\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** nums = [1,3,5,6], target = 2\n**Output:** 1\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** nums = [1,3,5,6], target = 7\n**Output:** 4\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= nums.length <= 104`\n* `-104 <= nums[i] <= 104`\n* `nums` contains **distinct** values sorted in **ascending** order.\n* `-104 <= target <= 104`\n\n\n",
    "inefficient_solution": "class Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        def recursive_search(nums, left, right, target):\n            if left == right:\n                return left\n            mid = (left + right) >> 1\n            if nums[mid] >= target:\n                return recursive_search(nums, left, mid, target)\n            else:\n                return recursive_search(nums, mid + 1, right, target)\n        \n        return recursive_search(nums, 0, len(nums), target)",
    "efficient_solution": "class Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        left, right = 0, len(nums)\n        while left < right:\n            mid = (left + right) >> 1\n            if nums[mid] >= target:\n                right = mid\n            else:\n                left = mid + 1\n        return left\n",
    "model_generation": "### Efficient Solution:\n\nYou can use a modified binary search algorithm to achieve the desired result in `O(log n)` time complexity. Here's the efficient solution:\n\n```python\nclass Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left\n```\n\n### Explanation:\n\nThis solution uses a binary search approach to find the target value in the sorted array. Here's how it works:\n\n1. Initialize two pointers, `left` and `right`, to the start and end of the array, respectively.\n2. While `left` is less than or equal to `right`, perform the following steps:\n   * Calculate the middle index `mid` using the average of `left` and `right`.\n   * Compare the value at index `mid` with the target value:\n     * If they are equal, return `mid` as the index.\n     * If the value at index `mid` is less than the target, move the `left` pointer to `mid + 1`.\n     * If the value at index `mid` is greater than the target, move the `right` pointer to `mid - 1`.\n3. After the loop ends, `left` will be pointing to the index where the target value should be inserted to maintain the sorted order. Return this index.\n\n### Time Complexity:\n\nThe time complexity of this solution is `O(log n)`, where `n` is the length of the input array. This is because we divide the search space in half at each iteration, resulting in a logarithmic time complexity.\n\n### Space Complexity:\n\nThe space complexity of this solution is `O(1)`, as we only use a constant amount of space to store the pointers and indices.",
    "model_solution": "class Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left",
    "is_python": true
}