{
    "problem_idx": "162",
    "description": "\nA peak element is an element that is strictly greater than its neighbors.\n\n\nGiven a **0-indexed** integer array `nums`, find a peak element, and return its index. If the array contains multiple peaks, return the index to **any of the peaks**.\n\n\nYou may imagine that `nums[-1] = nums[n] = -\u221e`. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.\n\n\nYou must write an algorithm that runs in `O(log n)` time.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** nums = [1,2,3,1]\n**Output:** 2\n**Explanation:** 3 is a peak element and your function should return the index number 2.\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** nums = [1,2,1,3,5,6,4]\n**Output:** 5\n**Explanation:** Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6.\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= nums.length <= 1000`\n* `-231 <= nums[i] <= 231 - 1`\n* `nums[i] != nums[i + 1]` for all valid `i`.\n\n\n",
    "inefficient_solution": "class Solution:\n    def findPeakElement(self, nums: List[int]) -> int:\n        n = len(nums)\n        memory = [0] * n\n        for i in range(n):\n            memory[i] = [nums[i], i]\n        peak_indices = []\n        for i in range(n):\n            temp = memory[i][0]\n            left = right = 0\n            for j in range(len(memory)):\n                if memory[j][0] > temp:\n                    temp = memory[j][0]\n                    left = right = memory[j][1]\n                elif memory[j][0] < temp:\n                    right = memory[j][1]\n            peak_indices.append(left)\n        return peak_indices[0]",
    "efficient_solution": "class Solution:\n    def findPeakElement(self, nums: List[int]) -> int:\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = (left + right) >> 1\n            if nums[mid] > nums[mid + 1]:\n                right = mid\n            else:\n                left = mid + 1\n        return left\n",
    "model_generation": "### Efficient Solution\n\nTo find a peak element in the given array in O(log n) time, we can use a modified binary search algorithm. Here's a Python solution for the problem:\n\n```python\nclass Solution:\n    def findPeakElement(self, nums: List[int]) -> int:\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = left + (right - left) // 2\n            if nums[mid] > nums[mid + 1]:\n                # If the middle element is greater than the next one, \n                # the peak must be on the left half\n                right = mid\n            else:\n                # If the middle element is not greater than the next one, \n                # the peak must be on the right half\n                left = mid + 1\n        return left\n```\n\n### Explanation\n\nThis solution works by dividing the array into two halves at each step and comparing the middle element with its next one. If the middle element is greater than the next one, it means the peak element must be on the left half, so we move the `right` pointer to `mid`. Otherwise, we move the `left` pointer to `mid + 1`. This process continues until we find the peak element.\n\n### Time Complexity\n\nThe time complexity of this solution is O(log n), where n is the length of the array. This is because we divide the array in half at each step, reducing the search space by half.\n\n### Space Complexity\n\nThe space complexity of this solution is O(1), as we only use a constant amount of space to store the left and right pointers.",
    "model_solution": "class Solution:\n    def findPeakElement(self, nums: List[int]) -> int:\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = left + (right - left) // 2\n            if nums[mid] > nums[mid + 1]:\n                # If the middle element is greater than the next one, \n                # the peak must be on the left half\n                right = mid\n            else:\n                # If the middle element is not greater than the next one, \n                # the peak must be on the right half\n                left = mid + 1\n        return left",
    "is_python": true
}