{
    "problem_idx": "704",
    "description": "\nGiven an array of integers `nums` which is sorted in ascending order, and an integer `target`, write a function to search `target` in `nums`. If `target` exists, then return its index. Otherwise, return `-1`.\n\n\nYou must write an algorithm with `O(log n)` runtime complexity.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** nums = [-1,0,3,5,9,12], target = 9\n**Output:** 4\n**Explanation:** 9 exists in nums and its index is 4\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** nums = [-1,0,3,5,9,12], target = 2\n**Output:** -1\n**Explanation:** 2 does not exist in nums so return -1\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= nums.length <= 104`\n* `-104 < nums[i], target < 104`\n* All the integers in `nums` are **unique**.\n* `nums` is sorted in ascending order.\n\n\n",
    "inefficient_solution": "class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        n = len(nums)\n        nums_copy = [0] * n\n        for i in range(n):\n            nums_copy[i] = nums[i]\n        nums = nums_copy\n        \n        left, right = 0, n - 1\n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] >= target:\n                nums[mid] = -1\n                right = mid\n            else:\n                nums[mid] = -1\n                left = mid + 1\n        if nums[left] != -1 and nums[left] == target:\n            return left\n        else:\n            return -1",
    "efficient_solution": "class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = (left + right) >> 1\n            if nums[mid] >= target:\n                right = mid\n            else:\n                left = mid + 1\n        return left if nums[left] == target else -1\n",
    "model_generation": "Here's a more efficient solution with `O(log n)` runtime complexity using binary search:\n\n```python\nclass Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return -1\n```\n\n**Explanation:**\n\nBinary search is an efficient algorithm for finding an item from a sorted list of items. It works by repeatedly dividing in half the portion of the list that could contain the item, until you've narrowed down the possible locations to just one.\n\nIn this solution, we initialize two pointers, `left` and `right`, to the start and end of the list, respectively. We then enter a loop that continues as long as `left` is less than or equal to `right`.\n\n Inside the loop, we calculate the midpoint `mid` of the current range `[left, right]`. We then check if `nums[mid]` is equal to `target`. If it is, we return `mid` immediately.\n\nIf `nums[mid]` is less than `target`, we know that `target` must be in the right half of the list, so we update `left` to `mid + 1`. If `nums[mid]` is greater than `target`, we know that `target` must be in the left half of the list, so we update `right` to `mid - 1`.\n\nIf the loop ends without finding `target`, we return `-1` to indicate that `target` is not in the list.\n\n**Time complexity:** `O(log n)`\n\n**Space complexity:** `O(1)`\n\nThis solution has a time complexity of `O(log n)` because we divide the search space in half at each step. In the worst case, we need to perform `log(n)` steps to find `target` or determine that it's not in the list. The space complexity is `O(1)` because we only use a constant amount of space to store the `left` and `right` pointers.",
    "model_solution": "class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return -1",
    "is_python": true
}