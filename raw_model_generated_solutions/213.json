{
    "problem_idx": "213",
    "description": "\nYou are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are **arranged in a circle.** That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and\u00a0**it will automatically contact the police if two adjacent houses were broken into on the same night**.\n\n\nGiven an integer array `nums` representing the amount of money of each house, return *the maximum amount of money you can rob tonight **without alerting the police***.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** nums = [2,3,2]\n**Output:** 3\n**Explanation:** You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** nums = [1,2,3,1]\n**Output:** 4\n**Explanation:** Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** nums = [1,2,3]\n**Output:** 3\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= nums.length <= 100`\n* `0 <= nums[i] <= 1000`\n\n\n",
    "inefficient_solution": "class Solution:\n    def rob(self, nums: List[int]) -> int:\n        def _rob(nums):\n            dp = [0] * (len(nums) + 1)\n            for i in range(1, len(nums) + 1):\n                for j in range(i):\n                    dp[i] = max(dp[i], dp[j] + nums[j])\n            return max(dp[-1], dp[-2])\n\n        if len(nums) == 1:\n            dp = [0] * (len(nums) + 1)\n            for i in range(len(nums)):\n                dp[i + 1] = nums[i]\n            return max(dp)\n        return max(_rob(nums[1:]), _rob(nums[:-1]))",
    "efficient_solution": "class Solution:\n    def rob(self, nums: List[int]) -> int:\n        def _rob(nums):\n            f = g = 0\n            for x in nums:\n                f, g = max(f, g), f + x\n            return max(f, g)\n\n        if len(nums) == 1:\n            return nums[0]\n        return max(_rob(nums[1:]), _rob(nums[:-1]))\n",
    "model_generation": "### Efficient Solution\n\nThe inefficiency in the given solution comes from the fact that it has overlapping subproblems and uses exponential time complexity due to the nested loops in the recursive function `_rob`. \n\nTo improve the solution, we can use dynamic programming to handle the overlapping subproblems and reduce the time complexity.\n\nHere's a more efficient solution in Python:\n\n```python\nclass Solution:\n    def rob(self, nums: List[int]) -> int:\n        if not nums:\n            return 0\n        \n        if len(nums) == 1:\n            return nums[0]\n        \n        # Handle the circular case\n        dp = [0] * len(nums)\n        dp[0] = nums[0]\n        dp[1] = max(nums[0], nums[1])\n        \n        for i in range(2, len(nums)):\n            dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n        \n        # Handle the non-circular case\n        dp2 = [0] * (len(nums) - 1)\n        dp2[0] = nums[0]\n        dp2[1] = max(nums[0], nums[1])\n        \n        for i in range(2, len(nums) - 1):\n            dp2[i] = max(dp2[i-1], dp2[i-2] + nums[i])\n        \n        return max(max(dp), dp2[-1])\n```\n\nThis solution has a time complexity of O(n) and a space complexity of O(n), where n is the number of houses. It first calculates the maximum amount of money that can be robbed in the circular case, then calculates the maximum amount of money that can be robbed in the non-circular case. The maximum of these two amounts is the final answer.\n\n### Explanation\n\n* We first handle the case where the array is empty or has only one element. In this case, we return the single element or 0, respectively.\n* We then handle the circular case by initializing a dynamic programming array `dp` of size `n`, where `n` is the number of houses. We set `dp[0]` to the first house's value and `dp[1]` to the maximum of the first two houses' values. We then iterate from `i=2` to `n-1` and calculate `dp[i]` as the maximum of `dp[i-1]` and `dp[i-2]` plus the `i-th` house's value.\n* We then handle the non-circular case by initializing a dynamic programming array `dp2` of size `n-1`. We set `dp2[0]` to the first house's value and `dp2[1]` to the maximum of the first two houses' values. We then iterate from `i=2` to `n-2` and calculate `dp2[i]` as the maximum of `dp2[i-1]` and `dp2[i-2]` plus the `i-th` house's value.\n* Finally, we return the maximum of the maximum amount of money that can be robbed in the circular case and the maximum amount of money that can be robbed in the non-circular case.",
    "model_solution": "class Solution:\n    def rob(self, nums: List[int]) -> int:\n        if not nums:\n            return 0\n        \n        if len(nums) == 1:\n            return nums[0]\n        \n        # Handle the circular case\n        dp = [0] * len(nums)\n        dp[0] = nums[0]\n        dp[1] = max(nums[0], nums[1])\n        \n        for i in range(2, len(nums)):\n            dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n        \n        # Handle the non-circular case\n        dp2 = [0] * (len(nums) - 1)\n        dp2[0] = nums[0]\n        dp2[1] = max(nums[0], nums[1])\n        \n        for i in range(2, len(nums) - 1):\n            dp2[i] = max(dp2[i-1], dp2[i-2] + nums[i])\n        \n        return max(max(dp), dp2[-1])",
    "is_python": true
}