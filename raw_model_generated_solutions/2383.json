{
    "problem_idx": "2383",
    "description": "\nYou are entering a competition, and are given two **positive** integers `initialEnergy` and `initialExperience` denoting your initial energy and initial experience respectively.\n\n\nYou are also given two **0-indexed** integer arrays `energy` and `experience`, both of length `n`.\n\n\nYou will face `n` opponents **in order**. The energy and experience of the `ith` opponent is denoted by `energy[i]` and `experience[i]` respectively. When you face an opponent, you need to have both **strictly** greater experience and energy to defeat them and move to the next opponent if available.\n\n\nDefeating the `ith` opponent **increases** your experience by `experience[i]`, but **decreases** your energy by `energy[i]`.\n\n\nBefore starting the competition, you can train for some number of hours. After each hour of training, you can **either** choose to increase your initial experience by one, or increase your initial energy by one.\n\n\nReturn *the **minimum** number of training hours required to defeat all* `n` *opponents*.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** initialEnergy = 5, initialExperience = 3, energy = [1,4,3,2], experience = [2,6,3,1]\n**Output:** 8\n**Explanation:** You can increase your energy to 11 after 6 hours of training, and your experience to 5 after 2 hours of training.\nYou face the opponents in the following order:\n- You have more energy and experience than the 0th opponent so you win.\n  Your energy becomes 11 - 1 = 10, and your experience becomes 5 + 2 = 7.\n- You have more energy and experience than the 1st opponent so you win.\n  Your energy becomes 10 - 4 = 6, and your experience becomes 7 + 6 = 13.\n- You have more energy and experience than the 2nd opponent so you win.\n  Your energy becomes 6 - 3 = 3, and your experience becomes 13 + 3 = 16.\n- You have more energy and experience than the 3rd opponent so you win.\n  Your energy becomes 3 - 2 = 1, and your experience becomes 16 + 1 = 17.\nYou did a total of 6 + 2 = 8 hours of training before the competition, so we return 8.\nIt can be proven that no smaller answer exists.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** initialEnergy = 2, initialExperience = 4, energy = [1], experience = [3]\n**Output:** 0\n**Explanation:** You do not need any additional energy or experience to win the competition, so we return 0.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `n == energy.length == experience.length`\n* `1 <= n <= 100`\n* `1 <= initialEnergy, initialExperience, energy[i], experience[i] <= 100`\n\n\n",
    "inefficient_solution": "class Solution:\n    def minNumberOfHours(\n        self,\n        initialEnergy: int,\n        initialExperience: int,\n        energy: List[int],\n        experience: List[int],\n    ) -> int:\n        ans = []\n        for a, b in zip(energy, experience):\n            temp = []\n            if initialEnergy <= a:\n                for _ in range(a - initialEnergy + 1):\n                    temp.append(1)\n                initialEnergy = a + 1\n            if initialExperience <= b:\n                for _ in range(b - initialExperience + 1):\n                    temp.append(1)\n                initialExperience = b + 1\n            temp.append(initialEnergy - a)\n            temp.append(initialExperience + b)\n            ans.extend(temp)\n        import copy\n        ans = copy.deepcopy(ans)\n        return len(ans)",
    "efficient_solution": "class Solution:\n    def minNumberOfHours(\n        self,\n        initialEnergy: int,\n        initialExperience: int,\n        energy: List[int],\n        experience: List[int],\n    ) -> int:\n        ans = 0\n        for a, b in zip(energy, experience):\n            if initialEnergy <= a:\n                ans += a - initialEnergy + 1\n                initialEnergy = a + 1\n            if initialExperience <= b:\n                ans += b - initialExperience + 1\n                initialExperience = b + 1\n            initialEnergy -= a\n            initialExperience += b\n        return ans\n",
    "model_generation": "### Efficient Solution:\n\nThe problem can be solved using a binary search approach. We can simulate the process of training for a certain number of hours and then competing against the opponents. If we can defeat all opponents, then the number of hours we trained is a possible answer. We can keep increasing the number of hours we trained until we find a situation where we cannot defeat all opponents.\n\nHere is the efficient solution:\n\n```python\nfrom typing import List\n\nclass Solution:\n    def minNumberOfHours(\n        self,\n        initialEnergy: int,\n        initialExperience: int,\n        energy: List[int],\n        experience: List[int],\n    ) -> int:\n        n = len(energy)\n        left, right = 0, n * 100  # Since energy and experience are at most 100\n        while left < right:\n            mid = (left + right + 1) // 2\n            total_experience = initialExperience + mid\n            total_energy = initialEnergy\n            can_defeat_all = True\n            for i in range(n):\n                if total_experience >= experience[i] and total_energy >= energy[i]:\n                    total_experience += experience[i]\n                    total_energy -= energy[i]\n                else:\n                    can_defeat_all = False\n                    break\n            if can_defeat_all:\n                right = mid - 1\n            else:\n                left = mid\n\n        return left + 1\n```\n\n### Explanation:\n\n1.  We perform a binary search on the range $[0, n \\times 100]$ to find the minimum number of training hours required.\n2.  For each possible number of training hours, we simulate the process of competing against the opponents.\n3.  If we can defeat all opponents, then the number of training hours we considered is a possible answer.\n4.  We keep increasing the number of training hours until we find a situation where we cannot defeat all opponents.\n\nThis solution has a time complexity of O(n log (n \\* 100)) and a space complexity of O(1). The space complexity is O(1) because we are only using a constant amount of space to store the variables.",
    "model_solution": "from typing import List\n\nclass Solution:\n    def minNumberOfHours(\n        self,\n        initialEnergy: int,\n        initialExperience: int,\n        energy: List[int],\n        experience: List[int],\n    ) -> int:\n        n = len(energy)\n        left, right = 0, n * 100  # Since energy and experience are at most 100\n        while left < right:\n            mid = (left + right + 1) // 2\n            total_experience = initialExperience + mid\n            total_energy = initialEnergy\n            can_defeat_all = True\n            for i in range(n):\n                if total_experience >= experience[i] and total_energy >= energy[i]:\n                    total_experience += experience[i]\n                    total_energy -= energy[i]\n                else:\n                    can_defeat_all = False\n                    break\n            if can_defeat_all:\n                right = mid - 1\n            else:\n                left = mid\n\n        return left + 1",
    "is_python": true
}