{
    "problem_idx": "1151",
    "description": "\nGiven a\u00a0binary array `data`, return\u00a0the minimum number of swaps required to group all `1`\u2019s present in the array together in **any place** in the array.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** data = [1,0,1,0,1]\n**Output:** 1\n**Explanation:** There are 3 ways to group all 1's together:\n[1,1,1,0,0] using 1 swap.\n[0,1,1,1,0] using 2 swaps.\n[0,0,1,1,1] using 1 swap.\nThe minimum is 1.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** data = [0,0,0,1,0]\n**Output:** 0\n**Explanation:** Since there is only one 1 in the array, no swaps are needed.\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** data = [1,0,1,0,1,0,0,1,1,0,1]\n**Output:** 3\n**Explanation:** One possible solution that uses 3 swaps is [0,0,0,0,0,1,1,1,1,1,1].\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= data.length <= 105`\n* `data[i]` is either `0` or `1`.\n\n\n",
    "inefficient_solution": "class Solution:\n    def minSwaps(self, data: List[int]) -> int:\n        all_ones = [1] * data.count(1)\n        all_zeros = [0] * len(data) - len(all_ones)\n        result = []\n        for i in range(len(data)):\n            temp = []\n            for j in range(len(data)):\n                if j < i:\n                    temp.append(data[j])\n                else:\n                    if j - i < len(all_ones):\n                        temp.append(all_ones[-(j - i)])\n                    else:\n                        temp.append(all_zeros[-(j - i) + len(all_ones)])\n            result.append(temp)\n        min_swaps = float('inf')\n        for arrangement in result:\n            swaps = 0\n            for i in range(len(arrangement)):\n                if arrangement[i] != 1:\n                    swaps += 1\n                    j = i\n                    while j < len(arrangement) and arrangement[j] != 1:\n                        j += 1\n                    if j == len(arrangement):\n                        break\n                    temp = arrangement[i:j+1]\n                    temp.sort()\n                    arrangement[i:j+1] = temp\n                    swaps += j - i\n            min_swaps = min(min_swaps, swaps)\n        return min_swaps",
    "efficient_solution": "class Solution:\n    def minSwaps(self, data: List[int]) -> int:\n        k = data.count(1)\n        t = sum(data[:k])\n        mx = t\n        for i in range(k, len(data)):\n            t += data[i]\n            t -= data[i - k]\n            mx = max(mx, t)\n        return k - mx\n",
    "model_generation": "Here's a more efficient solution using a two-pointer approach:\n\n```python\nclass Solution:\n    def minSwaps(self, data: List[int]) -> int:\n        n = len(data)\n        ones = sum(data)\n        swaps = 0\n        start = 0\n        end = 0\n\n        while end < n:\n            while end < n and data[end] == 0:\n                end += 1\n\n            if end < n:\n                count = 0\n                while start <= end and count < ones:\n                    if data[start] == 1:\n                        count += 1\n                    start += 1\n\n                swaps += end - start + 1\n                start = end + 1\n\n        return swaps\n```\n\nExplanation:\n\n*   We start with two pointers, `start` and `end`, at the beginning of the array.\n*   We move the `end` pointer to the right until we encounter a `1`. This is because we need to count the number of `1`s in the window.\n*   Once we've found the first `1` at the `end` position, we move the `start` pointer to the right until we've found `ones` number of `1`s. This is because we want to count the minimum number of swaps required to move all the `1`s together.\n*   At each step, we increment the `swaps` counter by the number of elements we need to swap. This is the difference between the current window size (`end - start + 1`) and the number of `1`s we've already found (`count`).\n*   We repeat this process until we've covered the entire array.\n*   Finally, we return the total number of swaps required.\n\nThis solution has a time complexity of O(n), where n is the length of the input array, making it more efficient than the original solution.",
    "model_solution": "class Solution:\n    def minSwaps(self, data: List[int]) -> int:\n        n = len(data)\n        ones = sum(data)\n        swaps = 0\n        start = 0\n        end = 0\n\n        while end < n:\n            while end < n and data[end] == 0:\n                end += 1\n\n            if end < n:\n                count = 0\n                while start <= end and count < ones:\n                    if data[start] == 1:\n                        count += 1\n                    start += 1\n\n                swaps += end - start + 1\n                start = end + 1\n\n        return swaps",
    "is_python": true
}