{
    "problem_idx": "2901",
    "description": "\nYou are given an integer `n`, a **0-indexed** string array `words`, and a **0-indexed** array `groups`, both arrays having length `n`.\n\n\nThe **hamming distance** between two strings of equal length is the number of positions at which the corresponding characters are **different**.\n\n\nYou need to select the **longest** **subsequence** from an array of indices `[0, 1, ..., n - 1]`, such that for the subsequence denoted as `[i0, i1, ..., ik - 1]` having length `k`, the following holds:\n\n\n* For **adjacent** indices in the subsequence, their corresponding groups are **unequal**, i.e., `groups[ij] != groups[ij + 1]`, for each `j` where `0 < j + 1 < k`.\n* `words[ij]` and `words[ij + 1]` are **equal** in length, and the **hamming distance** between them is `1`, where `0 < j + 1 < k`, for all indices in the subsequence.\n\n\nReturn *a string array containing the words corresponding to the indices **(in order)** in the selected subsequence*. If there are multiple answers, return *any of them*.\n\n\nA **subsequence** of an array is a new array that is formed from the original array by deleting some (possibly none) of the elements without disturbing the relative positions of the remaining elements.\n\n\n**Note:** strings in `words` may be **unequal** in length.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** n = 3, words = [\"bab\",\"dab\",\"cab\"], groups = [1,2,2]\n**Output:** [\"bab\",\"cab\"]\n**Explanation:** A subsequence that can be selected is [0,2].\n- groups[0] != groups[2]\n- words[0].length == words[2].length, and the hamming distance between them is 1.\nSo, a valid answer is [words[0],words[2]] = [\"bab\",\"cab\"].\nAnother subsequence that can be selected is [0,1].\n- groups[0] != groups[1]\n- words[0].length == words[1].length, and the hamming distance between them is 1.\nSo, another valid answer is [words[0],words[1]] = [\"bab\",\"dab\"].\nIt can be shown that the length of the longest subsequence of indices that satisfies the conditions is 2.  \n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** n = 4, words = [\"a\",\"b\",\"c\",\"d\"], groups = [1,2,3,4]\n**Output:** [\"a\",\"b\",\"c\",\"d\"]\n**Explanation:** We can select the subsequence [0,1,2,3].\nIt satisfies both conditions.\nHence, the answer is [words[0],words[1],words[2],words[3]] = [\"a\",\"b\",\"c\",\"d\"].\nIt has the longest length among all subsequences of indices that satisfy the conditions.\nHence, it is the only answer.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= n == words.length == groups.length <= 1000`\n* `1 <= words[i].length <= 10`\n* `1 <= groups[i] <= n`\n* `words` consists of **distinct** strings.\n* `words[i]` consists of lowercase English letters.\n\n\n",
    "inefficient_solution": "class Solution:\n    def getWordsInLongestSubsequence(\n        self, n: int, words: List[str], groups: List[int]\n    ) -> List[str]:\n        def check(s: str, t: str) -> bool:\n            return len(s) == len(t) and sum(a != b for a, b in zip(s, t)) == 1\n\n        f = [0] * (n * n)\n        g = [-1] * (n * n)\n        mx = 0\n        for i in range(n):\n            for j in range(n):\n                for k in range(n):\n                    if groups[i] != groups[k] and f[j * n + i] < f[k * n + j] + 1 and check(words[i], words[k]):\n                        f[j * n + i] = f[k * n + j] + 1\n                        g[j * n + i] = k * n + j\n                        mx = max(mx, f[j * n + i])\n        ans = []\n        for i in range(n * n):\n            if f[i] == mx:\n                j = i\n                while j >= 0:\n                    ans.append(words[j % n])\n                    j = g[j]\n                break\n        return ans[::-1]",
    "efficient_solution": "class Solution:\n    def getWordsInLongestSubsequence(\n        self, n: int, words: List[str], groups: List[int]\n    ) -> List[str]:\n        def check(s: str, t: str) -> bool:\n            return len(s) == len(t) and sum(a != b for a, b in zip(s, t)) == 1\n\n        f = [1] * n\n        g = [-1] * n\n        mx = 1\n        for i, x in enumerate(groups):\n            for j, y in enumerate(groups[:i]):\n                if x != y and f[i] < f[j] + 1 and check(words[i], words[j]):\n                    f[i] = f[j] + 1\n                    g[i] = j\n                    mx = max(mx, f[i])\n        ans = []\n        for i in range(n):\n            if f[i] == mx:\n                j = i\n                while j >= 0:\n                    ans.append(words[j])\n                    j = g[j]\n                break\n        return ans[::-1]\n",
    "model_generation": "Here is an efficient solution for the given problem. This solution uses a dynamic programming approach and presents a more efficient way to solve the problem.\n\n```python\nfrom typing import List\n\nclass Solution:\n    def getWordsInLongestSubsequence(\n        self, n: int, words: List[str], groups: List[int]\n    ) -> List[str]:\n        def check(s: str, t: str) -> bool:\n            return len(s) == len(t) and sum(a != b for a, b in zip(s, t)) == 1\n\n        # Create a dictionary to store the word length and the word itself\n        word_dict = {}\n        for i in range(n):\n            word_dict[len(words[i])] = word_dict.get(len(words[i]), []) + [words[i]]\n\n        # Sort the word lengths in descending order\n        word_lengths = sorted(word_dict.keys(), reverse=True)\n\n        ans = []\n        for length in word_lengths:\n            word_list = word_dict[length]\n            word_list.sort(key=lambda x: len(x))\n            for i in range(len(word_list)):\n                for j in range(i + 1, len(word_list)):\n                    if groups[word_list[i].index(words[i])] != groups[word_list[j].index(words[j])] and check(words[i], words[j]):\n                        ans.append(words[i])\n                        words[i], words[j] = None, None\n                        break\n\n        return ans\n```\n\n### Explanation:\n\nThis solution first creates a dictionary `word_dict` where the keys are the lengths of the words and the values are lists of words with the corresponding length. It then sorts the word lengths in descending order.\n\nThe main idea of the solution is to iterate over the word lengths in descending order and for each length, it iterates over the list of words with that length. If it finds two words that satisfy the conditions (i.e., the groups are different and the hamming distance is 1), it adds the first word to the result list and removes both words from the list.\n\nThis solution has a time complexity of O(n^2 * m^2), where n is the number of words and m is the maximum length of a word. It presents a more efficient way to solve the problem by avoiding the use of dynamic programming and instead using a dictionary to store the word lengths and a list to store the words with each length.",
    "model_solution": "from typing import List\n\nclass Solution:\n    def getWordsInLongestSubsequence(\n        self, n: int, words: List[str], groups: List[int]\n    ) -> List[str]:\n        def check(s: str, t: str) -> bool:\n            return len(s) == len(t) and sum(a != b for a, b in zip(s, t)) == 1\n\n        # Create a dictionary to store the word length and the word itself\n        word_dict = {}\n        for i in range(n):\n            word_dict[len(words[i])] = word_dict.get(len(words[i]), []) + [words[i]]\n\n        # Sort the word lengths in descending order\n        word_lengths = sorted(word_dict.keys(), reverse=True)\n\n        ans = []\n        for length in word_lengths:\n            word_list = word_dict[length]\n            word_list.sort(key=lambda x: len(x))\n            for i in range(len(word_list)):\n                for j in range(i + 1, len(word_list)):\n                    if groups[word_list[i].index(words[i])] != groups[word_list[j].index(words[j])] and check(words[i], words[j]):\n                        ans.append(words[i])\n                        words[i], words[j] = None, None\n                        break\n\n        return ans",
    "is_python": true
}