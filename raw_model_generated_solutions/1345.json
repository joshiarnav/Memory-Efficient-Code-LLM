{
    "problem_idx": "1345",
    "description": "\nGiven an array of\u00a0integers `arr`, you are initially positioned at the first index of the array.\n\n\nIn one step you can jump from index `i` to index:\n\n\n* `i + 1` where:\u00a0`i + 1 < arr.length`.\n* `i - 1` where:\u00a0`i - 1 >= 0`.\n* `j` where: `arr[i] == arr[j]` and `i != j`.\n\n\nReturn *the minimum number of steps* to reach the **last index** of the array.\n\n\nNotice that you can not jump outside of the array at any time.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** arr = [100,-23,-23,404,100,23,23,23,3,404]\n**Output:** 3\n**Explanation:** You need three jumps from index 0 --> 4 --> 3 --> 9. Note that index 9 is the last index of the array.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** arr = [7]\n**Output:** 0\n**Explanation:** Start index is the last index. You do not need to jump.\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** arr = [7,6,9,6,9,6,9,7]\n**Output:** 1\n**Explanation:** You can jump directly from index 0 to index 7 which is last index of the array.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= arr.length <= 5 * 104`\n* `-108 <= arr[i] <= 108`\n\n\n",
    "inefficient_solution": "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        n = len(arr)\n        jumps = [n] * n\n        jumps[0] = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                if arr[i] == arr[j]:\n                    jumps[j] = min(jumps[j], jumps[i] + 1)\n            for j in range(n):\n                if arr[i] == arr[j]:\n                    jumps[j] = min(jumps[j], jumps[i] + 1)\n        return jumps[-1]",
    "efficient_solution": "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        idx = defaultdict(list)\n        for i, v in enumerate(arr):\n            idx[v].append(i)\n        q = deque([(0, 0)])\n        vis = {0}\n        while q:\n            i, step = q.popleft()\n            if i == len(arr) - 1:\n                return step\n            v = arr[i]\n            step += 1\n            for j in idx[v]:\n                if j not in vis:\n                    vis.add(j)\n                    q.append((j, step))\n            del idx[v]\n            if i + 1 < len(arr) and (i + 1) not in vis:\n                vis.add(i + 1)\n                q.append((i + 1, step))\n            if i - 1 >= 0 and (i - 1) not in vis:\n                vis.add(i - 1)\n                q.append((i - 1, step))\n",
    "model_generation": "The given inefficient solution has a time complexity of O(n^2) due to the nested loops. We can improve the solution to O(n) by using a queue-based approach and a dictionary to store the indices of the elements we have seen.\n\nHere's the efficient solution:\n\n```python\nfrom collections import deque\nfrom typing import List\n\nclass Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        n = len(arr)\n        if n == 1:\n            return 0\n        \n        # Create a dictionary to store the indices of the elements we have seen\n        index_dict = {}\n        for i, num in enumerate(arr):\n            if num not in index_dict:\n                index_dict[num] = []\n            index_dict[num].append(i)\n        \n        # Initialize the queue with the starting index and the number of jumps\n        queue = deque([(0, 0)])\n        visited = set([0])\n        \n        while queue:\n            # Dequeue the current index and the number of jumps\n            curr_index, jumps = queue.popleft()\n            \n            # If we have reached the last index, return the number of jumps\n            if curr_index == n - 1:\n                return jumps\n            \n            # Get the elements that are equal to the current element\n            for next_index in index_dict[arr[curr_index]]:\n                # If we have not visited this index before, mark it as visited and enqueue it\n                if next_index not in visited:\n                    visited.add(next_index)\n                    queue.append((next_index, jumps + 1))\n            \n            # Enqueue the next index if it is a valid jump\n            if curr_index + 1 < n:\n                queue.append((curr_index + 1, jumps + 1))\n            if curr_index - 1 >= 0:\n                queue.append((curr_index - 1, jumps + 1))\n```\n\nThis solution uses a queue to keep track of the indices we need to visit, and a set to keep track of the indices we have already visited. It iterates through the array once, and for each element, it adds its indices to the queue if we have not visited them before. Finally, it returns the minimum number of jumps to reach the last index.\n\nThis solution has a time complexity of O(n) and a space complexity of O(n), where n is the length of the array.",
    "model_solution": "from collections import deque\nfrom typing import List\n\nclass Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        n = len(arr)\n        if n == 1:\n            return 0\n        \n        # Create a dictionary to store the indices of the elements we have seen\n        index_dict = {}\n        for i, num in enumerate(arr):\n            if num not in index_dict:\n                index_dict[num] = []\n            index_dict[num].append(i)\n        \n        # Initialize the queue with the starting index and the number of jumps\n        queue = deque([(0, 0)])\n        visited = set([0])\n        \n        while queue:\n            # Dequeue the current index and the number of jumps\n            curr_index, jumps = queue.popleft()\n            \n            # If we have reached the last index, return the number of jumps\n            if curr_index == n - 1:\n                return jumps\n            \n            # Get the elements that are equal to the current element\n            for next_index in index_dict[arr[curr_index]]:\n                # If we have not visited this index before, mark it as visited and enqueue it\n                if next_index not in visited:\n                    visited.add(next_index)\n                    queue.append((next_index, jumps + 1))\n            \n            # Enqueue the next index if it is a valid jump\n            if curr_index + 1 < n:\n                queue.append((curr_index + 1, jumps + 1))\n            if curr_index - 1 >= 0:\n                queue.append((curr_index - 1, jumps + 1))",
    "is_python": true
}