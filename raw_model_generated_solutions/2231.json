{
    "problem_idx": "2231",
    "description": "\nYou are given a positive integer `num`. You may swap any two digits of `num` that have the same **parity** (i.e. both odd digits or both even digits).\n\n\nReturn *the **largest** possible value of* `num` *after **any** number of swaps.*\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** num = 1234\n**Output:** 3412\n**Explanation:** Swap the digit 3 with the digit 1, this results in the number 3214.\nSwap the digit 2 with the digit 4, this results in the number 3412.\nNote that there may be other sequences of swaps but it can be shown that 3412 is the largest possible number.\nAlso note that we may not swap the digit 4 with the digit 1 since they are of different parities.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** num = 65875\n**Output:** 87655\n**Explanation:** Swap the digit 8 with the digit 6, this results in the number 85675.\nSwap the first digit 5 with the digit 7, this results in the number 87655.\nNote that there may be other sequences of swaps but it can be shown that 87655 is the largest possible number.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= num <= 109`\n\n\n",
    "inefficient_solution": "class Solution:\n    def largestInteger(self, num: int) -> int:\n        parity = [0] * 2\n        parity_list = [[] for _ in range(2)]\n        x = num\n        while x:\n            x, v = divmod(x, 10)\n            parity[v % 2] += 1\n            parity_list[v % 2].append(v)\n        ans = []\n        x = num\n        for _ in range(parity[1]):\n            x, v = divmod(x, 10)\n            ans.append(str(v))\n        for _ in range(parity[0]):\n            x, v = divmod(x, 10)\n            ans.append(str(v))\n        ans.sort(reverse=True)\n        return int(''.join(ans))",
    "efficient_solution": "class Solution:\n    def largestInteger(self, num: int) -> int:\n        cnt = Counter()\n        x = num\n        while x:\n            x, v = divmod(x, 10)\n            cnt[v] += 1\n        x = num\n        ans = 0\n        t = 1\n        while x:\n            x, v = divmod(x, 10)\n            for y in range(10):\n                if ((v ^ y) & 1) == 0 and cnt[y]:\n                    ans += y * t\n                    t *= 10\n                    cnt[y] -= 1\n                    break\n        return ans\n",
    "model_generation": "Here is a more efficient solution:\n\n```python\nclass Solution:\n    def largestInteger(self, num: int) -> int:\n        nums = list(map(int, str(num)))\n        nums.sort(key=lambda x: (x % 2, -x))\n        return int(''.join(map(str, nums)))\n```\n\nExplanation:\n\n1. Convert the input number to a list of integers, where each integer is a digit of the number.\n2. Sort this list of integers in descending order, but with a twist: when two numbers have the same parity (i.e., both odd or both even), their order is determined by their value in descending order. This is done by using a lambda function as the sorting key, which returns a tuple where the first element is the parity (even or odd) of the number and the second element is the negative of the number itself. This ensures that numbers with the same parity are sorted in descending order.\n3. Finally, convert the sorted list of integers back to a string and return it as an integer.\n\nThis solution has a time complexity of O(n log n) due to the sorting operation, where n is the number of digits in the input number. The space complexity is O(n) for storing the list of digits.\n\nThe previous solution's time complexity was also O(n log n) due to the sorting operation, but it had a higher space complexity due to the use of multiple lists and variables. The new solution is more efficient and easier to understand.",
    "model_solution": "class Solution:\n    def largestInteger(self, num: int) -> int:\n        nums = list(map(int, str(num)))\n        nums.sort(key=lambda x: (x % 2, -x))\n        return int(''.join(map(str, nums)))",
    "is_python": true
}