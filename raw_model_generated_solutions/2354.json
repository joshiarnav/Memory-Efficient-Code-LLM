{
    "problem_idx": "2354",
    "description": "\nYou are given a **0-indexed** positive integer array `nums` and a positive integer `k`.\n\n\nA pair of numbers `(num1, num2)` is called **excellent** if the following conditions are satisfied:\n\n\n* **Both** the numbers `num1` and `num2` exist in the array `nums`.\n* The sum of the number of set bits in `num1 OR num2` and `num1 AND num2` is greater than or equal to `k`, where `OR` is the bitwise **OR** operation and `AND` is the bitwise **AND** operation.\n\n\nReturn *the number of **distinct** excellent pairs*.\n\n\nTwo pairs `(a, b)` and `(c, d)` are considered distinct if either `a != c` or `b != d`. For example, `(1, 2)` and `(2, 1)` are distinct.\n\n\n**Note** that a pair `(num1, num2)` such that `num1 == num2` can also be excellent if you have at least **one** occurrence of `num1` in the array.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** nums = [1,2,3,1], k = 3\n**Output:** 5\n**Explanation:** The excellent pairs are the following:\n- (3, 3). (3 AND 3) and (3 OR 3) are both equal to (11) in binary. The total number of set bits is 2 + 2 = 4, which is greater than or equal to k = 3.\n- (2, 3) and (3, 2). (2 AND 3) is equal to (10) in binary, and (2 OR 3) is equal to (11) in binary. The total number of set bits is 1 + 2 = 3.\n- (1, 3) and (3, 1). (1 AND 3) is equal to (01) in binary, and (1 OR 3) is equal to (11) in binary. The total number of set bits is 1 + 2 = 3.\nSo the number of excellent pairs is 5.\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** nums = [5,1,1], k = 10\n**Output:** 0\n**Explanation:** There are no excellent pairs for this array.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= nums.length <= 105`\n* `1 <= nums[i] <= 109`\n* `1 <= k <= 60`\n\n\n",
    "inefficient_solution": "class Solution:\n    def countExcellentPairs(self, nums: List[int], k: int) -> int:\n        s = set(nums)\n        ans = 0\n        cnt = [0] * 60\n        for v in s:\n            cnt[v.bit_count()] += 1\n        for v in s:\n            t = v.bit_count()\n            for i in range(60):\n                if t + i >= k:\n                    new_cnt = [0] * 60\n                    for j in range(60):\n                        new_cnt[j] = cnt[j]\n                    for j in range(60):\n                        new_cnt[j] += cnt[j]\n                    for j in range(60):\n                        if t + i >= k and j + i >= k:\n                            ans += new_cnt[j]\n        return ans",
    "efficient_solution": "class Solution:\n    def countExcellentPairs(self, nums: List[int], k: int) -> int:\n        s = set(nums)\n        ans = 0\n        cnt = Counter()\n        for v in s:\n            cnt[v.bit_count()] += 1\n        for v in s:\n            t = v.bit_count()\n            for i, x in cnt.items():\n                if t + i >= k:\n                    ans += x\n        return ans\n",
    "model_generation": "Here is an efficient solution to the problem. We will use a hashmap to store the count of numbers with each bit count, and then for each number, we will iterate over the hashmap to find the number of pairs that satisfy the condition.\n\n```python\nclass Solution:\n    def countExcellentPairs(self, nums: List[int], k: int) -> int:\n        bit_counts = {}\n        for num in nums:\n            bit_count = bin(num).count('1')\n            bit_counts[bit_count] = bit_counts.get(bit_count, 0) + 1\n        \n        ans = 0\n        for count1 in bit_counts:\n            for count2 in bit_counts:\n                if count1 + count2 >= k:\n                    ans += bit_counts[count1] * bit_counts[count2]\n        \n        return ans\n```\n\nThis solution works by first creating a hashmap `bit_counts` where the keys are the bit counts of the numbers in the array and the values are the counts of numbers with each bit count. \n\nThen, it iterates over the hashmap and for each pair of bit counts, if the sum is greater than or equal to `k`, it adds the product of the counts of the two bit counts to the answer. This is because for each number with a certain bit count, we can pair it with every number with a bit count that, when added to the first bit count, is greater than or equal to `k`.\n\nThis solution has a time complexity of O(n + m), where n is the length of the array and m is the maximum bit count of the numbers in the array. This is because we are iterating over the array once to create the hashmap, and then iterating over the hashmap once to calculate the answer. The space complexity is also O(m), where m is the maximum bit count of the numbers in the array, because we need to store the counts of numbers with each bit count in the hashmap.",
    "model_solution": "class Solution:\n    def countExcellentPairs(self, nums: List[int], k: int) -> int:\n        bit_counts = {}\n        for num in nums:\n            bit_count = bin(num).count('1')\n            bit_counts[bit_count] = bit_counts.get(bit_count, 0) + 1\n        \n        ans = 0\n        for count1 in bit_counts:\n            for count2 in bit_counts:\n                if count1 + count2 >= k:\n                    ans += bit_counts[count1] * bit_counts[count2]\n        \n        return ans",
    "is_python": true
}