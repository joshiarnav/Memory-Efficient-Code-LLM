{
    "problem_idx": "1405",
    "description": "\nA string `s` is called **happy** if it satisfies the following conditions:\n\n\n* `s` only contains the letters `'a'`, `'b'`, and `'c'`.\n* `s` does not contain any of `\"aaa\"`, `\"bbb\"`, or `\"ccc\"` as a substring.\n* `s` contains **at most** `a` occurrences of the letter `'a'`.\n* `s` contains **at most** `b` occurrences of the letter `'b'`.\n* `s` contains **at most** `c` occurrences of the letter `'c'`.\n\n\nGiven three integers `a`, `b`, and `c`, return *the **longest possible happy** string*. If there are multiple longest happy strings, return *any of them*. If there is no such string, return *the empty string* `\"\"`.\n\n\nA **substring** is a contiguous sequence of characters within a string.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** a = 1, b = 1, c = 7\n**Output:** \"ccaccbcc\"\n**Explanation:** \"ccbccacc\" would also be a correct answer.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** a = 7, b = 1, c = 0\n**Output:** \"aabaa\"\n**Explanation:** It is the only correct answer in this case.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `0 <= a, b, c <= 100`\n* `a + b + c > 0`\n\n\n",
    "inefficient_solution": "class Solution:\n    def longestDiverseString(self, a: int, b: int, c: int) -> str:\n        h = []\n        if a > 0:\n            h.append([a, 'a'])\n            h.append([a, 'a'])\n        if b > 0:\n            h.append([b, 'b'])\n            h.append([b, 'b'])\n        if c > 0:\n            h.append([c, 'c'])\n            h.append([c, 'c'])\n\n        ans = []\n        while len(h) > 0:\n            cur = h.pop()\n            if len(ans) >= 2 and ans[-1] == cur[1] and ans[-2] == cur[1]:\n                if len(h) == 0:\n                    break\n                nxt = h.pop()\n                h.append(nxt)\n                h.append(nxt)\n                ans.append(nxt[1])\n                nxt[0] += 1\n                h.append(nxt)\n                h.append(cur)\n            else:\n                ans.append(cur[1])\n                h.append(cur)\n\n        return ''.join(ans)",
    "efficient_solution": "class Solution:\n    def longestDiverseString(self, a: int, b: int, c: int) -> str:\n        h = []\n        if a > 0:\n            heappush(h, [-a, 'a'])\n        if b > 0:\n            heappush(h, [-b, 'b'])\n        if c > 0:\n            heappush(h, [-c, 'c'])\n\n        ans = []\n        while len(h) > 0:\n            cur = heappop(h)\n            if len(ans) >= 2 and ans[-1] == cur[1] and ans[-2] == cur[1]:\n                if len(h) == 0:\n                    break\n                nxt = heappop(h)\n                ans.append(nxt[1])\n                if -nxt[0] > 1:\n                    nxt[0] += 1\n                    heappush(h, nxt)\n                heappush(h, cur)\n            else:\n                ans.append(cur[1])\n                if -cur[0] > 1:\n                    cur[0] += 1\n                    heappush(h, cur)\n\n        return ''.join(ans)\n",
    "model_generation": "### Efficient Solution:\n\n```python\nclass Solution:\n    def longestDiverseString(self, a: int, b: int, c: int) -> str:\n        chars = [['a', a], ['b', b], ['c', c]]\n        chars.sort(key=lambda x: x[1], reverse=True)\n        \n        ans = []\n        while len(chars) > 0:\n            cur = chars.pop()\n            if len(ans) >= 2 and ans[-1] == cur[0] and ans[-2] == cur[0]:\n                if len(chars) > 0:\n                    nxt = chars.pop()\n                    chars.append([nxt[0] + 1, nxt[0]])\n                    chars.append([nxt[0] + 1, nxt[0]])\n                    ans.append(nxt[0] + 1)\n                else:\n                    ans.append(cur[1])\n            else:\n                ans.extend([cur[0]] * (cur[1] - (len(ans) >= 2 and ans[-1] == cur[0] and ans[-2] == cur[0])))\n        \n        return ''.join(map(str, ans))\n```\n\n### Explanation:\n\nThe provided solution is inefficient because it tries two characters at a time and keeps popping from the heap. However, we can make it more efficient by sorting the heap by the frequency of characters and then appending the character with the highest frequency to the result. If the last two characters in the result are the same as the current character, we can append two characters with the next highest frequency to the heap and append one of them to the result.\n\n### Time Complexity:\n\nThe time complexity of the efficient solution is O(max(a, b, c)), where a, b, and c are the input parameters. This is because in the worst case, we might need to append all characters with the same frequency to the result.\n\n### Space Complexity:\n\nThe space complexity of the efficient solution is O(max(a, b, c)), where a, b, and c are the input parameters. This is because in the worst case, the heap might contain all characters with the same frequency.",
    "model_solution": "class Solution:\n    def longestDiverseString(self, a: int, b: int, c: int) -> str:\n        chars = [['a', a], ['b', b], ['c', c]]\n        chars.sort(key=lambda x: x[1], reverse=True)\n        \n        ans = []\n        while len(chars) > 0:\n            cur = chars.pop()\n            if len(ans) >= 2 and ans[-1] == cur[0] and ans[-2] == cur[0]:\n                if len(chars) > 0:\n                    nxt = chars.pop()\n                    chars.append([nxt[0] + 1, nxt[0]])\n                    chars.append([nxt[0] + 1, nxt[0]])\n                    ans.append(nxt[0] + 1)\n                else:\n                    ans.append(cur[1])\n            else:\n                ans.extend([cur[0]] * (cur[1] - (len(ans) >= 2 and ans[-1] == cur[0] and ans[-2] == cur[0])))\n        \n        return ''.join(map(str, ans))",
    "is_python": true
}