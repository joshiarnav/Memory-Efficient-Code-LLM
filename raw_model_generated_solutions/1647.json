{
    "problem_idx": "1647",
    "description": "\nA string `s` is called **good** if there are no two different characters in `s` that have the same **frequency**.\n\n\nGiven a string `s`, return *the **minimum** number of characters you need to delete to make* `s` ***good**.*\n\n\nThe **frequency** of a character in a string is the number of times it appears in the string. For example, in the string `\"aab\"`, the **frequency** of `'a'` is `2`, while the **frequency** of `'b'` is `1`.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** s = \"aab\"\n**Output:** 0\n**Explanation:** s is already good.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** s = \"aaabbbcc\"\n**Output:** 2\n**Explanation:** You can delete two 'b's resulting in the good string \"aaabcc\".\nAnother way it to delete one 'b' and one 'c' resulting in the good string \"aaabbc\".\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** s = \"ceabaacb\"\n**Output:** 2\n**Explanation:** You can delete both 'c's resulting in the good string \"eabaab\".\nNote that we only care about characters that are still in the string at the end (i.e. frequency of 0 is ignored).\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= s.length <= 105`\n* `s`\u00a0contains only lowercase English letters.\n\n\n",
    "inefficient_solution": "class Solution:\n    def minDeletions(self, s: str) -> int:\n        char_freq = {}\n        for char in s:\n            if char in char_freq:\n                char_freq[char] += 1\n            else:\n                char_freq[char] = 1\n\n        max_freq = max(char_freq.values())\n\n        freq_list = []\n        for char in char_freq:\n            freq_list.append(char_freq[char])\n\n        freq_list.sort(reverse=True)\n\n        ans = 0\n        pre = float('inf')\n        for freq in freq_list:\n            if pre == 0:\n                ans += freq\n            elif freq >= pre:\n                ans += freq - pre + 1\n                pre -= 1\n            else:\n                pre = freq\n\n        return ans",
    "efficient_solution": "class Solution:\n    def minDeletions(self, s: str) -> int:\n        cnt = Counter(s)\n        ans, pre = 0, inf\n        for v in sorted(cnt.values(), reverse=True):\n            if pre == 0:\n                ans += v\n            elif v >= pre:\n                ans += v - pre + 1\n                pre -= 1\n            else:\n                pre = v\n        return ans\n",
    "model_generation": "### Problem Description:\n\nA string `s` is called **good** if there are no two different characters in `s` that have the same **frequency**.\n\n\nGiven a string `s`, return *the **minimum** number of characters you need to delete to make* `s` ***good**.*\n\n\nThe **frequency** of a character in a string is the number of times it appears in the string. For example, in the string `\"aab\"`, the **frequency** of `'a'` is `2`, while the **frequency** of `'b'` is `1`.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** s = \"aab\"\n**Output:** 0\n**Explanation:** s is already good.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** s = \"aaabbbcc\"\n**Output:** 2\n**Explanation:** You can delete two 'b's resulting in the good string \"aaabcc\".\nAnother way it to delete one 'b' and one 'c' resulting in the good string \"aaabbc\".\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** s = \"ceabaacb\"\n**Output:** 2\n**Explanation:** You can delete both 'c's resulting in the good string \"eabaab\".\nNote that we only care about characters that are still in the string at the end (i.e. frequency of 0 is ignored).\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= s.length <= 105`\n* `s`\u00a0contains only lowercase English letters.\n\n\n\n\n### Inefficient Solution:\n```python\nclass Solution:\n    def minDeletions(self, s: str) -> int:\n        char_freq = {}\n        for char in s:\n            if char in char_freq:\n                char_freq[char] += 1\n            else:\n                char_freq[char] = 1\n\n        max_freq = max(char_freq.values())\n\n        freq_list = []\n        for char in char_freq:\n            freq_list.append(char_freq[char])\n\n        freq_list.sort(reverse=True)\n\n        ans = 0\n        pre = float('inf')\n        for freq in freq_list:\n            if pre == 0:\n                ans += freq\n            elif freq >= pre:\n                ans += freq - pre + 1\n                pre -= 1\n            else:\n                pre = freq\n\n        return ans\n```\n\n### Efficient Solution:\n\nWe can use a dictionary to store the frequency of each character in the string, and then use a set to store the unique frequencies. The idea is to find the maximum frequency that can be assigned to a character, and then calculate the minimum number of deletions required to make the string good.\n\n```python\nclass Solution:\n    def minDeletions(self, s: str) -> int:\n        char_freq = {}\n        for char in s:\n            if char in char_freq:\n                char_freq[char] += 1\n            else:\n                char_freq[char] = 1\n        \n        freq_set = set()\n        ans = 0\n        \n        for freq in sorted(char_freq.values(), reverse=True):\n            while freq in freq_set:\n                freq -= 1\n                ans += 1\n            if freq > 0:\n                freq_set.add(freq)\n        \n        return ans\n```\n\nThis solution works by iterating over the frequencies in descending order, and for each frequency, it checks if it's already in the set of unique frequencies. If it is, it decrements the frequency until it's not in the set, and increments the answer by the number of decrements. This process continues until a frequency is found that's not in the set, which is then added to the set.\n\nThe time complexity of this solution is O(n log n) due to the sorting of the frequencies, and the space complexity is O(n) for storing the frequency of each character.",
    "model_solution": "class Solution:\n    def minDeletions(self, s: str) -> int:\n        char_freq = {}\n        for char in s:\n            if char in char_freq:\n                char_freq[char] += 1\n            else:\n                char_freq[char] = 1\n\n        max_freq = max(char_freq.values())\n\n        freq_list = []\n        for char in char_freq:\n            freq_list.append(char_freq[char])\n\n        freq_list.sort(reverse=True)\n\n        ans = 0\n        pre = float('inf')\n        for freq in freq_list:\n            if pre == 0:\n                ans += freq\n            elif freq >= pre:\n                ans += freq - pre + 1\n                pre -= 1\n            else:\n                pre = freq\n\n        return ans",
    "is_python": true
}