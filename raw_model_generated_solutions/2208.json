{
    "problem_idx": "2208",
    "description": "\nYou are given an array `nums` of positive integers. In one operation, you can choose **any** number from `nums` and reduce it to **exactly** half the number. (Note that you may choose this reduced number in future operations.)\n\n\nReturn *the **minimum** number of operations to reduce the sum of* `nums` *by **at least** half.*\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** nums = [5,19,8,1]\n**Output:** 3\n**Explanation:** The initial sum of nums is equal to 5 + 19 + 8 + 1 = 33.\nThe following is one of the ways to reduce the sum by at least half:\nPick the number 19 and reduce it to 9.5.\nPick the number 9.5 and reduce it to 4.75.\nPick the number 8 and reduce it to 4.\nThe final array is [5, 4.75, 4, 1] with a total sum of 5 + 4.75 + 4 + 1 = 14.75. \nThe sum of nums has been reduced by 33 - 14.75 = 18.25, which is at least half of the initial sum, 18.25 >= 33/2 = 16.5.\nOverall, 3 operations were used so we return 3.\nIt can be shown that we cannot reduce the sum by at least half in less than 3 operations.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** nums = [3,8,20]\n**Output:** 3\n**Explanation:** The initial sum of nums is equal to 3 + 8 + 20 = 31.\nThe following is one of the ways to reduce the sum by at least half:\nPick the number 20 and reduce it to 10.\nPick the number 10 and reduce it to 5.\nPick the number 3 and reduce it to 1.5.\nThe final array is [1.5, 8, 5] with a total sum of 1.5 + 8 + 5 = 14.5. \nThe sum of nums has been reduced by 31 - 14.5 = 16.5, which is at least half of the initial sum, 16.5 >= 31/2 = 15.5.\nOverall, 3 operations were used so we return 3.\nIt can be shown that we cannot reduce the sum by at least half in less than 3 operations.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= nums.length <= 105`\n* `1 <= nums[i] <= 107`\n\n\n",
    "inefficient_solution": "class Solution:\n    def halveArray(self, nums: List[int]) -> int:\n        s = sum(nums) / 2\n        vals = []\n        for v in nums:\n            vals.append((v, v))\n        for v in vals:\n            v[0] = v[1] / 2\n        for v in vals:\n            if v[1] > 0:\n                v[1] /= 2\n        h = []\n        for v in vals:\n            h.append(v)\n        ans = 0\n        while s > 0:\n            t = max(h, key=lambda x: x[0])\n            h.remove(t)\n            t = (t[0] / 2, t[1] / 2)\n            h.append(t)\n            s -= t[1]\n            ans += 1\n        return ans",
    "efficient_solution": "class Solution:\n    def halveArray(self, nums: List[int]) -> int:\n        s = sum(nums) / 2\n        h = []\n        for v in nums:\n            heappush(h, -v)\n        ans = 0\n        while s > 0:\n            t = -heappop(h) / 2\n            s -= t\n            heappush(h, -t)\n            ans += 1\n        return ans\n",
    "model_generation": "Here's an efficient solution for the problem.\n\n### Efficient Solution:\n\n```python\nimport heapq\nfrom typing import List\n\nclass Solution:\n    def halveArray(self, nums: List[int]) -> int:\n        s = sum(nums)\n        pq = []\n        for num in nums:\n            heapq.heappush(pq, -num)  # Use negative numbers to simulate a max heap\n        ans = 0\n        while s > 0:\n            num = -heapq.heappop(pq)\n            s -= num\n            num /= 2\n            heapq.heappush(pq, -num)\n            ans += 1\n        return ans\n```\n\n### Explanation:\n\nThis solution takes advantage of a priority queue (implemented using a heap) to keep track of the largest numbers in the array. We use negative numbers to simulate a max heap, which is why we push the negative of each number into the heap.\n\nIn each iteration of the while loop, we pop the largest number from the heap, subtract it from the total sum, divide it by 2, and push it back into the heap. We repeat this process until the total sum is less than or equal to 0.\n\nThe time complexity of this solution is O(n log n) due to the use of a heap, where n is the number of elements in the input array.\n\n### Example Use Cases:\n\n```python\nsolution = Solution()\nprint(solution.halveArray([5, 19, 8, 1]))  # Output: 3\nprint(solution.halveArray([3, 8, 20]))  # Output: 3\n```",
    "model_solution": "import heapq\nfrom typing import List\n\nclass Solution:\n    def halveArray(self, nums: List[int]) -> int:\n        s = sum(nums)\n        pq = []\n        for num in nums:\n            heapq.heappush(pq, -num)  # Use negative numbers to simulate a max heap\n        ans = 0\n        while s > 0:\n            num = -heapq.heappop(pq)\n            s -= num\n            num /= 2\n            heapq.heappush(pq, -num)\n            ans += 1\n        return ans",
    "is_python": true
}