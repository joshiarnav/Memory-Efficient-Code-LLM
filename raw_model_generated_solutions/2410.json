{
    "problem_idx": "2410",
    "description": "\nYou are given a **0-indexed** integer array `players`, where `players[i]` represents the **ability** of the `ith` player. You are also given a **0-indexed** integer array `trainers`, where `trainers[j]` represents the **training capacity** of the `jth` trainer.\n\n\nThe `ith` player can **match** with the `jth` trainer if the player's ability is **less than or equal to** the trainer's training capacity. Additionally, the `ith` player can be matched with at most one trainer, and the `jth` trainer can be matched with at most one player.\n\n\nReturn *the **maximum** number of matchings between* `players` *and* `trainers` *that satisfy these conditions.*\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** players = [4,7,9], trainers = [8,2,5,8]\n**Output:** 2\n**Explanation:**\nOne of the ways we can form two matchings is as follows:\n- players[0] can be matched with trainers[0] since 4 <= 8.\n- players[1] can be matched with trainers[3] since 7 <= 8.\nIt can be proven that 2 is the maximum number of matchings that can be formed.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** players = [1,1,1], trainers = [10]\n**Output:** 1\n**Explanation:**\nThe trainer can be matched with any of the 3 players.\nEach player can only be matched with one trainer, so the maximum answer is 1.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= players.length, trainers.length <= 105`\n* `1 <= players[i], trainers[j] <= 109`\n\n\n",
    "inefficient_solution": "class Solution:\n    def matchPlayersAndTrainers(self, players: List[int], trainers: List[int]) -> int:\n        players = [i * 1000 for i in players]\n        trainers = [i * 1000 for i in trainers]\n        players.sort()\n        trainers.sort()\n        ans = j = 0\n        while j < len(trainers):\n            for p in players:\n                if p <= trainers[j]:\n                    ans += 1\n                    break\n            j += 1\n        return ans",
    "efficient_solution": "class Solution:\n    def matchPlayersAndTrainers(self, players: List[int], trainers: List[int]) -> int:\n        players.sort()\n        trainers.sort()\n        ans = j = 0\n        for p in players:\n            while j < len(trainers) and trainers[j] < p:\n                j += 1\n            if j < len(trainers):\n                ans += 1\n                j += 1\n        return ans\n",
    "model_generation": "### Efficient Solution\n\nWe can use a two-pointer technique to solve this problem efficiently. The idea is to sort both the players and trainers arrays and then move two pointers, one from the start of the `players` array and one from the start of the `trainers` array.\n\nHere is the efficient solution in Python:\n\n```python\nclass Solution:\n    def matchPlayersAndTrainers(self, players: List[int], trainers: List[int]) -> int:\n        players.sort()\n        trainers.sort()\n        j = 0\n        ans = 0\n        for p in players:\n            while j < len(trainers) and p > trainers[j]:\n                j += 1\n            if j < len(trainers):\n                ans += 1\n                j += 1\n        return ans\n```\n\n### Explanation\n\n- We first sort both the `players` and `trainers` arrays.\n- We initialize two pointers, `i` and `j`, to 0, where `i` is used to traverse the `players` array and `j` is used to traverse the `trainers` array.\n- We initialize a variable `ans` to 0, which will store the maximum number of matchings.\n- We then iterate over the `players` array. For each player, we iteratively move the `j` pointer to the right until we find a trainer with a capacity greater than or equal to the player's ability. If we find such a trainer, we increment `ans` by 1 and move the `j` pointer to the right.\n- Finally, we return `ans`, which stores the maximum number of matchings.\n\n### Time Complexity\n\nThe time complexity of this solution is O(n log n + m log m), where n is the number of players and m is the number of trainers. This is because we first sort both arrays, which takes O(n log n + m log m) time, and then we iterate over the `players` array, which takes O(n) time.\n\n### Space Complexity\n\nThe space complexity of this solution is O(1), excluding the space required for the input arrays. This is because we only use a constant amount of space to store the variables `ans`, `i`, and `j`.",
    "model_solution": "class Solution:\n    def matchPlayersAndTrainers(self, players: List[int], trainers: List[int]) -> int:\n        players.sort()\n        trainers.sort()\n        j = 0\n        ans = 0\n        for p in players:\n            while j < len(trainers) and p > trainers[j]:\n                j += 1\n            if j < len(trainers):\n                ans += 1\n                j += 1\n        return ans",
    "is_python": true
}