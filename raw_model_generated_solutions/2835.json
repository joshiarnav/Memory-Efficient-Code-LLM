{
    "problem_idx": "2835",
    "description": "\nYou are given a **0-indexed** array `nums` consisting of **non-negative** powers of `2`, and an integer `target`.\n\n\nIn one operation, you must apply the following changes to the array:\n\n\n* Choose any element of the array `nums[i]` such that `nums[i] > 1`.\n* Remove `nums[i]` from the array.\n* Add **two** occurrences of `nums[i] / 2` to the **end** of `nums`.\n\n\nReturn the ***minimum number of operations** you need to perform so that* `nums` *contains a **subsequence** whose elements sum to* `target`. If it is impossible to obtain such a subsequence, return `-1`.\n\n\nA **subsequence** is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** nums = [1,2,8], target = 7\n**Output:** 1\n**Explanation:** In the first operation, we choose element nums[2]. The array becomes equal to nums = [1,2,4,4].\nAt this stage, nums contains the subsequence [1,2,4] which sums up to 7.\nIt can be shown that there is no shorter sequence of operations that results in a subsequnce that sums up to 7.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** nums = [1,32,1,2], target = 12\n**Output:** 2\n**Explanation:** In the first operation, we choose element nums[1]. The array becomes equal to nums = [1,1,2,16,16].\nIn the second operation, we choose element nums[3]. The array becomes equal to nums = [1,1,2,16,8,8]\nAt this stage, nums contains the subsequence [1,1,2,8] which sums up to 12.\nIt can be shown that there is no shorter sequence of operations that results in a subsequence that sums up to 12.\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** nums = [1,32,1], target = 35\n**Output:** -1\n**Explanation:** It can be shown that no sequence of operations results in a subsequence that sums up to 35.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= nums.length <= 1000`\n* `1 <= nums[i] <= 230`\n* `nums` consists only of non-negative powers of two.\n* `1 <= target < 231`\n\n\n",
    "inefficient_solution": "class Solution:\n    def minOperations(self, nums: List[int], target: int) -> int:\n        s = sum(nums)\n        if s < target:\n            return -1\n        max_num = max(nums)\n        powers_of_2 = [0] * 30\n        for x in nums:\n            i = 0\n            while x > 1:\n                if x & 1:\n                    powers_of_2[i] += 1\n                x >>= 1\n                i += 1\n        for i in range(30):\n            powers_of_2[i] += 1\n        n = len(powers_of_2)\n        dp = [[0] * (target + 1) for _ in range(n + 1)]\n        for i in range(n + 1):\n            dp[i][0] = 1\n        for i in range(1, n + 1):\n            for j in range(1, target + 1):\n                for k in range(min(j, powers_of_2[i - 1] * 2) + 1):\n                    dp[i][j] |= dp[i - 1][j - k]\n        max_operations = n\n        for i in range(target + 1):\n            for j in range(n, 0, -1):\n                if dp[j][i]:\n                    max_operations = min(max_operations, j - i)\n                    break\n        return max_operations",
    "efficient_solution": "class Solution:\n    def minOperations(self, nums: List[int], target: int) -> int:\n        s = sum(nums)\n        if s < target:\n            return -1\n        cnt = [0] * 32\n        for x in nums:\n            for i in range(32):\n                if x >> i & 1:\n                    cnt[i] += 1\n        i = j = 0\n        ans = 0\n        while 1:\n            while i < 32 and (target >> i & 1) == 0:\n                i += 1\n            if i == 32:\n                break\n            while j < i:\n                cnt[j + 1] += cnt[j] // 2\n                cnt[j] %= 2\n                j += 1\n            while cnt[j] == 0:\n                cnt[j] = 1\n                j += 1\n            ans += j - i\n            cnt[j] -= 1\n            j = i\n            i += 1\n        return ans\n",
    "model_generation": "### Efficient Solution\n\n```python\nclass Solution:\n    def minOperations(self, nums: List[int], target: int) -> int:\n        dp = {0: 0}  # Initialize a dictionary to store the minimum operations for each sum\n        \n        for num in sorted(nums, reverse=True):\n            new_dp = {}  # Initialize a dictionary to store the minimum operations for the current sum\n            for s, op in dp.items():\n                new_s = s + num\n                if new_s > target:\n                    continue\n                if new_s not in new_dp or op + 1 < new_dp[new_s]:\n                    new_dp[new_s] = op + 1\n                new_s = s + 2 * num\n                if new_s <= target and (new_s not in new_dp or op + 1 < new_dp[new_s]):\n                    new_dp[new_s] = op + 1\n            dp = new_dp\n        \n        return dp.get(target, -1)\n```\n\n### Explanation:\n\nThis efficient solution uses dynamic programming to find the minimum number of operations.\n\n1.  Initialize a dictionary `dp` to store the minimum operations for each sum from 0 to `target`.\n2.  Iterate over the sorted `nums` array in descending order.\n3.  For each number `num` in the array, update the `dp` dictionary by considering two types of operations:\n    *   Add `num` to the current sum `s`.\n    *   Add `2 * num` to the current sum `s`.\n4.  If the new sum is within the range `[0, target]`, update the minimum operations in the `dp` dictionary.\n5.  After iterating over all numbers in the array, the `dp` dictionary will contain the minimum operations for each sum from 0 to `target`.\n6.  Return the minimum operations for the target sum. If the target sum is not reachable, return -1.\n\nThis solution has a time complexity of O(n log n) due to the sorting of the `nums` array, where n is the length of the array. The space complexity is O(n), where n is the target sum.",
    "model_solution": "class Solution:\n    def minOperations(self, nums: List[int], target: int) -> int:\n        dp = {0: 0}  # Initialize a dictionary to store the minimum operations for each sum\n        \n        for num in sorted(nums, reverse=True):\n            new_dp = {}  # Initialize a dictionary to store the minimum operations for the current sum\n            for s, op in dp.items():\n                new_s = s + num\n                if new_s > target:\n                    continue\n                if new_s not in new_dp or op + 1 < new_dp[new_s]:\n                    new_dp[new_s] = op + 1\n                new_s = s + 2 * num\n                if new_s <= target and (new_s not in new_dp or op + 1 < new_dp[new_s]):\n                    new_dp[new_s] = op + 1\n            dp = new_dp\n        \n        return dp.get(target, -1)",
    "is_python": true
}