{
    "problem_idx": "1442",
    "description": "\nGiven an array of integers `arr`.\n\n\nWe want to select three indices `i`, `j` and `k` where `(0 <= i < j <= k < arr.length)`.\n\n\nLet's define `a` and `b` as follows:\n\n\n* `a = arr[i] ^ arr[i + 1] ^ ... ^ arr[j - 1]`\n* `b = arr[j] ^ arr[j + 1] ^ ... ^ arr[k]`\n\n\nNote that **^** denotes the **bitwise-xor** operation.\n\n\nReturn *the number of triplets* (`i`, `j` and `k`) Where `a == b`.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** arr = [2,3,1,6,7]\n**Output:** 4\n**Explanation:** The triplets are (0,1,2), (0,2,2), (2,3,4) and (2,4,4)\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** arr = [1,1,1,1,1]\n**Output:** 10\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= arr.length <= 300`\n* `1 <= arr[i] <= 108`\n\n\n",
    "inefficient_solution": "class Solution:\n    def countTriplets(self, arr: List[int]) -> int:\n        n = len(arr)\n        pre = [0] * (n * 100)  # allocate 100 times more memory than needed\n        for i in range(n):\n            pre[i + 1] = pre[i] ^ arr[i]\n        ans = 0\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                for k in range(j, n):\n                    a = 0\n                    for x in range(i, j):\n                        a ^= arr[x]\n                    b = 0\n                    for y in range(j, k + 1):\n                        b ^= arr[y]\n                    if a == b:\n                        ans += 1\n        return ans",
    "efficient_solution": "class Solution:\n    def countTriplets(self, arr: List[int]) -> int:\n        n = len(arr)\n        pre = [0] * (n + 1)\n        for i in range(n):\n            pre[i + 1] = pre[i] ^ arr[i]\n        ans = 0\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                for k in range(j, n):\n                    a, b = pre[j] ^ pre[i], pre[k + 1] ^ pre[j]\n                    if a == b:\n                        ans += 1\n        return ans\n",
    "model_generation": "### Problem Description:\n\nGiven an array of integers `arr`, we want to select three indices `i`, `j`, and `k` where `(0 <= i < j <= k < arr.length)`, and define `a` and `b` as follows:\n\n* `a = arr[i] ^ arr[i + 1] ^ ... ^ arr[j - 1]`\n* `b = arr[j] ^ arr[j + 1] ^ ... ^ arr[k]`\n\nNote that **^** denotes the **bitwise-xor** operation.\n\nReturn the number of triplets (`i`, `j`, and `k`) Where `a == b`.\n\n### Efficient Solution:\n\n```python\nclass Solution:\n    def countTriplets(self, arr: List[int]) -> int:\n        n = len(arr)\n        prefix_xor = [0] * n\n        prefix_xor[0] = arr[0]\n        for i in range(1, n):\n            prefix_xor[i] = prefix_xor[i - 1] ^ arr[i]\n        \n        ans = 0\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                a = prefix_xor[i]\n                b = prefix_xor[j - 1] ^ prefix_xor[j]\n                if a == b:\n                    # Count the number of pairs (j, k) where a == b\n                    ans += n - j\n        return ans\n```\n\n### Explanation:\n\nWe use a prefix XOR array to store the XOR of all elements up to each index. This allows us to calculate `a` and `b` in constant time.\n\nFor each pair of indices `(i, j)`, we calculate `a` as the XOR of all elements up to `i` (inclusive), and `b` as the XOR of all elements from `j` to the end of the array.\n\nWe then count the number of pairs `(j, k)` where `a == b`. We can do this by subtracting `j` from `n`, since we can choose any index `k` in the range `[j, n)` to form a triple `(i, j, k)` where `a == b`.\n\nThis solution has a time complexity of O(n^2) and a space complexity of O(n), which is more efficient than the original solution.",
    "model_solution": "class Solution:\n    def countTriplets(self, arr: List[int]) -> int:\n        n = len(arr)\n        prefix_xor = [0] * n\n        prefix_xor[0] = arr[0]\n        for i in range(1, n):\n            prefix_xor[i] = prefix_xor[i - 1] ^ arr[i]\n        \n        ans = 0\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                a = prefix_xor[i]\n                b = prefix_xor[j - 1] ^ prefix_xor[j]\n                if a == b:\n                    # Count the number of pairs (j, k) where a == b\n                    ans += n - j\n        return ans",
    "is_python": true
}