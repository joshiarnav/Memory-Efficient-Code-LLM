{
    "problem_idx": "413",
    "description": "\nAn integer array is called arithmetic if it consists of **at least three elements** and if the difference between any two consecutive elements is the same.\n\n\n* For example, `[1,3,5,7,9]`, `[7,7,7,7]`, and `[3,-1,-5,-9]` are arithmetic sequences.\n\n\nGiven an integer array `nums`, return *the number of arithmetic **subarrays** of* `nums`.\n\n\nA **subarray** is a contiguous subsequence of the array.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** nums = [1,2,3,4]\n**Output:** 3\n**Explanation:** We have 3 arithmetic slices in nums: [1, 2, 3], [2, 3, 4] and [1,2,3,4] itself.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** nums = [1]\n**Output:** 0\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= nums.length <= 5000`\n* `-1000 <= nums[i] <= 1000`\n\n\n",
    "inefficient_solution": "class Solution:\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\n        ans = 0\n        slices = []\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                for k in range(j + 1, len(nums)):\n                    diff = nums[j] - nums[i]\n                    if nums[k] - nums[j] == diff:\n                        slices.append((nums[i], nums[j], nums[k]))\n                        if len(slices) == 1:\n                            ans += 1\n                        else:\n                            for slice in slices[:-1]:\n                                if (slice[1] - slice[0]) == diff and (slice[2] - slice[1]) == diff:\n                                    ans += 1\n                                    break\n        return ans",
    "efficient_solution": "class Solution:\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\n        ans = cnt = 0\n        d = 3000\n        for a, b in pairwise(nums):\n            if b - a == d:\n                cnt += 1\n            else:\n                d = b - a\n                cnt = 0\n            ans += cnt\n        return ans\n",
    "model_generation": "### Efficient Solution\n\n```python\nclass Solution:\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\n        n = len(nums)\n        ans = 0\n        dp = [0] * n\n        \n        # Initialize dp[0] and dp[1] as 0\n        for i in range(2, n):\n            if nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2]:\n                dp[i] = dp[i - 1] + 1\n                ans += dp[i]\n        \n        return ans\n```\n\n### Explanation\n\nThe given solution is inefficient because it uses three nested loops to generate all possible subarrays and checks each subarray for being an arithmetic sequence. However, we can solve the problem more efficiently by maintaining a dynamic programming (DP) array `dp` to store the number of arithmetic sequences ending at each position `i`. We can update `dp` iteratively by checking if the current element forms an arithmetic sequence with the previous two elements. If they form an arithmetic sequence, we increment the value at `dp[i]` by the value at `dp[i - 1]`, effectively counting the number of arithmetic sequences ending at `i - 1` as a new arithmetic sequence ending at `i`. Finally, we sum up all the values in `dp` to get the total number of arithmetic sequences.\n\nThe time complexity of this solution is O(n), where n is the number of elements in the input array, because we only need to iterate through the array once to fill up the DP array. The space complexity is also O(n) because we need to store the DP array.",
    "model_solution": "class Solution:\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\n        n = len(nums)\n        ans = 0\n        dp = [0] * n\n        \n        # Initialize dp[0] and dp[1] as 0\n        for i in range(2, n):\n            if nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2]:\n                dp[i] = dp[i - 1] + 1\n                ans += dp[i]\n        \n        return ans",
    "is_python": true
}