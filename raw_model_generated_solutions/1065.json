{
    "problem_idx": "1065",
    "description": "\nGiven a string `text` and an array of strings `words`, return *an array of all index pairs* `[i, j]` *so that the substring* `text[i...j]` *is in `words`*.\n\n\nReturn the pairs `[i, j]` in sorted order (i.e., sort them by their first coordinate, and in case of ties sort them by their second coordinate).\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** text = \"thestoryofleetcodeandme\", words = [\"story\",\"fleet\",\"leetcode\"]\n**Output:** [[3,7],[9,13],[10,17]]\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** text = \"ababa\", words = [\"aba\",\"ab\"]\n**Output:** [[0,1],[0,2],[2,3],[2,4]]\n**Explanation:** Notice that matches can overlap, see \"aba\" is found in [0,2] and [2,4].\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= text.length <= 100`\n* `1 <= words.length <= 20`\n* `1 <= words[i].length <= 50`\n* `text` and `words[i]` consist of lowercase English letters.\n* All the strings of `words` are **unique**.\n\n\n",
    "inefficient_solution": "class Solution:\n    def indexPairs(self, text: str, words: List[str]) -> List[List[int]]:\n        n = len(text)\n        m = len(words)\n        freq_table = {}\n        for w in words:\n            freq_table[w] = 1\n        for i in range(m):\n            w = words[i]\n            for j in range(n):\n                substring = text[j:j+len(w)]\n                if substring in freq_table:\n                    freq_table[substring] += 1\n        ans = []\n        for i in range(n):\n            for j in range(i, n):\n                substring = text[i:j+1]\n                if substring in freq_table and freq_table[substring] > 1:\n                    ans.append([i, j])\n        return ans",
    "efficient_solution": "class Trie:\n    def __init__(self):\n        self.children = [None] * 26\n        self.is_end = False\n\n    def insert(self, word):\n        node = self\n        for c in word:\n            idx = ord(c) - ord('a')\n            if node.children[idx] is None:\n                node.children[idx] = Trie()\n            node = node.children[idx]\n        node.is_end = True\n\n\nclass Solution:\n    def indexPairs(self, text: str, words: List[str]) -> List[List[int]]:\n        trie = Trie()\n        for w in words:\n            trie.insert(w)\n        n = len(text)\n        ans = []\n        for i in range(n):\n            node = trie\n            for j in range(i, n):\n                idx = ord(text[j]) - ord('a')\n                if node.children[idx] is None:\n                    break\n                node = node.children[idx]\n                if node.is_end:\n                    ans.append([i, j])\n        return ans\n",
    "model_generation": "### Efficient Solution\nTo solve this problem efficiently, we can use a two-pointer technique. The idea is to slide a window of increasing size over the `text` string and check if the substring within the window is present in the `words` list.\n\nHere's the efficient solution:\n\n```python\nfrom typing import List\n\nclass Solution:\n    def indexPairs(self, text: str, words: List[str]) -> List[List[int]]:\n        n = len(text)\n        m = len(words)\n        ans = []\n        \n        # Iterate over each word in the words list\n        for w in words:\n            # Find the index of the word in the text\n            index = text.find(w)\n            while index != -1:\n                # Append the index pair to the answer list\n                ans.append([index, index + len(w) - 1])\n                \n                # Find the next occurrence of the word in the text\n                index = text.find(w, index + 1)\n        \n        # Sort the answer list\n        ans.sort()\n        \n        return ans\n```\n\n### Explanation:\n\n1. We iterate over each word in the `words` list.\n2. For each word, we find its index in the `text` string using the `find()` method.\n3. Once we find the index, we append the index pair to the `ans` list.\n4. We continue finding the next occurrence of the word in the `text` string by passing the current index plus one to the `find()` method.\n5. Finally, we sort the `ans` list to ensure that the index pairs are in sorted order.\n\n### Time Complexity:\n\nThe time complexity of this solution is O(n*m*avg_len), where n is the length of the `text` string, m is the number of words in the `words` list, and avg_len is the average length of the words in the `words` list.\n\n### Space Complexity:\n\nThe space complexity of this solution is O(m*avg_len), as we need to store the index pairs for each word in the `ans` list.",
    "model_solution": "from typing import List\n\nclass Solution:\n    def indexPairs(self, text: str, words: List[str]) -> List[List[int]]:\n        n = len(text)\n        m = len(words)\n        ans = []\n        \n        # Iterate over each word in the words list\n        for w in words:\n            # Find the index of the word in the text\n            index = text.find(w)\n            while index != -1:\n                # Append the index pair to the answer list\n                ans.append([index, index + len(w) - 1])\n                \n                # Find the next occurrence of the word in the text\n                index = text.find(w, index + 1)\n        \n        # Sort the answer list\n        ans.sort()\n        \n        return ans",
    "is_python": true
}