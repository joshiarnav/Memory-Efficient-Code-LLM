{
    "problem_idx": "1955",
    "description": "\nA sequence is **special** if it consists of a **positive** number of `0`s, followed by a **positive** number of `1`s, then a **positive** number of `2`s.\n\n\n* For example, `[0,1,2]` and `[0,0,1,1,1,2]` are special.\n* In contrast, `[2,1,0]`, `[1]`, and `[0,1,2,0]` are not special.\n\n\nGiven an array `nums` (consisting of **only** integers `0`, `1`, and `2`), return *the **number of different subsequences** that are special*. Since the answer may be very large, **return it modulo** `109 + 7`.\n\n\nA **subsequence** of an array is a sequence that can be derived from the array by deleting some or no elements without changing the order of the remaining elements. Two subsequences are **different** if the **set of indices** chosen are different.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** nums = [0,1,2,2]\n**Output:** 3\n**Explanation:** The special subsequences are bolded [**0**,**1**,**2**,2], [**0**,**1**,2,**2**], and [**0**,**1**,**2**,**2**].\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** nums = [2,2,0,0]\n**Output:** 0\n**Explanation:** There are no special subsequences in [2,2,0,0].\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** nums = [0,1,2,0,1,2]\n**Output:** 7\n**Explanation:** The special subsequences are bolded:\n- [**0**,**1**,**2**,0,1,2]\n- [**0**,**1**,2,0,1,**2**]\n- [**0**,**1**,**2**,0,1,**2**]\n- [**0**,**1**,2,0,**1**,**2**]\n- [**0**,1,2,**0**,**1**,**2**]\n- [**0**,1,2,0,**1**,**2**]\n- [0,1,2,**0**,**1**,**2**]\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= nums.length <= 105`\n* `0 <= nums[i] <= 2`\n\n\n",
    "inefficient_solution": "class Solution:\n    def countSpecialSubsequences(self, nums: List[int]) -> int:\n        mod = 10**9 + 7\n        n = len(nums)\n        dp = [[[] for _ in range(3)] for _ in range(n)]\n        for i in range(n):\n            for j in range(3):\n                dp[i][j] = [0] * 10\n        for i in range(n):\n            dp[i][0][0] = 1 if nums[i] == 0 else 0\n        for i in range(1, n):\n            for j in range(3):\n                for k in range(len(dp[i-1][j])):\n                    dp[i][j][k] = 0\n            for j in range(3):\n                if nums[i] == 0:\n                    dp[i][0][0] = (2 * dp[i-1][0][0] + dp[i-1][0][0]) % mod\n                elif nums[i] == 1:\n                    dp[i][1][0] = (dp[i-1][0][0] + 2 * dp[i-1][1][0]) % mod\n                else:\n                    dp[i][2][0] = (dp[i-1][1][0] + 2 * dp[i-1][2][0]) % mod\n        ans = 0\n        for i in range(n):\n            for j in range(3):\n                ans = (ans + dp[n-1][j][0]) % mod\n        return ans",
    "efficient_solution": "class Solution:\n    def countSpecialSubsequences(self, nums: List[int]) -> int:\n        mod = 10**9 + 7\n        n = len(nums)\n        f = [0] * 3\n        f[0] = nums[0] == 0\n        for i in range(1, n):\n            if nums[i] == 0:\n                f[0] = (2 * f[0] + 1) % mod\n            elif nums[i] == 1:\n                f[1] = (f[0] + 2 * f[1]) % mod\n            else:\n                f[2] = (f[1] + 2 * f[2]) % mod\n        return f[2]\n",
    "model_generation": "### Efficient Solution\n\n```python\nclass Solution:\n    def countSpecialSubsequences(self, nums: List[int]) -> int:\n        mod = 10**9 + 7\n        n = len(nums)\n        dp = [[0, 0, 0] for _ in range(n + 1)]\n        \n        dp[0][0] = 1\n        for i in range(n):\n            if nums[i] == 0:\n                dp[i + 1][0] = (dp[i][0] * 2) % mod\n            elif nums[i] == 1:\n                dp[i + 1][1] = (dp[i][0] + dp[i][1] * 2) % mod\n            else:\n                dp[i + 1][2] = (dp[i][1] + dp[i][2] * 2) % mod\n        \n        return (dp[n][0] + dp[n][1]) % mod\n```\n\n### Explanation\n\nThe provided solution is inefficient because it uses a 3D array, where the extra dimension is not necessary. We can achieve the same result by using a 2D array.\n\nThe key idea here is to keep track of the number of special subsequences ending at each prefix of the array, with the last element being the maximum length of `0`s, `1`s, and `2`s seen so far.\n\nWe can calculate the number of special subsequences ending at each prefix in linear time using the previously calculated values.\n\nFinally, we return the sum of the number of special subsequences ending at the last prefix, which is the maximum length of `0`s and `1`s, modulo `10^9 + 7`.",
    "model_solution": "class Solution:\n    def countSpecialSubsequences(self, nums: List[int]) -> int:\n        mod = 10**9 + 7\n        n = len(nums)\n        dp = [[0, 0, 0] for _ in range(n + 1)]\n        \n        dp[0][0] = 1\n        for i in range(n):\n            if nums[i] == 0:\n                dp[i + 1][0] = (dp[i][0] * 2) % mod\n            elif nums[i] == 1:\n                dp[i + 1][1] = (dp[i][0] + dp[i][1] * 2) % mod\n            else:\n                dp[i + 1][2] = (dp[i][1] + dp[i][2] * 2) % mod\n        \n        return (dp[n][0] + dp[n][1]) % mod",
    "is_python": true
}