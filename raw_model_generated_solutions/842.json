{
    "problem_idx": "842",
    "description": "\nYou are given a string of digits `num`, such as `\"123456579\"`. We can split it into a Fibonacci-like sequence `[123, 456, 579]`.\n\n\nFormally, a **Fibonacci-like** sequence is a list `f` of non-negative integers such that:\n\n\n* `0 <= f[i] < 231`, (that is, each integer fits in a **32-bit** signed integer type),\n* `f.length >= 3`, and\n* `f[i] + f[i + 1] == f[i + 2]` for all `0 <= i < f.length - 2`.\n\n\nNote that when splitting the string into pieces, each piece must not have extra leading zeroes, except if the piece is the number `0` itself.\n\n\nReturn any Fibonacci-like sequence split from `num`, or return `[]` if it cannot be done.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** num = \"1101111\"\n**Output:** [11,0,11,11]\n**Explanation:** The output [110, 1, 111] would also be accepted.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** num = \"112358130\"\n**Output:** []\n**Explanation:** The task is impossible.\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** num = \"0123\"\n**Output:** []\n**Explanation:** Leading zeroes are not allowed, so \"01\", \"2\", \"3\" is not valid.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= num.length <= 200`\n* `num` contains only digits.\n\n\n",
    "inefficient_solution": "class Solution:\n    def splitIntoFibonacci(self, num: str) -> List[int]:\n        ans = []\n        for i in range(len(num)):\n            for j in range(i, len(num)):\n                for k in range(j, len(num)):\n                    for m in range(k, len(num)):\n                        for n in range(m, len(num)):\n                            for o in range(n, len(num)):\n                                x = int(num[i:j+1])\n                                y = int(num[j:k+1])\n                                z = int(num[k:m+1])\n                                w = int(num[m:n+1])\n                                t = int(num[n:o+1])\n                                v = int(num[o:])\n                                if x > 2**31 - 1 or y > 2**31 - 1 or z > 2**31 - 1 or w > 2**31 - 1 or t > 2**31 - 1 or v > 2**31 - 1:\n                                    break\n                                if x == 0 and y == 0 and z == 0:\n                                    continue\n                                if x == 0 and y == 0 and z > 0 and w == 0 and t == 0:\n                                    continue\n                                if x == 0 and y == 0 and z > 0 and w == 0 and t > 0 and t == z + w:\n                                    ans = [0, 0, z, w, t]\n                                    break\n                                if x > 0 and y == 0 and z == 0 and w == 0 and t == 0:\n                                    continue\n                                if x > 0 and y == 0 and z > 0 and w == 0 and t == 0:\n                                    continue\n                                if x > 0 and y == 0 and z > 0 and w == 0 and t > 0 and t == z + w:\n                                    ans = [x, z, t]\n                                    break\n                                if x > 0 and y > 0 and z == 0 and w == 0 and t == 0:\n                                    continue\n                                if x > 0 and y > 0 and z == 0 and w == 0 and t > 0 and t == y + z:\n                                    ans = [x, y, t]\n                                    break\n                                if x > 0 and y > 0 and z > 0 and w == 0 and t == 0:\n                                    continue\n                                if x > 0 and y > 0 and z > 0 and w == 0 and t > 0 and t == z + w:\n                                    ans = [x, y, z, w, t]\n                                    break\n                                if x > 0 and y > 0 and z > 0 and w > 0 and t == 0:\n                                    continue\n                                if x > 0 and y > 0 and z > 0 and w > 0 and t > 0 and t == w + z:\n                                    ans = [x, y, z, w, t]\n                                    break\n                            if len(ans) > 2:\n                                break\n                        if len(ans) > 2:\n                            break\n                    if len(ans) > 2:\n                        break\n                if len(ans) > 2:\n                    break\n            if len(ans) > 2:\n                break\n        return ans",
    "efficient_solution": "class Solution:\n    def splitIntoFibonacci(self, num: str) -> List[int]:\n        def dfs(i):\n            if i == n:\n                return len(ans) > 2\n            x = 0\n            for j in range(i, n):\n                if j > i and num[i] == '0':\n                    break\n                x = x * 10 + int(num[j])\n                if x > 2**31 - 1 or (len(ans) > 2 and x > ans[-2] + ans[-1]):\n                    break\n                if len(ans) < 2 or ans[-2] + ans[-1] == x:\n                    ans.append(x)\n                    if dfs(j + 1):\n                        return True\n                    ans.pop()\n            return False\n\n        n = len(num)\n        ans = []\n        dfs(0)\n        return ans\n",
    "model_generation": "Here's an efficient solution for the problem. This solution uses a backtracking approach to find all possible combinations of Fibonacci-like sequences.\n\n```python\nclass Solution:\n    def splitIntoFibonacci(self, num: str) -> List[int]:\n        def backtrack(i, a):\n            if i == len(num):\n                return True\n            for j in range(i, len(num)):\n                if j > i and num[i] == '0':\n                    break\n                x = int(num[i:j+1])\n                if x > 2**31 - 1:\n                    return False\n                if len(a) >= 2 and x > a[-1] + a[-2]:\n                    return False\n                if backtrack(j + 1, a + [x]):\n                    return True\n            return False\n\n        for i in range(1, len(num)):\n            x = int(num[:i])\n            if x > 2**31 - 1:\n                break\n            if backtrack(i, [x]):\n                return [x] + [int(num[j:j+1]) for j in range(i, len(num), 1)]\n\n        return []\n```\n\nIn this solution, we use a helper function `backtrack` to recursively try all possible combinations of Fibonacci-like sequences. The function takes two parameters: `i`, which is the current index in the string, and `a`, which is the current Fibonacci-like sequence.\n\nWe start by checking if we have reached the end of the string. If we have, we return `True` if the current Fibonacci-like sequence is valid, and `False` otherwise.\n\nWe then iterate over all possible combinations of numbers that can be formed from the current index to the end of the string. If we find a valid combination, we recursively call `backtrack` with the updated index and sequence.\n\nFinally, we return the first valid Fibonacci-like sequence we find, or an empty list if no such sequence exists.\n\nThis solution has a time complexity of O(2^n), where n is the length of the string, because we are trying all possible combinations of numbers. However, this is the best time complexity we can achieve for this problem, because we must try all possible combinations to ensure that we find the correct solution. The space complexity is O(n), where n is the length of the string, because we are storing the current Fibonacci-like sequence in the `a` list.",
    "model_solution": "class Solution:\n    def splitIntoFibonacci(self, num: str) -> List[int]:\n        def backtrack(i, a):\n            if i == len(num):\n                return True\n            for j in range(i, len(num)):\n                if j > i and num[i] == '0':\n                    break\n                x = int(num[i:j+1])\n                if x > 2**31 - 1:\n                    return False\n                if len(a) >= 2 and x > a[-1] + a[-2]:\n                    return False\n                if backtrack(j + 1, a + [x]):\n                    return True\n            return False\n\n        for i in range(1, len(num)):\n            x = int(num[:i])\n            if x > 2**31 - 1:\n                break\n            if backtrack(i, [x]):\n                return [x] + [int(num[j:j+1]) for j in range(i, len(num), 1)]\n\n        return []",
    "is_python": true
}