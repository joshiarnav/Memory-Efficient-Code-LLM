{
    "problem_idx": "815",
    "description": "\nYou are given an array `routes` representing bus routes where `routes[i]` is a bus route that the `ith` bus repeats forever.\n\n\n* For example, if `routes[0] = [1, 5, 7]`, this means that the `0th` bus travels in the sequence `1 -> 5 -> 7 -> 1 -> 5 -> 7 -> 1 -> ...` forever.\n\n\nYou will start at the bus stop `source` (You are not on any bus initially), and you want to go to the bus stop `target`. You can travel between bus stops by buses only.\n\n\nReturn *the least number of buses you must take to travel from* `source` *to* `target`. Return `-1` if it is not possible.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** routes = [[1,2,7],[3,6,7]], source = 1, target = 6\n**Output:** 2\n**Explanation:** The best strategy is take the first bus to the bus stop 7, then take the second bus to the bus stop 6.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** routes = [[7,12],[4,5,15],[6],[15,19],[9,12,13]], source = 15, target = 12\n**Output:** -1\n\n```\n\n\u00a0\n\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= routes.length <= 500`.\n* `1 <= routes[i].length <= 105`\n* All the values of `routes[i]` are **unique**.\n* `sum(routes[i].length) <= 105`\n* `0 <= routes[i][j] < 106`\n* `0 <= source, target < 106`\n\n\n",
    "inefficient_solution": "class Solution:\n    def numBusesToDestination(\n        self, routes: List[List[int]], source: int, target: int\n    ) -> int:\n        if source == target:\n            return 0\n\n        s = [set(r) for r in routes]\n        d = defaultdict(list)\n        for i, r in enumerate(routes):\n            for v in r:\n                d[v] = d.get(v, []) + [i]\n\n        g = defaultdict(list)\n        for ids in d.values():\n            m = len(ids)\n            for i in range(m):\n                for j in range(i + 1, m):\n                    a, b = ids[i], ids[j]\n                    g[a] = g.get(a, []) + [b]\n                    g[b] = g.get(b, []) + [a]\n\n        q = deque(d[source])\n        ans = 1\n        vis = set(d[source])\n        while q:\n            for _ in range(len(q)):\n                i = q.popleft()\n                if target in s[i]:\n                    return ans\n                for j in g[i]:\n                    if j not in vis:\n                        vis.add(j)\n                        q.extend(d[j])\n            ans += 1\n        return -1",
    "efficient_solution": "class Solution:\n    def numBusesToDestination(\n        self, routes: List[List[int]], source: int, target: int\n    ) -> int:\n        if source == target:\n            return 0\n\n        s = [set(r) for r in routes]\n        d = defaultdict(list)\n        for i, r in enumerate(routes):\n            for v in r:\n                d[v].append(i)\n\n        g = defaultdict(list)\n        for ids in d.values():\n            m = len(ids)\n            for i in range(m):\n                for j in range(i + 1, m):\n                    a, b = ids[i], ids[j]\n                    g[a].append(b)\n                    g[b].append(a)\n        q = deque(d[source])\n        ans = 1\n        vis = set(d[source])\n        while q:\n            for _ in range(len(q)):\n                i = q.popleft()\n                if target in s[i]:\n                    return ans\n                for j in g[i]:\n                    if j not in vis:\n                        vis.add(j)\n                        q.append(j)\n            ans += 1\n        return -1\n",
    "model_generation": "### Efficient Solution:\n\n```python\nfrom collections import defaultdict, deque\n\nclass Solution:\n    def numBusesToDestination(\n        self, routes: List[List[int]], source: int, target: int\n    ) -> int:\n        if source == target:\n            return 0\n\n        # Create a dictionary to store the bus stop indices for each stop\n        stop_bus_indices = defaultdict(list)\n        for i, route in enumerate(routes):\n            for stop in route:\n                stop_bus_indices[stop].append(i)\n\n        # Initialize a queue with the source stop and its corresponding bus indices\n        q = deque([(source, 0)])\n        visited_stops = set()\n        visited_buses = set()\n\n        while q:\n            current_stop, bus_count = q.popleft()\n            if current_stop == target:\n                return bus_count\n\n            # Mark the current stop as visited\n            visited_stops.add(current_stop)\n\n            # Iterate over the buses that stop at the current stop\n            for bus in stop_bus_indices[current_stop]:\n                if bus not in visited_buses:\n                    visited_buses.add(bus)\n\n                    # Add the bus stops that the current bus visits to the queue\n                    for stop in routes[bus]:\n                        if stop not in visited_stops:\n                            q.append((stop, bus_count + 1))\n\n        return -1\n```\n\n### Explanation:\n\nThis solution uses a similar approach as the inefficient solution, but with some key optimizations:\n\n* We use a `defaultdict` to store the bus indices for each stop, which allows us to look up the bus indices for a given stop in constant time.\n* We use a `deque` to implement the queue, which provides efficient append and pop operations.\n* We use a `set` to keep track of the visited stops and buses, which allows us to check if a stop or bus has been visited in constant time.\n* We only add a bus to the queue if its corresponding bus index has not been visited yet, which avoids unnecessary iterations.\n* We use a single loop to process all the stops in the queue, which reduces the number of iterations.\n\nOverall, this solution has a time complexity of O(n), where n is the number of bus stops, and a space complexity of O(n), where n is the number of bus stops.",
    "model_solution": "from collections import defaultdict, deque\n\nclass Solution:\n    def numBusesToDestination(\n        self, routes: List[List[int]], source: int, target: int\n    ) -> int:\n        if source == target:\n            return 0\n\n        # Create a dictionary to store the bus stop indices for each stop\n        stop_bus_indices = defaultdict(list)\n        for i, route in enumerate(routes):\n            for stop in route:\n                stop_bus_indices[stop].append(i)\n\n        # Initialize a queue with the source stop and its corresponding bus indices\n        q = deque([(source, 0)])\n        visited_stops = set()\n        visited_buses = set()\n\n        while q:\n            current_stop, bus_count = q.popleft()\n            if current_stop == target:\n                return bus_count\n\n            # Mark the current stop as visited\n            visited_stops.add(current_stop)\n\n            # Iterate over the buses that stop at the current stop\n            for bus in stop_bus_indices[current_stop]:\n                if bus not in visited_buses:\n                    visited_buses.add(bus)\n\n                    # Add the bus stops that the current bus visits to the queue\n                    for stop in routes[bus]:\n                        if stop not in visited_stops:\n                            q.append((stop, bus_count + 1))\n\n        return -1",
    "is_python": true
}