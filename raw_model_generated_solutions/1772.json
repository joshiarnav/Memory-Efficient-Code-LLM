{
    "problem_idx": "1772",
    "description": "\nYou are given a string array `features` where `features[i]` is a single word that represents the name of a feature of the latest product you are working on. You have made a survey where users have reported which features they like. You are given a string array `responses`, where each `responses[i]` is a string containing space-separated words.\n\n\nThe **popularity** of a feature is the number of `responses[i]` that contain the feature. You want to sort the features in non-increasing order by their popularity. If two features have the same popularity, order them by their original index in `features`. Notice that one response could contain the same feature multiple times; this feature is only counted once in its popularity.\n\n\nReturn *the features in sorted order.*\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** features = [\"cooler\",\"lock\",\"touch\"], responses = [\"i like cooler cooler\",\"lock touch cool\",\"locker like touch\"]\n**Output:** [\"touch\",\"cooler\",\"lock\"]\n**Explanation:** appearances(\"cooler\") = 1, appearances(\"lock\") = 1, appearances(\"touch\") = 2. Since \"cooler\" and \"lock\" both had 1 appearance, \"cooler\" comes first because \"cooler\" came first in the features array.\n\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** features = [\"a\",\"aa\",\"b\",\"c\"], responses = [\"a\",\"a aa\",\"a a a a a\",\"b a\"]\n**Output:** [\"a\",\"aa\",\"b\",\"c\"]\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= features.length <= 104`\n* `1 <= features[i].length <= 10`\n* `features` contains no duplicates.\n* `features[i]` consists of lowercase letters.\n* `1 <= responses.length <= 102`\n* `1 <= responses[i].length <= 103`\n* `responses[i]` consists of lowercase letters and spaces.\n* `responses[i]` contains no two consecutive spaces.\n* `responses[i]` has no leading or trailing spaces.\n\n\n",
    "inefficient_solution": "class Solution:\n    def sortFeatures(self, features: List[str], responses: List[str]) -> List[str]:\n        dict = {}\n        for i, feature in enumerate(features):\n            dict[feature] = []\n        for response in responses:\n            words = response.split()\n            for feature in features:\n                if feature in words:\n                    dict[feature].append(response)\n        cnt = {feature: len(set(response for response in responses for word in response.split() if word == feature)) for feature in features}\n        return sorted(features, key=lambda w: (-cnt[w], features.index(w)))",
    "efficient_solution": "class Solution:\n    def sortFeatures(self, features: List[str], responses: List[str]) -> List[str]:\n        cnt = Counter()\n        for s in responses:\n            for w in set(s.split()):\n                cnt[w] += 1\n        return sorted(features, key=lambda w: -cnt[w])\n",
    "model_generation": "Here's an efficient solution using a dictionary to count the appearances of each feature in the responses:\n\n```python\nclass Solution:\n    def sortFeatures(self, features: List[str], responses: List[str]) -> List[str]:\n        # Count the appearances of each feature in the responses\n        cnt = {}\n        for response in responses:\n            words = response.split()\n            for feature in features:\n                if feature in words:\n                    cnt[feature] = cnt.get(feature, 0) + 1\n        \n        # Sort the features based on their popularity and original index\n        return sorted(features, key=lambda w: (-cnt.get(w, 0), features.index(w)))\n```\n\nIn this solution, we first count the appearances of each feature in the responses by iterating over the responses and features. We use a dictionary to store the count of each feature, and we update the count for each feature whenever we find it in a response. \n\nThen, we sort the features based on their popularity (i.e., the count of each feature) and their original index. We use the `get` method of the dictionary to handle features that appear zero times, and we use the `index` method of the list to get the original index of each feature.\n\nThis solution has a time complexity of O(n * m), where n is the number of responses and m is the number of features, which is more efficient than the original solution that has a time complexity of O(n * m * k), where k is the maximum number of words in a response.",
    "model_solution": "class Solution:\n    def sortFeatures(self, features: List[str], responses: List[str]) -> List[str]:\n        # Count the appearances of each feature in the responses\n        cnt = {}\n        for response in responses:\n            words = response.split()\n            for feature in features:\n                if feature in words:\n                    cnt[feature] = cnt.get(feature, 0) + 1\n        \n        # Sort the features based on their popularity and original index\n        return sorted(features, key=lambda w: (-cnt.get(w, 0), features.index(w)))",
    "is_python": true
}