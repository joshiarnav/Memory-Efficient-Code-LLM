{
    "problem_idx": "2760",
    "description": "\nYou are given a **0-indexed** integer array `nums` and an integer `threshold`.\n\n\nFind the length of the **longest subarray** of `nums` starting at index `l` and ending at index `r` `(0 <= l <= r < nums.length)` that satisfies the following conditions:\n\n\n* `nums[l] % 2 == 0`\n* For all indices `i` in the range `[l, r - 1]`, `nums[i] % 2 != nums[i + 1] % 2`\n* For all indices `i` in the range `[l, r]`, `nums[i] <= threshold`\n\n\nReturn *an integer denoting the length of the longest such subarray.*\n\n\n**Note:** A **subarray** is a contiguous non-empty sequence of elements within an array.\n\n\n\u00a0\n\n\n**Example 1:**\n\n\n\n```\n\n**Input:** nums = [3,2,5,4], threshold = 5\n**Output:** 3\n**Explanation:** In this example, we can select the subarray that starts at l = 1 and ends at r = 3 => [2,5,4]. This subarray satisfies the conditions.\nHence, the answer is the length of the subarray, 3. We can show that 3 is the maximum possible achievable length.\n```\n\n**Example 2:**\n\n\n\n```\n\n**Input:** nums = [1,2], threshold = 2\n**Output:** 1\n**Explanation:** In this example, we can select the subarray that starts at l = 1 and ends at r = 1 => [2]. \nIt satisfies all the conditions and we can show that 1 is the maximum possible achievable length.\n\n```\n\n**Example 3:**\n\n\n\n```\n\n**Input:** nums = [2,3,4,5], threshold = 4\n**Output:** 3\n**Explanation:** In this example, we can select the subarray that starts at l = 0 and ends at r = 2 => [2,3,4]. \nIt satisfies all the conditions.\nHence, the answer is the length of the subarray, 3. We can show that 3 is the maximum possible achievable length.\n\n```\n\n\u00a0\n\n\n**Constraints:**\n\n\n* `1 <= nums.length <= 100`\n* `1 <= nums[i] <= 100`\n* `1 <= threshold <= 100`\n\n\n",
    "inefficient_solution": "class Solution:\n    def longestAlternatingSubarray(self, nums, threshold):\n        n = len(nums)\n        if n == 1:\n            return 1\n\n        max_len = 0\n        for i in range(n):\n            length = 1\n            flag = nums[i] % 2\n            for j in range(i + 1, n):\n                if nums[j] % 2 != flag and nums[j] <= threshold:\n                    length += 1\n                elif nums[j] % 2 == flag or nums[j] > threshold:\n                    break\n                else:\n                    flag = nums[j] % 2\n                    length += 1\n                max_len = max(max_len, length)\n\n        return max_len",
    "efficient_solution": "class Solution:\n    def longestAlternatingSubarray(self, nums: List[int], threshold: int) -> int:\n        ans, l, n = 0, 0, len(nums)\n        while l < n:\n            if nums[l] % 2 == 0 and nums[l] <= threshold:\n                r = l + 1\n                while r < n and nums[r] % 2 != nums[r - 1] % 2 and nums[r] <= threshold:\n                    r += 1\n                ans = max(ans, r - l)\n                l = r\n            else:\n                l += 1\n        return ans\n",
    "model_generation": "### Efficient Solution\n\nThe given inefficient solution has a time complexity of O(n^2) due to the nested for loops. We can improve this to O(n) time complexity by using a two-pointer approach. This approach will keep track of the start and end of the current subarray that satisfies the conditions.\n\n```python\nclass Solution:\n    def longestAlternatingSubarray(self, nums, threshold):\n        n = len(nums)\n        max_len = 0\n        left = 0\n        \n        # Handle the case where length is 1\n        for i in range(n):\n            if nums[i] % 2 == 0 and nums[i] <= threshold:\n                max_len = max(max_len, 1)\n        \n        for right in range(n):\n            # If current element is even and not within the threshold, move the left pointer to the right\n            while left <= right and (nums[right] % 2 == nums[left] % 2 or nums[right] > threshold):\n                if nums[left] % 2 == 0 and nums[left] <= threshold:\n                    max_len = max(max_len, right - left + 1)\n                left += 1\n            \n            # If the current element is even and within the threshold, update the maximum length\n            if nums[right] % 2 == 0 and nums[right] <= threshold:\n                max_len = max(max_len, right - left + 1)\n        \n        return max_len\n```\n\nThis efficient solution uses a two-pointer approach to keep track of the start and end of the current subarray that satisfies the conditions. It starts by handling the case where the length of the subarray is 1, and then iterates over the array using the right pointer. For each position of the right pointer, it moves the left pointer to the right until the conditions are no longer satisfied. It then updates the maximum length if the current subarray satisfies the conditions. This approach has a time complexity of O(n) and is more efficient than the original solution.",
    "model_solution": "class Solution:\n    def longestAlternatingSubarray(self, nums, threshold):\n        n = len(nums)\n        max_len = 0\n        left = 0\n        \n        # Handle the case where length is 1\n        for i in range(n):\n            if nums[i] % 2 == 0 and nums[i] <= threshold:\n                max_len = max(max_len, 1)\n        \n        for right in range(n):\n            # If current element is even and not within the threshold, move the left pointer to the right\n            while left <= right and (nums[right] % 2 == nums[left] % 2 or nums[right] > threshold):\n                if nums[left] % 2 == 0 and nums[left] <= threshold:\n                    max_len = max(max_len, right - left + 1)\n                left += 1\n            \n            # If the current element is even and within the threshold, update the maximum length\n            if nums[right] % 2 == 0 and nums[right] <= threshold:\n                max_len = max(max_len, right - left + 1)\n        \n        return max_len",
    "is_python": true
}